(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.wd = {})));
}(this, (function (exports) { 'use strict';

	var out_of_memory = /* tuple */[
	  "Out_of_memory",
	  0
	];

	var sys_error = /* tuple */[
	  "Sys_error",
	  -1
	];

	var failure = /* tuple */[
	  "Failure",
	  -2
	];

	var invalid_argument = /* tuple */[
	  "Invalid_argument",
	  -3
	];

	var end_of_file = /* tuple */[
	  "End_of_file",
	  -4
	];

	var division_by_zero = /* tuple */[
	  "Division_by_zero",
	  -5
	];

	var not_found = /* tuple */[
	  "Not_found",
	  -6
	];

	var match_failure = /* tuple */[
	  "Match_failure",
	  -7
	];

	var stack_overflow = /* tuple */[
	  "Stack_overflow",
	  -8
	];

	var sys_blocked_io = /* tuple */[
	  "Sys_blocked_io",
	  -9
	];

	var assert_failure = /* tuple */[
	  "Assert_failure",
	  -10
	];

	var undefined_recursive_module = /* tuple */[
	  "Undefined_recursive_module",
	  -11
	];

	out_of_memory.tag = 248;

	sys_error.tag = 248;

	failure.tag = 248;

	invalid_argument.tag = 248;

	end_of_file.tag = 248;

	division_by_zero.tag = 248;

	not_found.tag = 248;

	match_failure.tag = 248;

	stack_overflow.tag = 248;

	sys_blocked_io.tag = 248;

	assert_failure.tag = 248;

	undefined_recursive_module.tag = 248;


	/*  Not a pure module */

	function caml_array_sub(x, offset, len) {
	  var result = new Array(len);
	  var j = 0;
	  var i = offset;
	  while(j < len) {
	    result[j] = x[i];
	    j = j + 1 | 0;
	    i = i + 1 | 0;
	  }
	  return result;
	}

	function caml_array_get(xs, index) {
	  if (index < 0 || index >= xs.length) {
	    throw [
	          invalid_argument,
	          "index out of bounds"
	        ];
	  } else {
	    return xs[index];
	  }
	}

	function caml_array_dup(prim) {
	  return prim.slice(0);
	}


	/* No side effect */

	function app(_f, _args) {
	  while(true) {
	    var args = _args;
	    var f = _f;
	    var arity = f.length;
	    var arity$1 = arity === 0 ? 1 : arity;
	    var len = args.length;
	    var d = arity$1 - len | 0;
	    if (d === 0) {
	      return f.apply(null, args);
	    } else if (d < 0) {
	      _args = caml_array_sub(args, arity$1, -d | 0);
	      _f = f.apply(null, caml_array_sub(args, 0, arity$1));
	      continue ;
	    } else {
	      return (function(f,args){
	      return function (x) {
	        return app(f, args.concat(/* array */[x]));
	      }
	      }(f,args));
	    }
	  }
	}

	function curry_1(o, a0, arity) {
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[a0]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          return o(a0);
	      case 2 : 
	          return (function (param) {
	              return o(a0, param);
	            });
	      case 3 : 
	          return (function (param, param$1) {
	              return o(a0, param, param$1);
	            });
	      case 4 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, param, param$1, param$2);
	            });
	      case 5 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, param, param$1, param$2, param$3);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2, param$3, param$4) {
	              return o(a0, param, param$1, param$2, param$3, param$4);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3, param$4, param$5) {
	              return o(a0, param, param$1, param$2, param$3, param$4, param$5);
	            });
	      
	    }
	  }
	}

	function _1(o, a0) {
	  var arity = o.length;
	  if (arity === 1) {
	    return o(a0);
	  } else {
	    return curry_1(o, a0, arity);
	  }
	}

	function __1(o) {
	  var arity = o.length;
	  if (arity === 1) {
	    return o;
	  } else {
	    return (function (a0) {
	        return _1(o, a0);
	      });
	  }
	}

	function curry_2(o, a0, a1, arity) {
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          return app(o(a0), /* array */[a1]);
	      case 2 : 
	          return o(a0, a1);
	      case 3 : 
	          return (function (param) {
	              return o(a0, a1, param);
	            });
	      case 4 : 
	          return (function (param, param$1) {
	              return o(a0, a1, param, param$1);
	            });
	      case 5 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, param, param$1, param$2);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, a1, param, param$1, param$2, param$3);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3, param$4) {
	              return o(a0, a1, param, param$1, param$2, param$3, param$4);
	            });
	      
	    }
	  }
	}

	function _2(o, a0, a1) {
	  var arity = o.length;
	  if (arity === 2) {
	    return o(a0, a1);
	  } else {
	    return curry_2(o, a0, a1, arity);
	  }
	}

	function curry_3(o, a0, a1, a2, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[a2]);
	      case 3 : 
	          return o(a0, a1, a2);
	      case 4 : 
	          return (function (param) {
	              return o(a0, a1, a2, param);
	            });
	      case 5 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, param, param$1);
	            });
	      case 6 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, a2, param, param$1, param$2);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2, param$3) {
	              return o(a0, a1, a2, param, param$1, param$2, param$3);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2
	              ]);
	  }
	  
	}

	function _3(o, a0, a1, a2) {
	  var arity = o.length;
	  if (arity === 3) {
	    return o(a0, a1, a2);
	  } else {
	    return curry_3(o, a0, a1, a2, arity);
	  }
	}

	function curry_4(o, a0, a1, a2, a3, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[a3]);
	      case 4 : 
	          return o(a0, a1, a2, a3);
	      case 5 : 
	          return (function (param) {
	              return o(a0, a1, a2, a3, param);
	            });
	      case 6 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, a3, param, param$1);
	            });
	      case 7 : 
	          return (function (param, param$1, param$2) {
	              return o(a0, a1, a2, a3, param, param$1, param$2);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3
	              ]);
	  }
	  
	}

	function _4(o, a0, a1, a2, a3) {
	  var arity = o.length;
	  if (arity === 4) {
	    return o(a0, a1, a2, a3);
	  } else {
	    return curry_4(o, a0, a1, a2, a3, arity);
	  }
	}

	function curry_5(o, a0, a1, a2, a3, a4, arity) {
	  var exit = 0;
	  if (arity > 7 || arity < 0) {
	    return app(o, /* array */[
	                a0,
	                a1,
	                a2,
	                a3,
	                a4
	              ]);
	  } else {
	    switch (arity) {
	      case 0 : 
	      case 1 : 
	          exit = 1;
	          break;
	      case 2 : 
	          return app(o(a0, a1), /* array */[
	                      a2,
	                      a3,
	                      a4
	                    ]);
	      case 3 : 
	          return app(o(a0, a1, a2), /* array */[
	                      a3,
	                      a4
	                    ]);
	      case 4 : 
	          return app(o(a0, a1, a2, a3), /* array */[a4]);
	      case 5 : 
	          return o(a0, a1, a2, a3, a4);
	      case 6 : 
	          return (function (param) {
	              return o(a0, a1, a2, a3, a4, param);
	            });
	      case 7 : 
	          return (function (param, param$1) {
	              return o(a0, a1, a2, a3, a4, param, param$1);
	            });
	      
	    }
	  }
	  if (exit === 1) {
	    return app(o(a0), /* array */[
	                a1,
	                a2,
	                a3,
	                a4
	              ]);
	  }
	  
	}

	function _5(o, a0, a1, a2, a3, a4) {
	  var arity = o.length;
	  if (arity === 5) {
	    return o(a0, a1, a2, a3, a4);
	  } else {
	    return curry_5(o, a0, a1, a2, a3, a4, arity);
	  }
	}


	/* No side effect */

	function entries(dict) {
	  var keys = Object.keys(dict);
	  var l = keys.length;
	  var values = new Array(l);
	  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
	    var key = keys[i];
	    values[i] = /* tuple */[
	      key,
	      dict[key]
	    ];
	  }
	  return values;
	}

	function values(dict) {
	  var keys = Object.keys(dict);
	  var l = keys.length;
	  var values$1 = new Array(l);
	  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
	    values$1[i] = dict[keys[i]];
	  }
	  return values$1;
	}

	function fromList$1(entries) {
	  var dict = { };
	  var _param = entries;
	  while(true) {
	    var param = _param;
	    if (param) {
	      var match = param[0];
	      dict[match[0]] = match[1];
	      _param = param[1];
	      continue ;
	    } else {
	      return dict;
	    }
	  }
	}

	function map(f, source) {
	  var target = { };
	  var keys = Object.keys(source);
	  var l = keys.length;
	  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
	    var key = keys[i];
	    target[key] = f(source[key]);
	  }
	  return target;
	}


	/* unsafeDeleteKey Not a pure module */

	var undefinedHeader = /* array */[];

	function some$1(x) {
	  if (x === undefined) {
	    var block = /* tuple */[
	      undefinedHeader,
	      0
	    ];
	    block.tag = 256;
	    return block;
	  } else if (x !== null && x[0] === undefinedHeader) {
	    var nid = x[1] + 1 | 0;
	    var block$1 = /* tuple */[
	      undefinedHeader,
	      nid
	    ];
	    block$1.tag = 256;
	    return block$1;
	  } else {
	    return x;
	  }
	}

	function nullable_to_opt(x) {
	  if (x === null || x === undefined) {
	    return undefined;
	  } else {
	    return some$1(x);
	  }
	}

	function undefined_to_opt(x) {
	  if (x === undefined) {
	    return undefined;
	  } else {
	    return some$1(x);
	  }
	}

	function valFromOption(x) {
	  if (x !== null && x[0] === undefinedHeader) {
	    var depth = x[1];
	    if (depth === 0) {
	      return undefined;
	    } else {
	      return /* tuple */[
	              undefinedHeader,
	              depth - 1 | 0
	            ];
	    }
	  } else {
	    return x;
	  }
	}


	/* No side effect */

	function isSome(param) {
	  return param !== undefined;
	}

	function isNone(param) {
	  return param === undefined;
	}

	function getExn(x) {
	  if (x !== undefined) {
	    return valFromOption(x);
	  } else {
	    throw new Error("getExn");
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function createEmpty() {
	  return { };
	}

	function set(key, value, map$$1) {
	  map$$1[key] = value;
	  return map$$1;
	}

	function get(key, map$$1) {
	  return undefined_to_opt(map$$1[key]);
	}

	function unsafeGet(key, map$$1) {
	  return map$$1[key];
	}

	function deleteVal(key, map$$1) {
	  return set(key, undefined, map$$1);
	}

	function has(key, map$$1) {
	  return isSome(undefined_to_opt(map$$1[key]));
	}

	var fromList = fromList$1;


	/* Js_dict Not a pure module */

	var id = /* record */[/* contents */0];

	function get_id() {
	  id[0] += 1;
	  return id[0];
	}

	function create$1(str) {
	  var v_001 = get_id(/* () */0);
	  var v = /* tuple */[
	    str,
	    v_001
	  ];
	  v.tag = 248;
	  return v;
	}

	function isCamlExceptionOrOpenVariant(e) {
	  if (e === undefined) {
	    return false;
	  } else if (e.tag === 248) {
	    return true;
	  } else {
	    var slot = e[0];
	    if (slot !== undefined) {
	      return slot.tag === 248;
	    } else {
	      return false;
	    }
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	var Check_fail = create$1("Exception-WonderLog.Check_fail");

	var $$throw = (
	    function(msg){
	            throw new Error(msg)
	    });


	/* throw Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function getJsonStr(json) {
	  return JSON.stringify(json);
	}

	function warn(msg) {
	  console.warn("Warn: " + (String(msg) + ""));
	  return /* () */0;
	}

	function buildDebugMessage(description, params, _) {
	  return "\n  Debug:\n\n  description\n  " + (String(description) + ("\n\n  params\n  " + (String(params) + "\n\n  ")));
	}

	function debugWithFunc(func, isTest) {
	  if (isTest) {
	    return _1(func, /* () */0);
	  } else {
	    return /* () */0;
	  }
	}

	function debug(buildMessageFunc, isTest) {
	  if (isTest) {
	    console.log(_1(buildMessageFunc, /* () */0));
	    console.trace();
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function buildDebugJsonMessage(description, $$var, _) {
	  var varStr = JSON.stringify($$var);
	  return "\n  DebugJson:\n\n  description\n  " + (String(description) + ("\n\n  variable value\n  " + (String(varStr) + "\n  ")));
	}

	function debugJson(buildMessageFunc, isTest) {
	  if (isTest) {
	    console.log(_1(buildMessageFunc, /* () */0));
	    console.trace();
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function buildFatalMessage(title, description, reason, solution, params) {
	  return "\n  Fatal:\n\n  title\n  " + (String(title) + ("\n\n  description\n  " + (String(description) + ("\n\n  reason\n  " + (String(reason) + ("\n\n  solution\n  " + (String(solution) + ("\n\n  params\n  " + (String(params) + "\n\n   ")))))))));
	}

	function fatal(msg) {
	  return _1($$throw, msg);
	}

	function buildAssertMessage(expect, actual) {
	  return "expect " + (String(expect) + (", but actual " + (String(actual) + "")));
	}


	/* Exception-WonderLog Not a pure module */

	var $$Error = create$1("Js_exn.Error");

	function internalToOCamlException(e) {
	  if (isCamlExceptionOrOpenVariant(e)) {
	    return e;
	  } else {
	    return [
	            $$Error,
	            e
	          ];
	  }
	}


	/* No side effect */

	/* No side effect */

	function caml_int_compare(x, y) {
	  if (x < y) {
	    return -1;
	  } else if (x === y) {
	    return 0;
	  } else {
	    return 1;
	  }
	}

	function caml_bool_compare(x, y) {
	  if (x) {
	    if (y) {
	      return 0;
	    } else {
	      return 1;
	    }
	  } else if (y) {
	    return -1;
	  } else {
	    return 0;
	  }
	}

	function caml_string_compare(s1, s2) {
	  if (s1 === s2) {
	    return 0;
	  } else if (s1 < s2) {
	    return -1;
	  } else {
	    return 1;
	  }
	}


	/* No side effect */

	var for_in = function (o,foo){
	        for (var x in o) { foo(x); }
	      };

	function caml_compare(_a, _b) {
	  while(true) {
	    var b = _b;
	    var a = _a;
	    if (a === b) {
	      return 0;
	    } else {
	      var a_type = typeof a;
	      var b_type = typeof b;
	      var exit = 0;
	      switch (a_type) {
	        case "boolean" : 
	            if (b_type === "boolean") {
	              return caml_bool_compare(a, b);
	            } else {
	              exit = 1;
	            }
	            break;
	        case "function" : 
	            if (b_type === "function") {
	              throw [
	                    invalid_argument,
	                    "compare: functional value"
	                  ];
	            } else {
	              exit = 1;
	            }
	            break;
	        case "number" : 
	            if (b_type === "number") {
	              return caml_int_compare(a, b);
	            } else {
	              exit = 1;
	            }
	            break;
	        case "string" : 
	            if (b_type === "string") {
	              return caml_string_compare(a, b);
	            } else {
	              return 1;
	            }
	        case "undefined" : 
	            return -1;
	        default:
	          exit = 1;
	      }
	      if (exit === 1) {
	        switch (b_type) {
	          case "string" : 
	              return -1;
	          case "undefined" : 
	              return 1;
	          default:
	            if (a_type === "boolean") {
	              return 1;
	            } else if (b_type === "boolean") {
	              return -1;
	            } else if (a_type === "function") {
	              return 1;
	            } else if (b_type === "function") {
	              return -1;
	            } else if (a_type === "number") {
	              if (b === null || b.tag === 256) {
	                return 1;
	              } else {
	                return -1;
	              }
	            } else if (b_type === "number") {
	              if (a === null || a.tag === 256) {
	                return -1;
	              } else {
	                return 1;
	              }
	            } else if (a === null) {
	              if (b.tag === 256) {
	                return 1;
	              } else {
	                return -1;
	              }
	            } else if (b === null) {
	              if (a.tag === 256) {
	                return -1;
	              } else {
	                return 1;
	              }
	            } else {
	              var tag_a = a.tag | 0;
	              var tag_b = b.tag | 0;
	              if (tag_a === 250) {
	                _a = a[0];
	                continue ;
	              } else if (tag_b === 250) {
	                _b = b[0];
	                continue ;
	              } else if (tag_a === 256) {
	                if (tag_b === 256) {
	                  return caml_int_compare(a[1], b[1]);
	                } else {
	                  return -1;
	                }
	              } else if (tag_a === 248) {
	                return caml_int_compare(a[1], b[1]);
	              } else if (tag_a === 251) {
	                throw [
	                      invalid_argument,
	                      "equal: abstract value"
	                    ];
	              } else if (tag_a !== tag_b) {
	                if (tag_a < tag_b) {
	                  return -1;
	                } else {
	                  return 1;
	                }
	              } else {
	                var len_a = a.length | 0;
	                var len_b = b.length | 0;
	                if (len_a === len_b) {
	                  if (Array.isArray(a)) {
	                    var a$1 = a;
	                    var b$1 = b;
	                    var _i = 0;
	                    var same_length = len_a;
	                    while(true) {
	                      var i = _i;
	                      if (i === same_length) {
	                        return 0;
	                      } else {
	                        var res = caml_compare(a$1[i], b$1[i]);
	                        if (res !== 0) {
	                          return res;
	                        } else {
	                          _i = i + 1 | 0;
	                          continue ;
	                        }
	                      }
	                    }
	                  } else {
	                    var a$2 = a;
	                    var b$2 = b;
	                    var min_key_lhs = /* record */[/* contents */undefined];
	                    var min_key_rhs = /* record */[/* contents */undefined];
	                    var do_key = function (param, key) {
	                      var min_key = param[2];
	                      var b = param[1];
	                      if (!b.hasOwnProperty(key) || caml_compare(param[0][key], b[key]) > 0) {
	                        var match = min_key[0];
	                        if (match !== undefined && key >= match) {
	                          return 0;
	                        } else {
	                          min_key[0] = key;
	                          return /* () */0;
	                        }
	                      } else {
	                        return 0;
	                      }
	                    };
	                    var partial_arg = /* tuple */[
	                      a$2,
	                      b$2,
	                      min_key_rhs
	                    ];
	                    var do_key_a = (function(partial_arg){
	                    return function do_key_a(param) {
	                      return do_key(partial_arg, param);
	                    }
	                    }(partial_arg));
	                    var partial_arg$1 = /* tuple */[
	                      b$2,
	                      a$2,
	                      min_key_lhs
	                    ];
	                    var do_key_b = (function(partial_arg$1){
	                    return function do_key_b(param) {
	                      return do_key(partial_arg$1, param);
	                    }
	                    }(partial_arg$1));
	                    for_in(a$2, do_key_a);
	                    for_in(b$2, do_key_b);
	                    var match = min_key_lhs[0];
	                    var match$1 = min_key_rhs[0];
	                    if (match !== undefined) {
	                      if (match$1 !== undefined) {
	                        return caml_string_compare(match, match$1);
	                      } else {
	                        return -1;
	                      }
	                    } else if (match$1 !== undefined) {
	                      return 1;
	                    } else {
	                      return 0;
	                    }
	                  }
	                } else if (len_a < len_b) {
	                  var a$3 = a;
	                  var b$3 = b;
	                  var _i$1 = 0;
	                  var short_length = len_a;
	                  while(true) {
	                    var i$1 = _i$1;
	                    if (i$1 === short_length) {
	                      return -1;
	                    } else {
	                      var res$1 = caml_compare(a$3[i$1], b$3[i$1]);
	                      if (res$1 !== 0) {
	                        return res$1;
	                      } else {
	                        _i$1 = i$1 + 1 | 0;
	                        continue ;
	                      }
	                    }
	                  }
	                } else {
	                  var a$4 = a;
	                  var b$4 = b;
	                  var _i$2 = 0;
	                  var short_length$1 = len_b;
	                  while(true) {
	                    var i$2 = _i$2;
	                    if (i$2 === short_length$1) {
	                      return 1;
	                    } else {
	                      var res$2 = caml_compare(a$4[i$2], b$4[i$2]);
	                      if (res$2 !== 0) {
	                        return res$2;
	                      } else {
	                        _i$2 = i$2 + 1 | 0;
	                        continue ;
	                      }
	                    }
	                  }
	                }
	              }
	            }
	        }
	      }
	      
	    }
	  }
	}

	function caml_equal(_a, _b) {
	  while(true) {
	    var b = _b;
	    var a = _a;
	    if (a === b) {
	      return true;
	    } else {
	      var a_type = typeof a;
	      if (a_type === "string" || a_type === "number" || a_type === "boolean" || a_type === "undefined" || a === null) {
	        return false;
	      } else {
	        var b_type = typeof b;
	        if (a_type === "function" || b_type === "function") {
	          throw [
	                invalid_argument,
	                "equal: functional value"
	              ];
	        } else if (b_type === "number" || b_type === "undefined" || b === null) {
	          return false;
	        } else {
	          var tag_a = a.tag | 0;
	          var tag_b = b.tag | 0;
	          if (tag_a === 250) {
	            _a = a[0];
	            continue ;
	          } else if (tag_b === 250) {
	            _b = b[0];
	            continue ;
	          } else if (tag_a === 248) {
	            return a[1] === b[1];
	          } else if (tag_a === 251) {
	            throw [
	                  invalid_argument,
	                  "equal: abstract value"
	                ];
	          } else if (tag_a !== tag_b) {
	            return false;
	          } else if (tag_a === 256) {
	            return a[1] === b[1];
	          } else {
	            var len_a = a.length | 0;
	            var len_b = b.length | 0;
	            if (len_a === len_b) {
	              if (Array.isArray(a)) {
	                var a$1 = a;
	                var b$1 = b;
	                var _i = 0;
	                var same_length = len_a;
	                while(true) {
	                  var i = _i;
	                  if (i === same_length) {
	                    return true;
	                  } else if (caml_equal(a$1[i], b$1[i])) {
	                    _i = i + 1 | 0;
	                    continue ;
	                  } else {
	                    return false;
	                  }
	                }
	              } else {
	                var a$2 = a;
	                var b$2 = b;
	                var result = /* record */[/* contents */true];
	                var do_key_a = (function(b$2,result){
	                return function do_key_a(key) {
	                  if (b$2.hasOwnProperty(key)) {
	                    return 0;
	                  } else {
	                    result[0] = false;
	                    return /* () */0;
	                  }
	                }
	                }(b$2,result));
	                var do_key_b = (function(a$2,b$2,result){
	                return function do_key_b(key) {
	                  if (!a$2.hasOwnProperty(key) || !caml_equal(b$2[key], a$2[key])) {
	                    result[0] = false;
	                    return /* () */0;
	                  } else {
	                    return 0;
	                  }
	                }
	                }(a$2,b$2,result));
	                for_in(a$2, do_key_a);
	                if (result[0]) {
	                  for_in(b$2, do_key_b);
	                }
	                return result[0];
	              }
	            } else {
	              return false;
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function caml_notequal(a, b) {
	  return !caml_equal(a, b);
	}

	function caml_greaterequal(a, b) {
	  return caml_compare(a, b) >= 0;
	}

	function caml_greaterthan(a, b) {
	  return caml_compare(a, b) > 0;
	}

	function caml_lessequal(a, b) {
	  return caml_compare(a, b) <= 0;
	}

	function caml_lessthan(a, b) {
	  return caml_compare(a, b) < 0;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _assert(result, msg) {
	  if (result) {
	    return /* () */0;
	  } else {
	    throw [
	          Check_fail,
	          msg
	        ];
	  }
	}

	var test = function (message,func){
	  try{
	  func();
	  } catch(e){
	    throw new Error(JSON.stringify(message));
	  }
	  };

	function requireCheck(f, isTest) {
	  if (isTest) {
	    return _1(f, /* () */0);
	  } else {
	    return /* () */0;
	  }
	}

	function ensureCheck(f, isTest, returnVal) {
	  if (isTest) {
	    _1(f, returnVal);
	    return returnVal;
	  } else {
	    return returnVal;
	  }
	}

	function assertFail() {
	  throw [
	        Check_fail,
	        "fail"
	      ];
	}

	function assertPass() {
	  return /* () */0;
	}

	function assertTrue(source) {
	  return _assert(source === true, "expect to be true, but actual is false");
	}

	function assertFalse(source) {
	  return _assert(source === false, "expect to be false, but actual is true");
	}

	function assertIsBool(source) {
	  return _assert(source === true || source === false, "expect to be bool, but actual not");
	}

	var _isNullableExist = (
	function(source) {
	    return source !== undefined && source !== null;
	}
	);

	function assertNullableExist(source) {
	  return _assert(_1(_isNullableExist, source), "expect exist, but actual not");
	}

	function assertExist(source) {
	  return _assert(isSome(source), "expect exist, but actual not");
	}

	function assertNotExist(source) {
	  return _assert(isNone(source), "expect not exist, but actual exist");
	}

	function _getEqualMessage(source, target) {
	  return "\"expect to be " + (String(target) + (", but actual is " + (String(source) + "\"")));
	}

	function assertEqual(_, source, target) {
	  return _assert(caml_equal(source, target), _getEqualMessage(source, target));
	}

	function _getNotEqualMessage(source, target) {
	  return "\"expect not to be " + (String(target) + (", but actual is " + (String(source) + "\"")));
	}

	function assertNotEqual(_, source, target) {
	  return _assert(caml_notequal(source, target), _getNotEqualMessage(source, target));
	}

	function assertGt(_, source, target) {
	  return _assert(caml_greaterthan(source, target), "expect " + (String(source) + (" > " + (String(target) + ", but actual isn\'t"))));
	}

	function assertGte(_, source, target) {
	  return _assert(caml_greaterequal(source, target), "expect " + (String(source) + (" >= " + (String(target) + ", but actual isn\'t"))));
	}

	function assertLt(_, source, target) {
	  return _assert(caml_lessthan(source, target), "expect " + (String(source) + (" < " + (String(target) + ", but actual isn\'t"))));
	}

	function assertLte(_, source, target) {
	  return _assert(caml_lessequal(source, target), "expect " + (String(source) + (" <= " + (String(target) + ", but actual isn\'t"))));
	}

	function $eq(a, b) {
	  return assertEqual(/* Int */0, a, b);
	}

	function $eq$eq$dot(a, b) {
	  return assertEqual(/* Float */1, a, b);
	}

	function $eq$eq$caret(a, b) {
	  return assertEqual(/* String */2, a, b);
	}

	function $less$great$eq(a, b) {
	  return assertNotEqual(/* Int */0, a, b);
	}

	function $less$great$eq$dot(a, b) {
	  return assertNotEqual(/* Float */1, a, b);
	}

	function $great(a, b) {
	  return assertGt(/* Int */0, a, b);
	}

	function $great$dot(a, b) {
	  return assertGt(/* Float */1, a, b);
	}

	function $great$eq(a, b) {
	  return assertGte(/* Int */0, a, b);
	}

	function $great$eq$dot(a, b) {
	  return assertGte(/* Float */1, a, b);
	}

	function $less(a, b) {
	  return assertLt(/* Int */0, a, b);
	}

	function $less$dot(a, b) {
	  return assertLt(/* Float */1, a, b);
	}

	function $less$eq(a, b) {
	  return assertLte(/* Int */0, a, b);
	}

	function $less$eq$dot(a, b) {
	  return assertLte(/* Float */1, a, b);
	}

	var Operators = /* module */[
	  /* = */$eq,
	  /* ==. */$eq$eq$dot,
	  /* ==^ */$eq$eq$caret,
	  /* <>= */$less$great$eq,
	  /* <>=. */$less$great$eq$dot,
	  /* > */$great,
	  /* >. */$great$dot,
	  /* >= */$great$eq,
	  /* >=. */$great$eq$dot,
	  /* < */$less,
	  /* <. */$less$dot,
	  /* <= */$less$eq,
	  /* <=. */$less$eq$dot
	];


	/* _isNullableExist Not a pure module */

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function Stream (source) {
	  this.source = source;
	}

	Stream.prototype.run = function (sink, scheduler) {
	  return this.source.run(sink, scheduler)
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */

	// Non-mutating array operations

	// cons :: a -> [a] -> [a]
	// a with x prepended
	function cons(x, a) {
	  var l = a.length;
	  var b = new Array(l + 1);
	  b[0] = x;
	  for (var i = 0; i < l; ++i) {
	    b[i + 1] = a[i];
	  }
	  return b;
	}

	// append :: a -> [a] -> [a]
	// a with x appended
	function append(x, a) {
	  var l = a.length;
	  var b = new Array(l + 1);
	  for (var i = 0; i < l; ++i) {
	    b[i] = a[i];
	  }

	  b[l] = x;
	  return b;
	}

	// drop :: Int -> [a] -> [a]
	// drop first n elements
	function drop(n, a) {
	  // eslint-disable-line complexity
	  if (n < 0) {
	    throw new TypeError('n must be >= 0');
	  }

	  var l = a.length;
	  if (n === 0 || l === 0) {
	    return a;
	  }

	  if (n >= l) {
	    return [];
	  }

	  return unsafeDrop(n, a, l - n);
	}

	// unsafeDrop :: Int -> [a] -> Int -> [a]
	// Internal helper for drop
	function unsafeDrop(n, a, l) {
	  var b = new Array(l);
	  for (var i = 0; i < l; ++i) {
	    b[i] = a[n + i];
	  }
	  return b;
	}

	// tail :: [a] -> [a]
	// drop head element
	function tail(a) {
	  return drop(1, a);
	}

	// copy :: [a] -> [a]
	// duplicate a (shallow duplication)
	function copy(a) {
	  var l = a.length;
	  var b = new Array(l);
	  for (var i = 0; i < l; ++i) {
	    b[i] = a[i];
	  }
	  return b;
	}

	// map :: (a -> b) -> [a] -> [b]
	// transform each element with f
	function map$2(f, a) {
	  var l = a.length;
	  var b = new Array(l);
	  for (var i = 0; i < l; ++i) {
	    b[i] = f(a[i]);
	  }
	  return b;
	}

	// reduce :: (a -> b -> a) -> a -> [b] -> a
	// accumulate via left-fold
	function reduce(f, z, a) {
	  var r = z;
	  for (var i = 0, l = a.length; i < l; ++i) {
	    r = f(r, a[i], i);
	  }
	  return r;
	}

	// replace :: a -> Int -> [a]
	// replace element at index
	function replace(x, i, a) {
	  // eslint-disable-line complexity
	  if (i < 0) {
	    throw new TypeError('i must be >= 0');
	  }

	  var l = a.length;
	  var b = new Array(l);
	  for (var j = 0; j < l; ++j) {
	    b[j] = i === j ? x : a[j];
	  }
	  return b;
	}

	// remove :: Int -> [a] -> [a]
	// remove element at index
	function remove(i, a) {
	  // eslint-disable-line complexity
	  if (i < 0) {
	    throw new TypeError('i must be >= 0');
	  }

	  var l = a.length;
	  if (l === 0 || i >= l) {
	    // exit early if index beyond end of array
	    return a;
	  }

	  if (l === 1) {
	    // exit early if index in bounds and length === 1
	    return [];
	  }

	  return unsafeRemove(i, a, l - 1);
	}

	// unsafeRemove :: Int -> [a] -> Int -> [a]
	// Internal helper to remove element at index
	function unsafeRemove(i, a, l) {
	  var b = new Array(l);
	  var j = void 0;
	  for (j = 0; j < i; ++j) {
	    b[j] = a[j];
	  }
	  for (j = i; j < l; ++j) {
	    b[j] = a[j + 1];
	  }

	  return b;
	}

	// removeAll :: (a -> boolean) -> [a] -> [a]
	// remove all elements matching a predicate
	function removeAll(f, a) {
	  var l = a.length;
	  var b = new Array(l);
	  var j = 0;
	  for (var x, i = 0; i < l; ++i) {
	    x = a[i];
	    if (!f(x)) {
	      b[j] = x;
	      ++j;
	    }
	  }

	  b.length = j;
	  return b;
	}

	// findIndex :: a -> [a] -> Int
	// find index of x in a, from the left
	function findIndex(x, a) {
	  for (var i = 0, l = a.length; i < l; ++i) {
	    if (x === a[i]) {
	      return i;
	    }
	  }
	  return -1;
	}

	// isArrayLike :: * -> boolean
	// Return true iff x is array-like
	function isArrayLike(x) {
	  return x != null && typeof x.length === 'number' && typeof x !== 'function';
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */

	// id :: a -> a
	var id$1 = function id(x) {
	  return x;
	};

	// compose :: (b -> c) -> (a -> b) -> (a -> c)
	var compose = function compose(f, g) {
	  return function (x) {
	    return f(g(x));
	  };
	};

	// apply :: (a -> b) -> a -> b
	var apply = function apply(f, x) {
	  return f(x);
	};

	// curry2 :: ((a, b) -> c) -> (a -> b -> c)
	function curry2(f) {
	  function curried(a, b) {
	    switch (arguments.length) {
	      case 0:
	        return curried;
	      case 1:
	        return function (b) {
	          return f(a, b);
	        };
	      default:
	        return f(a, b);
	    }
	  }
	  return curried;
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Create a new Disposable which will dispose its underlying resource.
	 * @param {function} dispose function
	 * @param {*?} data any data to be passed to disposer function
	 * @constructor
	 */
	function Disposable (dispose, data) {
	  this._dispose = dispose;
	  this._data = data;
	}

	Disposable.prototype.dispose = function () {
	  return this._dispose(this._data)
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function SettableDisposable () {
	  this.disposable = void 0;
	  this.disposed = false;
	  this._resolve = void 0;

	  var self = this;
	  this.result = new Promise(function (resolve) {
	    self._resolve = resolve;
	  });
	}

	SettableDisposable.prototype.setDisposable = function (disposable) {
	  if (this.disposable !== void 0) {
	    throw new Error('setDisposable called more than once')
	  }

	  this.disposable = disposable;

	  if (this.disposed) {
	    this._resolve(disposable.dispose());
	  }
	};

	SettableDisposable.prototype.dispose = function () {
	  if (this.disposed) {
	    return this.result
	  }

	  this.disposed = true;

	  if (this.disposable !== void 0) {
	    this.result = this.disposable.dispose();
	  }

	  return this.result
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function isPromise (p) {
	  return p !== null && typeof p === 'object' && typeof p.then === 'function'
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */
	var map$3 = map$2;
	var identity = id$1;

	/**
	 * Call disposable.dispose.  If it returns a promise, catch promise
	 * error and forward it through the provided sink.
	 * @param {number} t time
	 * @param {{dispose: function}} disposable
	 * @param {{error: function}} sink
	 * @return {*} result of disposable.dispose
	 */
	function tryDispose (t, disposable, sink) {
	  var result = disposeSafely(disposable);
	  return isPromise(result)
	    ? result.catch(function (e) {
	      sink.error(t, e);
	    })
	    : result
	}

	/**
	 * Create a new Disposable which will dispose its underlying resource
	 * at most once.
	 * @param {function} dispose function
	 * @param {*?} data any data to be passed to disposer function
	 * @return {Disposable}
	 */
	function create$2 (dispose, data) {
	  return once(new Disposable(dispose, data))
	}

	/**
	 * Create a noop disposable. Can be used to satisfy a Disposable
	 * requirement when no actual resource needs to be disposed.
	 * @return {Disposable|exports|module.exports}
	 */
	function empty$1 () {
	  return new Disposable(identity, void 0)
	}

	/**
	 * Create a disposable that will dispose all input disposables in parallel.
	 * @param {Array<Disposable>} disposables
	 * @return {Disposable}
	 */
	function all (disposables) {
	  return create$2(disposeAll, disposables)
	}

	function disposeAll (disposables) {
	  return Promise.all(map$3(disposeSafely, disposables))
	}

	function disposeSafely (disposable) {
	  try {
	    return disposable.dispose()
	  } catch (e) {
	    return Promise.reject(e)
	  }
	}

	/**
	 * Create a disposable from a promise for another disposable
	 * @param {Promise<Disposable>} disposablePromise
	 * @return {Disposable}
	 */


	/**
	 * Create a disposable proxy that allows its underlying disposable to
	 * be set later.
	 * @return {SettableDisposable}
	 */
	function settable () {
	  return new SettableDisposable()
	}

	/**
	 * Wrap an existing disposable (which may not already have been once()d)
	 * so that it will only dispose its underlying resource at most once.
	 * @param {{ dispose: function() }} disposable
	 * @return {Disposable} wrapped disposable
	 */
	function once (disposable) {
	  return new Disposable(disposeMemoized, memoized(disposable))
	}

	function disposeMemoized (memoized) {
	  if (!memoized.disposed) {
	    memoized.disposed = true;
	    memoized.value = disposeSafely(memoized.disposable);
	    memoized.disposable = void 0;
	  }

	  return memoized.value
	}

	function memoized (disposable) {
	  return { disposed: false, disposable: disposable, value: void 0 }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function fatalError (e) {
	  setTimeout(function () {
	    throw e
	  }, 0);
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function PropagateTask (run, value, sink) {
	  this._run = run;
	  this.value = value;
	  this.sink = sink;
	  this.active = true;
	}

	PropagateTask.event = function (value, sink) {
	  return new PropagateTask(emit, value, sink)
	};

	PropagateTask.end = function (value, sink) {
	  return new PropagateTask(end, value, sink)
	};

	PropagateTask.error = function (value, sink) {
	  return new PropagateTask(error$1, value, sink)
	};

	PropagateTask.prototype.dispose = function () {
	  this.active = false;
	};

	PropagateTask.prototype.run = function (t) {
	  if (!this.active) {
	    return
	  }
	  this._run(t, this.value, this.sink);
	};

	PropagateTask.prototype.error = function (t, e) {
	  if (!this.active) {
	    return fatalError(e)
	  }
	  this.sink.error(t, e);
	};

	function error$1 (t, e, sink) {
	  sink.error(t, e);
	}

	function emit (t, x, sink) {
	  sink.event(t, x);
	}

	function end (t, x, sink) {
	  sink.end(t, x);
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Stream containing only x
	 * @param {*} x
	 * @returns {Stream}
	 */
	function of (x) {
	  return new Stream(new Just(x))
	}

	function Just (x) {
	  this.value = x;
	}

	Just.prototype.run = function (sink, scheduler) {
	  return scheduler.asap(new PropagateTask(runJust, this.value, sink))
	};

	function runJust (t, x, sink) {
	  sink.event(t, x);
	  sink.end(t, void 0);
	}

	/**
	 * Stream containing no events and ends immediately
	 * @returns {Stream}
	 */
	function empty () {
	  return EMPTY
	}

	function EmptySource () {}

	EmptySource.prototype.run = function (sink, scheduler) {
	  var task = PropagateTask.end(void 0, sink);
	  scheduler.asap(task);

	  return create$2(disposeEmpty, task)
	};

	function disposeEmpty (task) {
	  return task.dispose()
	}

	var EMPTY = new Stream(new EmptySource());

	/**
	 * Stream containing no events and never ends
	 * @returns {Stream}
	 */

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function fromArray$1 (a) {
	  return new Stream(new ArraySource(a))
	}

	function ArraySource (a) {
	  this.array = a;
	}

	ArraySource.prototype.run = function (sink, scheduler) {
	  return scheduler.asap(new PropagateTask(runProducer, this.array, sink))
	};

	function runProducer (t, array, sink) {
	  for (var i = 0, l = array.length; i < l && this.active; ++i) {
	    sink.event(t, array[i]);
	  }

	  this.active && sink.end(t);
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/* global Set, Symbol */
	var iteratorSymbol;
	// Firefox ships a partial implementation using the name @@iterator.
	// https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
	if (typeof Set === 'function' && typeof new Set()['@@iterator'] === 'function') {
	  iteratorSymbol = '@@iterator';
	} else {
	  iteratorSymbol = typeof Symbol === 'function' ? Symbol.iterator
	  : '_es6shim_iterator_';
	}

	function isIterable (o) {
	  return typeof o[iteratorSymbol] === 'function'
	}

	function getIterator (o) {
	  return o[iteratorSymbol]()
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function fromIterable (iterable) {
	  return new Stream(new IterableSource(iterable))
	}

	function IterableSource (iterable) {
	  this.iterable = iterable;
	}

	IterableSource.prototype.run = function (sink, scheduler) {
	  return scheduler.asap(new PropagateTask(runProducer$1, getIterator(this.iterable), sink))
	};

	function runProducer$1 (t, iterator, sink) {
	  var r = iterator.next();

	  while (!r.done && this.active) {
	    sink.event(t, r.value);
	    r = iterator.next();
	  }

	  sink.end(t, r.value);
	}

	function symbolObservablePonyfill(root) {
		var result;
		var Symbol = root.Symbol;

		if (typeof Symbol === 'function') {
			if (Symbol.observable) {
				result = Symbol.observable;
			} else {
				result = Symbol('observable');
				Symbol.observable = result;
			}
		} else {
			result = '@@observable';
		}

		return result;
	}

	/* global window */
	var root;

	if (typeof self !== 'undefined') {
	  root = self;
	} else if (typeof window !== 'undefined') {
	  root = window;
	} else if (typeof global !== 'undefined') {
	  root = global;
	} else if (typeof module !== 'undefined') {
	  root = module;
	} else {
	  root = Function('return this')();
	}

	var result = symbolObservablePonyfill(root);

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function getObservable (o) { // eslint-disable-line complexity
	  var obs = null;
	  if (o) {
	  // Access foreign method only once
	    var method = o[result];
	    if (typeof method === 'function') {
	      obs = method.call(o);
	      if (!(obs && typeof obs.subscribe === 'function')) {
	        throw new TypeError('invalid observable ' + obs)
	      }
	    }
	  }

	  return obs
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function tryEvent (t, x, sink) {
	  try {
	    sink.event(t, x);
	  } catch (e) {
	    sink.error(t, e);
	  }
	}

	function tryEnd (t, x, sink) {
	  try {
	    sink.end(t, x);
	  } catch (e) {
	    sink.error(t, e);
	  }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function fromObservable (observable) {
	  return new Stream(new ObservableSource(observable))
	}

	function ObservableSource (observable) {
	  this.observable = observable;
	}

	ObservableSource.prototype.run = function (sink, scheduler) {
	  var sub = this.observable.subscribe(new SubscriberSink(sink, scheduler));
	  if (typeof sub === 'function') {
	    return create$2(sub)
	  } else if (sub && typeof sub.unsubscribe === 'function') {
	    return create$2(unsubscribe, sub)
	  }

	  throw new TypeError('Observable returned invalid subscription ' + String(sub))
	};

	function SubscriberSink (sink, scheduler) {
	  this.sink = sink;
	  this.scheduler = scheduler;
	}

	SubscriberSink.prototype.next = function (x) {
	  tryEvent(this.scheduler.now(), x, this.sink);
	};

	SubscriberSink.prototype.complete = function (x) {
	  tryEnd(this.scheduler.now(), x, this.sink);
	};

	SubscriberSink.prototype.error = function (e) {
	  this.sink.error(this.scheduler.now(), e);
	};

	function unsubscribe (subscription) {
	  return subscription.unsubscribe()
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function from (a) { // eslint-disable-line complexity
	  if (a instanceof Stream) {
	    return a
	  }

	  var observable = getObservable(a);
	  if (observable != null) {
	    return fromObservable(observable)
	  }

	  if (Array.isArray(a) || isArrayLike(a)) {
	    return fromArray$1(a)
	  }

	  if (isIterable(a)) {
	    return fromIterable(a)
	  }

	  throw new TypeError('from(x) must be observable, iterable, or array-like: ' + a)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Create a stream that emits the current time periodically
	 * @param {Number} period periodicity of events in millis
	 * @param {*} deprecatedValue @deprecated value to emit each period
	 * @returns {Stream} new stream that emits the current time every period
	 */

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function ScheduledTask (delay, period, task, scheduler) {
	  this.time = delay;
	  this.period = period;
	  this.task = task;
	  this.scheduler = scheduler;
	  this.active = true;
	}

	ScheduledTask.prototype.run = function () {
	  return this.task.run(this.time)
	};

	ScheduledTask.prototype.error = function (e) {
	  return this.task.error(this.time, e)
	};

	ScheduledTask.prototype.dispose = function () {
	  this.scheduler.cancel(this);
	  return this.task.dispose()
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function defer (task) {
	  return Promise.resolve(task).then(runTask)
	}

	function runTask (task) {
	  try {
	    return task.run()
	  } catch (e) {
	    return task.error(e)
	  }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function Scheduler (timer, timeline) {
	  this.timer = timer;
	  this.timeline = timeline;

	  this._timer = null;
	  this._nextArrival = Infinity;

	  var self = this;
	  this._runReadyTasksBound = function () {
	    self._runReadyTasks(self.now());
	  };
	}

	Scheduler.prototype.now = function () {
	  return this.timer.now()
	};

	Scheduler.prototype.asap = function (task) {
	  return this.schedule(0, -1, task)
	};

	Scheduler.prototype.delay = function (delay, task) {
	  return this.schedule(delay, -1, task)
	};

	Scheduler.prototype.periodic = function (period, task) {
	  return this.schedule(0, period, task)
	};

	Scheduler.prototype.schedule = function (delay, period, task) {
	  var now = this.now();
	  var st = new ScheduledTask(now + Math.max(0, delay), period, task, this);

	  this.timeline.add(st);
	  this._scheduleNextRun(now);
	  return st
	};

	Scheduler.prototype.cancel = function (task) {
	  task.active = false;
	  if (this.timeline.remove(task)) {
	    this._reschedule();
	  }
	};

	Scheduler.prototype.cancelAll = function (f) {
	  this.timeline.removeAll(f);
	  this._reschedule();
	};

	Scheduler.prototype._reschedule = function () {
	  if (this.timeline.isEmpty()) {
	    this._unschedule();
	  } else {
	    this._scheduleNextRun(this.now());
	  }
	};

	Scheduler.prototype._unschedule = function () {
	  this.timer.clearTimer(this._timer);
	  this._timer = null;
	};

	Scheduler.prototype._scheduleNextRun = function (now) { // eslint-disable-line complexity
	  if (this.timeline.isEmpty()) {
	    return
	  }

	  var nextArrival = this.timeline.nextArrival();

	  if (this._timer === null) {
	    this._scheduleNextArrival(nextArrival, now);
	  } else if (nextArrival < this._nextArrival) {
	    this._unschedule();
	    this._scheduleNextArrival(nextArrival, now);
	  }
	};

	Scheduler.prototype._scheduleNextArrival = function (nextArrival, now) {
	  this._nextArrival = nextArrival;
	  var delay = Math.max(0, nextArrival - now);
	  this._timer = this.timer.setTimer(this._runReadyTasksBound, delay);
	};

	Scheduler.prototype._runReadyTasks = function (now) {
	  this._timer = null;
	  this.timeline.runTasks(now, runTask);
	  this._scheduleNextRun(this.now());
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/* global setTimeout, clearTimeout */

	function ClockTimer () {}

	ClockTimer.prototype.now = Date.now;

	ClockTimer.prototype.setTimer = function (f, dt) {
	  return dt <= 0 ? runAsap(f) : setTimeout(f, dt)
	};

	ClockTimer.prototype.clearTimer = function (t) {
	  return t instanceof Asap ? t.cancel() : clearTimeout(t)
	};

	function Asap (f) {
	  this.f = f;
	  this.active = true;
	}

	Asap.prototype.run = function () {
	  return this.active && this.f()
	};

	Asap.prototype.error = function (e) {
	  throw e
	};

	Asap.prototype.cancel = function () {
	  this.active = false;
	};

	function runAsap (f) {
	  var task = new Asap(f);
	  defer(task);
	  return task
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function Timeline () {
	  this.tasks = [];
	}

	Timeline.prototype.nextArrival = function () {
	  return this.isEmpty() ? Infinity : this.tasks[0].time
	};

	Timeline.prototype.isEmpty = function () {
	  return this.tasks.length === 0
	};

	Timeline.prototype.add = function (st) {
	  insertByTime(st, this.tasks);
	};

	Timeline.prototype.remove = function (st) {
	  var i = binarySearch(st.time, this.tasks);

	  if (i >= 0 && i < this.tasks.length) {
	    var at = findIndex(st, this.tasks[i].events);
	    if (at >= 0) {
	      this.tasks[i].events.splice(at, 1);
	      return true
	    }
	  }

	  return false
	};

	Timeline.prototype.removeAll = function (f) {
	  for (var i = 0, l = this.tasks.length; i < l; ++i) {
	    removeAllFrom(f, this.tasks[i]);
	  }
	};

	Timeline.prototype.runTasks = function (t, runTask) {
	  var tasks = this.tasks;
	  var l = tasks.length;
	  var i = 0;

	  while (i < l && tasks[i].time <= t) {
	    ++i;
	  }

	  this.tasks = tasks.slice(i);

	  // Run all ready tasks
	  for (var j = 0; j < i; ++j) {
	    this.tasks = runTasks(runTask, tasks[j], this.tasks);
	  }
	};

	function runTasks (runTask, timeslot, tasks) { // eslint-disable-line complexity
	  var events = timeslot.events;
	  for (var i = 0; i < events.length; ++i) {
	    var task = events[i];

	    if (task.active) {
	      runTask(task);

	      // Reschedule periodic repeating tasks
	      // Check active again, since a task may have canceled itself
	      if (task.period >= 0 && task.active) {
	        task.time = task.time + task.period;
	        insertByTime(task, tasks);
	      }
	    }
	  }

	  return tasks
	}

	function insertByTime (task, timeslots) { // eslint-disable-line complexity
	  var l = timeslots.length;

	  if (l === 0) {
	    timeslots.push(newTimeslot(task.time, [task]));
	    return
	  }

	  var i = binarySearch(task.time, timeslots);

	  if (i >= l) {
	    timeslots.push(newTimeslot(task.time, [task]));
	  } else if (task.time === timeslots[i].time) {
	    timeslots[i].events.push(task);
	  } else {
	    timeslots.splice(i, 0, newTimeslot(task.time, [task]));
	  }
	}

	function removeAllFrom (f, timeslot) {
	  timeslot.events = removeAll(f, timeslot.events);
	}

	function binarySearch (t, sortedArray) { // eslint-disable-line complexity
	  var lo = 0;
	  var hi = sortedArray.length;
	  var mid, y;

	  while (lo < hi) {
	    mid = Math.floor((lo + hi) / 2);
	    y = sortedArray[mid];

	    if (t === y.time) {
	      return mid
	    } else if (t < y.time) {
	      hi = mid;
	    } else {
	      lo = mid + 1;
	    }
	  }
	  return hi
	}

	function newTimeslot (t, events) {
	  return { time: t, events: events }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	var defaultScheduler = new Scheduler(new ClockTimer(), new Timeline());

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function subscribe (subscriber, stream) {
	  if (Object(subscriber) !== subscriber) {
	    throw new TypeError('subscriber must be an object')
	  }

	  var disposable = settable();
	  var observer = new SubscribeObserver(fatalError, subscriber, disposable);

	  disposable.setDisposable(stream.source.run(observer, defaultScheduler));

	  return new Subscription(disposable)
	}

	function SubscribeObserver (fatalError$$1, subscriber, disposable) {
	  this.fatalError = fatalError$$1;
	  this.subscriber = subscriber;
	  this.disposable = disposable;
	}

	SubscribeObserver.prototype.event = function (t, x) {
	  if (!this.disposable.disposed && typeof this.subscriber.next === 'function') {
	    this.subscriber.next(x);
	  }
	};

	SubscribeObserver.prototype.end = function (t, x) {
	  if (!this.disposable.disposed) {
	    var s = this.subscriber;
	    var fatalError$$1 = this.fatalError;
	    Promise.resolve(this.disposable.dispose()).then(function () {
	      if (typeof s.complete === 'function') {
	        s.complete(x);
	      }
	    }).catch(function (e) {
	      throwError(e, s, fatalError$$1);
	    });
	  }
	};

	SubscribeObserver.prototype.error = function (t, e) {
	  var s = this.subscriber;
	  var fatalError$$1 = this.fatalError;
	  Promise.resolve(this.disposable.dispose()).then(function () {
	    throwError(e, s, fatalError$$1);
	  });
	};

	function Subscription (disposable) {
	  this.disposable = disposable;
	}

	Subscription.prototype.unsubscribe = function () {
	  this.disposable.dispose();
	};

	function throwError (e1, subscriber, throwError) {
	  if (typeof subscriber.error === 'function') {
	    try {
	      subscriber.error(e1);
	    } catch (e2) {
	      throwError(e2);
	    }
	  } else {
	    throwError(e1);
	  }
	}

	/** @license MIT License (c) copyright 2010-2017 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function thru (f, stream) {
	  return f(stream)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function EventTargetSource (event, source, capture) {
	  this.event = event;
	  this.source = source;
	  this.capture = capture;
	}

	EventTargetSource.prototype.run = function (sink, scheduler) {
	  function addEvent (e) {
	    tryEvent(scheduler.now(), e, sink);
	  }

	  this.source.addEventListener(this.event, addEvent, this.capture);

	  return create$2(disposeEventTarget,
	    { target: this, addEvent: addEvent })
	};

	function disposeEventTarget (info) {
	  var target = info.target;
	  target.source.removeEventListener(target.event, info.addEvent, target.capture);
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function DeferredSink (sink) {
	  this.sink = sink;
	  this.events = [];
	  this.active = true;
	}

	DeferredSink.prototype.event = function (t, x) {
	  if (!this.active) {
	    return
	  }

	  if (this.events.length === 0) {
	    defer(new PropagateAllTask(this.sink, t, this.events));
	  }

	  this.events.push({ time: t, value: x });
	};

	DeferredSink.prototype.end = function (t, x) {
	  if (!this.active) {
	    return
	  }

	  this._end(new EndTask(t, x, this.sink));
	};

	DeferredSink.prototype.error = function (t, e) {
	  this._end(new ErrorTask(t, e, this.sink));
	};

	DeferredSink.prototype._end = function (task) {
	  this.active = false;
	  defer(task);
	};

	function PropagateAllTask (sink, time, events) {
	  this.sink = sink;
	  this.events = events;
	  this.time = time;
	}

	PropagateAllTask.prototype.run = function () {
	  var events = this.events;
	  var sink = this.sink;
	  var event;

	  for (var i = 0, l = events.length; i < l; ++i) {
	    event = events[i];
	    this.time = event.time;
	    sink.event(event.time, event.value);
	  }

	  events.length = 0;
	};

	PropagateAllTask.prototype.error = function (e) {
	  this.sink.error(this.time, e);
	};

	function EndTask (t, x, sink) {
	  this.time = t;
	  this.value = x;
	  this.sink = sink;
	}

	EndTask.prototype.run = function () {
	  this.sink.end(this.time, this.value);
	};

	EndTask.prototype.error = function (e) {
	  this.sink.error(this.time, e);
	};

	function ErrorTask (t, e, sink) {
	  this.time = t;
	  this.value = e;
	  this.sink = sink;
	}

	ErrorTask.prototype.run = function () {
	  this.sink.error(this.time, this.value);
	};

	ErrorTask.prototype.error = function (e) {
	  throw e
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function EventEmitterSource (event, source) {
	  this.event = event;
	  this.source = source;
	}

	EventEmitterSource.prototype.run = function (sink, scheduler) {
	  // NOTE: Because EventEmitter allows events in the same call stack as
	  // a listener is added, use a DeferredSink to buffer events
	  // until the stack clears, then propagate.  This maintains most.js's
	  // invariant that no event will be delivered in the same call stack
	  // as an observer begins observing.
	  var dsink = new DeferredSink(sink);

	  function addEventVariadic (a) {
	    var l = arguments.length;
	    if (l > 1) {
	      var arr = new Array(l);
	      for (var i = 0; i < l; ++i) {
	        arr[i] = arguments[i];
	      }
	      tryEvent(scheduler.now(), arr, dsink);
	    } else {
	      tryEvent(scheduler.now(), a, dsink);
	    }
	  }

	  this.source.addListener(this.event, addEventVariadic);

	  return create$2(disposeEventEmitter, { target: this, addEvent: addEventVariadic })
	};

	function disposeEventEmitter (info) {
	  var target = info.target;
	  target.source.removeListener(target.event, info.addEvent);
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Create a stream from an EventTarget, such as a DOM Node, or EventEmitter.
	 * @param {String} event event type name, e.g. 'click'
	 * @param {EventTarget|EventEmitter} source EventTarget or EventEmitter
	 * @param {*?} capture for DOM events, whether to use
	 *  capturing--passed as 3rd parameter to addEventListener.
	 * @returns {Stream} stream containing all events of the specified type
	 * from the source.
	 */
	function fromEvent (event, source, capture) { // eslint-disable-line complexity
	  var s;

	  if (typeof source.addEventListener === 'function' && typeof source.removeEventListener === 'function') {
	    if (arguments.length < 3) {
	      capture = false;
	    }

	    s = new EventTargetSource(event, source, capture);
	  } else if (typeof source.addListener === 'function' && typeof source.removeListener === 'function') {
	    s = new EventEmitterSource(event, source);
	  } else {
	    throw new Error('source must support addEventListener/removeEventListener or addListener/removeListener')
	  }

	  return new Stream(s)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function withDefaultScheduler (source) {
	  return withScheduler(source, defaultScheduler)
	}

	function withScheduler (source, scheduler) {
	  return new Promise(function (resolve, reject) {
	    runSource(source, scheduler, resolve, reject);
	  })
	}

	function runSource (source, scheduler, resolve, reject) {
	  var disposable = settable();
	  var observer = new Drain(resolve, reject, disposable);

	  disposable.setDisposable(source.run(observer, scheduler));
	}

	function Drain (end, error, disposable) {
	  this._end = end;
	  this._error = error;
	  this._disposable = disposable;
	  this.active = true;
	}

	Drain.prototype.event = function (t, x) {};

	Drain.prototype.end = function (t, x) {
	  if (!this.active) {
	    return
	  }
	  this.active = false;
	  disposeThen(this._end, this._error, this._disposable, x);
	};

	Drain.prototype.error = function (t, e) {
	  this.active = false;
	  disposeThen(this._error, this._error, this._disposable, e);
	};

	function disposeThen (end, error, disposable, x) {
	  Promise.resolve(disposable.dispose()).then(function () {
	    end(x);
	  }, error);
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * A sink mixin that simply forwards event, end, and error to
	 * another sink.
	 * @param sink
	 * @constructor
	 */
	function Pipe (sink) {
	  this.sink = sink;
	}

	Pipe.prototype.event = function (t, x) {
	  return this.sink.event(t, x)
	};

	Pipe.prototype.end = function (t, x) {
	  return this.sink.end(t, x)
	};

	Pipe.prototype.error = function (t, e) {
	  return this.sink.error(t, e)
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function Filter (p, source) {
	  this.p = p;
	  this.source = source;
	}

	/**
	 * Create a filtered source, fusing adjacent filter.filter if possible
	 * @param {function(x:*):boolean} p filtering predicate
	 * @param {{run:function}} source source to filter
	 * @returns {Filter} filtered source
	 */
	Filter.create = function createFilter (p, source) {
	  if (source instanceof Filter) {
	    return new Filter(and(source.p, p), source.source)
	  }

	  return new Filter(p, source)
	};

	Filter.prototype.run = function (sink, scheduler) {
	  return this.source.run(new FilterSink(this.p, sink), scheduler)
	};

	function FilterSink (p, sink) {
	  this.p = p;
	  this.sink = sink;
	}

	FilterSink.prototype.end = Pipe.prototype.end;
	FilterSink.prototype.error = Pipe.prototype.error;

	FilterSink.prototype.event = function (t, x) {
	  var p = this.p;
	  p(x) && this.sink.event(t, x);
	};

	function and (p, q) {
	  return function (x) {
	    return p(x) && q(x)
	  }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function FilterMap (p, f, source) {
	  this.p = p;
	  this.f = f;
	  this.source = source;
	}

	FilterMap.prototype.run = function (sink, scheduler) {
	  return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler)
	};

	function FilterMapSink (p, f, sink) {
	  this.p = p;
	  this.f = f;
	  this.sink = sink;
	}

	FilterMapSink.prototype.event = function (t, x) {
	  var f = this.f;
	  var p = this.p;
	  p(x) && this.sink.event(t, f(x));
	};

	FilterMapSink.prototype.end = Pipe.prototype.end;
	FilterMapSink.prototype.error = Pipe.prototype.error;

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function Map (f, source) {
	  this.f = f;
	  this.source = source;
	}

	/**
	 * Create a mapped source, fusing adjacent map.map, filter.map,
	 * and filter.map.map if possible
	 * @param {function(*):*} f mapping function
	 * @param {{run:function}} source source to map
	 * @returns {Map|FilterMap} mapped source, possibly fused
	 */
	Map.create = function createMap (f, source) {
	  if (source instanceof Map) {
	    return new Map(compose(f, source.f), source.source)
	  }

	  if (source instanceof Filter) {
	    return new FilterMap(source.p, f, source.source)
	  }

	  return new Map(f, source)
	};

	Map.prototype.run = function (sink, scheduler) { // eslint-disable-line no-extend-native
	  return this.source.run(new MapSink(this.f, sink), scheduler)
	};

	function MapSink (f, sink) {
	  this.f = f;
	  this.sink = sink;
	}

	MapSink.prototype.end = Pipe.prototype.end;
	MapSink.prototype.error = Pipe.prototype.error;

	MapSink.prototype.event = function (t, x) {
	  var f = this.f;
	  this.sink.event(t, f(x));
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Transform each value in the stream by applying f to each
	 * @param {function(*):*} f mapping function
	 * @param {Stream} stream stream to map
	 * @returns {Stream} stream containing items transformed by f
	 */
	function map$4 (f, stream) {
	  return new Stream(Map.create(f, stream.source))
	}

	/**
	* Replace each value in the stream with x
	* @param {*} x
	* @param {Stream} stream
	* @returns {Stream} stream containing items replaced with x
	*/
	function constant (x, stream) {
	  return map$4(function () {
	    return x
	  }, stream)
	}

	/**
	* Perform a side effect for each item in the stream
	* @param {function(x:*):*} f side effect to execute for each item. The
	*  return value will be discarded.
	* @param {Stream} stream stream to tap
	* @returns {Stream} new stream containing the same items as this stream
	*/
	function tap (f, stream) {
	  return new Stream(new Tap(f, stream.source))
	}

	function Tap (f, source) {
	  this.source = source;
	  this.f = f;
	}

	Tap.prototype.run = function (sink, scheduler) {
	  return this.source.run(new TapSink(this.f, sink), scheduler)
	};

	function TapSink (f, sink) {
	  this.sink = sink;
	  this.f = f;
	}

	TapSink.prototype.end = Pipe.prototype.end;
	TapSink.prototype.error = Pipe.prototype.error;

	TapSink.prototype.event = function (t, x) {
	  var f = this.f;
	  f(x);
	  this.sink.event(t, x);
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Observe all the event values in the stream in time order. The
	 * provided function `f` will be called for each event value
	 * @param {function(x:T):*} f function to call with each event value
	 * @param {Stream<T>} stream stream to observe
	 * @return {Promise} promise that fulfills after the stream ends without
	 *  an error, or rejects if the stream ends with an error.
	 */
	function observe (f, stream) {
	  return drain(tap(f, stream))
	}

	/**
	 * "Run" a stream by creating demand and consuming all events
	 * @param {Stream<T>} stream stream to drain
	 * @return {Promise} promise that fulfills after the stream ends without
	 *  an error, or rejects if the stream ends with an error.
	 */
	function drain (stream) {
	  return withDefaultScheduler(stream.source)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Generalized feedback loop. Call a stepper function for each event. The stepper
	 * will be called with 2 params: the current seed and the an event value.  It must
	 * return a new { seed, value } pair. The `seed` will be fed back into the next
	 * invocation of stepper, and the `value` will be propagated as the event value.
	 * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function
	 * @param {*} seed initial seed value passed to first stepper call
	 * @param {Stream} stream event stream
	 * @returns {Stream} new stream whose values are the `value` field of the objects
	 * returned by the stepper
	 */
	function loop (stepper, seed, stream) {
	  return new Stream(new Loop(stepper, seed, stream.source))
	}

	function Loop (stepper, seed, source) {
	  this.step = stepper;
	  this.seed = seed;
	  this.source = source;
	}

	Loop.prototype.run = function (sink, scheduler) {
	  return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler)
	};

	function LoopSink (stepper, seed, sink) {
	  this.step = stepper;
	  this.seed = seed;
	  this.sink = sink;
	}

	LoopSink.prototype.error = Pipe.prototype.error;

	LoopSink.prototype.event = function (t, x) {
	  var result = this.step(this.seed, x);
	  this.seed = result.seed;
	  this.sink.event(t, result.value);
	};

	LoopSink.prototype.end = function (t) {
	  this.sink.end(t, this.seed);
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Create a stream containing successive reduce results of applying f to
	 * the previous reduce result and the current stream item.
	 * @param {function(result:*, x:*):*} f reducer function
	 * @param {*} initial initial value
	 * @param {Stream} stream stream to scan
	 * @returns {Stream} new stream containing successive reduce results
	 */
	function scan (f, initial, stream) {
	  return new Stream(new Scan(f, initial, stream.source))
	}

	function Scan (f, z, source) {
	  this.source = source;
	  this.f = f;
	  this.value = z;
	}

	Scan.prototype.run = function (sink, scheduler) {
	  var d1 = scheduler.asap(PropagateTask.event(this.value, sink));
	  var d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler);
	  return all([d1, d2])
	};

	function ScanSink (f, z, sink) {
	  this.f = f;
	  this.value = z;
	  this.sink = sink;
	}

	ScanSink.prototype.event = function (t, x) {
	  var f = this.f;
	  this.value = f(this.value, x);
	  this.sink.event(t, this.value);
	};

	ScanSink.prototype.error = Pipe.prototype.error;
	ScanSink.prototype.end = Pipe.prototype.end;

	/**
	* Reduce a stream to produce a single result.  Note that reducing an infinite
	* stream will return a Promise that never fulfills, but that may reject if an error
	* occurs.
	* @param {function(result:*, x:*):*} f reducer function
	* @param {*} initial initial value
	* @param {Stream} stream to reduce
	* @returns {Promise} promise for the file result of the reduce
	*/
	function reduce$1 (f, initial, stream) {
	  return withDefaultScheduler(new Reduce(f, initial, stream.source))
	}

	function Reduce (f, z, source) {
	  this.source = source;
	  this.f = f;
	  this.value = z;
	}

	Reduce.prototype.run = function (sink, scheduler) {
	  return this.source.run(new ReduceSink(this.f, this.value, sink), scheduler)
	};

	function ReduceSink (f, z, sink) {
	  this.f = f;
	  this.value = z;
	  this.sink = sink;
	}

	ReduceSink.prototype.event = function (t, x) {
	  var f = this.f;
	  this.value = f(this.value, x);
	  this.sink.event(t, this.value);
	};

	ReduceSink.prototype.error = Pipe.prototype.error;

	ReduceSink.prototype.end = function (t) {
	  this.sink.end(t, this.value);
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Compute a stream by unfolding tuples of future values from a seed value
	 * Event times may be controlled by returning a Promise from f
	 * @param {function(seed:*):{value:*, seed:*, done:boolean}|Promise<{value:*, seed:*, done:boolean}>} f unfolding function accepts
	 *  a seed and returns a new tuple with a value, new seed, and boolean done flag.
	 *  If tuple.done is true, the stream will end.
	 * @param {*} seed seed value
	 * @returns {Stream} stream containing all value of all tuples produced by the
	 *  unfolding function.
	 */

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Compute a stream by iteratively calling f to produce values
	 * Event times may be controlled by returning a Promise from f
	 * @param {function(x:*):*|Promise<*>} f
	 * @param {*} x initial value
	 * @returns {Stream}
	 */

	/** @license MIT License (c) copyright 2010-2014 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Compute a stream using an *async* generator, which yields promises
	 * to control event times.
	 * @param f
	 * @returns {Stream}
	 */

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function continueWith (f, stream) {
	  return new Stream(new ContinueWith(f, stream.source))
	}

	function ContinueWith (f, source) {
	  this.f = f;
	  this.source = source;
	}

	ContinueWith.prototype.run = function (sink, scheduler) {
	  return new ContinueWithSink(this.f, this.source, sink, scheduler)
	};

	function ContinueWithSink (f, source, sink, scheduler) {
	  this.f = f;
	  this.sink = sink;
	  this.scheduler = scheduler;
	  this.active = true;
	  this.disposable = once(source.run(this, scheduler));
	}

	ContinueWithSink.prototype.error = Pipe.prototype.error;

	ContinueWithSink.prototype.event = function (t, x) {
	  if (!this.active) {
	    return
	  }
	  this.sink.event(t, x);
	};

	ContinueWithSink.prototype.end = function (t, x) {
	  if (!this.active) {
	    return
	  }

	  tryDispose(t, this.disposable, this.sink);
	  this._startNext(t, x, this.sink);
	};

	ContinueWithSink.prototype._startNext = function (t, x, sink) {
	  try {
	    this.disposable = this._continue(this.f, x, sink);
	  } catch (e) {
	    sink.error(t, e);
	  }
	};

	ContinueWithSink.prototype._continue = function (f, x, sink) {
	  return f(x).source.run(sink, this.scheduler)
	};

	ContinueWithSink.prototype.dispose = function () {
	  this.active = false;
	  return this.disposable.dispose()
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * @param {*} x value to prepend
	 * @param {Stream} stream
	 * @returns {Stream} new stream with x prepended
	 */
	function cons$1 (x, stream) {
	  return concat(of(x), stream)
	}

	/**
	* @param {Stream} left
	* @param {Stream} right
	* @returns {Stream} new stream containing all events in left followed by all
	*  events in right.  This *timeshifts* right to the end of left.
	*/
	function concat (left, right) {
	  return continueWith(function () {
	    return right
	  }, left)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function IndexSink (i, sink) {
	  this.sink = sink;
	  this.index = i;
	  this.active = true;
	  this.value = void 0;
	}

	IndexSink.prototype.event = function (t, x) {
	  if (!this.active) {
	    return
	  }
	  this.value = x;
	  this.sink.event(t, this);
	};

	IndexSink.prototype.end = function (t, x) {
	  if (!this.active) {
	    return
	  }
	  this.active = false;
	  this.sink.end(t, { index: this.index, value: x });
	};

	IndexSink.prototype.error = Pipe.prototype.error;

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function invoke (f, args) {
	  /* eslint complexity: [2,7] */
	  switch (args.length) {
	    case 0: return f()
	    case 1: return f(args[0])
	    case 2: return f(args[0], args[1])
	    case 3: return f(args[0], args[1], args[2])
	    case 4: return f(args[0], args[1], args[2], args[3])
	    case 5: return f(args[0], args[1], args[2], args[3], args[4])
	    default:
	      return f.apply(void 0, args)
	  }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	var map$5 = map$2;
	var tail$1 = tail;

	/**
	 * Combine latest events from all input streams
	 * @param {function(...events):*} f function to combine most recent events
	 * @returns {Stream} stream containing the result of applying f to the most recent
	 *  event of each input stream, whenever a new event arrives on any stream.
	 */
	function combine (f /*, ...streams */) {
	  return combineArray(f, tail$1(arguments))
	}

	/**
	* Combine latest events from all input streams
	* @param {function(...events):*} f function to combine most recent events
	* @param {[Stream]} streams most recent events
	* @returns {Stream} stream containing the result of applying f to the most recent
	*  event of each input stream, whenever a new event arrives on any stream.
	*/
	function combineArray (f, streams) {
	  var l = streams.length;
	  return l === 0 ? empty()
	  : l === 1 ? map$4(f, streams[0])
	  : new Stream(combineSources(f, streams))
	}

	function combineSources (f, streams) {
	  return new Combine(f, map$5(getSource, streams))
	}

	function getSource (stream) {
	  return stream.source
	}

	function Combine (f, sources) {
	  this.f = f;
	  this.sources = sources;
	}

	Combine.prototype.run = function (sink, scheduler) {
	  var l = this.sources.length;
	  var disposables = new Array(l);
	  var sinks = new Array(l);

	  var mergeSink = new CombineSink(disposables, sinks, sink, this.f);

	  for (var indexSink, i = 0; i < l; ++i) {
	    indexSink = sinks[i] = new IndexSink(i, mergeSink);
	    disposables[i] = this.sources[i].run(indexSink, scheduler);
	  }

	  return all(disposables)
	};

	function CombineSink (disposables, sinks, sink, f) {
	  this.sink = sink;
	  this.disposables = disposables;
	  this.sinks = sinks;
	  this.f = f;

	  var l = sinks.length;
	  this.awaiting = l;
	  this.values = new Array(l);
	  this.hasValue = new Array(l);
	  for (var i = 0; i < l; ++i) {
	    this.hasValue[i] = false;
	  }

	  this.activeCount = sinks.length;
	}

	CombineSink.prototype.error = Pipe.prototype.error;

	CombineSink.prototype.event = function (t, indexedValue) {
	  var i = indexedValue.index;
	  var awaiting = this._updateReady(i);

	  this.values[i] = indexedValue.value;
	  if (awaiting === 0) {
	    this.sink.event(t, invoke(this.f, this.values));
	  }
	};

	CombineSink.prototype._updateReady = function (index) {
	  if (this.awaiting > 0) {
	    if (!this.hasValue[index]) {
	      this.hasValue[index] = true;
	      this.awaiting -= 1;
	    }
	  }
	  return this.awaiting
	};

	CombineSink.prototype.end = function (t, indexedValue) {
	  tryDispose(t, this.disposables[indexedValue.index], this.sink);
	  if (--this.activeCount === 0) {
	    this.sink.end(t, indexedValue.value);
	  }
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Assume fs is a stream containing functions, and apply the latest function
	 * in fs to the latest value in xs.
	 * fs:         --f---------g--------h------>
	 * xs:         -a-------b-------c-------d-->
	 * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->
	 * @param {Stream} fs stream of functions to apply to the latest x
	 * @param {Stream} xs stream of values to which to apply all the latest f
	 * @returns {Stream} stream containing all the applications of fs to xs
	 */
	function ap (fs, xs) {
	  return combine(apply, fs, xs)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Transform a stream by passing its events through a transducer.
	 * @param  {function} transducer transducer function
	 * @param  {Stream} stream stream whose events will be passed through the
	 *  transducer
	 * @return {Stream} stream of events transformed by the transducer
	 */
	function transduce (transducer, stream) {
	  return new Stream(new Transduce(transducer, stream.source))
	}

	function Transduce (transducer, source) {
	  this.transducer = transducer;
	  this.source = source;
	}

	Transduce.prototype.run = function (sink, scheduler) {
	  var xf = this.transducer(new Transformer(sink));
	  return this.source.run(new TransduceSink(getTxHandler(xf), sink), scheduler)
	};

	function TransduceSink (adapter, sink) {
	  this.xf = adapter;
	  this.sink = sink;
	}

	TransduceSink.prototype.event = function (t, x) {
	  var next = this.xf.step(t, x);

	  return this.xf.isReduced(next)
	    ? this.sink.end(t, this.xf.getResult(next))
	    : next
	};

	TransduceSink.prototype.end = function (t, x) {
	  return this.xf.result(x)
	};

	TransduceSink.prototype.error = function (t, e) {
	  return this.sink.error(t, e)
	};

	function Transformer (sink) {
	  this.time = -Infinity;
	  this.sink = sink;
	}

	Transformer.prototype['@@transducer/init'] = Transformer.prototype.init = function () {};

	Transformer.prototype['@@transducer/step'] = Transformer.prototype.step = function (t, x) {
	  if (!isNaN(t)) {
	    this.time = Math.max(t, this.time);
	  }
	  return this.sink.event(this.time, x)
	};

	Transformer.prototype['@@transducer/result'] = Transformer.prototype.result = function (x) {
	  return this.sink.end(this.time, x)
	};

	/**
	* Given an object supporting the new or legacy transducer protocol,
	* create an adapter for it.
	* @param {object} tx transform
	* @returns {TxAdapter|LegacyTxAdapter}
	*/
	function getTxHandler (tx) {
	  return typeof tx['@@transducer/step'] === 'function'
	    ? new TxAdapter(tx)
	    : new LegacyTxAdapter(tx)
	}

	/**
	* Adapter for new official transducer protocol
	* @param {object} tx transform
	* @constructor
	*/
	function TxAdapter (tx) {
	  this.tx = tx;
	}

	TxAdapter.prototype.step = function (t, x) {
	  return this.tx['@@transducer/step'](t, x)
	};
	TxAdapter.prototype.result = function (x) {
	  return this.tx['@@transducer/result'](x)
	};
	TxAdapter.prototype.isReduced = function (x) {
	  return x != null && x['@@transducer/reduced']
	};
	TxAdapter.prototype.getResult = function (x) {
	  return x['@@transducer/value']
	};

	/**
	* Adapter for older transducer protocol
	* @param {object} tx transform
	* @constructor
	*/
	function LegacyTxAdapter (tx) {
	  this.tx = tx;
	}

	LegacyTxAdapter.prototype.step = function (t, x) {
	  return this.tx.step(t, x)
	};
	LegacyTxAdapter.prototype.result = function (x) {
	  return this.tx.result(x)
	};
	LegacyTxAdapter.prototype.isReduced = function (x) {
	  return x != null && x.__transducers_reduced__
	};
	LegacyTxAdapter.prototype.getResult = function (x) {
	  return x.value
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Doubly linked list
	 * @constructor
	 */
	function LinkedList () {
	  this.head = null;
	  this.length = 0;
	}

	/**
	 * Add a node to the end of the list
	 * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to add
	 */
	LinkedList.prototype.add = function (x) {
	  if (this.head !== null) {
	    this.head.prev = x;
	    x.next = this.head;
	  }
	  this.head = x;
	  ++this.length;
	};

	/**
	 * Remove the provided node from the list
	 * @param {{prev:Object|null, next:Object|null, dispose:function}} x node to remove
	 */
	LinkedList.prototype.remove = function (x) { // eslint-disable-line  complexity
	  --this.length;
	  if (x === this.head) {
	    this.head = this.head.next;
	  }
	  if (x.next !== null) {
	    x.next.prev = x.prev;
	    x.next = null;
	  }
	  if (x.prev !== null) {
	    x.prev.next = x.next;
	    x.prev = null;
	  }
	};

	/**
	 * @returns {boolean} true iff there are no nodes in the list
	 */
	LinkedList.prototype.isEmpty = function () {
	  return this.length === 0
	};

	/**
	 * Dispose all nodes
	 * @returns {Promise} promise that fulfills when all nodes have been disposed,
	 *  or rejects if an error occurs while disposing
	 */
	LinkedList.prototype.dispose = function () {
	  if (this.isEmpty()) {
	    return Promise.resolve()
	  }

	  var promises = [];
	  var x = this.head;
	  this.head = null;
	  this.length = 0;

	  while (x !== null) {
	    promises.push(x.dispose());
	    x = x.next;
	  }

	  return Promise.all(promises)
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function mergeConcurrently (concurrency, stream) {
	  return mergeMapConcurrently(id$1, concurrency, stream)
	}

	function mergeMapConcurrently (f, concurrency, stream) {
	  return new Stream(new MergeConcurrently(f, concurrency, stream.source))
	}

	function MergeConcurrently (f, concurrency, source) {
	  this.f = f;
	  this.concurrency = concurrency;
	  this.source = source;
	}

	MergeConcurrently.prototype.run = function (sink, scheduler) {
	  return new Outer(this.f, this.concurrency, this.source, sink, scheduler)
	};

	function Outer (f, concurrency, source, sink, scheduler) {
	  this.f = f;
	  this.concurrency = concurrency;
	  this.sink = sink;
	  this.scheduler = scheduler;
	  this.pending = [];
	  this.current = new LinkedList();
	  this.disposable = once(source.run(this, scheduler));
	  this.active = true;
	}

	Outer.prototype.event = function (t, x) {
	  this._addInner(t, x);
	};

	Outer.prototype._addInner = function (t, x) {
	  if (this.current.length < this.concurrency) {
	    this._startInner(t, x);
	  } else {
	    this.pending.push(x);
	  }
	};

	Outer.prototype._startInner = function (t, x) {
	  try {
	    this._initInner(t, x);
	  } catch (e) {
	    this.error(t, e);
	  }
	};

	Outer.prototype._initInner = function (t, x) {
	  var innerSink = new Inner(t, this, this.sink);
	  innerSink.disposable = mapAndRun(this.f, x, innerSink, this.scheduler);
	  this.current.add(innerSink);
	};

	function mapAndRun (f, x, sink, scheduler) {
	  return f(x).source.run(sink, scheduler)
	}

	Outer.prototype.end = function (t, x) {
	  this.active = false;
	  tryDispose(t, this.disposable, this.sink);
	  this._checkEnd(t, x);
	};

	Outer.prototype.error = function (t, e) {
	  this.active = false;
	  this.sink.error(t, e);
	};

	Outer.prototype.dispose = function () {
	  this.active = false;
	  this.pending.length = 0;
	  return Promise.all([this.disposable.dispose(), this.current.dispose()])
	};

	Outer.prototype._endInner = function (t, x, inner) {
	  this.current.remove(inner);
	  tryDispose(t, inner, this);

	  if (this.pending.length === 0) {
	    this._checkEnd(t, x);
	  } else {
	    this._startInner(t, this.pending.shift());
	  }
	};

	Outer.prototype._checkEnd = function (t, x) {
	  if (!this.active && this.current.isEmpty()) {
	    this.sink.end(t, x);
	  }
	};

	function Inner (time, outer, sink) {
	  this.prev = this.next = null;
	  this.time = time;
	  this.outer = outer;
	  this.sink = sink;
	  this.disposable = void 0;
	}

	Inner.prototype.event = function (t, x) {
	  this.sink.event(Math.max(t, this.time), x);
	};

	Inner.prototype.end = function (t, x) {
	  this.outer._endInner(Math.max(t, this.time), x, this);
	};

	Inner.prototype.error = function (t, e) {
	  this.outer.error(Math.max(t, this.time), e);
	};

	Inner.prototype.dispose = function () {
	  return this.disposable.dispose()
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Map each value in the stream to a new stream, and merge it into the
	 * returned outer stream. Event arrival times are preserved.
	 * @param {function(x:*):Stream} f chaining function, must return a Stream
	 * @param {Stream} stream
	 * @returns {Stream} new stream containing all events from each stream returned by f
	 */
	function flatMap (f, stream) {
	  return mergeMapConcurrently(f, Infinity, stream)
	}

	/**
	 * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner
	 * streams to the outer. Event arrival times are preserved.
	 * @param {Stream<Stream<X>>} stream stream of streams
	 * @returns {Stream<X>} new stream containing all events of all inner streams
	 */
	function join (stream) {
	  return mergeConcurrently(Infinity, stream)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Map each value in stream to a new stream, and concatenate them all
	 * stream:              -a---b---cX
	 * f(a):                 1-1-1-1X
	 * f(b):                        -2-2-2-2X
	 * f(c):                                -3-3-3-3X
	 * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X
	 * @param {function(x:*):Stream} f function to map each value to a stream
	 * @param {Stream} stream
	 * @returns {Stream} new stream containing all events from each stream returned by f
	 */
	function concatMap (f, stream) {
	  return mergeMapConcurrently(f, 1, stream)
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	var copy$1 = copy;
	var reduce$2 = reduce;

	/**
	 * @returns {Stream} stream containing events from all streams in the argument
	 * list in time order.  If two events are simultaneous they will be merged in
	 * arbitrary order.
	 */
	function merge (/* ...streams */) {
	  return mergeArray(copy$1(arguments))
	}

	/**
	 * @param {Array} streams array of stream to merge
	 * @returns {Stream} stream containing events from all input observables
	 * in time order.  If two events are simultaneous they will be merged in
	 * arbitrary order.
	 */
	function mergeArray (streams) {
	  var l = streams.length;
	  return l === 0 ? empty()
	    : l === 1 ? streams[0]
	    : new Stream(mergeSources(streams))
	}

	/**
	 * This implements fusion/flattening for merge.  It will
	 * fuse adjacent merge operations.  For example:
	 * - a.merge(b).merge(c) effectively becomes merge(a, b, c)
	 * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)
	 * It does this by concatenating the sources arrays of
	 * any nested Merge sources, in effect "flattening" nested
	 * merge operations into a single merge.
	 */
	function mergeSources (streams) {
	  return new Merge(reduce$2(appendSources, [], streams))
	}

	function appendSources (sources, stream) {
	  var source = stream.source;
	  return source instanceof Merge
	    ? sources.concat(source.sources)
	    : sources.concat(source)
	}

	function Merge (sources) {
	  this.sources = sources;
	}

	Merge.prototype.run = function (sink, scheduler) {
	  var l = this.sources.length;
	  var disposables = new Array(l);
	  var sinks = new Array(l);

	  var mergeSink = new MergeSink(disposables, sinks, sink);

	  for (var indexSink, i = 0; i < l; ++i) {
	    indexSink = sinks[i] = new IndexSink(i, mergeSink);
	    disposables[i] = this.sources[i].run(indexSink, scheduler);
	  }

	  return all(disposables)
	};

	function MergeSink (disposables, sinks, sink) {
	  this.sink = sink;
	  this.disposables = disposables;
	  this.activeCount = sinks.length;
	}

	MergeSink.prototype.error = Pipe.prototype.error;

	MergeSink.prototype.event = function (t, indexValue) {
	  this.sink.event(t, indexValue.value);
	};

	MergeSink.prototype.end = function (t, indexedValue) {
	  tryDispose(t, this.disposables[indexedValue.index], this.sink);
	  if (--this.activeCount === 0) {
	    this.sink.end(t, indexedValue.value);
	  }
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * When an event arrives on sampler, emit the result of calling f with the latest
	 * values of all streams being sampled
	 * @param {function(...values):*} f function to apply to each set of sampled values
	 * @param {Stream} sampler streams will be sampled whenever an event arrives
	 *  on sampler
	 * @returns {Stream} stream of sampled and transformed values
	 */


	/**
	 * When an event arrives on sampler, emit the latest event value from stream.
	 * @param {Stream} sampler stream of events at whose arrival time
	 *  stream's latest value will be propagated
	 * @param {Stream} stream stream of values
	 * @returns {Stream} sampled stream of values
	 */
	function sampleWith (sampler, stream) {
	  return new Stream(new Sampler(id$1, sampler.source, [stream.source]))
	}

	function sampleArray (f, sampler, streams) {
	  return new Stream(new Sampler(f, sampler.source, map$2(getSource$1, streams)))
	}

	function getSource$1 (stream) {
	  return stream.source
	}

	function Sampler (f, sampler, sources) {
	  this.f = f;
	  this.sampler = sampler;
	  this.sources = sources;
	}

	Sampler.prototype.run = function (sink, scheduler) {
	  var l = this.sources.length;
	  var disposables = new Array(l + 1);
	  var sinks = new Array(l);

	  var sampleSink = new SampleSink(this.f, sinks, sink);

	  for (var hold, i = 0; i < l; ++i) {
	    hold = sinks[i] = new Hold(sampleSink);
	    disposables[i] = this.sources[i].run(hold, scheduler);
	  }

	  disposables[i] = this.sampler.run(sampleSink, scheduler);

	  return all(disposables)
	};

	function Hold (sink) {
	  this.sink = sink;
	  this.hasValue = false;
	}

	Hold.prototype.event = function (t, x) {
	  this.value = x;
	  this.hasValue = true;
	  this.sink._notify(this);
	};

	Hold.prototype.end = function () {};
	Hold.prototype.error = Pipe.prototype.error;

	function SampleSink (f, sinks, sink) {
	  this.f = f;
	  this.sinks = sinks;
	  this.sink = sink;
	  this.active = false;
	}

	SampleSink.prototype._notify = function () {
	  if (!this.active) {
	    this.active = this.sinks.every(hasValue);
	  }
	};

	SampleSink.prototype.event = function (t) {
	  if (this.active) {
	    this.sink.event(t, invoke(this.f, map$2(getValue, this.sinks)));
	  }
	};

	SampleSink.prototype.end = Pipe.prototype.end;
	SampleSink.prototype.error = Pipe.prototype.error;

	function hasValue (hold) {
	  return hold.hasValue
	}

	function getValue (hold) {
	  return hold.value
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	// Based on https://github.com/petkaantonov/deque

	function Queue (capPow2) {
	  this._capacity = capPow2 || 32;
	  this._length = 0;
	  this._head = 0;
	}

	Queue.prototype.push = function (x) {
	  var len = this._length;
	  this._checkCapacity(len + 1);

	  var i = (this._head + len) & (this._capacity - 1);
	  this[i] = x;
	  this._length = len + 1;
	};

	Queue.prototype.shift = function () {
	  var head = this._head;
	  var x = this[head];

	  this[head] = void 0;
	  this._head = (head + 1) & (this._capacity - 1);
	  this._length--;
	  return x
	};

	Queue.prototype.isEmpty = function () {
	  return this._length === 0
	};

	Queue.prototype.length = function () {
	  return this._length
	};

	Queue.prototype._checkCapacity = function (size) {
	  if (this._capacity < size) {
	    this._ensureCapacity(this._capacity << 1);
	  }
	};

	Queue.prototype._ensureCapacity = function (capacity) {
	  var oldCapacity = this._capacity;
	  this._capacity = capacity;

	  var last = this._head + this._length;

	  if (last > oldCapacity) {
	    copy$2(this, 0, this, oldCapacity, last & (oldCapacity - 1));
	  }
	};

	function copy$2 (src, srcIndex, dst, dstIndex, len) {
	  for (var j = 0; j < len; ++j) {
	    dst[j + dstIndex] = src[j + srcIndex];
	    src[j + srcIndex] = void 0;
	  }
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	var map$6 = map$2;
	/**
	 * Combine streams pairwise (or tuple-wise) by index by applying f to values
	 * at corresponding indices.  The returned stream ends when any of the input
	 * streams ends.
	 * @param {function} f function to combine values
	 * @returns {Stream} new stream with items at corresponding indices combined
	 *  using f
	 */


	/**
	* Combine streams pairwise (or tuple-wise) by index by applying f to values
	* at corresponding indices.  The returned stream ends when any of the input
	* streams ends.
	* @param {function} f function to combine values
	* @param {[Stream]} streams streams to zip using f
	* @returns {Stream} new stream with items at corresponding indices combined
	*  using f
	*/
	function zipArray (f, streams) {
	  return streams.length === 0 ? empty()
	: streams.length === 1 ? map$4(f, streams[0])
	: new Stream(new Zip(f, map$6(getSource$2, streams)))
	}

	function getSource$2 (stream) {
	  return stream.source
	}

	function Zip (f, sources) {
	  this.f = f;
	  this.sources = sources;
	}

	Zip.prototype.run = function (sink, scheduler) {
	  var l = this.sources.length;
	  var disposables = new Array(l);
	  var sinks = new Array(l);
	  var buffers = new Array(l);

	  var zipSink = new ZipSink(this.f, buffers, sinks, sink);

	  for (var indexSink, i = 0; i < l; ++i) {
	    buffers[i] = new Queue();
	    indexSink = sinks[i] = new IndexSink(i, zipSink);
	    disposables[i] = this.sources[i].run(indexSink, scheduler);
	  }

	  return all(disposables)
	};

	function ZipSink (f, buffers, sinks, sink) {
	  this.f = f;
	  this.sinks = sinks;
	  this.sink = sink;
	  this.buffers = buffers;
	}

	ZipSink.prototype.event = function (t, indexedValue) { // eslint-disable-line complexity
	  var buffers = this.buffers;
	  var buffer = buffers[indexedValue.index];

	  buffer.push(indexedValue.value);

	  if (buffer.length() === 1) {
	    if (!ready(this.buffers)) {
	      return
	    }

	    emitZipped(this.f, t, buffers, this.sink);

	    if (ended(this.buffers, this.sinks)) {
	      this.sink.end(t, void 0);
	    }
	  }
	};

	ZipSink.prototype.end = function (t, indexedValue) {
	  var buffer = this.buffers[indexedValue.index];
	  if (buffer.isEmpty()) {
	    this.sink.end(t, indexedValue.value);
	  }
	};

	ZipSink.prototype.error = Pipe.prototype.error;

	function emitZipped (f, t, buffers, sink) {
	  sink.event(t, invoke(f, map$6(head, buffers)));
	}

	function head (buffer) {
	  return buffer.shift()
	}

	function ended (buffers, sinks) {
	  for (var i = 0, l = buffers.length; i < l; ++i) {
	    if (buffers[i].isEmpty() && !sinks[i].active) {
	      return true
	    }
	  }
	  return false
	}

	function ready (buffers) {
	  for (var i = 0, l = buffers.length; i < l; ++i) {
	    if (buffers[i].isEmpty()) {
	      return false
	    }
	  }
	  return true
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Given a stream of streams, return a new stream that adopts the behavior
	 * of the most recent inner stream.
	 * @param {Stream} stream of streams on which to switch
	 * @returns {Stream} switching stream
	 */
	function switchLatest (stream) {
	  return new Stream(new Switch(stream.source))
	}

	function Switch (source) {
	  this.source = source;
	}

	Switch.prototype.run = function (sink, scheduler) {
	  var switchSink = new SwitchSink(sink, scheduler);
	  return all([switchSink, this.source.run(switchSink, scheduler)])
	};

	function SwitchSink (sink, scheduler) {
	  this.sink = sink;
	  this.scheduler = scheduler;
	  this.current = null;
	  this.ended = false;
	}

	SwitchSink.prototype.event = function (t, stream) {
	  this._disposeCurrent(t); // TODO: capture the result of this dispose
	  this.current = new Segment(t, Infinity, this, this.sink);
	  this.current.disposable = stream.source.run(this.current, this.scheduler);
	};

	SwitchSink.prototype.end = function (t, x) {
	  this.ended = true;
	  this._checkEnd(t, x);
	};

	SwitchSink.prototype.error = function (t, e) {
	  this.ended = true;
	  this.sink.error(t, e);
	};

	SwitchSink.prototype.dispose = function () {
	  return this._disposeCurrent(this.scheduler.now())
	};

	SwitchSink.prototype._disposeCurrent = function (t) {
	  if (this.current !== null) {
	    return this.current._dispose(t)
	  }
	};

	SwitchSink.prototype._disposeInner = function (t, inner) {
	  inner._dispose(t); // TODO: capture the result of this dispose
	  if (inner === this.current) {
	    this.current = null;
	  }
	};

	SwitchSink.prototype._checkEnd = function (t, x) {
	  if (this.ended && this.current === null) {
	    this.sink.end(t, x);
	  }
	};

	SwitchSink.prototype._endInner = function (t, x, inner) {
	  this._disposeInner(t, inner);
	  this._checkEnd(t, x);
	};

	SwitchSink.prototype._errorInner = function (t, e, inner) {
	  this._disposeInner(t, inner);
	  this.sink.error(t, e);
	};

	function Segment (min, max, outer, sink) {
	  this.min = min;
	  this.max = max;
	  this.outer = outer;
	  this.sink = sink;
	  this.disposable = empty$1();
	}

	Segment.prototype.event = function (t, x) {
	  if (t < this.max) {
	    this.sink.event(Math.max(t, this.min), x);
	  }
	};

	Segment.prototype.end = function (t, x) {
	  this.outer._endInner(Math.max(t, this.min), x, this);
	};

	Segment.prototype.error = function (t, e) {
	  this.outer._errorInner(Math.max(t, this.min), e, this);
	};

	Segment.prototype._dispose = function (t) {
	  this.max = t;
	  tryDispose(t, this.disposable, this.sink);
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Retain only items matching a predicate
	 * @param {function(x:*):boolean} p filtering predicate called for each item
	 * @param {Stream} stream stream to filter
	 * @returns {Stream} stream containing only items for which predicate returns truthy
	 */
	function filter$1 (p, stream) {
	  return new Stream(Filter.create(p, stream.source))
	}

	/**
	 * Skip repeated events, using === to detect duplicates
	 * @param {Stream} stream stream from which to omit repeated events
	 * @returns {Stream} stream without repeated events
	 */
	function skipRepeats (stream) {
	  return skipRepeatsWith(same, stream)
	}

	/**
	 * Skip repeated events using the provided equals function to detect duplicates
	 * @param {function(a:*, b:*):boolean} equals optional function to compare items
	 * @param {Stream} stream stream from which to omit repeated events
	 * @returns {Stream} stream without repeated events
	 */
	function skipRepeatsWith (equals, stream) {
	  return new Stream(new SkipRepeats(equals, stream.source))
	}

	function SkipRepeats (equals, source) {
	  this.equals = equals;
	  this.source = source;
	}

	SkipRepeats.prototype.run = function (sink, scheduler) {
	  return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler)
	};

	function SkipRepeatsSink (equals, sink) {
	  this.equals = equals;
	  this.sink = sink;
	  this.value = void 0;
	  this.init = true;
	}

	SkipRepeatsSink.prototype.end = Pipe.prototype.end;
	SkipRepeatsSink.prototype.error = Pipe.prototype.error;

	SkipRepeatsSink.prototype.event = function (t, x) {
	  if (this.init) {
	    this.init = false;
	    this.value = x;
	    this.sink.event(t, x);
	  } else if (!this.equals(this.value, x)) {
	    this.value = x;
	    this.sink.event(t, x);
	  }
	};

	function same (a, b) {
	  return a === b
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * @param {number} n
	 * @param {Stream} stream
	 * @returns {Stream} new stream containing only up to the first n items from stream
	 */
	function take (n, stream) {
	  return slice(0, n, stream)
	}

	/**
	 * @param {number} n
	 * @param {Stream} stream
	 * @returns {Stream} new stream with the first n items removed
	 */
	function skip (n, stream) {
	  return slice(n, Infinity, stream)
	}

	/**
	 * Slice a stream by index. Negative start/end indexes are not supported
	 * @param {number} start
	 * @param {number} end
	 * @param {Stream} stream
	 * @returns {Stream} stream containing items where start <= index < end
	 */
	function slice (start, end, stream) {
	  return end <= start ? empty()
	    : new Stream(sliceSource(start, end, stream.source))
	}

	function sliceSource (start, end, source) {
	  return source instanceof Map ? commuteMapSlice(start, end, source)
	    : source instanceof Slice ? fuseSlice(start, end, source)
	    : new Slice(start, end, source)
	}

	function commuteMapSlice (start, end, source) {
	  return Map.create(source.f, sliceSource(start, end, source.source))
	}

	function fuseSlice (start, end, source) {
	  start += source.min;
	  end = Math.min(end + source.min, source.max);
	  return new Slice(start, end, source.source)
	}

	function Slice (min, max, source) {
	  this.source = source;
	  this.min = min;
	  this.max = max;
	}

	Slice.prototype.run = function (sink, scheduler) {
	  var disposable = settable();
	  var sliceSink = new SliceSink(this.min, this.max - this.min, sink, disposable);

	  disposable.setDisposable(this.source.run(sliceSink, scheduler));
	  return disposable
	};

	function SliceSink (skip, take, sink, disposable) {
	  this.sink = sink;
	  this.skip = skip;
	  this.take = take;
	  this.disposable = disposable;
	}

	SliceSink.prototype.end = Pipe.prototype.end;
	SliceSink.prototype.error = Pipe.prototype.error;

	SliceSink.prototype.event = function (t, x) {
	  /* eslint complexity: [1, 4] */
	  if (this.skip > 0) {
	    this.skip -= 1;
	    return
	  }

	  if (this.take === 0) {
	    return
	  }

	  this.take -= 1;
	  this.sink.event(t, x);
	  if (this.take === 0) {
	    this.disposable.dispose();
	    this.sink.end(t, x);
	  }
	};

	function takeWhile (p, stream) {
	  return new Stream(new TakeWhile(p, stream.source))
	}

	function TakeWhile (p, source) {
	  this.p = p;
	  this.source = source;
	}

	TakeWhile.prototype.run = function (sink, scheduler) {
	  var disposable = settable();
	  var takeWhileSink = new TakeWhileSink(this.p, sink, disposable);

	  disposable.setDisposable(this.source.run(takeWhileSink, scheduler));
	  return disposable
	};

	function TakeWhileSink (p, sink, disposable) {
	  this.p = p;
	  this.sink = sink;
	  this.active = true;
	  this.disposable = disposable;
	}

	TakeWhileSink.prototype.end = Pipe.prototype.end;
	TakeWhileSink.prototype.error = Pipe.prototype.error;

	TakeWhileSink.prototype.event = function (t, x) {
	  if (!this.active) {
	    return
	  }

	  var p = this.p;
	  this.active = p(x);
	  if (this.active) {
	    this.sink.event(t, x);
	  } else {
	    this.disposable.dispose();
	    this.sink.end(t, x);
	  }
	};

	function skipWhile (p, stream) {
	  return new Stream(new SkipWhile(p, stream.source))
	}

	function SkipWhile (p, source) {
	  this.p = p;
	  this.source = source;
	}

	SkipWhile.prototype.run = function (sink, scheduler) {
	  return this.source.run(new SkipWhileSink(this.p, sink), scheduler)
	};

	function SkipWhileSink (p, sink) {
	  this.p = p;
	  this.sink = sink;
	  this.skipping = true;
	}

	SkipWhileSink.prototype.end = Pipe.prototype.end;
	SkipWhileSink.prototype.error = Pipe.prototype.error;

	SkipWhileSink.prototype.event = function (t, x) {
	  if (this.skipping) {
	    var p = this.p;
	    this.skipping = p(x);
	    if (this.skipping) {
	      return
	    }
	  }

	  this.sink.event(t, x);
	};

	function skipAfter (p, stream) {
	  return new Stream(new SkipAfter(p, stream.source))
	}

	function SkipAfter (p, source) {
	  this.p = p;
	  this.source = source;
	}

	SkipAfter.prototype.run = function run (sink, scheduler) {
	  return this.source.run(new SkipAfterSink(this.p, sink), scheduler)
	};

	function SkipAfterSink (p, sink) {
	  this.p = p;
	  this.sink = sink;
	  this.skipping = false;
	}

	SkipAfterSink.prototype.event = function event (t, x) {
	  if (this.skipping) {
	    return
	  }

	  var p = this.p;
	  this.skipping = p(x);
	  this.sink.event(t, x);

	  if (this.skipping) {
	    this.sink.end(t, x);
	  }
	};

	SkipAfterSink.prototype.end = Pipe.prototype.end;
	SkipAfterSink.prototype.error = Pipe.prototype.error;

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function takeUntil (signal, stream) {
	  return new Stream(new Until(signal.source, stream.source))
	}

	function skipUntil (signal, stream) {
	  return new Stream(new Since(signal.source, stream.source))
	}

	function during (timeWindow, stream) {
	  return takeUntil(join(timeWindow), skipUntil(timeWindow, stream))
	}

	function Until (maxSignal, source) {
	  this.maxSignal = maxSignal;
	  this.source = source;
	}

	Until.prototype.run = function (sink, scheduler) {
	  var min = new Bound(-Infinity, sink);
	  var max = new UpperBound(this.maxSignal, sink, scheduler);
	  var disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);

	  return all([min, max, disposable])
	};

	function Since (minSignal, source) {
	  this.minSignal = minSignal;
	  this.source = source;
	}

	Since.prototype.run = function (sink, scheduler) {
	  var min = new LowerBound(this.minSignal, sink, scheduler);
	  var max = new Bound(Infinity, sink);
	  var disposable = this.source.run(new TimeWindowSink(min, max, sink), scheduler);

	  return all([min, max, disposable])
	};

	function Bound (value, sink) {
	  this.value = value;
	  this.sink = sink;
	}

	Bound.prototype.error = Pipe.prototype.error;
	Bound.prototype.event = noop;
	Bound.prototype.end = noop;
	Bound.prototype.dispose = noop;

	function TimeWindowSink (min, max, sink) {
	  this.min = min;
	  this.max = max;
	  this.sink = sink;
	}

	TimeWindowSink.prototype.event = function (t, x) {
	  if (t >= this.min.value && t < this.max.value) {
	    this.sink.event(t, x);
	  }
	};

	TimeWindowSink.prototype.error = Pipe.prototype.error;
	TimeWindowSink.prototype.end = Pipe.prototype.end;

	function LowerBound (signal, sink, scheduler) {
	  this.value = Infinity;
	  this.sink = sink;
	  this.disposable = signal.run(this, scheduler);
	}

	LowerBound.prototype.event = function (t /*, x */) {
	  if (t < this.value) {
	    this.value = t;
	  }
	};

	LowerBound.prototype.end = noop;
	LowerBound.prototype.error = Pipe.prototype.error;

	LowerBound.prototype.dispose = function () {
	  return this.disposable.dispose()
	};

	function UpperBound (signal, sink, scheduler) {
	  this.value = Infinity;
	  this.sink = sink;
	  this.disposable = signal.run(this, scheduler);
	}

	UpperBound.prototype.event = function (t, x) {
	  if (t < this.value) {
	    this.value = t;
	    this.sink.end(t, x);
	  }
	};

	UpperBound.prototype.end = noop;
	UpperBound.prototype.error = Pipe.prototype.error;

	UpperBound.prototype.dispose = function () {
	  return this.disposable.dispose()
	};

	function noop () {}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * @param {Number} delayTime milliseconds to delay each item
	 * @param {Stream} stream
	 * @returns {Stream} new stream containing the same items, but delayed by ms
	 */
	function delay (delayTime, stream) {
	  return delayTime <= 0 ? stream
	    : new Stream(new Delay(delayTime, stream.source))
	}

	function Delay (dt, source) {
	  this.dt = dt;
	  this.source = source;
	}

	Delay.prototype.run = function (sink, scheduler) {
	  var delaySink = new DelaySink(this.dt, sink, scheduler);
	  return all([delaySink, this.source.run(delaySink, scheduler)])
	};

	function DelaySink (dt, sink, scheduler) {
	  this.dt = dt;
	  this.sink = sink;
	  this.scheduler = scheduler;
	}

	DelaySink.prototype.dispose = function () {
	  var self = this;
	  this.scheduler.cancelAll(function (scheduledTask) {
	    return scheduledTask.task.sink === self.sink
	  });
	};

	DelaySink.prototype.event = function (t, x) {
	  this.scheduler.delay(this.dt, PropagateTask.event(x, this.sink));
	};

	DelaySink.prototype.end = function (t, x) {
	  this.scheduler.delay(this.dt, PropagateTask.end(x, this.sink));
	};

	DelaySink.prototype.error = Pipe.prototype.error;

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function timestamp (stream) {
	  return new Stream(new Timestamp(stream.source))
	}

	function Timestamp (source) {
	  this.source = source;
	}

	Timestamp.prototype.run = function (sink, scheduler) {
	  return this.source.run(new TimestampSink(sink), scheduler)
	};

	function TimestampSink (sink) {
	  this.sink = sink;
	}

	TimestampSink.prototype.end = Pipe.prototype.end;
	TimestampSink.prototype.error = Pipe.prototype.error;

	TimestampSink.prototype.event = function (t, x) {
	  this.sink.event(t, { time: t, value: x });
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Limit the rate of events by suppressing events that occur too often
	 * @param {Number} period time to suppress events
	 * @param {Stream} stream
	 * @returns {Stream}
	 */
	function throttle (period, stream) {
	  return new Stream(throttleSource(period, stream.source))
	}

	function throttleSource (period, source) {
	  return source instanceof Map ? commuteMapThrottle(period, source)
	    : source instanceof Throttle ? fuseThrottle(period, source)
	    : new Throttle(period, source)
	}

	function commuteMapThrottle (period, source) {
	  return Map.create(source.f, throttleSource(period, source.source))
	}

	function fuseThrottle (period, source) {
	  return new Throttle(Math.max(period, source.period), source.source)
	}

	function Throttle (period, source) {
	  this.period = period;
	  this.source = source;
	}

	Throttle.prototype.run = function (sink, scheduler) {
	  return this.source.run(new ThrottleSink(this.period, sink), scheduler)
	};

	function ThrottleSink (period, sink) {
	  this.time = 0;
	  this.period = period;
	  this.sink = sink;
	}

	ThrottleSink.prototype.event = function (t, x) {
	  if (t >= this.time) {
	    this.time = t + this.period;
	    this.sink.event(t, x);
	  }
	};

	ThrottleSink.prototype.end = Pipe.prototype.end;

	ThrottleSink.prototype.error = Pipe.prototype.error;

	/**
	 * Wait for a burst of events to subside and emit only the last event in the burst
	 * @param {Number} period events occuring more frequently than this
	 *  will be suppressed
	 * @param {Stream} stream stream to debounce
	 * @returns {Stream} new debounced stream
	 */
	function debounce (period, stream) {
	  return new Stream(new Debounce(period, stream.source))
	}

	function Debounce (dt, source) {
	  this.dt = dt;
	  this.source = source;
	}

	Debounce.prototype.run = function (sink, scheduler) {
	  return new DebounceSink(this.dt, this.source, sink, scheduler)
	};

	function DebounceSink (dt, source, sink, scheduler) {
	  this.dt = dt;
	  this.sink = sink;
	  this.scheduler = scheduler;
	  this.value = void 0;
	  this.timer = null;
	  this.disposable = source.run(this, scheduler);
	}

	DebounceSink.prototype.event = function (t, x) {
	  this._clearTimer();
	  this.value = x;
	  this.timer = this.scheduler.delay(this.dt, new DebounceTask(this, x));
	};

	DebounceSink.prototype._event = function (t, x) {
	  this._clearTimer();
	  this.sink.event(t, x);
	};

	DebounceSink.prototype.end = function (t, x) {
	  if (this._clearTimer()) {
	    this.sink.event(t, this.value);
	    this.value = void 0;
	  }
	  this.sink.end(t, x);
	};

	DebounceSink.prototype.error = function (t, x) {
	  this._clearTimer();
	  this.sink.error(t, x);
	};

	DebounceSink.prototype.dispose = function () {
	  this._clearTimer();
	  return this.disposable.dispose()
	};

	DebounceSink.prototype._clearTimer = function () {
	  if (this.timer === null) {
	    return false
	  }
	  this.timer.dispose();
	  this.timer = null;
	  return true
	};

	function DebounceTask (debounce, value) {
	  this.debounce = debounce;
	  this.value = value;
	}

	DebounceTask.prototype.run = function (t) {
	  this.debounce._event(t, this.value);
	};

	DebounceTask.prototype.error = function (t, e) {
	  this.debounce.error(t, e);
	};

	DebounceTask.prototype.dispose = function () {};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * Create a stream containing only the promise's fulfillment
	 * value at the time it fulfills.
	 * @param {Promise<T>} p promise
	 * @return {Stream<T>} stream containing promise's fulfillment value.
	 *  If the promise rejects, the stream will error
	 */
	function fromPromise (p) {
	  return awaitPromises(of(p))
	}

	/**
	 * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.
	 * Event order is preserved.
	 * @param {Stream<Promise<T>>} stream
	 * @return {Stream<T>} stream of fulfillment values.  The stream will
	 * error if any promise rejects.
	 */
	function awaitPromises (stream) {
	  return new Stream(new Await(stream.source))
	}

	function Await (source) {
	  this.source = source;
	}

	Await.prototype.run = function (sink, scheduler) {
	  return this.source.run(new AwaitSink(sink, scheduler), scheduler)
	};

	function AwaitSink (sink, scheduler) {
	  this.sink = sink;
	  this.scheduler = scheduler;
	  this.queue = Promise.resolve();
	  var self = this;

	  // Pre-create closures, to avoid creating them per event
	  this._eventBound = function (x) {
	    self.sink.event(self.scheduler.now(), x);
	  };

	  this._endBound = function (x) {
	    self.sink.end(self.scheduler.now(), x);
	  };

	  this._errorBound = function (e) {
	    self.sink.error(self.scheduler.now(), e);
	  };
	}

	AwaitSink.prototype.event = function (t, promise) {
	  var self = this;
	  this.queue = this.queue.then(function () {
	    return self._event(promise)
	  }).catch(this._errorBound);
	};

	AwaitSink.prototype.end = function (t, x) {
	  var self = this;
	  this.queue = this.queue.then(function () {
	    return self._end(x)
	  }).catch(this._errorBound);
	};

	AwaitSink.prototype.error = function (t, e) {
	  var self = this;
	  // Don't resolve error values, propagate directly
	  this.queue = this.queue.then(function () {
	    return self._errorBound(e)
	  }).catch(fatalError);
	};

	AwaitSink.prototype._event = function (promise) {
	  return promise.then(this._eventBound)
	};

	AwaitSink.prototype._end = function (x) {
	  return Promise.resolve(x).then(this._endBound)
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	function SafeSink (sink) {
	  this.sink = sink;
	  this.active = true;
	}

	SafeSink.prototype.event = function (t, x) {
	  if (!this.active) {
	    return
	  }
	  this.sink.event(t, x);
	};

	SafeSink.prototype.end = function (t, x) {
	  if (!this.active) {
	    return
	  }
	  this.disable();
	  this.sink.end(t, x);
	};

	SafeSink.prototype.error = function (t, e) {
	  this.disable();
	  this.sink.error(t, e);
	};

	SafeSink.prototype.disable = function () {
	  this.active = false;
	  return this.sink
	};

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/**
	 * If stream encounters an error, recover and continue with items from stream
	 * returned by f.
	 * @param {function(error:*):Stream} f function which returns a new stream
	 * @param {Stream} stream
	 * @returns {Stream} new stream which will recover from an error by calling f
	 */
	function recoverWith (f, stream) {
	  return new Stream(new RecoverWith(f, stream.source))
	}

	var flatMapError = recoverWith;

	/**
	 * Create a stream containing only an error
	 * @param {*} e error value, preferably an Error or Error subtype
	 * @returns {Stream} new stream containing only an error
	 */


	function RecoverWith (f, source) {
	  this.f = f;
	  this.source = source;
	}

	RecoverWith.prototype.run = function (sink, scheduler) {
	  return new RecoverWithSink(this.f, this.source, sink, scheduler)
	};

	function RecoverWithSink (f, source, sink, scheduler) {
	  this.f = f;
	  this.sink = new SafeSink(sink);
	  this.scheduler = scheduler;
	  this.disposable = source.run(this, scheduler);
	}

	RecoverWithSink.prototype.event = function (t, x) {
	  tryEvent(t, x, this.sink);
	};

	RecoverWithSink.prototype.end = function (t, x) {
	  tryEnd(t, x, this.sink);
	};

	RecoverWithSink.prototype.error = function (t, e) {
	  var nextSink = this.sink.disable();

	  tryDispose(t, this.disposable, this.sink);
	  this._startNext(t, e, nextSink);
	};

	RecoverWithSink.prototype._startNext = function (t, x, sink) {
	  try {
	    this.disposable = this._continue(this.f, x, sink);
	  } catch (e) {
	    sink.error(t, e);
	  }
	};

	RecoverWithSink.prototype._continue = function (f, x, sink) {
	  var stream = f(x);
	  return stream.source.run(sink, this.scheduler)
	};

	RecoverWithSink.prototype.dispose = function () {
	  return this.disposable.dispose()
	};

	var MulticastDisposable = function MulticastDisposable (source, sink) {
	  this.source = source;
	  this.sink = sink;
	  this.disposed = false;
	};

	MulticastDisposable.prototype.dispose = function dispose () {
	  if (this.disposed) {
	    return
	  }
	  this.disposed = true;
	  var remaining = this.source.remove(this.sink);
	  return remaining === 0 && this.source._dispose()
	};

	function tryEvent$1 (t, x, sink) {
	  try {
	    sink.event(t, x);
	  } catch (e) {
	    sink.error(t, e);
	  }
	}

	function tryEnd$1 (t, x, sink) {
	  try {
	    sink.end(t, x);
	  } catch (e) {
	    sink.error(t, e);
	  }
	}

	var dispose = function (disposable) { return disposable.dispose(); };

	var emptyDisposable = {
	  dispose: function dispose$1 () {}
	};

	var MulticastSource = function MulticastSource (source) {
	  this.source = source;
	  this.sinks = [];
	  this._disposable = emptyDisposable;
	};

	MulticastSource.prototype.run = function run (sink, scheduler) {
	  var n = this.add(sink);
	  if (n === 1) {
	    this._disposable = this.source.run(this, scheduler);
	  }
	  return new MulticastDisposable(this, sink)
	};

	MulticastSource.prototype._dispose = function _dispose () {
	  var disposable = this._disposable;
	  this._disposable = emptyDisposable;
	  return Promise.resolve(disposable).then(dispose)
	};

	MulticastSource.prototype.add = function add (sink) {
	  this.sinks = append(sink, this.sinks);
	  return this.sinks.length
	};

	MulticastSource.prototype.remove = function remove$1 (sink) {
	  var i = findIndex(sink, this.sinks);
	  // istanbul ignore next
	  if (i >= 0) {
	    this.sinks = remove(i, this.sinks);
	  }

	  return this.sinks.length
	};

	MulticastSource.prototype.event = function event (time, value) {
	  var s = this.sinks;
	  if (s.length === 1) {
	    return s[0].event(time, value)
	  }
	  for (var i = 0; i < s.length; ++i) {
	    tryEvent$1(time, value, s[i]);
	  }
	};

	MulticastSource.prototype.end = function end (time, value) {
	  var s = this.sinks;
	  for (var i = 0; i < s.length; ++i) {
	    tryEnd$1(time, value, s[i]);
	  }
	};

	MulticastSource.prototype.error = function error (time, err) {
	  var s = this.sinks;
	  for (var i = 0; i < s.length; ++i) {
	    s[i].error(time, err);
	  }
	};

	function multicast (stream) {
	  var source = stream.source;
	  return source instanceof MulticastSource
	    ? stream
	    : new stream.constructor(new MulticastSource(source))
	}

	/** @license MIT License (c) copyright 2010-2016 original author or authors */
	/** @author Brian Cavalier */
	/** @author John Hann */

	/* eslint import/first: 0 */

	// Add of and empty to constructor for fantasy-land compat
	Stream.of = of;
	Stream.empty = empty;
	// Add from to constructor for ES Observable compat
	Stream.from = from;
	// -----------------------------------------------------------------------
	// Draft ES Observable proposal interop
	// https://github.com/zenparsing/es-observable

	Stream.prototype.subscribe = function (subscriber) {
	  return subscribe(subscriber, this)
	};

	Stream.prototype[result] = function () {
	  return this
	};

	// -----------------------------------------------------------------------
	// Fluent adapter

	/**
	 * Adapt a functional stream transform to fluent style.
	 * It applies f to the this stream object
	 * @param  {function(s: Stream): Stream} f function that
	 * receives the stream itself and must return a new stream
	 * @return {Stream}
	 */
	Stream.prototype.thru = function (f) {
	  return thru(f, this)
	};

	// -----------------------------------------------------------------------
	// Observing

	/**
	 * Process all the events in the stream
	 * @returns {Promise} promise that fulfills when the stream ends, or rejects
	 *  if the stream fails with an unhandled error.
	 */
	Stream.prototype.observe = Stream.prototype.forEach = function (f) {
	  return observe(f, this)
	};

	/**
	 * Consume all events in the stream, without providing a function to process each.
	 * This causes a stream to become active and begin emitting events, and is useful
	 * in cases where all processing has been setup upstream via other combinators, and
	 * there is no need to process the terminal events.
	 * @returns {Promise} promise that fulfills when the stream ends, or rejects
	 *  if the stream fails with an unhandled error.
	 */
	Stream.prototype.drain = function () {
	  return drain(this)
	};

	// -------------------------------------------------------

	/**
	 * Generalized feedback loop. Call a stepper function for each event. The stepper
	 * will be called with 2 params: the current seed and the an event value.  It must
	 * return a new { seed, value } pair. The `seed` will be fed back into the next
	 * invocation of stepper, and the `value` will be propagated as the event value.
	 * @param {function(seed:*, value:*):{seed:*, value:*}} stepper loop step function
	 * @param {*} seed initial seed value passed to first stepper call
	 * @returns {Stream} new stream whose values are the `value` field of the objects
	 * returned by the stepper
	 */
	Stream.prototype.loop = function (stepper, seed) {
	  return loop(stepper, seed, this)
	};

	// -------------------------------------------------------

	/**
	 * Create a stream containing successive reduce results of applying f to
	 * the previous reduce result and the current stream item.
	 * @param {function(result:*, x:*):*} f reducer function
	 * @param {*} initial initial value
	 * @returns {Stream} new stream containing successive reduce results
	 */
	Stream.prototype.scan = function (f, initial) {
	  return scan(f, initial, this)
	};

	/**
	 * Reduce the stream to produce a single result.  Note that reducing an infinite
	 * stream will return a Promise that never fulfills, but that may reject if an error
	 * occurs.
	 * @param {function(result:*, x:*):*} f reducer function
	 * @param {*} initial optional initial value
	 * @returns {Promise} promise for the file result of the reduce
	 */
	Stream.prototype.reduce = function (f, initial) {
	  return reduce$1(f, initial, this)
	};

	/**
	 * @param {Stream} tail
	 * @returns {Stream} new stream containing all items in this followed by
	 *  all items in tail
	 */
	Stream.prototype.concat = function (tail$$1) {
	  return concat(this, tail$$1)
	};

	/**
	 * @param {*} x value to prepend
	 * @returns {Stream} a new stream with x prepended
	 */
	Stream.prototype.startWith = function (x) {
	  return cons$1(x, this)
	};

	// -----------------------------------------------------------------------
	// Transforming

	/**
	 * Transform each value in the stream by applying f to each
	 * @param {function(*):*} f mapping function
	 * @returns {Stream} stream containing items transformed by f
	 */
	Stream.prototype.map = function (f) {
	  return map$4(f, this)
	};

	/**
	 * Assume this stream contains functions, and apply each function to each item
	 * in the provided stream.  This generates, in effect, a cross product.
	 * @param {Stream} xs stream of items to which
	 * @returns {Stream} stream containing the cross product of items
	 */
	Stream.prototype.ap = function (xs) {
	  return ap(this, xs)
	};

	/**
	 * Replace each value in the stream with x
	 * @param {*} x
	 * @returns {Stream} stream containing items replaced with x
	 */
	Stream.prototype.constant = function (x) {
	  return constant(x, this)
	};

	/**
	 * Perform a side effect for each item in the stream
	 * @param {function(x:*):*} f side effect to execute for each item. The
	 *  return value will be discarded.
	 * @returns {Stream} new stream containing the same items as this stream
	 */
	Stream.prototype.tap = function (f) {
	  return tap(f, this)
	};

	// -----------------------------------------------------------------------
	// Transducer support

	/**
	 * Transform this stream by passing its events through a transducer.
	 * @param  {function} transducer transducer function
	 * @return {Stream} stream of events transformed by the transducer
	 */
	Stream.prototype.transduce = function (transducer) {
	  return transduce(transducer, this)
	};

	// -----------------------------------------------------------------------
	// FlatMapping

	/**
	 * Map each value in the stream to a new stream, and merge it into the
	 * returned outer stream. Event arrival times are preserved.
	 * @param {function(x:*):Stream} f chaining function, must return a Stream
	 * @returns {Stream} new stream containing all events from each stream returned by f
	 */
	Stream.prototype.chain = function (f) {
	  return flatMap(f, this)
	};

	// @deprecated use chain instead
	Stream.prototype.flatMap = Stream.prototype.chain;

	  /**
	 * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner
	 * streams to the outer. Event arrival times are preserved.
	 * @returns {Stream<X>} new stream containing all events of all inner streams
	 */
	Stream.prototype.join = function () {
	  return join(this)
	};

	/**
	 * Map the end event to a new stream, and begin emitting its values.
	 * @param {function(x:*):Stream} f function that receives the end event value,
	 * and *must* return a new Stream to continue with.
	 * @returns {Stream} new stream that emits all events from the original stream,
	 * followed by all events from the stream returned by f.
	 */
	Stream.prototype.continueWith = function (f) {
	  return continueWith(f, this)
	};

	// @deprecated use continueWith instead
	Stream.prototype.flatMapEnd = Stream.prototype.continueWith;

	Stream.prototype.concatMap = function (f) {
	  return concatMap(f, this)
	};

	// -----------------------------------------------------------------------
	// Concurrent merging

	/**
	 * Flatten a Stream<Stream<X>> to Stream<X> by merging inner
	 * streams to the outer, limiting the number of inner streams that may
	 * be active concurrently.
	 * @param {number} concurrency at most this many inner streams will be
	 *  allowed to be active concurrently.
	 * @return {Stream<X>} new stream containing all events of all inner
	 *  streams, with limited concurrency.
	 */
	Stream.prototype.mergeConcurrently = function (concurrency) {
	  return mergeConcurrently(concurrency, this)
	};

	// -----------------------------------------------------------------------
	// Merging

	/**
	 * Merge this stream and all the provided streams
	 * @returns {Stream} stream containing items from this stream and s in time
	 * order.  If two events are simultaneous they will be merged in
	 * arbitrary order.
	 */
	Stream.prototype.merge = function (/* ...streams */) {
	  return mergeArray(cons(this, arguments))
	};

	// -----------------------------------------------------------------------
	// Combining

	/**
	 * Combine latest events from all input streams
	 * @param {function(...events):*} f function to combine most recent events
	 * @returns {Stream} stream containing the result of applying f to the most recent
	 *  event of each input stream, whenever a new event arrives on any stream.
	 */
	Stream.prototype.combine = function (f /*, ...streams */) {
	  return combineArray(f, replace(this, 0, arguments))
	};

	// -----------------------------------------------------------------------
	// Sampling

	/**
	 * When an event arrives on sampler, emit the latest event value from stream.
	 * @param {Stream} sampler stream of events at whose arrival time
	 *  signal's latest value will be propagated
	 * @returns {Stream} sampled stream of values
	 */
	Stream.prototype.sampleWith = function (sampler) {
	  return sampleWith(sampler, this)
	};

	/**
	 * When an event arrives on this stream, emit the result of calling f with the latest
	 * values of all streams being sampled
	 * @param {function(...values):*} f function to apply to each set of sampled values
	 * @returns {Stream} stream of sampled and transformed values
	 */
	Stream.prototype.sample = function (f /* ...streams */) {
	  return sampleArray(f, this, tail(arguments))
	};

	// -----------------------------------------------------------------------
	// Zipping

	/**
	 * Pair-wise combine items with those in s. Given 2 streams:
	 * [1,2,3] zipWith f [4,5,6] -> [f(1,4),f(2,5),f(3,6)]
	 * Note: zip causes fast streams to buffer and wait for slow streams.
	 * @param {function(a:Stream, b:Stream, ...):*} f function to combine items
	 * @returns {Stream} new stream containing pairs
	 */
	Stream.prototype.zip = function (f /*, ...streams */) {
	  return zipArray(f, replace(this, 0, arguments))
	};

	// -----------------------------------------------------------------------
	// Switching

	/**
	 * Given a stream of streams, return a new stream that adopts the behavior
	 * of the most recent inner stream.
	 * @returns {Stream} switching stream
	 */
	Stream.prototype.switchLatest = function () {
	  return switchLatest(this)
	};

	// @deprecated use switchLatest instead
	Stream.prototype.switch = Stream.prototype.switchLatest;

	// -----------------------------------------------------------------------
	// Filtering

	/**
	 * Retain only items matching a predicate
	 * stream:                           -12345678-
	 * filter(x => x % 2 === 0, stream): --2-4-6-8-
	 * @param {function(x:*):boolean} p filtering predicate called for each item
	 * @returns {Stream} stream containing only items for which predicate returns truthy
	 */
	Stream.prototype.filter = function (p) {
	  return filter$1(p, this)
	};

	/**
	 * Skip repeated events, using === to compare items
	 * stream:           -abbcd-
	 * distinct(stream): -ab-cd-
	 * @returns {Stream} stream with no repeated events
	 */
	Stream.prototype.skipRepeats = function () {
	  return skipRepeats(this)
	};

	/**
	 * Skip repeated events, using supplied equals function to compare items
	 * @param {function(a:*, b:*):boolean} equals function to compare items
	 * @returns {Stream} stream with no repeated events
	 */
	Stream.prototype.skipRepeatsWith = function (equals) {
	  return skipRepeatsWith(equals, this)
	};

	// -----------------------------------------------------------------------
	// Slicing

	/**
	 * stream:          -abcd-
	 * take(2, stream): -ab|
	 * @param {Number} n take up to this many events
	 * @returns {Stream} stream containing at most the first n items from this stream
	 */
	Stream.prototype.take = function (n) {
	  return take(n, this)
	};

	/**
	 * stream:          -abcd->
	 * skip(2, stream): ---cd->
	 * @param {Number} n skip this many events
	 * @returns {Stream} stream not containing the first n events
	 */
	Stream.prototype.skip = function (n) {
	  return skip(n, this)
	};

	/**
	 * Slice a stream by event index. Equivalent to, but more efficient than
	 * stream.take(end).skip(start);
	 * NOTE: Negative start and end are not supported
	 * @param {Number} start skip all events before the start index
	 * @param {Number} end allow all events from the start index to the end index
	 * @returns {Stream} stream containing items where start <= index < end
	 */
	Stream.prototype.slice = function (start, end) {
	  return slice(start, end, this)
	};

	/**
	 * stream:                        -123451234->
	 * takeWhile(x => x < 5, stream): -1234|
	 * @param {function(x:*):boolean} p predicate
	 * @returns {Stream} stream containing items up to, but not including, the
	 * first item for which p returns falsy.
	 */
	Stream.prototype.takeWhile = function (p) {
	  return takeWhile(p, this)
	};

	/**
	 * stream:                        -123451234->
	 * skipWhile(x => x < 5, stream): -----51234->
	 * @param {function(x:*):boolean} p predicate
	 * @returns {Stream} stream containing items following *and including* the
	 * first item for which p returns falsy.
	 */
	Stream.prototype.skipWhile = function (p) {
	  return skipWhile(p, this)
	};

	/**
	 * stream:                         -123456789->
	 * skipAfter(x => x === 5, stream):-12345|
	 * @param {function(x:*):boolean} p predicate
	 * @returns {Stream} stream containing items up to, *and including*, the
	 * first item for which p returns truthy.
	 */
	Stream.prototype.skipAfter = function (p) {
	  return skipAfter(p, this)
	};

	// -----------------------------------------------------------------------
	// Time slicing

	/**
	 * stream:                    -a-b-c-d-e-f-g->
	 * signal:                    -------x
	 * takeUntil(signal, stream): -a-b-c-|
	 * @param {Stream} signal retain only events in stream before the first
	 * event in signal
	 * @returns {Stream} new stream containing only events that occur before
	 * the first event in signal.
	 */
	Stream.prototype.until = function (signal) {
	  return takeUntil(signal, this)
	};

	// @deprecated use until instead
	Stream.prototype.takeUntil = Stream.prototype.until;

	  /**
	 * stream:                    -a-b-c-d-e-f-g->
	 * signal:                    -------x
	 * takeUntil(signal, stream): -------d-e-f-g->
	 * @param {Stream} signal retain only events in stream at or after the first
	 * event in signal
	 * @returns {Stream} new stream containing only events that occur after
	 * the first event in signal.
	 */
	Stream.prototype.since = function (signal) {
	  return skipUntil(signal, this)
	};

	// @deprecated use since instead
	Stream.prototype.skipUntil = Stream.prototype.since;

	  /**
	 * stream:                    -a-b-c-d-e-f-g->
	 * timeWindow:                -----s
	 * s:                               -----t
	 * stream.during(timeWindow): -----c-d-e-|
	 * @param {Stream<Stream>} timeWindow a stream whose first event (s) represents
	 *  the window start time.  That event (s) is itself a stream whose first event (t)
	 *  represents the window end time
	 * @returns {Stream} new stream containing only events within the provided timespan
	 */
	Stream.prototype.during = function (timeWindow) {
	  return during(timeWindow, this)
	};

	// -----------------------------------------------------------------------
	// Delaying

	/**
	 * @param {Number} delayTime milliseconds to delay each item
	 * @returns {Stream} new stream containing the same items, but delayed by ms
	 */
	Stream.prototype.delay = function (delayTime) {
	  return delay(delayTime, this)
	};

	// -----------------------------------------------------------------------
	// Getting event timestamp

	/**
	 * Expose event timestamps into the stream. Turns a Stream<X> into
	 * Stream<{time:t, value:X}>
	 * @returns {Stream<{time:number, value:*}>}
	 */
	Stream.prototype.timestamp = function () {
	  return timestamp(this)
	};

	// -----------------------------------------------------------------------
	// Rate limiting

	/**
	 * Limit the rate of events
	 * stream:              abcd----abcd----
	 * throttle(2, stream): a-c-----a-c-----
	 * @param {Number} period time to suppress events
	 * @returns {Stream} new stream that skips events for throttle period
	 */
	Stream.prototype.throttle = function (period) {
	  return throttle(period, this)
	};

	/**
	 * Wait for a burst of events to subside and emit only the last event in the burst
	 * stream:              abcd----abcd----
	 * debounce(2, stream): -----d-------d--
	 * @param {Number} period events occuring more frequently than this
	 *  on the provided scheduler will be suppressed
	 * @returns {Stream} new debounced stream
	 */
	Stream.prototype.debounce = function (period) {
	  return debounce(period, this)
	};

	// -----------------------------------------------------------------------
	// Awaiting Promises

	/**
	 * Await promises, turning a Stream<Promise<X>> into Stream<X>.  Preserves
	 * event order, but timeshifts events based on promise resolution time.
	 * @returns {Stream<X>} stream containing non-promise values
	 */
	Stream.prototype.awaitPromises = function () {
	  return awaitPromises(this)
	};

	// @deprecated use awaitPromises instead
	Stream.prototype.await = Stream.prototype.awaitPromises;

	// -----------------------------------------------------------------------
	// Error handling

	/**
	 * If this stream encounters an error, recover and continue with items from stream
	 * returned by f.
	 * stream:                  -a-b-c-X-
	 * f(X):                           d-e-f-g-
	 * flatMapError(f, stream): -a-b-c-d-e-f-g-
	 * @param {function(error:*):Stream} f function which returns a new stream
	 * @returns {Stream} new stream which will recover from an error by calling f
	 */
	Stream.prototype.recoverWith = function (f) {
	  return flatMapError(f, this)
	};

	// @deprecated use recoverWith instead
	Stream.prototype.flatMapError = Stream.prototype.recoverWith;

	// -----------------------------------------------------------------------
	// Multicasting

	/**
	 * Transform the stream into multicast stream.  That means that many subscribers
	 * to the stream will not cause multiple invocations of the internal machinery.
	 * @returns {Stream} new stream which will multicast events to all observers.
	 */
	Stream.prototype.multicast = function () {
	  return multicast(this)
	};

	// export the instance of the defaultScheduler for third-party libraries
	// export an implementation of Task used internally for third-party libraries

	function createStateData$1() {
	  return /* record */[
	          /* state */undefined,
	          /* isDebug */false
	        ];
	}


	/* No side effect */

	var stateData = createStateData$1(/* () */0);


	/* stateData Not a pure module */

	function getIsDebug(stateData) {
	  return stateData[/* isDebug */1];
	}

	function setIsDebug$1(stateData, isDebug) {
	  stateData[/* isDebug */1] = isDebug;
	  return stateData;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function createEmpty$1() {
	  return /* array */[];
	}

	function removeDuplicateItems(arr) {
	  var resultArr = /* array */[];
	  var map = createEmpty(/* () */0);
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    var item = arr[i];
	    var key = item.toString();
	    var match = get(key, map);
	    if (match === undefined) {
	      resultArr.push(item);
	      set(key, item, map);
	    }
	    
	  }
	  return resultArr;
	}

	function isNotEqual(index, target, arr) {
	  if (index >= arr.length) {
	    return true;
	  } else {
	    return caml_notequal(arr[index], target);
	  }
	}

	function forEach(func, arr) {
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    func(arr[i]);
	  }
	  return /* () */0;
	}

	function range(a, b) {
	  var result = /* array */[];
	  for(var i = a; i <= b; ++i){
	    result.push(i);
	  }
	  return result;
	}

	function reduceOneParam(func, param, arr) {
	  var mutableParam = param;
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    mutableParam = func(mutableParam, arr[i]);
	  }
	  return mutableParam;
	}

	function reduceOneParami(func, param, arr) {
	  var mutableParam = param;
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    mutableParam = func(mutableParam, arr[i], i);
	  }
	  return mutableParam;
	}


	/* HashMapService-WonderCommonlib Not a pure module */

	var _isFromEventStream = (
	  function(stream) {
	    var source = stream.source;
	    return !!source.event && !!source.source;
	  }
	  );

	function concatArray(streamArr) {
	  var match = streamArr.length;
	  if (match !== 0) {
	    return reduceOneParam((function (stream1, stream2) {
	                  _1(_isFromEventStream, stream1) === true;
	                  return stream1.concat(stream2);
	                }), caml_array_get(streamArr, 0), streamArr.slice(1));
	  } else {
	    return of(1);
	  }
	}

	function callFunc(func) {
	  return map$4((function (func) {
	                return _1(func, /* () */0);
	              }), of(func));
	}


	/* _isFromEventStream Not a pure module */

	function deleteBySwap(index, lastIndex, arr) {
	  requireCheck((function () {
	          var len = arr.length;
	          return test(buildAssertMessage("lastIndex:" + (String(lastIndex) + (" === arr.length:" + (String(len) + ""))), "not"), (function () {
	                        return assertEqual(/* Int */0, arr.length - 1 | 0, lastIndex);
	                      }));
	        }), getIsDebug(stateData));
	  arr[index] = arr[lastIndex];
	  arr.pop();
	  return /* () */0;
	}

	function range$1(a, b) {
	  var result = createEmpty$1(/* () */0);
	  for(var i = a; i <= b; ++i){
	    result.push(i);
	  }
	  return result;
	}

	function push(item, arr) {
	  arr.push(item);
	  return arr;
	}

	function getLast(arr) {
	  return arr[arr.length - 1 | 0];
	}

	function removeDuplicateItems$1(buildKeyFunc, arr) {
	  var resultArr = /* array */[];
	  var map = createEmpty(/* () */0);
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    var item = arr[i];
	    var key = buildKeyFunc(item);
	    var match = get(key, map);
	    if (match === undefined) {
	      resultArr.push(item);
	      set(key, item, map);
	    }
	    
	  }
	  return resultArr;
	}


	/* Log-WonderLog Not a pure module */

	function unsafeGet$1(optionData) {
	  requireCheck((function () {
	          return test(buildAssertMessage("data exist(get by getExn)", "not"), (function () {
	                        return assertExist(optionData);
	                      }));
	        }), getIsDebug(stateData));
	  return getExn(optionData);
	}

	function isJsonSerializedValueNone(value) {
	  if (value === null) {
	    return true;
	  } else {
	    return value === undefined;
	  }
	}

	var unsafeGetJsonSerializedValue = unsafeGet$1;


	/* Log-WonderLog Not a pure module */

	function unsafeFindFirst(arr, targetValue, func) {
	  return ensureCheck((function (first) {
	                var arrJson = getJsonStr(arr);
	                return test(buildAssertMessage("find " + (String(targetValue) + (" in " + (String(arrJson) + ""))), "not"), (function () {
	                              return assertNullableExist(first);
	                            }));
	              }), getIsDebug(stateData), arr.find(func));
	}

	function findFirst(arr, _, func) {
	  return undefined_to_opt(arr.find(__1(func)));
	}

	var filterTargetName = caml_equal;

	function _throwJobFlagsShouldBeDefined() {
	  return fatal(buildFatalMessage("throwJobFlagsShouldBeDefined", "jobFlags should be defined", "", "", ""));
	}

	function unsafeGetFlags(flags) {
	  if (flags !== undefined) {
	    return valFromOption(flags);
	  } else {
	    return _throwJobFlagsShouldBeDefined(/* () */0);
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _unsafeGetWorkerJobConfig(record) {
	  requireCheck((function () {
	          return test(buildAssertMessage("render job config exist", "not"), (function () {
	                        return assertExist(record);
	                      }));
	        }), getIsDebug(stateData));
	  return unsafeGet$1(record);
	}

	function getSetting$1(record) {
	  return _unsafeGetWorkerJobConfig(record)[/* setting */0];
	}

	function _getRenderWorkerPipelineJobs(workerPipeline, workerPipelines) {
	  return unsafeFindFirst(workerPipelines, workerPipeline, (function (param) {
	                    return filterTargetName(param[/* name */0], workerPipeline);
	                  }))[/* jobs */1][/* render */0];
	}

	function getRenderWorkerPipelineJobs(record) {
	  var match = _unsafeGetWorkerJobConfig(record);
	  return _getRenderWorkerPipelineJobs(match[/* setting */0][/* workerPipeline */3], match[/* workerPipelines */3]);
	}

	function getWorkerJobs(record) {
	  return _unsafeGetWorkerJobConfig(record)[/* workerJobs */6];
	}


	/* Log-WonderLog Not a pure module */

	/* node_std_output Not a pure module */

	/* No side effect */

	function div(x, y) {
	  if (y === 0) {
	    throw division_by_zero;
	  } else {
	    return x / y | 0;
	  }
	}

	var imul = ( Math.imul || function (x,y) {
	  y |= 0; return ((((x >> 16) * y) << 16) + (x & 0xffff) * y)|0; 
	}
	);


	/* imul Not a pure module */

	/* repeat Not a pure module */

	/* two_ptr_32_dbl Not a pure module */

	/* float_of_string Not a pure module */

	function bytes_of_string(s) {
	  var len = s.length;
	  var res = new Array(len);
	  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
	    res[i] = s.charCodeAt(i);
	  }
	  return res;
	}


	/* No side effect */

	/* No side effect */

	/* No side effect */

	function failwith(s) {
	  throw [
	        failure,
	        s
	      ];
	}

	var Exit = create$1("Pervasives.Exit");

	function $at(l1, l2) {
	  if (l1) {
	    return /* :: */[
	            l1[0],
	            $at(l1[1], l2)
	          ];
	  } else {
	    return l2;
	  }
	}


	/* No side effect */

	function length$1(l) {
	  var _len = 0;
	  var _param = l;
	  while(true) {
	    var param = _param;
	    var len = _len;
	    if (param) {
	      _param = param[1];
	      _len = len + 1 | 0;
	      continue ;
	    } else {
	      return len;
	    }
	  }
	}

	function rev_append(_l1, _l2) {
	  while(true) {
	    var l2 = _l2;
	    var l1 = _l1;
	    if (l1) {
	      _l2 = /* :: */[
	        l1[0],
	        l2
	      ];
	      _l1 = l1[1];
	      continue ;
	    } else {
	      return l2;
	    }
	  }
	}

	function rev(l) {
	  return rev_append(l, /* [] */0);
	}

	function fold_left(f, _accu, _l) {
	  while(true) {
	    var l = _l;
	    var accu = _accu;
	    if (l) {
	      _l = l[1];
	      _accu = _2(f, accu, l[0]);
	      continue ;
	    } else {
	      return accu;
	    }
	  }
	}

	function find_all(p) {
	  return (function (param) {
	      var _accu = /* [] */0;
	      var _param = param;
	      while(true) {
	        var param$1 = _param;
	        var accu = _accu;
	        if (param$1) {
	          var l = param$1[1];
	          var x = param$1[0];
	          if (_1(p, x)) {
	            _param = l;
	            _accu = /* :: */[
	              x,
	              accu
	            ];
	            continue ;
	          } else {
	            _param = l;
	            continue ;
	          }
	        } else {
	          return rev_append(accu, /* [] */0);
	        }
	      }
	    });
	}

	var append$1 = $at;

	var filter$2 = find_all;


	/* No side effect */

	function getExecutableJob(jobs, jobItemName) {
	  return unsafeFindFirst(jobs, jobItemName, (function (param) {
	                return filterTargetName(param[/* name */0], jobItemName);
	              }));
	}

	function _addHandleFuncToList(action, handleFunc, handleList) {
	  if (action) {
	    return $at(handleList, /* :: */[
	                handleFunc,
	                /* [] */0
	              ]);
	  } else {
	    return /* :: */[
	            handleFunc,
	            handleList
	          ];
	  }
	}

	function _findAllCustomJobHandles(_subJobName, workerCustomMainLoopTargetJobMap, _handleList) {
	  while(true) {
	    var handleList = _handleList;
	    var subJobName = _subJobName;
	    var match = get(subJobName, workerCustomMainLoopTargetJobMap);
	    if (match !== undefined) {
	      var match$1 = match;
	      _handleList = _addHandleFuncToList(match$1[1], match$1[2], handleList);
	      _subJobName = match$1[0];
	      continue ;
	    } else {
	      return handleList;
	    }
	  }
	}

	function _buildCustomStreamArr(customJobHandleList, stateData) {
	  return fold_left((function (streamArr, customHandle) {
	                return push(callFunc((function () {
	                                  _1(customHandle, stateData);
	                                  return undefined;
	                                })), streamArr);
	              }), /* array */[], customJobHandleList);
	}

	function addCustomJobHandleToStreamArr(subJobName, workerCustomMainTargetJobMap, stateData, streamArr) {
	  var list = _findAllCustomJobHandles(subJobName, workerCustomMainTargetJobMap, /* [] */0);
	  if (length$1(list) === 0) {
	    return streamArr;
	  } else {
	    return streamArr.concat(_buildCustomStreamArr(list, stateData));
	  }
	}


	/* MostUtils-Wonderjs Not a pure module */

	function _buildStreamArr(param, findFunc, getJobHandleFunc, state) {
	  var jobs = param[4];
	  var stateData$$1 = param[3];
	  var pipelineJobs = param[1];
	  var jobHandleMap = param[0];
	  return reduceOneParam((function (streamArr, param) {
	                var subJobName = param[/* name */0];
	                var match = findFirst(pipelineJobs, subJobName, (function (param) {
	                        return filterTargetName(param[/* name */0], subJobName);
	                      }));
	                if (match !== undefined) {
	                  return addCustomJobHandleToStreamArr(subJobName, state[/* jobRecord */2][/* workerCustomMainInitTargetJobMap */2], stateData$$1, push(_3(findFunc, /* tuple */[
	                                      match,
	                                      pipelineJobs,
	                                      jobHandleMap,
	                                      jobs,
	                                      stateData$$1
	                                    ], getJobHandleFunc, state), streamArr));
	                } else {
	                  var match$1 = getExecutableJob(jobs, subJobName);
	                  var handleFunc = _2(getJobHandleFunc, subJobName, jobHandleMap);
	                  return addCustomJobHandleToStreamArr(subJobName, state[/* jobRecord */2][/* workerCustomMainInitTargetJobMap */2], stateData$$1, push(_2(handleFunc, match$1[/* flags */1], stateData$$1), streamArr));
	                }
	              }), /* array */[], param[2].filter((function (param) {
	                    return !has(param[/* name */0], state[/* jobRecord */2][/* workerCustomMainInitRemovedDefaultJobMap */4]);
	                  })));
	}

	function _find(param, getJobHandleFunc, state) {
	  var stateData$$1 = param[4];
	  var mainInitJobs = param[3];
	  var jobHandleMap = param[2];
	  var pipelineJobs = param[1];
	  var match = param[0];
	  var pipelineSubJobs = match[/* jobs */2];
	  var link = match[/* link */1];
	  switch (link) {
	    case "concat" : 
	        return concatArray(_buildStreamArr(/* tuple */[
	                        jobHandleMap,
	                        pipelineJobs,
	                        pipelineSubJobs,
	                        stateData$$1,
	                        mainInitJobs
	                      ], _find, getJobHandleFunc, state));
	    case "merge" : 
	        return mergeArray(_buildStreamArr(/* tuple */[
	                        jobHandleMap,
	                        pipelineJobs,
	                        pipelineSubJobs,
	                        stateData$$1,
	                        mainInitJobs
	                      ], _find, getJobHandleFunc, state));
	    default:
	      return fatal(buildFatalMessage("_find", "invalid link: " + (String(link) + ""), "", "", ""));
	  }
	}

	function _findFrameJob(jobs) {
	  requireCheck((function () {
	          return test(buildAssertMessage("frame job only has one", "not"), (function () {
	                        return Operators[/* = */0](jobs.filter((function (param) {
	                                          return filterTargetName(param[/* name */0], "frame");
	                                        })).length, 1);
	                      }));
	        }), getIsDebug(stateData));
	  var jobName = "frame";
	  return unsafeFindFirst(jobs, jobName, (function (param) {
	                return filterTargetName(param[/* name */0], jobName);
	              }));
	}

	function getMainInitJobStream$1(jobHandleMap, stateData$$1, getJobHandleFunc, state) {
	  var match = unsafeGet$1(state[/* workerJobRecord */4]);
	  var setting = match[/* setting */0];
	  var match$1 = unsafeFindFirst(match[/* mainInitPipelines */1], setting[/* mainInitPipeline */1], (function (param) {
	          return filterTargetName(param[/* name */0], setting[/* mainInitPipeline */1]);
	        }));
	  var jobs = match$1[/* jobs */1];
	  return _find(/* tuple */[
	              _findFrameJob(jobs),
	              jobs,
	              jobHandleMap,
	              match[/* mainInitJobs */4],
	              stateData$$1
	            ], getJobHandleFunc, state);
	}


	/* most Not a pure module */

	function _buildStreamArr$1(param, findFunc, getJobHandleFunc, state) {
	  var jobs = param[4];
	  var stateData$$1 = param[3];
	  var pipelineJobs = param[1];
	  var jobHandleMap = param[0];
	  return reduceOneParam((function (streamArr, param) {
	                var subJobName = param[/* name */0];
	                var match = findFirst(pipelineJobs, subJobName, (function (param) {
	                        return filterTargetName(param[/* name */0], subJobName);
	                      }));
	                if (match !== undefined) {
	                  return addCustomJobHandleToStreamArr(subJobName, state[/* jobRecord */2][/* workerCustomMainLoopTargetJobMap */5], stateData$$1, push(_3(findFunc, /* tuple */[
	                                      match,
	                                      pipelineJobs,
	                                      jobHandleMap,
	                                      jobs,
	                                      stateData$$1
	                                    ], getJobHandleFunc, state), streamArr));
	                } else {
	                  var match$1 = getExecutableJob(jobs, subJobName);
	                  var handleFunc = _2(getJobHandleFunc, subJobName, jobHandleMap);
	                  return addCustomJobHandleToStreamArr(subJobName, state[/* jobRecord */2][/* workerCustomMainLoopTargetJobMap */5], stateData$$1, push(_2(handleFunc, match$1[/* flags */1], stateData$$1), streamArr));
	                }
	              }), /* array */[], param[2].filter((function (param) {
	                    return !has(param[/* name */0], state[/* jobRecord */2][/* workerCustomMainLoopRemovedDefaultJobMap */7]);
	                  })));
	}

	function _find$1(param, getJobHandleFunc, state) {
	  var stateData$$1 = param[4];
	  var mainLoopJobs = param[3];
	  var jobHandleMap = param[2];
	  var pipelineJobs = param[1];
	  var match = param[0];
	  var pipelineSubJobs = match[/* jobs */2];
	  var link = match[/* link */1];
	  switch (link) {
	    case "concat" : 
	        return concatArray(_buildStreamArr$1(/* tuple */[
	                        jobHandleMap,
	                        pipelineJobs,
	                        pipelineSubJobs,
	                        stateData$$1,
	                        mainLoopJobs
	                      ], _find$1, getJobHandleFunc, state));
	    case "merge" : 
	        return mergeArray(_buildStreamArr$1(/* tuple */[
	                        jobHandleMap,
	                        pipelineJobs,
	                        pipelineSubJobs,
	                        stateData$$1,
	                        mainLoopJobs
	                      ], _find$1, getJobHandleFunc, state));
	    default:
	      return fatal(buildFatalMessage("_find", "invalid link: " + (String(link) + ""), "", "", ""));
	  }
	}

	function _findFrameJob$1(jobs) {
	  requireCheck((function () {
	          return test(buildAssertMessage("frame job only has one", "not"), (function () {
	                        return Operators[/* = */0](jobs.filter((function (param) {
	                                          return filterTargetName(param[/* name */0], "frame");
	                                        })).length, 1);
	                      }));
	        }), getIsDebug(stateData));
	  var jobName = "frame";
	  return unsafeFindFirst(jobs, jobName, (function (param) {
	                return filterTargetName(param[/* name */0], jobName);
	              }));
	}

	function getMainLoopJobStream$1(jobHandleMap, stateData$$1, getJobHandleFunc, state) {
	  var match = unsafeGet$1(state[/* workerJobRecord */4]);
	  var setting = match[/* setting */0];
	  var match$1 = unsafeFindFirst(match[/* mainLoopPipelines */2], setting[/* mainLoopPipeline */2], (function (param) {
	          return filterTargetName(param[/* name */0], setting[/* mainLoopPipeline */2]);
	        }));
	  var jobs = match$1[/* jobs */1];
	  return _find$1(/* tuple */[
	              _findFrameJob$1(jobs),
	              jobs,
	              jobHandleMap,
	              match[/* mainLoopJobs */5],
	              stateData$$1
	            ], getJobHandleFunc, state);
	}


	/* most Not a pure module */

	function getMainInitJobStream(stateData, param, state) {
	  return getMainInitJobStream$1(_1(param[0], /* () */0), stateData, param[1], state);
	}

	function getMainLoopJobStream(stateData, param, state) {
	  return getMainLoopJobStream$1(_1(param[0], /* () */0), stateData, param[1], state);
	}

	function addWorkerMainInitJob$2(param, action, targetHandleFunc, state) {
	  var sourceJobName = param[1];
	  var targetJobName = param[0];
	  var newrecord = caml_array_dup(state);
	  var init = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */init[/* noWorkerInitJobList */0],
	    /* noWorkerLoopJobList */init[/* noWorkerLoopJobList */1],
	    /* workerCustomMainInitTargetJobMap */set(sourceJobName, /* tuple */[
	          targetJobName,
	          action,
	          targetHandleFunc
	        ], state[/* jobRecord */2][/* workerCustomMainInitTargetJobMap */2]),
	    /* workerCustomMainInitSourceJobMap */set(targetJobName, sourceJobName, state[/* jobRecord */2][/* workerCustomMainInitSourceJobMap */3]),
	    /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */init[/* workerCustomMainLoopTargetJobMap */5],
	    /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	    /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}

	function removeWorkerMainInitJob$2(targetJobName, state) {
	  var match = get(targetJobName, state[/* jobRecord */2][/* workerCustomMainInitSourceJobMap */3]);
	  if (match !== undefined) {
	    var newrecord = caml_array_dup(state);
	    var init = state[/* jobRecord */2];
	    newrecord[/* jobRecord */2] = /* record */[
	      /* noWorkerInitJobList */init[/* noWorkerInitJobList */0],
	      /* noWorkerLoopJobList */init[/* noWorkerLoopJobList */1],
	      /* workerCustomMainInitTargetJobMap */deleteVal(match, state[/* jobRecord */2][/* workerCustomMainInitTargetJobMap */2]),
	      /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	      /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	      /* workerCustomMainLoopTargetJobMap */init[/* workerCustomMainLoopTargetJobMap */5],
	      /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	      /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	    ];
	    return newrecord;
	  } else {
	    var newrecord$1 = caml_array_dup(state);
	    var init$1 = state[/* jobRecord */2];
	    newrecord$1[/* jobRecord */2] = /* record */[
	      /* noWorkerInitJobList */init$1[/* noWorkerInitJobList */0],
	      /* noWorkerLoopJobList */init$1[/* noWorkerLoopJobList */1],
	      /* workerCustomMainInitTargetJobMap */init$1[/* workerCustomMainInitTargetJobMap */2],
	      /* workerCustomMainInitSourceJobMap */init$1[/* workerCustomMainInitSourceJobMap */3],
	      /* workerCustomMainInitRemovedDefaultJobMap */set(targetJobName, true, state[/* jobRecord */2][/* workerCustomMainInitRemovedDefaultJobMap */4]),
	      /* workerCustomMainLoopTargetJobMap */init$1[/* workerCustomMainLoopTargetJobMap */5],
	      /* workerCustomMainLoopSourceJobMap */init$1[/* workerCustomMainLoopSourceJobMap */6],
	      /* workerCustomMainLoopRemovedDefaultJobMap */init$1[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	    ];
	    return newrecord$1;
	  }
	}

	function addWorkerMainLoopJob$2(param, action, targetHandleFunc, state) {
	  var sourceJobName = param[1];
	  var targetJobName = param[0];
	  var newrecord = caml_array_dup(state);
	  var init = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */init[/* noWorkerInitJobList */0],
	    /* noWorkerLoopJobList */init[/* noWorkerLoopJobList */1],
	    /* workerCustomMainInitTargetJobMap */init[/* workerCustomMainInitTargetJobMap */2],
	    /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	    /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */set(sourceJobName, /* tuple */[
	          targetJobName,
	          action,
	          targetHandleFunc
	        ], state[/* jobRecord */2][/* workerCustomMainLoopTargetJobMap */5]),
	    /* workerCustomMainLoopSourceJobMap */set(targetJobName, sourceJobName, state[/* jobRecord */2][/* workerCustomMainLoopSourceJobMap */6]),
	    /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}

	function removeWorkerMainLoopJob$2(targetJobName, state) {
	  var match = get(targetJobName, state[/* jobRecord */2][/* workerCustomMainLoopSourceJobMap */6]);
	  if (match !== undefined) {
	    var newrecord = caml_array_dup(state);
	    var init = state[/* jobRecord */2];
	    newrecord[/* jobRecord */2] = /* record */[
	      /* noWorkerInitJobList */init[/* noWorkerInitJobList */0],
	      /* noWorkerLoopJobList */init[/* noWorkerLoopJobList */1],
	      /* workerCustomMainInitTargetJobMap */init[/* workerCustomMainInitTargetJobMap */2],
	      /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	      /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	      /* workerCustomMainLoopTargetJobMap */deleteVal(match, state[/* jobRecord */2][/* workerCustomMainLoopTargetJobMap */5]),
	      /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	      /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	    ];
	    return newrecord;
	  } else {
	    var newrecord$1 = caml_array_dup(state);
	    var init$1 = state[/* jobRecord */2];
	    newrecord$1[/* jobRecord */2] = /* record */[
	      /* noWorkerInitJobList */init$1[/* noWorkerInitJobList */0],
	      /* noWorkerLoopJobList */init$1[/* noWorkerLoopJobList */1],
	      /* workerCustomMainInitTargetJobMap */init$1[/* workerCustomMainInitTargetJobMap */2],
	      /* workerCustomMainInitSourceJobMap */init$1[/* workerCustomMainInitSourceJobMap */3],
	      /* workerCustomMainInitRemovedDefaultJobMap */init$1[/* workerCustomMainInitRemovedDefaultJobMap */4],
	      /* workerCustomMainLoopTargetJobMap */init$1[/* workerCustomMainLoopTargetJobMap */5],
	      /* workerCustomMainLoopSourceJobMap */init$1[/* workerCustomMainLoopSourceJobMap */6],
	      /* workerCustomMainLoopRemovedDefaultJobMap */set(targetJobName, true, state[/* jobRecord */2][/* workerCustomMainLoopRemovedDefaultJobMap */7])
	    ];
	    return newrecord$1;
	  }
	}


	/* HashMapService-WonderCommonlib Not a pure module */

	function handleGetNoneJob(name, jobHandleMap) {
	  return fatal(buildFatalMessage("get no job", "can\'t find job handle function whose job name is " + (String(name) + ""), "", "make sure that the job name defined in config record be correctly", "jobHandleMap:" + (getJsonStr(jobHandleMap) + ("\nname: " + (String(name) + "")))));
	}

	function addJob(param, jobList) {
	  var targetHandleFunc = param[3];
	  var targetJobName = param[0];
	  if (param[2]) {
	    var afterJobName = param[1];
	    return fold_left((function (list, jobItem) {
	                  var match = jobItem[0] === afterJobName;
	                  if (match) {
	                    return $at(list, /* :: */[
	                                jobItem,
	                                /* :: */[
	                                  /* tuple */[
	                                    targetJobName,
	                                    targetHandleFunc
	                                  ],
	                                  /* [] */0
	                                ]
	                              ]);
	                  } else {
	                    return $at(list, /* :: */[
	                                jobItem,
	                                /* [] */0
	                              ]);
	                  }
	                }), /* [] */0, jobList);
	  } else {
	    return /* :: */[
	            /* tuple */[
	              targetJobName,
	              targetHandleFunc
	            ],
	            jobList
	          ];
	  }
	}

	function removeJob(targetJobName, jobList) {
	  return filter$2((function (param) {
	                  return param[0] !== targetJobName;
	                }))(jobList);
	}


	/* Log-WonderLog Not a pure module */

	function _unsafeGetNoWorkerJobConfig(record) {
	  requireCheck((function () {
	          return test(buildAssertMessage("noWorker job config exist", "not"), (function () {
	                        return assertExist(record);
	                      }));
	        }), getIsDebug(stateData));
	  return unsafeGet$1(record);
	}

	function getInitPipelines(record) {
	  return _unsafeGetNoWorkerJobConfig(record)[/* initPipelines */1];
	}

	function getInitJobs(record) {
	  return _unsafeGetNoWorkerJobConfig(record)[/* initJobs */3];
	}

	function getLoopPipelines(record) {
	  return _unsafeGetNoWorkerJobConfig(record)[/* loopPipelines */2];
	}

	function getLoopJobs(record) {
	  return _unsafeGetNoWorkerJobConfig(record)[/* loopJobs */4];
	}

	function getSetting$2(record) {
	  return _unsafeGetNoWorkerJobConfig(record)[/* setting */0];
	}

	function _getExecutableJob(jobs, param) {
	  var pipelineJobName = param[/* name */0];
	  var match = unsafeFindFirst(jobs, pipelineJobName, (function (param) {
	          return filterTargetName(param[/* name */0], pipelineJobName);
	        }));
	  return /* record */[
	          /* name */pipelineJobName,
	          /* flags */match[/* flags */1]
	        ];
	}

	function _getPipelineExecutableJobs(pipeline, pipelines, jobs) {
	  var pipelineItem = unsafeFindFirst(pipelines, pipeline, (function (param) {
	          return filterTargetName(param[/* name */0], pipeline);
	        }));
	  return pipelineItem[/* jobs */1].map((function (param) {
	                return _getExecutableJob(jobs, param);
	              }));
	}

	function getInitPipelineExecutableJobs(param, initPipelines, jobs) {
	  return _getPipelineExecutableJobs(param[/* initPipeline */0], initPipelines, jobs);
	}

	function getLoopPipelineExecutableJobs(param, loopPipelines, jobs) {
	  return _getPipelineExecutableJobs(param[/* loopPipeline */1], loopPipelines, jobs);
	}


	/* Log-WonderLog Not a pure module */

	function _getAllNoWorkerJobs(executableJobs, jobHandleMap, _) {
	  return reduceOneParam((function (list, param) {
	                var name = param[/* name */0];
	                var match = get(name, jobHandleMap);
	                if (match !== undefined) {
	                  return $at(list, /* :: */[
	                              /* tuple */[
	                                name,
	                                _1(match, param[/* flags */1])
	                              ],
	                              /* [] */0
	                            ]);
	                } else {
	                  return handleGetNoneJob(name, jobHandleMap);
	                }
	              }), /* [] */0, executableJobs);
	}

	function execNoWorkerInitJobs(state) {
	  return fold_left((function (state, param) {
	                return _1(param[1], state);
	              }), state, state[/* jobRecord */2][/* noWorkerInitJobList */0]);
	}

	function execNoWorkerLoopJobs(state) {
	  return fold_left((function (state, param) {
	                return _1(param[1], state);
	              }), state, state[/* jobRecord */2][/* noWorkerLoopJobList */1]);
	}

	function init(param, state) {
	  var newrecord = caml_array_dup(state);
	  var init$1 = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */_getAllNoWorkerJobs(getInitPipelineExecutableJobs(getSetting$2(state[/* noWorkerJobRecord */3]), getInitPipelines(state[/* noWorkerJobRecord */3]), getInitJobs(state[/* noWorkerJobRecord */3])), _1(param[0], /* () */0), state),
	    /* noWorkerLoopJobList */_getAllNoWorkerJobs(getLoopPipelineExecutableJobs(getSetting$2(state[/* noWorkerJobRecord */3]), getLoopPipelines(state[/* noWorkerJobRecord */3]), getLoopJobs(state[/* noWorkerJobRecord */3])), _1(param[1], /* () */0), state),
	    /* workerCustomMainInitTargetJobMap */init$1[/* workerCustomMainInitTargetJobMap */2],
	    /* workerCustomMainInitSourceJobMap */init$1[/* workerCustomMainInitSourceJobMap */3],
	    /* workerCustomMainInitRemovedDefaultJobMap */init$1[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */init$1[/* workerCustomMainLoopTargetJobMap */5],
	    /* workerCustomMainLoopSourceJobMap */init$1[/* workerCustomMainLoopSourceJobMap */6],
	    /* workerCustomMainLoopRemovedDefaultJobMap */init$1[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}

	function addNoWorkerInitJob$2(param, action, targetHandleFunc, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */addJob(/* tuple */[
	          param[0],
	          param[1],
	          action,
	          targetHandleFunc
	        ], state[/* jobRecord */2][/* noWorkerInitJobList */0]),
	    /* noWorkerLoopJobList */init[/* noWorkerLoopJobList */1],
	    /* workerCustomMainInitTargetJobMap */init[/* workerCustomMainInitTargetJobMap */2],
	    /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	    /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */init[/* workerCustomMainLoopTargetJobMap */5],
	    /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	    /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}

	function addNoWorkerLoopJob$2(param, action, targetHandleFunc, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */init[/* noWorkerInitJobList */0],
	    /* noWorkerLoopJobList */addJob(/* tuple */[
	          param[0],
	          param[1],
	          action,
	          targetHandleFunc
	        ], state[/* jobRecord */2][/* noWorkerLoopJobList */1]),
	    /* workerCustomMainInitTargetJobMap */init[/* workerCustomMainInitTargetJobMap */2],
	    /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	    /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */init[/* workerCustomMainLoopTargetJobMap */5],
	    /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	    /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}

	function removeNoWorkerInitJob$2(targetJobName, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */removeJob(targetJobName, state[/* jobRecord */2][/* noWorkerInitJobList */0]),
	    /* noWorkerLoopJobList */init[/* noWorkerLoopJobList */1],
	    /* workerCustomMainInitTargetJobMap */init[/* workerCustomMainInitTargetJobMap */2],
	    /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	    /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */init[/* workerCustomMainLoopTargetJobMap */5],
	    /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	    /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}

	function removeNoWorkerLoopJob$2(targetJobName, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* jobRecord */2];
	  newrecord[/* jobRecord */2] = /* record */[
	    /* noWorkerInitJobList */init[/* noWorkerInitJobList */0],
	    /* noWorkerLoopJobList */removeJob(targetJobName, state[/* jobRecord */2][/* noWorkerLoopJobList */1]),
	    /* workerCustomMainInitTargetJobMap */init[/* workerCustomMainInitTargetJobMap */2],
	    /* workerCustomMainInitSourceJobMap */init[/* workerCustomMainInitSourceJobMap */3],
	    /* workerCustomMainInitRemovedDefaultJobMap */init[/* workerCustomMainInitRemovedDefaultJobMap */4],
	    /* workerCustomMainLoopTargetJobMap */init[/* workerCustomMainLoopTargetJobMap */5],
	    /* workerCustomMainLoopSourceJobMap */init[/* workerCustomMainLoopSourceJobMap */6],
	    /* workerCustomMainLoopRemovedDefaultJobMap */init[/* workerCustomMainLoopRemovedDefaultJobMap */7]
	  ];
	  return newrecord;
	}


	/* JobService-Wonderjs Not a pure module */

	function addNoWorkerInitJob$1(param, action, targetHandleFunc, state) {
	  return addNoWorkerInitJob$2(/* tuple */[
	              param[0],
	              param[1]
	            ], action, targetHandleFunc, state);
	}

	function addNoWorkerLoopJob$1(param, action, targetHandleFunc, state) {
	  return addNoWorkerLoopJob$2(/* tuple */[
	              param[0],
	              param[1]
	            ], action, targetHandleFunc, state);
	}

	var removeNoWorkerInitJob$1 = removeNoWorkerInitJob$2;

	var removeNoWorkerLoopJob$1 = removeNoWorkerLoopJob$2;

	function addWorkerMainInitJob$1(param, action, targetHandleFunc, state) {
	  return addWorkerMainInitJob$2(/* tuple */[
	              param[0],
	              param[1]
	            ], action, targetHandleFunc, state);
	}

	var removeWorkerMainInitJob$1 = removeWorkerMainInitJob$2;

	function addWorkerMainLoopJob$1(param, action, targetHandleFunc, state) {
	  return addWorkerMainLoopJob$2(/* tuple */[
	              param[0],
	              param[1]
	            ], action, targetHandleFunc, state);
	}

	var removeWorkerMainLoopJob$1 = removeWorkerMainLoopJob$2;


	/* WorkerJobMainService-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	function isEmpty(value) {
	  if (value === null) {
	    return true;
	  } else {
	    return value === undefined;
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function createEmpty$2() {
	  return /* array */[];
	}

	function unsafeGet$2(key, map) {
	  return map[key];
	}

	function get$3(key, map) {
	  var value = map[key];
	  var match = isEmpty(value);
	  if (match) {
	    return undefined;
	  } else {
	    return some$1(value);
	  }
	}

	function has$1(key, map) {
	  return !isEmpty(map[key]);
	}

	function set$1(key, value, map) {
	  map[key] = value;
	  return map;
	}

	function deleteVal$1(key, map) {
	  map[key] = undefined;
	  return map;
	}


	/* No side effect */

	var getGameObject$1 = get$3;

	function unsafeGetGameObject$1(component, gameObjectMap) {
	  return ensureCheck((function (gameObject) {
	                return test(buildAssertMessage("component\'s gameObject exist", "not"), (function () {
	                              return assertNullableExist(gameObject);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(component, gameObjectMap));
	}


	/* Log-WonderLog Not a pure module */

	function isDeleted(item) {
	  return item == null;
	}

	function length$2(prim) {
	  return prim.length;
	}

	function copy$3(prim) {
	  return prim.slice();
	}

	function getValidValues(map) {
	  return map.filter((function (value) {
	                return value !== undefined;
	              }));
	}

	function getValidKeys(map) {
	  return reduceOneParami((function (arr, value, key) {
	                if (value === undefined) {
	                  return arr;
	                } else {
	                  arr.push(key);
	                  return arr;
	                }
	              }), /* array */[], map);
	}

	function forEachValid(func, map) {
	  return forEach((function (value) {
	                if (value === undefined) {
	                  return /* () */0;
	                } else {
	                  return func(value);
	                }
	              }), map);
	}

	function reduceValid(func, initValue, map) {
	  return reduceOneParam((function (previousValue, value) {
	                if (value === undefined) {
	                  return previousValue;
	                } else {
	                  return func(previousValue, value);
	                }
	              }), initValue, map);
	}

	function reduceiValid(func, initValue, map) {
	  return reduceOneParami((function (previousValue, value, index) {
	                if (value === undefined) {
	                  return previousValue;
	                } else {
	                  return func(previousValue, value, index);
	                }
	              }), initValue, map);
	}

	function indexOf(targetValue, map) {
	  return map.indexOf(targetValue);
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function isAlive$1(component, disposedIndexArray) {
	  return !disposedIndexArray.includes(component);
	}

	function checkComponentShouldAlive(component, isAliveFunc, record) {
	  return test(buildAssertMessage("dispose the alive component", "not"), (function () {
	                return assertTrue(_2(isAliveFunc, component, record));
	              }));
	}

	function checkComponentShouldAliveWithBatchDispose(componentArr, isAliveFunc, record) {
	  return forEach((function (component) {
	                return checkComponentShouldAlive(component, isAliveFunc, record);
	              }), componentArr);
	}

	var disposeSparseMapData = deleteVal$1;

	function removeFromArray(target, arr) {
	  var index = arr.indexOf(target);
	  var lastIndex = arr.length - 1 | 0;
	  deleteBySwap(index, lastIndex, arr);
	  return arr;
	}


	/* Log-WonderLog Not a pure module */

	function isAlive(cameraView, param) {
	  return isAlive$1(cameraView, param[/* disposedIndexArray */2]);
	}

	function _disposeData(cameraView, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* gameObjectMap */disposeSparseMapData(cameraView, record[/* gameObjectMap */1]),
	          /* disposedIndexArray */record[/* disposedIndexArray */2]
	        ];
	}

	function handleBatchDisposeComponent(cameraViewArray, record) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(cameraViewArray, isAlive, record);
	        }), getIsDebug(stateData));
	  return reduceOneParam((function (record, cameraView) {
	                return _disposeData(cameraView, record);
	              }), /* record */[
	              /* index */record[/* index */0],
	              /* gameObjectMap */record[/* gameObjectMap */1],
	              /* disposedIndexArray */record[/* disposedIndexArray */2].concat(cameraViewArray)
	            ], cameraViewArray);
	}


	/* Contract-WonderLog Not a pure module */

	function getGameObject(cameraView, param) {
	  return getGameObject$1(cameraView, param[/* gameObjectMap */1]);
	}

	function unsafeGetGameObject(cameraView, param) {
	  return unsafeGetGameObject$1(cameraView, param[/* gameObjectMap */1]);
	}

	function _isValidComponent(cameraView, maxIndex) {
	  if (cameraView >= 0) {
	    return cameraView < maxIndex;
	  } else {
	    return false;
	  }
	}

	function _getGameObject(index, record) {
	  var match = getGameObject(index, record);
	  if (match !== undefined) {
	    return match;
	  }
	  
	}

	function _findFirstBasicCameraView(_index, maxIndex, record) {
	  while(true) {
	    var index = _index;
	    var match = _isValidComponent(index, maxIndex);
	    if (match) {
	      var match$1 = isAlive(index, record);
	      if (match$1) {
	        return _getGameObject(index, record);
	      } else {
	        _index = index + 1 | 0;
	        continue ;
	      }
	    } else {
	      return undefined;
	    }
	  }
	}

	function findFirstGameObject(record) {
	  return _findFirstBasicCameraView(0, record[/* index */0], record);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getCurrentCameraGameObject$2(basicCameraViewRecord, param) {
	  var currentCameraGameObject = param[/* currentCameraGameObject */0];
	  if (currentCameraGameObject !== undefined) {
	    return currentCameraGameObject;
	  } else {
	    return findFirstGameObject(basicCameraViewRecord);
	  }
	}

	function setCurrentCameraGameObject$2(uid, record) {
	  return /* record */[
	          /* currentCameraGameObject */uid,
	          /* ambientLight */record[/* ambientLight */1],
	          /* sceneGameObject */record[/* sceneGameObject */2]
	        ];
	}


	/* GameObjectBasicCameraViewService-Wonderjs Not a pure module */

	function getDefaultColor() {
	  return /* array */[
	          0,
	          0,
	          0
	        ];
	}


	/* No side effect */

	function checkNotExceedMaxCountByIndex(maxCount, index) {
	  return ensureCheck((function (index) {
	                var maxIndex = maxCount - 1 | 0;
	                return test(buildAssertMessage("index: " + (String(index) + (" <= maxIndex: " + (String(maxIndex) + ""))), "not"), (function () {
	                              return Operators[/* <= */11](index, maxIndex);
	                            }));
	              }), getIsDebug(stateData), index);
	}

	function checkNotExceedMaxCount(maxCount, resultTuple) {
	  checkNotExceedMaxCountByIndex(maxCount, resultTuple[1]);
	  return resultTuple;
	}


	/* Log-WonderLog Not a pure module */

	function unsafeGetBuffer(param) {
	  return unsafeGet$1(param[/* buffer */2]);
	}

	function getTransformCount(record) {
	  return unsafeGetBuffer(record)[/* transformCount */2];
	}

	function getCustomGeometryPointCount(record) {
	  return unsafeGetBuffer(record)[/* customGeometryPointCount */0];
	}

	function getCustomGeometryCount(record) {
	  return unsafeGetBuffer(record)[/* customGeometryCount */1];
	}

	function getBasicMaterialCount(record) {
	  return unsafeGetBuffer(record)[/* basicMaterialCount */3];
	}

	function getLightMaterialCount(record) {
	  return unsafeGetBuffer(record)[/* lightMaterialCount */4];
	}

	function getMeshRendererCount(record) {
	  return unsafeGetBuffer(record)[/* meshRendererCount */8];
	}

	function getSourceInstanceCount(record) {
	  return unsafeGetBuffer(record)[/* instanceBuffer */9][/* sourceInstanceCount */0];
	}

	function getObjectInstanceCountPerSourceInstance(record) {
	  return unsafeGetBuffer(record)[/* instanceBuffer */9][/* objectInstanceCountPerSourceInstance */1];
	}

	function getTextureCountPerMaterial(record) {
	  return unsafeGetBuffer(record)[/* textureCountPerMaterial */5];
	}

	function getBasicSourceTextureCount(record) {
	  return unsafeGetBuffer(record)[/* basicSourceTextureCount */6];
	}

	function getArrayBufferViewSourceTextureCount(record) {
	  return unsafeGetBuffer(record)[/* arrayBufferViewSourceTextureCount */7];
	}


	/* OptionService-Wonderjs Not a pure module */

	function mark(transform, isDirty, record) {
	  var dirtyMap = record[/* dirtyMap */18];
	  set$1(transform, isDirty, dirtyMap);
	  return record;
	}

	function isDirty(transform, record) {
	  var dirtyMap = record[/* dirtyMap */18];
	  return ensureCheck((function (isDirty) {
	                return test(buildAssertMessage("return bool", "not"), (function () {
	                              return assertIsBool(isDirty);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(transform, dirtyMap) === true);
	}


	/* Log-WonderLog Not a pure module */

	function _getDisposedIndex(disposedIndexArray) {
	  return /* tuple */[
	          disposedIndexArray,
	          undefined_to_opt(disposedIndexArray.pop())
	        ];
	}

	function generateIndex(index, disposedIndexArray) {
	  var match = _getDisposedIndex(disposedIndexArray);
	  var match$1 = match[1];
	  var disposedIndexArray$1 = match[0];
	  if (match$1 !== undefined) {
	    return /* tuple */[
	            match$1,
	            index,
	            disposedIndexArray$1
	          ];
	  } else {
	    return /* tuple */[
	            index,
	            index + 1 | 0,
	            disposedIndexArray$1
	          ];
	  }
	}


	/* No side effect */

	function copyFloat32Array(typeArr) {
	  if (typeArr === undefined) {
	    return undefined;
	  } else {
	    return typeArr.slice();
	  }
	}

	function copyFloat32ArrayWithEndIndex(endIndex, typeArr) {
	  return typeArr.slice(0, endIndex);
	}

	function copyUint8ArrayWithEndIndex(endIndex, typeArr) {
	  return typeArr.slice(0, endIndex);
	}

	function copyUint16ArrayWithEndIndex(endIndex, typeArr) {
	  return typeArr.slice(0, endIndex);
	}

	function copyUint32ArrayWithEndIndex(endIndex, typeArr) {
	  return typeArr.slice(0, endIndex);
	}

	function deepCopyFloat32ArrayArray(arr) {
	  return arr.map(copyFloat32Array);
	}

	function deepCopyArrayArray(arr) {
	  return arr.map((function (itemArr) {
	                var match = isDeleted(itemArr);
	                if (match) {
	                  return undefined;
	                } else {
	                  return itemArr.slice();
	                }
	              }));
	}


	/* SparseMapService-Wonderjs Not a pure module */

	var _isSupportSharedArrayBuffer = (
	    function(){
	        return typeof SharedArrayBuffer !== "undefined"
	    }
	    );

	function isSupportSharedArrayBuffer() {
	  return _1(_isSupportSharedArrayBuffer, /* () */0);
	}

	function newSharedArrayBuffer(totalByteLength) {
	  var match = _1(_isSupportSharedArrayBuffer, /* () */0);
	  if (match) {
	    return new SharedArrayBuffer(totalByteLength);
	  } else {
	    return new ArrayBuffer(totalByteLength);
	  }
	}


	/* _isSupportSharedArrayBuffer Not a pure module */

	function getLocalToWorldMatricesSize() {
	  return 16;
	}

	function getLocalToWorldMatricesLength(count) {
	  return (count << 4);
	}

	function getLocalToWorldMatricesOffset() {
	  return 0;
	}

	function getLocalPositionsSize() {
	  return 3;
	}

	function getLocalPositionsLength(count) {
	  return imul(count, 3);
	}

	function getLocalPositionsOffset(count) {
	  return 0 + imul((count << 4), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getLocalRotationsSize() {
	  return 4;
	}

	function getLocalRotationsLength(count) {
	  return (count << 2);
	}

	function getLocalRotationsOffset(count) {
	  return getLocalPositionsOffset(count) + imul(imul(count, 3), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getLocalScalesSize() {
	  return 3;
	}

	function getLocalScalesLength(count) {
	  return imul(count, 3);
	}

	function getLocalScalesOffset(count) {
	  return getLocalRotationsOffset(count) + imul((count << 2), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getLocalToWorldMatrixIndex(index) {
	  return (index << 4);
	}

	function getLocalPositionIndex(index) {
	  return imul(index, 3);
	}

	function getLocalRotationIndex(index) {
	  return (index << 2);
	}

	function getLocalScaleIndex(index) {
	  return imul(index, 3);
	}

	function getTotalByteLength(count) {
	  return imul(imul(count, Float32Array.BYTES_PER_ELEMENT), 26);
	}

	function createBuffer(count) {
	  return newSharedArrayBuffer(getTotalByteLength(count));
	}


	/* Worker-Wonderjs Not a pure module */

	function findFirstHtmlElement($$document, str) {
	  var elements = $$document.querySelectorAll(str);
	  var match = elements.length;
	  if (match !== 0) {
	    return some$1(caml_array_get(elements, 0));
	  }
	  
	}

	function _prepend(sourceElement, targetElement) {
	  var match = targetElement.prepend;
	  if (match == null) {
	    return targetElement.insertBefore(sourceElement, targetElement.firstChild);
	  } else {
	    return targetElement.prepend(sourceElement);
	  }
	}

	function prependTo(sourceElement, targetElement) {
	  if (targetElement !== undefined) {
	    var match = sourceElement.nodeType;
	    if (match !== 1) {
	      return sourceElement;
	    } else {
	      _prepend(sourceElement, valFromOption(targetElement));
	      return sourceElement;
	    }
	  } else {
	    return failwith("targetElement should exist");
	  }
	}

	function setBatchStyle(element, cssText) {
	  element.style.cssText = cssText;
	  return element;
	}

	var requestPointerLock = function (element){
	  element.requestPointerLock();
	  };

	var exitPointerLock = function (){
	  document.exitPointerLock();
	  };


	/* No side effect */

	function buildCanvas() {
	  return document.createElement("canvas");
	}


	/* No side effect */

	var hasProperty = (
	    function has(property, target){
	        return property in target
	    }
	    );


	/* hasProperty Not a pure module */

	function setSetting$1(param) {
	  var worker = param[/* worker */6];
	  var gpu = param[/* gpu */5];
	  var context = param[/* context */4];
	  var isDebug = param[/* isDebug */3];
	  var buffer = param[/* buffer */2];
	  var memory = param[/* memory */1];
	  return /* record */[
	          /* canvasId */param[/* canvasId */0],
	          /* memory */memory !== undefined ? memory : /* record */[
	              /* maxDisposeCount */1000,
	              /* maxTypeArrayPoolSize */5000,
	              /* maxBigTypeArrayPoolSize */100
	            ],
	          /* buffer */buffer !== undefined ? buffer : /* record */[
	              /* customGeometryPointCount */1000000,
	              /* customGeometryCount */1000,
	              /* transformCount */10000,
	              /* basicMaterialCount */10000,
	              /* lightMaterialCount */10000,
	              /* textureCountPerMaterial */16,
	              /* basicSourceTextureCount */64,
	              /* arrayBufferViewSourceTextureCount */64,
	              /* meshRendererCount */10000,
	              /* instanceBuffer : record */[
	                /* sourceInstanceCount */2,
	                /* objectInstanceCountPerSourceInstance */10000
	              ]
	            ],
	          /* isDebug */isDebug !== undefined ? isDebug : false,
	          /* context */context !== undefined ? context : /* record */[
	              /* alpha */true,
	              /* depth */true,
	              /* stencil */false,
	              /* antialias */true,
	              /* premultipliedAlpha */true,
	              /* preserveDrawingBuffer */false
	            ],
	          /* gpu */gpu !== undefined ? gpu : /* record */[/* useHardwareInstance */true],
	          /* worker */worker !== undefined ? worker : /* record */[/* useWorker */false]
	        ];
	}

	function getCanvasId(param) {
	  return param[/* canvasId */0];
	}

	function unsafeGetMemory(param) {
	  return unsafeGet$1(param[/* memory */1]);
	}

	function unsafeGetIsDebug(param) {
	  return unsafeGet$1(param[/* isDebug */3]);
	}

	function unsafeGetGPU(param) {
	  return unsafeGet$1(param[/* gpu */5]);
	}

	function unsafeGetContext(param) {
	  return unsafeGet$1(param[/* context */4]);
	}

	function unsafeGetWorker(param) {
	  return unsafeGet$1(param[/* worker */6]);
	}


	/* OptionService-Wonderjs Not a pure module */

	function detect(state) {
	  var isSupportSharedArrayBuffer$$1 = isSupportSharedArrayBuffer(/* () */0);
	  var newrecord = caml_array_dup(state);
	  var match = !isSupportSharedArrayBuffer$$1;
	  newrecord[/* workerDetectRecord */40] = /* record */[
	    /* isSupportSharedArrayBuffer */isSupportSharedArrayBuffer$$1,
	    /* isSupportRenderWorkerAndSharedArrayBuffer */match ? false : _2(hasProperty, "transferControlToOffscreen", buildCanvas(/* () */0))
	  ];
	  return newrecord;
	}

	function isUseWorker(state) {
	  if (unsafeGetWorker(state[/* settingRecord */1])[/* useWorker */0]) {
	    return state[/* workerDetectRecord */40][/* isSupportRenderWorkerAndSharedArrayBuffer */1];
	  } else {
	    return false;
	  }
	}


	/* Worker-Wonderjs Not a pure module */

	function createTypeArrays(buffer, count) {
	  return /* tuple */[
	          new Float32Array(buffer, getLocalToWorldMatricesOffset(count), getLocalToWorldMatricesLength(count)),
	          new Float32Array(buffer, getLocalPositionsOffset(count), getLocalPositionsLength(count)),
	          new Float32Array(buffer, getLocalRotationsOffset(count), getLocalRotationsLength(count)),
	          new Float32Array(buffer, getLocalScalesOffset(count), getLocalScalesLength(count))
	        ];
	}


	/* BufferTransformService-Wonderjs Not a pure module */

	function getUint8_1(index, typeArray) {
	  return typeArray[index];
	}

	function getUint16_1(index, typeArray) {
	  return typeArray[index];
	}

	function getUint32_1(index, typeArray) {
	  return typeArray[index];
	}

	function getFloat1(index, typeArray) {
	  return typeArray[index];
	}

	function getFloat3(index, typeArray) {
	  return /* array */[
	          typeArray[index],
	          typeArray[index + 1 | 0],
	          typeArray[index + 2 | 0]
	        ];
	}

	function getFloat3Tuple(index, typeArray) {
	  return /* tuple */[
	          typeArray[index],
	          typeArray[index + 1 | 0],
	          typeArray[index + 2 | 0]
	        ];
	}

	function getFloat4Tuple(index, typeArray) {
	  return /* tuple */[
	          typeArray[index],
	          typeArray[index + 1 | 0],
	          typeArray[index + 2 | 0],
	          typeArray[index + 3 | 0]
	        ];
	}

	function setUint8_1(index, value, typeArray) {
	  typeArray[index] = value;
	  return typeArray;
	}

	function setUint16_1(index, value, typeArray) {
	  typeArray[index] = value;
	  return typeArray;
	}

	function setUint32_1(index, value, typeArray) {
	  typeArray[index] = value;
	  return typeArray;
	}

	function setFloat1(index, value, typeArray) {
	  typeArray[index] = value;
	  return typeArray;
	}

	function setFloat3(index, record, typeArray) {
	  requireCheck((function () {
	          var len = record.length;
	          return test(buildAssertMessage("record.length === 3", "is " + (String(len) + "")), (function () {
	                        return Operators[/* = */0](len, 3);
	                      }));
	        }), getIsDebug(stateData));
	  for(var i = index ,i_finish = index + 2 | 0; i <= i_finish; ++i){
	    typeArray[i] = record[i - index | 0];
	  }
	  return typeArray;
	}

	function setFloat4(index, record, typeArray) {
	  requireCheck((function () {
	          var len = record.length;
	          return test(buildAssertMessage("record.length === 4", "is " + (String(len) + "")), (function () {
	                        return Operators[/* = */0](len, 4);
	                      }));
	        }), getIsDebug(stateData));
	  for(var i = index ,i_finish = index + 3 | 0; i <= i_finish; ++i){
	    typeArray[i] = record[i - index | 0];
	  }
	  return typeArray;
	}

	function setFloat3ByTuple(index, param, typeArray) {
	  typeArray[index] = param[0];
	  typeArray[index + 1 | 0] = param[1];
	  typeArray[index + 2 | 0] = param[2];
	  return typeArray;
	}

	function setFloat4ByTuple(index, param, typeArray) {
	  typeArray[index] = param[0];
	  typeArray[index + 1 | 0] = param[1];
	  typeArray[index + 2 | 0] = param[2];
	  typeArray[index + 3 | 0] = param[3];
	  return typeArray;
	}

	function getFloat16TypeArray(index, typeArray) {
	  return typeArray.subarray(index, index + 16 | 0);
	}

	function setFloat16(index, record, typeArray) {
	  requireCheck((function () {
	          var len = record.length;
	          return test(buildAssertMessage("record.length === 16", "is " + (String(len) + "")), (function () {
	                        return Operators[/* = */0](len, 16);
	                      }));
	        }), getIsDebug(stateData));
	  for(var i = index ,i_finish = index + 15 | 0; i <= i_finish; ++i){
	    typeArray[i] = record[i - index | 0];
	  }
	  return typeArray;
	}

	function fillFloat32ArrayWithOffset(targetTypeArr, sourceTypeArr, offset) {
	  requireCheck((function () {
	          test(buildAssertMessage("offset should >= 0", "is " + (String(offset) + "")), (function () {
	                  return Operators[/* >= */7](offset, 0);
	                }));
	          var sourceTypeArrLen = sourceTypeArr.length;
	          var targetTypeArrLen = targetTypeArr.length;
	          return test(buildAssertMessage("sourceTypeArr.length:" + (String(sourceTypeArrLen) + (" + offset:" + (String(offset) + (" <= targetTypeArr.length:" + (String(targetTypeArrLen) + ""))))), ""), (function () {
	                        return Operators[/* <= */11](sourceTypeArrLen + offset | 0, targetTypeArrLen);
	                      }));
	        }), getIsDebug(stateData));
	  targetTypeArr.set(sourceTypeArr, offset);
	  return /* () */0;
	}

	function getFloat32ArraySubarray(typeArray, startIndex, endIndex) {
	  return typeArray.subarray(startIndex, endIndex);
	}

	function fillUint16ArrayWithOffset(targetTypeArr, sourceTypeArr, offset) {
	  requireCheck((function () {
	          test(buildAssertMessage("offset should >= 0", "is " + (String(offset) + "")), (function () {
	                  return Operators[/* >= */7](offset, 0);
	                }));
	          var sourceTypeArrLen = sourceTypeArr.length;
	          var targetTypeArrLen = targetTypeArr.length;
	          return test(buildAssertMessage("sourceTypeArr.length:" + (String(sourceTypeArrLen) + (" + offset:" + (String(offset) + (" <= targetTypeArr.length:" + (String(targetTypeArrLen) + ""))))), ""), (function () {
	                        return Operators[/* <= */11](sourceTypeArrLen + offset | 0, targetTypeArrLen);
	                      }));
	        }), getIsDebug(stateData));
	  targetTypeArr.set(sourceTypeArr, offset);
	  return /* () */0;
	}

	function getUint16ArraySubarray(typeArray, startIndex, endIndex) {
	  return typeArray.subarray(startIndex, endIndex);
	}

	function _setFloat32ArrayWithFloat32Array(targetTypeArr, sourceTypeArr, typeArrIndex, i) {
	  targetTypeArr[typeArrIndex] = sourceTypeArr[i];
	  return /* () */0;
	}

	function _setUint8ArrayWithUint8Array(targetTypeArr, sourceTypeArr, typeArrIndex, i) {
	  targetTypeArr[typeArrIndex] = sourceTypeArr[i];
	  return /* () */0;
	}

	function _setUint16ArrayWithUint16Array(targetTypeArr, sourceTypeArr, typeArrIndex, i) {
	  targetTypeArr[typeArrIndex] = sourceTypeArr[i];
	  return /* () */0;
	}

	function _setUint32ArrayWithUint32Array(targetTypeArr, sourceTypeArr, typeArrIndex, i) {
	  targetTypeArr[typeArrIndex] = sourceTypeArr[i];
	  return /* () */0;
	}

	function _fillTypeArrayWithTypeArr(param, param$1, endIndex, _setTypeArrWithTypeArr) {
	  var sourceTypeArr = param$1[0];
	  var targetTypeArr = param[0];
	  var typeArrIndex = param[1];
	  for(var i = param$1[1] ,i_finish = endIndex - 1 | 0; i <= i_finish; ++i){
	    _setTypeArrWithTypeArr(targetTypeArr, sourceTypeArr, typeArrIndex, i);
	    typeArrIndex = typeArrIndex + 1 | 0;
	  }
	  return typeArrIndex;
	}

	function fillUint8ArrayWithUint8Array(targetData, sourceData, endIndex) {
	  return _fillTypeArrayWithTypeArr(targetData, sourceData, endIndex, _setUint8ArrayWithUint8Array);
	}

	function fillUint16ArrayWithUint16Array(targetData, sourceData, endIndex) {
	  return _fillTypeArrayWithTypeArr(targetData, sourceData, endIndex, _setUint16ArrayWithUint16Array);
	}

	function fillUint32ArrayWithUint32Array(targetData, sourceData, endIndex) {
	  return _fillTypeArrayWithTypeArr(targetData, sourceData, endIndex, _setUint32ArrayWithUint32Array);
	}

	function fillFloat32ArrayWithFloat32Array(targetData, sourceData, endIndex) {
	  return _fillTypeArrayWithTypeArr(targetData, sourceData, endIndex, _setFloat32ArrayWithFloat32Array);
	}

	function setUint8Array(sourceTypeArr, targetTypeArr) {
	  targetTypeArr.set(sourceTypeArr);
	  return targetTypeArr;
	}

	function setUint16Array(sourceTypeArr, targetTypeArr) {
	  targetTypeArr.set(sourceTypeArr);
	  return targetTypeArr;
	}

	function setFloat32Array(sourceTypeArr, targetTypeArr) {
	  targetTypeArr.set(sourceTypeArr);
	  return targetTypeArr;
	}


	/* Log-WonderLog Not a pure module */

	function getLocalToWorldMatrixTypeArray(index, typeArr) {
	  return getFloat16TypeArray(getLocalToWorldMatrixIndex(index), typeArr);
	}

	function setLocalToWorldMatrix(index, data, typeArr) {
	  return setFloat16(getLocalToWorldMatrixIndex(index), data, typeArr);
	}

	function getLocalPositionTuple(index, typeArr) {
	  return getFloat3Tuple(getLocalPositionIndex(index), typeArr);
	}

	function setLocalPosition(index, data, typeArr) {
	  return setFloat3(getLocalPositionIndex(index), data, typeArr);
	}

	function setLocalPositionByTuple(index, dataTuple, typeArr) {
	  return setFloat3ByTuple(getLocalPositionIndex(index), dataTuple, typeArr);
	}

	function getLocalRotationTuple(index, typeArr) {
	  return getFloat4Tuple(getLocalRotationIndex(index), typeArr);
	}

	function setLocalRotation(index, data, typeArr) {
	  return setFloat4(getLocalRotationIndex(index), data, typeArr);
	}

	function setLocalRotationByTuple(index, dataTuple, typeArr) {
	  return setFloat4ByTuple(getLocalRotationIndex(index), dataTuple, typeArr);
	}

	function getLocalScaleTuple(index, typeArr) {
	  return getFloat3Tuple(getLocalScaleIndex(index), typeArr);
	}

	function setLocalScale(index, data, typeArr) {
	  return setFloat3(getLocalScaleIndex(index), data, typeArr);
	}

	function setLocalScaleByTuple(index, dataTuple, typeArr) {
	  return setFloat3ByTuple(getLocalScaleIndex(index), dataTuple, typeArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getRecord$1(param) {
	  return unsafeGet$1(param[/* transformRecord */12]);
	}

	function setAllTypeArrDataToDefault(count, param, param$1) {
	  var defaultLocalScale = param[3];
	  var defaultLocalRotation = param[2];
	  var defaultLocalPosition = param[1];
	  var defaultLocalToWorldMatrix = param[0];
	  return reduceOneParam((function (param, index) {
	                return /* tuple */[
	                        setLocalToWorldMatrix(index, defaultLocalToWorldMatrix, param[0]),
	                        setLocalPosition(index, defaultLocalPosition, param[1]),
	                        setLocalRotation(index, defaultLocalRotation, param[2]),
	                        setLocalScale(index, defaultLocalScale, param[3])
	                      ];
	              }), /* tuple */[
	              param$1[0],
	              param$1[1],
	              param$1[2],
	              param$1[3]
	            ], range(0, count - 1 | 0));
	}

	function _setAllTypeArrDataToDefault(count, defaultDataTuple, param) {
	  return /* tuple */[
	          param[0],
	          setAllTypeArrDataToDefault(count, defaultDataTuple, /* tuple */[
	                param[1],
	                param[2],
	                param[3],
	                param[4]
	              ])
	        ];
	}

	function _initBufferData(count, defaultDataTuple) {
	  var buffer = createBuffer(count);
	  var match = createTypeArrays(buffer, count);
	  return _setAllTypeArrDataToDefault(count, defaultDataTuple, /* tuple */[
	              buffer,
	              match[0],
	              match[1],
	              match[2],
	              match[3]
	            ]);
	}

	function _createForWorker(transformCount, defaultDataTuple, param, state) {
	  var match = _initBufferData(transformCount, defaultDataTuple);
	  var match$1 = match[1];
	  state[/* transformRecord */12] = /* record */[
	    /* index */0,
	    /* buffer */param[0],
	    /* localToWorldMatrices */param[1],
	    /* localPositions */param[2],
	    /* localRotations */param[3],
	    /* localScales */param[4],
	    /* copiedBuffer */some$1(match[0]),
	    /* copiedLocalToWorldMatrices */some$1(match$1[0]),
	    /* copiedLocalPositions */some$1(match$1[1]),
	    /* copiedLocalRotations */some$1(match$1[2]),
	    /* copiedLocalScales */some$1(match$1[3]),
	    /* defaultLocalToWorldMatrix */defaultDataTuple[0],
	    /* defaultLocalPosition */defaultDataTuple[1],
	    /* defaultLocalRotation */defaultDataTuple[2],
	    /* defaultLocalScale */defaultDataTuple[3],
	    /* parentMap */createEmpty$2(/* () */0),
	    /* childMap */createEmpty$2(/* () */0),
	    /* gameObjectMap */createEmpty$2(/* () */0),
	    /* dirtyMap */createEmpty$2(/* () */0),
	    /* localToWorldMatrixCacheMap */createEmpty$2(/* () */0),
	    /* normalMatrixCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0)
	  ];
	  return state;
	}

	function _createForNoWorker(param, param$1, state) {
	  state[/* transformRecord */12] = /* record */[
	    /* index */0,
	    /* buffer */param$1[0],
	    /* localToWorldMatrices */param$1[1],
	    /* localPositions */param$1[2],
	    /* localRotations */param$1[3],
	    /* localScales */param$1[4],
	    /* copiedBuffer */undefined,
	    /* copiedLocalToWorldMatrices */undefined,
	    /* copiedLocalPositions */undefined,
	    /* copiedLocalRotations */undefined,
	    /* copiedLocalScales */undefined,
	    /* defaultLocalToWorldMatrix */param[0],
	    /* defaultLocalPosition */param[1],
	    /* defaultLocalRotation */param[2],
	    /* defaultLocalScale */param[3],
	    /* parentMap */createEmpty$2(/* () */0),
	    /* childMap */createEmpty$2(/* () */0),
	    /* gameObjectMap */createEmpty$2(/* () */0),
	    /* dirtyMap */createEmpty$2(/* () */0),
	    /* localToWorldMatrixCacheMap */createEmpty$2(/* () */0),
	    /* normalMatrixCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0)
	  ];
	  return state;
	}

	function create$6(state) {
	  var transformCount = getTransformCount(state[/* settingRecord */1]);
	  var defaultLocalToWorldMatrix = /* array */[
	    1,
	    0,
	    0,
	    0,
	    0,
	    1,
	    0,
	    0,
	    0,
	    0,
	    1,
	    0,
	    0,
	    0,
	    0,
	    1
	  ];
	  var defaultLocalPosition = /* array */[
	    0,
	    0,
	    0
	  ];
	  var defaultLocalRotation = /* array */[
	    0,
	    0,
	    0,
	    1
	  ];
	  var defaultLocalScale = /* array */[
	    1,
	    1,
	    1
	  ];
	  var defaultDataTuple = /* tuple */[
	    defaultLocalToWorldMatrix,
	    defaultLocalPosition,
	    defaultLocalRotation,
	    defaultLocalScale
	  ];
	  var match = _initBufferData(transformCount, defaultDataTuple);
	  var match$1 = match[1];
	  var localScales = match$1[3];
	  var localRotations = match$1[2];
	  var localPositions = match$1[1];
	  var localToWorldMatrices = match$1[0];
	  var buffer = match[0];
	  var match$2 = isUseWorker(state);
	  if (match$2) {
	    return _createForWorker(transformCount, defaultDataTuple, /* tuple */[
	                buffer,
	                localToWorldMatrices,
	                localPositions,
	                localRotations,
	                localScales
	              ], state);
	  } else {
	    return _createForNoWorker(defaultDataTuple, /* tuple */[
	                buffer,
	                localToWorldMatrices,
	                localPositions,
	                localRotations,
	                localScales
	              ], state);
	  }
	}

	function deepCopyForRestore$1(state) {
	  var record = getRecord$1(state);
	  var index = record[/* index */0];
	  var localToWorldMatrices = record[/* localToWorldMatrices */2];
	  var localPositions = record[/* localPositions */3];
	  var localRotations = record[/* localRotations */4];
	  var localScales = record[/* localScales */5];
	  var parentMap = record[/* parentMap */15];
	  var childMap = record[/* childMap */16];
	  var gameObjectMap = record[/* gameObjectMap */17];
	  var dirtyMap = record[/* dirtyMap */18];
	  var disposedIndexArray = record[/* disposedIndexArray */21];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* transformRecord */12] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* localToWorldMatrices */copyFloat32ArrayWithEndIndex(imul(index, getLocalToWorldMatricesSize(/* () */0)), localToWorldMatrices),
	    /* localPositions */copyFloat32ArrayWithEndIndex(imul(index, getLocalPositionsSize(/* () */0)), localPositions),
	    /* localRotations */copyFloat32ArrayWithEndIndex(imul(index, getLocalRotationsSize(/* () */0)), localRotations),
	    /* localScales */copyFloat32ArrayWithEndIndex(imul(index, getLocalScalesSize(/* () */0)), localScales),
	    /* copiedBuffer */record[/* copiedBuffer */6],
	    /* copiedLocalToWorldMatrices */record[/* copiedLocalToWorldMatrices */7],
	    /* copiedLocalPositions */record[/* copiedLocalPositions */8],
	    /* copiedLocalRotations */record[/* copiedLocalRotations */9],
	    /* copiedLocalScales */record[/* copiedLocalScales */10],
	    /* defaultLocalToWorldMatrix */record[/* defaultLocalToWorldMatrix */11],
	    /* defaultLocalPosition */record[/* defaultLocalPosition */12],
	    /* defaultLocalRotation */record[/* defaultLocalRotation */13],
	    /* defaultLocalScale */record[/* defaultLocalScale */14],
	    /* parentMap */copy$3(parentMap),
	    /* childMap */deepCopyArrayArray(childMap),
	    /* gameObjectMap */copy$3(gameObjectMap),
	    /* dirtyMap */copy$3(dirtyMap),
	    /* localToWorldMatrixCacheMap */createEmpty$2(/* () */0),
	    /* normalMatrixCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */disposedIndexArray.slice()
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function _setDefaultChildren(index, childMap) {
	  return set$1(index, createEmpty$1(/* () */0), childMap);
	}

	function _initDataWhenCreate(index, transformRecord) {
	  var childMap = transformRecord[/* childMap */16];
	  var match = has$1(index, childMap);
	  if (match) {
	    return transformRecord;
	  } else {
	    var newrecord = caml_array_dup(transformRecord);
	    newrecord[/* childMap */16] = _setDefaultChildren(index, childMap);
	    return newrecord;
	  }
	}

	function createWithoutMarkNotDirtyWithRecord(settingRecord, transformRecord) {
	  var index = transformRecord[/* index */0];
	  var disposedIndexArray = transformRecord[/* disposedIndexArray */21];
	  var match = generateIndex(index, disposedIndexArray);
	  var index$1 = match[0];
	  transformRecord[/* index */0] = match[1];
	  var transformRecord$1 = _initDataWhenCreate(index$1, transformRecord);
	  transformRecord$1[/* disposedIndexArray */21] = match[2];
	  return checkNotExceedMaxCount(getTransformCount(settingRecord), /* tuple */[
	              transformRecord$1,
	              index$1
	            ]);
	}

	function createWithoutMarkNotDirty(state) {
	  var match = createWithoutMarkNotDirtyWithRecord(state[/* settingRecord */1], getRecord$1(state));
	  state[/* transformRecord */12] = match[0];
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}

	function create$5(state) {
	  var match = createWithoutMarkNotDirty(state);
	  var index = match[1];
	  var state$1 = match[0];
	  state$1[/* transformRecord */12] = mark(index, true, getRecord$1(state$1));
	  return /* tuple */[
	          state$1,
	          index
	        ];
	}


	/* BufferService-Wonderjs Not a pure module */

	var addComponentToGameObjectMap = set$1;


	/* No side effect */

	function handleAddComponent(transform, gameObjectUid, record) {
	  var gameObjectMap = record[/* gameObjectMap */17];
	  var newrecord = caml_array_dup(record);
	  newrecord[/* gameObjectMap */17] = addComponentToGameObjectMap(transform, gameObjectUid, gameObjectMap);
	  return newrecord;
	}


	/* No side effect */

	var getComponent = get$3;

	function unsafeGetComponent(uid, componentMap) {
	  return ensureCheck((function (r) {
	                return test(buildAssertMessage("component exist", "not"), (function () {
	                              return assertNullableExist(r);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(uid, componentMap));
	}

	function hasComponent(uid, componentMap) {
	  return unsafeGet$2(uid, componentMap) !== undefined;
	}

	function addComponent(uid, component, componentMap) {
	  requireCheck((function () {
	          return test(buildAssertMessage("this type of the component shouldn\'t be added before", "not"), (function () {
	                        return assertFalse(hasComponent(uid, componentMap));
	                      }));
	        }), getIsDebug(stateData));
	  set$1(uid, component, componentMap);
	  return /* () */0;
	}

	var removeComponent = deleteVal$1;

	var hasComponent$1 = hasComponent;

	function batchGetComponent(uidArray, componentMap) {
	  return reduceOneParam((function (arr, uid) {
	                var match = get$3(uid, componentMap);
	                if (match !== undefined) {
	                  return push(match, arr);
	                } else {
	                  return arr;
	                }
	              }), /* array */[], uidArray);
	}

	function batchDisposeComponent(componentRecord, handleFunc, componentArray) {
	  return handleFunc(componentArray, componentRecord);
	}


	/* Log-WonderLog Not a pure module */

	function handleAddComponent$1(light, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */record[/* intensities */3],
	          /* constants */record[/* constants */4],
	          /* linears */record[/* linears */5],
	          /* quadratics */record[/* quadratics */6],
	          /* ranges */record[/* ranges */7],
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */addComponentToGameObjectMap(light, gameObjectUid, record[/* gameObjectMap */9])
	        ];
	}


	/* No side effect */

	function handleAddComponent$2(geometry, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* vertices */record[/* vertices */1],
	          /* texCoords */record[/* texCoords */2],
	          /* normals */record[/* normals */3],
	          /* indices */record[/* indices */4],
	          /* gameObjectMap */addComponentToGameObjectMap(geometry, gameObjectUid, record[/* gameObjectMap */5]),
	          /* groupCountMap */record[/* groupCountMap */6],
	          /* disposedIndexArray */record[/* disposedIndexArray */7]
	        ];
	}


	/* No side effect */

	function handleAddComponent$3(material, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* shaderIndices */record[/* shaderIndices */2],
	          /* colors */record[/* colors */3],
	          /* textureIndices */record[/* textureIndices */4],
	          /* mapUnits */record[/* mapUnits */5],
	          /* textureCountMap */record[/* textureCountMap */6],
	          /* defaultColor */record[/* defaultColor */7],
	          /* gameObjectMap */addComponentToGameObjectMap(material, gameObjectUid, record[/* gameObjectMap */8]),
	          /* groupCountMap */record[/* groupCountMap */9],
	          /* disposedIndexArray */record[/* disposedIndexArray */10],
	          /* nameMap */record[/* nameMap */11],
	          /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */12]
	        ];
	}


	/* No side effect */

	function handleAddComponent$4(material, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* shaderIndices */record[/* shaderIndices */2],
	          /* diffuseColors */record[/* diffuseColors */3],
	          /* specularColors */record[/* specularColors */4],
	          /* shininess */record[/* shininess */5],
	          /* textureIndices */record[/* textureIndices */6],
	          /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	          /* specularMapUnits */record[/* specularMapUnits */8],
	          /* textureCountMap */record[/* textureCountMap */9],
	          /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	          /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	          /* defaultShininess */record[/* defaultShininess */12],
	          /* gameObjectMap */addComponentToGameObjectMap(material, gameObjectUid, record[/* gameObjectMap */13]),
	          /* groupCountMap */record[/* groupCountMap */14],
	          /* disposedIndexArray */record[/* disposedIndexArray */15],
	          /* nameMap */record[/* nameMap */16],
	          /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */17]
	        ];
	}


	/* No side effect */

	function getGroupCount$1(component, groupCountMap) {
	  var match = get$3(component, groupCountMap);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return 0;
	  }
	}

	function isGroupComponent(component, groupCountMap) {
	  return getGroupCount$1(component, groupCountMap) > 0;
	}

	function increaseGroupCount$1(component, groupCountMap) {
	  return set$1(component, getGroupCount$1(component, groupCountMap) + 1 | 0, groupCountMap);
	}

	function decreaseGroupCount$1(component, groupCountMap) {
	  return set$1(component, getGroupCount$1(component, groupCountMap) - 1 | 0, groupCountMap);
	}


	/* No side effect */

	function isGroupGeometry(geometry, record) {
	  return isGroupComponent(geometry, record[/* groupCountMap */6]);
	}

	function increaseGroupCount(geometry, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* vertices */record[/* vertices */1],
	          /* texCoords */record[/* texCoords */2],
	          /* normals */record[/* normals */3],
	          /* indices */record[/* indices */4],
	          /* gameObjectMap */record[/* gameObjectMap */5],
	          /* groupCountMap */increaseGroupCount$1(geometry, record[/* groupCountMap */6]),
	          /* disposedIndexArray */record[/* disposedIndexArray */7]
	        ];
	}

	function decreaseGroupCount(geometry, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* vertices */record[/* vertices */1],
	          /* texCoords */record[/* texCoords */2],
	          /* normals */record[/* normals */3],
	          /* indices */record[/* indices */4],
	          /* gameObjectMap */record[/* gameObjectMap */5],
	          /* groupCountMap */decreaseGroupCount$1(geometry, record[/* groupCountMap */6]),
	          /* disposedIndexArray */record[/* disposedIndexArray */7]
	        ];
	}


	/* No side effect */

	function handleAddComponent$5(geometry, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* vertices */record[/* vertices */2],
	          /* texCoords */record[/* texCoords */3],
	          /* normals */record[/* normals */4],
	          /* indices */record[/* indices */5],
	          /* verticesInfos */record[/* verticesInfos */6],
	          /* texCoordsInfos */record[/* texCoordsInfos */7],
	          /* normalsInfos */record[/* normalsInfos */8],
	          /* indicesInfos */record[/* indicesInfos */9],
	          /* verticesOffset */record[/* verticesOffset */10],
	          /* texCoordsOffset */record[/* texCoordsOffset */11],
	          /* normalsOffset */record[/* normalsOffset */12],
	          /* indicesOffset */record[/* indicesOffset */13],
	          /* disposeCount */record[/* disposeCount */14],
	          /* gameObjectMap */addComponentToGameObjectMap(geometry, gameObjectUid, record[/* gameObjectMap */15]),
	          /* groupCountMap */record[/* groupCountMap */16],
	          /* disposedIndexArray */record[/* disposedIndexArray */17],
	          /* disposedIndexMap */record[/* disposedIndexMap */18],
	          /* aliveIndexArray */record[/* aliveIndexArray */19]
	        ];
	}


	/* No side effect */

	var getMappedIndex = unsafeGet$2;

	var setMappedIndex = set$1;

	function markDisposed(index, mappedIndexMap) {
	  return set$1(index, -1, mappedIndexMap);
	}

	function isComponentAlive(component, mappedIndexMap) {
	  return unsafeGet$2(component, mappedIndexMap) !== -1;
	}


	/* No side effect */

	function getMappedIndexMap(param) {
	  return param[/* mappedIndexMap */4];
	}


	/* No side effect */

	function handleAddComponent$6(light, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */record[/* intensities */3],
	          /* mappedIndexMap */record[/* mappedIndexMap */4],
	          /* gameObjectMap */addComponentToGameObjectMap(getMappedIndex(light, getMappedIndexMap(record)), gameObjectUid, record[/* gameObjectMap */5])
	        ];
	}


	/* No side effect */

	function handleAddComponent$7(_, _$1, record) {
	  return record;
	}


	/* No side effect */

	function handleAddComponent$8(sourceInstance, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* objectInstanceTransformIndexMap */record[/* objectInstanceTransformIndexMap */1],
	          /* buffer */record[/* buffer */2],
	          /* isTransformStatics */record[/* isTransformStatics */3],
	          /* objectInstanceTransformCollections */record[/* objectInstanceTransformCollections */4],
	          /* matrixInstanceBufferCapacityMap */record[/* matrixInstanceBufferCapacityMap */5],
	          /* matrixFloat32ArrayMap */record[/* matrixFloat32ArrayMap */6],
	          /* isSendTransformMatrixDataMap */record[/* isSendTransformMatrixDataMap */7],
	          /* disposedIndexArray */record[/* disposedIndexArray */8],
	          /* gameObjectMap */addComponentToGameObjectMap(sourceInstance, gameObjectUid, record[/* gameObjectMap */9])
	        ];
	}


	/* No side effect */

	function handleAddComponent$9(cameraView, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* gameObjectMap */addComponentToGameObjectMap(cameraView, gameObjectUid, record[/* gameObjectMap */1]),
	          /* disposedIndexArray */record[/* disposedIndexArray */2]
	        ];
	}


	/* No side effect */

	function isGroupMaterial(material, record) {
	  return isGroupComponent(material, record[/* groupCountMap */9]);
	}

	function increaseGroupCount$2(material, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* shaderIndices */record[/* shaderIndices */2],
	          /* colors */record[/* colors */3],
	          /* textureIndices */record[/* textureIndices */4],
	          /* mapUnits */record[/* mapUnits */5],
	          /* textureCountMap */record[/* textureCountMap */6],
	          /* defaultColor */record[/* defaultColor */7],
	          /* gameObjectMap */record[/* gameObjectMap */8],
	          /* groupCountMap */increaseGroupCount$1(material, record[/* groupCountMap */9]),
	          /* disposedIndexArray */record[/* disposedIndexArray */10],
	          /* nameMap */record[/* nameMap */11],
	          /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */12]
	        ];
	}

	function decreaseGroupCount$2(material, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* shaderIndices */record[/* shaderIndices */2],
	          /* colors */record[/* colors */3],
	          /* textureIndices */record[/* textureIndices */4],
	          /* mapUnits */record[/* mapUnits */5],
	          /* textureCountMap */record[/* textureCountMap */6],
	          /* defaultColor */record[/* defaultColor */7],
	          /* gameObjectMap */record[/* gameObjectMap */8],
	          /* groupCountMap */decreaseGroupCount$1(material, record[/* groupCountMap */9]),
	          /* disposedIndexArray */record[/* disposedIndexArray */10],
	          /* nameMap */record[/* nameMap */11],
	          /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */12]
	        ];
	}


	/* No side effect */

	function isGroupMaterial$1(material, record) {
	  return isGroupComponent(material, record[/* groupCountMap */14]);
	}

	function increaseGroupCount$3(material, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* shaderIndices */record[/* shaderIndices */2],
	          /* diffuseColors */record[/* diffuseColors */3],
	          /* specularColors */record[/* specularColors */4],
	          /* shininess */record[/* shininess */5],
	          /* textureIndices */record[/* textureIndices */6],
	          /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	          /* specularMapUnits */record[/* specularMapUnits */8],
	          /* textureCountMap */record[/* textureCountMap */9],
	          /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	          /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	          /* defaultShininess */record[/* defaultShininess */12],
	          /* gameObjectMap */record[/* gameObjectMap */13],
	          /* groupCountMap */increaseGroupCount$1(material, record[/* groupCountMap */14]),
	          /* disposedIndexArray */record[/* disposedIndexArray */15],
	          /* nameMap */record[/* nameMap */16],
	          /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */17]
	        ];
	}

	function decreaseGroupCount$3(material, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* shaderIndices */record[/* shaderIndices */2],
	          /* diffuseColors */record[/* diffuseColors */3],
	          /* specularColors */record[/* specularColors */4],
	          /* shininess */record[/* shininess */5],
	          /* textureIndices */record[/* textureIndices */6],
	          /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	          /* specularMapUnits */record[/* specularMapUnits */8],
	          /* textureCountMap */record[/* textureCountMap */9],
	          /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	          /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	          /* defaultShininess */record[/* defaultShininess */12],
	          /* gameObjectMap */record[/* gameObjectMap */13],
	          /* groupCountMap */decreaseGroupCount$1(material, record[/* groupCountMap */14]),
	          /* disposedIndexArray */record[/* disposedIndexArray */15],
	          /* nameMap */record[/* nameMap */16],
	          /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */17]
	        ];
	}


	/* No side effect */

	function getBoxGeometryType() {
	  return 0;
	}

	function getCustomGeometryType() {
	  return 1;
	}

	var getComponentData = get$3;

	function unsafeGetComponentData(uid, currentComponentDataMap) {
	  return ensureCheck((function (r) {
	                return test(buildAssertMessage("has component", "not"), (function () {
	                              return assertNullableExist(r);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(uid, currentComponentDataMap));
	}


	/* Log-WonderLog Not a pure module */

	function _transformMat4ToTuple(param, mat4) {
	  var z = param[2];
	  var y = param[1];
	  var x = param[0];
	  var w = mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15];
	  var d = w;
	  w = d !== 0 ? d : 1.0;
	  return /* tuple */[
	          (mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12]) / w,
	          (mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13]) / w,
	          (mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14]) / w
	        ];
	}

	var transformMat4Tuple = _transformMat4ToTuple;

	function add$1(_, param, param$1) {
	  return /* tuple */[
	          param[0] + param$1[0],
	          param[1] + param$1[1],
	          param[2] + param$1[2]
	        ];
	}

	function sub$1(_, param, param$1) {
	  return /* tuple */[
	          param[0] - param$1[0],
	          param[1] - param$1[1],
	          param[2] - param$1[2]
	        ];
	}

	function scale(_, scalar, param) {
	  return /* tuple */[
	          param[0] * scalar,
	          param[1] * scalar,
	          param[2] * scalar
	        ];
	}

	function lerp(param, param$1, t) {
	  var z1 = param[2];
	  var y1 = param[1];
	  var x1 = param[0];
	  return /* tuple */[
	          x1 + t * (param$1[0] - x1),
	          y1 + t * (param$1[1] - y1),
	          z1 + t * (param$1[2] - z1)
	        ];
	}

	function cross(param, param$1) {
	  var z2 = param$1[2];
	  var y2 = param$1[1];
	  var x2 = param$1[0];
	  var z1 = param[2];
	  var y1 = param[1];
	  var x1 = param[0];
	  return /* tuple */[
	          y1 * z2 - y2 * z1,
	          z1 * x2 - z2 * x1,
	          x1 * y2 - x2 * y1
	        ];
	}

	function normalize(param) {
	  var z = param[2];
	  var y = param[1];
	  var x = param[0];
	  var d = Math.sqrt(x * x + y * y + z * z);
	  var match = d === 0;
	  if (match) {
	    return /* tuple */[
	            0,
	            0,
	            0
	          ];
	  } else {
	    return /* tuple */[
	            x / d,
	            y / d,
	            z / d
	          ];
	  }
	}

	var transformQuat = function (a,q){
	     // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
	    let qx = q[0], qy = q[1], qz = q[2], qw = q[3];
	    let x = a[0], y = a[1], z = a[2];
	    // var qvec = [qx, qy, qz];
	    // var uv = vec3.cross([], qvec, a);
	    let uvx = qy * z - qz * y,
	        uvy = qz * x - qx * z,
	        uvz = qx * y - qy * x;
	    // var uuv = vec3.cross([], qvec, uv);
	    let uuvx = qy * uvz - qz * uvy,
	        uuvy = qz * uvx - qx * uvz,
	        uuvz = qx * uvy - qy * uvx;
	    // vec3.scale(uv, uv, 2 * w);
	    let w2 = qw * 2;
	    uvx *= w2;
	    uvy *= w2;
	    uvz *= w2;
	    // vec3.scale(uuv, uuv, 2);
	    uuvx *= 2;
	    uuvy *= 2;
	    uuvz *= 2;
	    // return vec3.add(out, a, vec3.add(out, uv, uuv));

	    return [

	x + uvx + uuvx,
	y + uvy + uuvy,
	z + uvz + uuvz

	    ]

	  };


	/* No side effect */

	function _buildFaceData(width, height, depth) {
	  return /* tuple */[
	          /* array */[
	            /* array */[
	              0,
	              1,
	              3
	            ],
	            /* array */[
	              4,
	              5,
	              7
	            ],
	            /* array */[
	              3,
	              2,
	              6
	            ],
	            /* array */[
	              1,
	              0,
	              4
	            ],
	            /* array */[
	              1,
	              4,
	              2
	            ],
	            /* array */[
	              5,
	              0,
	              6
	            ]
	          ],
	          /* array */[
	            /* array */[
	              0,
	              0,
	              1
	            ],
	            /* array */[
	              0,
	              0,
	              -1
	            ],
	            /* array */[
	              0,
	              1,
	              0
	            ],
	            /* array */[
	              0,
	              -1,
	              0
	            ],
	            /* array */[
	              1,
	              0,
	              0
	            ],
	            /* array */[
	              -1,
	              0,
	              0
	            ]
	          ],
	          /* array */[
	            /* tuple */[
	              -width,
	              -height,
	              depth
	            ],
	            /* tuple */[
	              width,
	              -height,
	              depth
	            ],
	            /* tuple */[
	              width,
	              height,
	              depth
	            ],
	            /* tuple */[
	              -width,
	              height,
	              depth
	            ],
	            /* tuple */[
	              width,
	              -height,
	              -depth
	            ],
	            /* tuple */[
	              -width,
	              -height,
	              -depth
	            ],
	            /* tuple */[
	              -width,
	              height,
	              -depth
	            ],
	            /* tuple */[
	              width,
	              height,
	              -depth
	            ]
	          ]
	        ];
	}

	function _getLerpData(param, param$1, param$2) {
	  var side = param$1[0];
	  var corners = param[1];
	  var faceAxes = param[0];
	  return lerp(caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), param$2[0])), caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), param$2[1])), param$2[2] / param$1[1]);
	}

	function _generateVertex(param, param$1, param$2, vertices) {
	  var corners = param$1[1];
	  var faceAxes = param$1[0];
	  var side = param[0];
	  var match = add$1(/* Float */0, _getLerpData(/* tuple */[
	            faceAxes,
	            corners
	          ], /* tuple */[
	            side,
	            param[1]
	          ], /* tuple */[
	            0,
	            1,
	            param$2[0]
	          ]), sub$1(/* Float */0, _getLerpData(/* tuple */[
	                faceAxes,
	                corners
	              ], /* tuple */[
	                side,
	                param[2]
	              ], /* tuple */[
	                0,
	                2,
	                param$2[1]
	              ]), caml_array_get(corners, caml_array_get(caml_array_get(faceAxes, side), 0))));
	  vertices.push(match[0], match[1], match[2]);
	  return /* () */0;
	}

	function _generateTexCoord(u, v, texCoords) {
	  texCoords.push(u, v);
	  return /* () */0;
	}

	function _generateNormal(side, faceNormals, normals) {
	  normals.push(caml_array_get(caml_array_get(faceNormals, side), 0), caml_array_get(caml_array_get(faceNormals, side), 1), caml_array_get(caml_array_get(faceNormals, side), 2));
	  return /* () */0;
	}

	function _generateIndex(param, param$1, indices) {
	  var vSegmentIndex = param$1[1];
	  var uSegmentIndex = param$1[0];
	  var offset = param[2];
	  var uSegment = param[0];
	  if (uSegmentIndex < uSegment && vSegmentIndex < param[1]) {
	    indices.push((offset + vSegmentIndex | 0) + imul(uSegmentIndex, uSegment + 1 | 0) | 0, (offset + vSegmentIndex | 0) + imul(uSegmentIndex + 1 | 0, uSegment + 1 | 0) | 0, ((offset + vSegmentIndex | 0) + imul(uSegmentIndex, uSegment + 1 | 0) | 0) + 1 | 0, (offset + vSegmentIndex | 0) + imul(uSegmentIndex + 1 | 0, uSegment + 1 | 0) | 0, ((offset + vSegmentIndex | 0) + imul(uSegmentIndex + 1 | 0, uSegment + 1 | 0) | 0) + 1 | 0, ((offset + vSegmentIndex | 0) + imul(uSegmentIndex, uSegment + 1 | 0) | 0) + 1 | 0);
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function _generateFace(directionDataTuple, param, param$1) {
	  var vSegment = directionDataTuple[2];
	  var uSegment = directionDataTuple[1];
	  var side = directionDataTuple[0];
	  var indices = param$1[3];
	  var normals = param$1[2];
	  var texCoords = param$1[1];
	  var vertices = param$1[0];
	  var corners = param[2];
	  var faceNormals = param[1];
	  var faceAxes = param[0];
	  var offset = vertices.length / 3 | 0;
	  for(var i = 0; i <= uSegment; ++i){
	    for(var j = 0; j <= vSegment; ++j){
	      var segmentIndexTuple = /* tuple */[
	        i,
	        j
	      ];
	      _generateVertex(directionDataTuple, /* tuple */[
	            faceAxes,
	            corners
	          ], segmentIndexTuple, vertices);
	      _generateTexCoord(i / uSegment, j / vSegment, texCoords);
	      _generateNormal(side, faceNormals, normals);
	      _generateIndex(/* tuple */[
	            uSegment,
	            vSegment,
	            offset
	          ], segmentIndexTuple, indices);
	    }
	  }
	  return /* tuple */[
	          vertices,
	          texCoords,
	          normals,
	          indices
	        ];
	}

	function _buildAllFaceDirectionDataTupleArr(widthSegment, heightSegment, depthSegment) {
	  return /* array */[
	          /* tuple */[
	            0,
	            widthSegment,
	            heightSegment
	          ],
	          /* tuple */[
	            1,
	            widthSegment,
	            heightSegment
	          ],
	          /* tuple */[
	            2,
	            widthSegment,
	            depthSegment
	          ],
	          /* tuple */[
	            3,
	            widthSegment,
	            depthSegment
	          ],
	          /* tuple */[
	            4,
	            depthSegment,
	            heightSegment
	          ],
	          /* tuple */[
	            5,
	            depthSegment,
	            heightSegment
	          ]
	        ];
	}

	function generateAllFaces() {
	  var faceDataTuple = _buildFaceData(5, 5, 5);
	  return reduceOneParam((function (pointsTuple, directionDataTuple) {
	                return _generateFace(directionDataTuple, faceDataTuple, pointsTuple);
	              }), /* tuple */[
	              createEmpty$1(/* () */0),
	              createEmpty$1(/* () */0),
	              createEmpty$1(/* () */0),
	              createEmpty$1(/* () */0)
	            ], _buildAllFaceDirectionDataTupleArr(1, 1, 1));
	}

	function getIndicesCount$1() {
	  return 36;
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function getIndices(_, param) {
	  return param[/* boxGeometryRecord */5][/* indices */3];
	}

	function getIndicesCount(_, _$1) {
	  return getIndicesCount$1(/* () */0);
	}


	/* ComputePointsBoxGeometryService-Wonderjs Not a pure module */

	function getNormals(_, param) {
	  return param[/* boxGeometryRecord */5][/* normals */2];
	}


	/* No side effect */

	function getVertices(_, param) {
	  return param[/* boxGeometryRecord */5][/* vertices */0];
	}


	/* No side effect */

	function getTexCoords(_, param) {
	  return param[/* boxGeometryRecord */5][/* texCoords */1];
	}


	/* No side effect */

	function getVertexSize() {
	  return 3;
	}

	function getTexCoordsSize() {
	  return 2;
	}

	function getVertexLength(customGeometryPointCount) {
	  return imul(customGeometryPointCount, 3);
	}

	function getTexCoordsLength(customGeometryPointCount) {
	  return (customGeometryPointCount << 1);
	}

	function getVerticesOffset() {
	  return 0;
	}

	function getTexCoordsOffset(customGeometryPointCount) {
	  return 0 + imul(imul(customGeometryPointCount, 3), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getNormalsOffset(customGeometryPointCount) {
	  return getTexCoordsOffset(customGeometryPointCount) + imul((customGeometryPointCount << 1), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getIndexSize() {
	  return 1;
	}

	function getIndicesLength(customGeometryPointCount) {
	  return (customGeometryPointCount << 0);
	}

	function getIndicesOffset(customGeometryPointCount) {
	  return getNormalsOffset(customGeometryPointCount) + imul(imul(customGeometryPointCount, 3), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getVerticesInfosLength(customGeometryCount) {
	  return (customGeometryCount << 1);
	}

	function getVerticesInfosOffset(customGeometryPointCount) {
	  return getIndicesOffset(customGeometryPointCount) + imul((customGeometryPointCount << 0), Uint16Array.BYTES_PER_ELEMENT) | 0;
	}

	function getTexCoordsInfosLength(customGeometryCount) {
	  return (customGeometryCount << 1);
	}

	function getTexCoordsInfosOffset(customGeometryPointCount, customGeometryCount) {
	  return getVerticesInfosOffset(customGeometryPointCount) + imul((customGeometryCount << 1), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getNormalsInfosLength(customGeometryCount) {
	  return (customGeometryCount << 1);
	}

	function getNormalsInfosOffset(customGeometryPointCount, customGeometryCount) {
	  return getTexCoordsInfosOffset(customGeometryPointCount, customGeometryCount) + imul((customGeometryCount << 1), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getIndicesInfosLength(customGeometryCount) {
	  return (customGeometryCount << 1);
	}

	function getIndicesInfosOffset(customGeometryPointCount, customGeometryCount) {
	  return getNormalsInfosOffset(customGeometryPointCount, customGeometryCount) + imul((customGeometryCount << 1), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getInfoIndex(index) {
	  return (index << 1);
	}

	function getTotalByteLength$1(customGeometryPointCount, customGeometryCount) {
	  return imul(customGeometryPointCount, ((imul(Float32Array.BYTES_PER_ELEMENT, 3) << 1) + (Float32Array.BYTES_PER_ELEMENT << 1) | 0) + (Uint16Array.BYTES_PER_ELEMENT << 0) | 0) + (imul(customGeometryCount, Uint32Array.BYTES_PER_ELEMENT) << 3) | 0;
	}

	function createBuffer$1(customGeometryPointCount, customGeometryCount) {
	  return newSharedArrayBuffer(getTotalByteLength$1(customGeometryPointCount, customGeometryCount));
	}


	/* Worker-Wonderjs Not a pure module */

	function getInfo(infoIndex, infos) {
	  return ensureCheck((function (param) {
	                var endIndex = param[1];
	                var startIndex = param[0];
	                return test(buildAssertMessage("endIndex >= startIndex", "is " + (String(endIndex) + "")), (function () {
	                              return Operators[/* >= */7](endIndex, startIndex);
	                            }));
	              }), getIsDebug(stateData), /* tuple */[
	              getUint32_1(infoIndex, infos),
	              getUint32_1(infoIndex + 1 | 0, infos)
	            ]);
	}

	function setInfo(infoIndex, startIndex, endIndex, infos) {
	  requireCheck((function () {
	          test(buildAssertMessage("startIndex >= 0", "is " + (String(startIndex) + "")), (function () {
	                  return Operators[/* >= */7](startIndex, 0);
	                }));
	          return test(buildAssertMessage("endIndex >= startIndex", "is " + (String(endIndex) + "")), (function () {
	                        return Operators[/* >= */7](endIndex, startIndex);
	                      }));
	        }), getIsDebug(stateData));
	  return setUint32_1(infoIndex + 1 | 0, endIndex, setUint32_1(infoIndex, startIndex, infos));
	}

	function hasPointData(infoIndex, infos) {
	  var match = getInfo(infoIndex, infos);
	  return match[1] > match[0];
	}

	function getFloat32PointData(infoIndex, points, infos) {
	  var match = getInfo(infoIndex, infos);
	  return getFloat32ArraySubarray(points, match[0], match[1]);
	}

	function _setPointData(param, fillTypeArrayFunc) {
	  var offset = param[2];
	  var newOffset = offset + param[3] | 0;
	  setInfo(param[0], offset, newOffset, param[1]);
	  _1(fillTypeArrayFunc, offset);
	  return newOffset;
	}

	var setFloat32PointData = _setPointData;

	function getUint16PointData(infoIndex, points, infos) {
	  var match = getInfo(infoIndex, infos);
	  return getUint16ArraySubarray(points, match[0], match[1]);
	}

	var setUint16PointData = _setPointData;


	/* Log-WonderLog Not a pure module */

	function getIndices$1(index, param) {
	  var customGeometryRecord = param[/* customGeometryRecord */6];
	  return getUint16PointData(getInfoIndex(index), customGeometryRecord[/* indices */3], customGeometryRecord[/* indicesInfos */7]);
	}

	function getIndicesCount$2(index, param) {
	  var match = getInfo(getInfoIndex(index), param[/* customGeometryRecord */6][/* indicesInfos */7]);
	  return match[1] - match[0] | 0;
	}


	/* BufferCustomGeometryService-Wonderjs Not a pure module */

	function hasNormals$1(index, normalsInfos) {
	  return hasPointData(getInfoIndex(index), normalsInfos);
	}


	/* BufferCustomGeometryService-Wonderjs Not a pure module */

	function hasNormals(geometry, customGeometry) {
	  return hasNormals$1(geometry, customGeometry[/* normalsInfos */6]);
	}


	/* HasNormalsService-Wonderjs Not a pure module */

	function _getPosition(vertices, vIndex) {
	  return /* tuple */[
	          vertices[vIndex],
	          vertices[vIndex + 1 | 0],
	          vertices[vIndex + 2 | 0]
	        ];
	}

	function _setNormal(param, vIndex, normals) {
	  normals[vIndex] = normals[vIndex] + param[0];
	  normals[vIndex + 1 | 0] = normals[vIndex + 1 | 0] + param[1];
	  normals[vIndex + 2 | 0] = normals[vIndex + 2 | 0] + param[2];
	  return normals;
	}

	function _normalizeNormals(normals) {
	  var len = normals.length;
	  var _index = 0;
	  var normals$1 = normals;
	  while(true) {
	    var index = _index;
	    var match = index >= len;
	    if (match) {
	      return normals$1;
	    } else {
	      var x = normals$1[index];
	      var y = normals$1[index + 1 | 0];
	      var z = normals$1[index + 2 | 0];
	      var d = Math.sqrt(x * x + y * y + z * z);
	      var match$1 = d === 0;
	      if (match$1) {
	        normals$1[index] = 0;
	        normals$1[index + 1 | 0] = 0;
	        normals$1[index + 2 | 0] = 0;
	      } else {
	        normals$1[index] = x / d;
	        normals$1[index + 1 | 0] = y / d;
	        normals$1[index + 2 | 0] = z / d;
	      }
	      _index = index + 3 | 0;
	      continue ;
	    }
	  }
	}

	function computeVertexNormals$1(vertices, indices) {
	  var indicesLen = indices.length;
	  var _compute = function (_index, _normals) {
	    while(true) {
	      var normals = _normals;
	      var index = _index;
	      var match = index >= indicesLen;
	      if (match) {
	        return normals;
	      } else {
	        var va = imul(indices[index], 3);
	        var vb = imul(indices[index + 1 | 0], 3);
	        var vc = imul(indices[index + 2 | 0], 3);
	        var pa = _getPosition(vertices, va);
	        var pb = _getPosition(vertices, vb);
	        var pc = _getPosition(vertices, vc);
	        var v0 = sub$1(/* Float */0, pc, pb);
	        var v1 = sub$1(/* Float */0, pa, pb);
	        var faceNormalTuple = cross(v0, v1);
	        _normals = _setNormal(faceNormalTuple, vc, _setNormal(faceNormalTuple, vb, _setNormal(faceNormalTuple, va, normals)));
	        _index = index + 3 | 0;
	        continue ;
	      }
	    }
	  };
	  return _normalizeNormals(_compute(0, new Float32Array(vertices.length)));
	}


	/* No side effect */

	function getVertices$1(index, param) {
	  var customGeometryRecord = param[/* customGeometryRecord */6];
	  return getFloat32PointData(getInfoIndex(index), customGeometryRecord[/* vertices */0], customGeometryRecord[/* verticesInfos */4]);
	}


	/* BufferCustomGeometryService-Wonderjs Not a pure module */

	function computeVertexNormals(index, state) {
	  return computeVertexNormals$1(getVertices$1(index, state), getIndices$1(index, state));
	}


	/* GetCustomGeometryIndicesRenderService-Wonderjs Not a pure module */

	function _getNormals(index, param) {
	  var customGeometryRecord = param[/* customGeometryRecord */6];
	  return getFloat32PointData(getInfoIndex(index), customGeometryRecord[/* normals */2], customGeometryRecord[/* normalsInfos */6]);
	}

	function getNormals$1(index, state) {
	  var match = hasNormals(index, state[/* customGeometryRecord */6]);
	  if (match) {
	    return _getNormals(index, state);
	  } else {
	    return computeVertexNormals(index, state);
	  }
	}


	/* BufferCustomGeometryService-Wonderjs Not a pure module */

	function getTexCoords$1(index, param) {
	  var customGeometryRecord = param[/* customGeometryRecord */6];
	  return getFloat32PointData(getInfoIndex(index), customGeometryRecord[/* texCoords */1], customGeometryRecord[/* texCoordsInfos */5]);
	}


	/* BufferCustomGeometryService-Wonderjs Not a pure module */

	var addToMap = set$1;

	function hasComponent$1$1(uid, currentComponentDataMap, targetType_) {
	  var match = getComponentData(uid, currentComponentDataMap);
	  if (match !== undefined) {
	    return match[1] === targetType_;
	  } else {
	    return false;
	  }
	}

	function getCurrentGeometryBufferMapAndGetPointsFuncs(type_, vboBufferRecord) {
	  if (type_ === getBoxGeometryType(/* () */0)) {
	    return /* tuple */[
	            /* tuple */[
	              vboBufferRecord[/* boxGeometryVertexBufferMap */0],
	              vboBufferRecord[/* boxGeometryTexCoordBufferMap */1],
	              vboBufferRecord[/* boxGeometryNormalBufferMap */2],
	              vboBufferRecord[/* boxGeometryElementArrayBufferMap */3]
	            ],
	            /* tuple */[
	              getVertices,
	              getTexCoords,
	              getNormals,
	              getIndices
	            ]
	          ];
	  } else if (type_ === getCustomGeometryType(/* () */0)) {
	    return /* tuple */[
	            /* tuple */[
	              vboBufferRecord[/* customGeometryVertexBufferMap */4],
	              vboBufferRecord[/* customGeometryTexCoordBufferMap */5],
	              vboBufferRecord[/* customGeometryNormalBufferMap */6],
	              vboBufferRecord[/* customGeometryElementArrayBufferMap */7]
	            ],
	            /* tuple */[
	              getVertices$1,
	              getTexCoords$1,
	              getNormals$1,
	              getIndices$1
	            ]
	          ];
	  } else {
	    return fatal(buildFatalMessage("getCurrentGeometryBufferMapAndGetPointsFuncs", "unknown type_: " + (String(type_) + ""), "", "", ""));
	  }
	}

	function getGetIndicesCountFunc(type_) {
	  if (type_ === getBoxGeometryType(/* () */0)) {
	    return getIndicesCount;
	  } else {
	    return getIndicesCount$2;
	  }
	}


	/* Log-WonderLog Not a pure module */

	function hasBasicCameraViewComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* basicCameraViewMap */23]);
	}

	function hasPerspectiveCameraProjectionComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* perspectiveCameraProjectionMap */24]);
	}

	function hasArcballCameraControllerComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* arcballCameraControllerMap */25]);
	}

	function hasMeshRendererComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* meshRendererMap */26]);
	}

	function hasTransformComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* transformMap */22]);
	}

	function hasBoxGeometryComponent(uid, gameObjectRecord) {
	  return hasComponent$1$1(uid, gameObjectRecord[/* geometryDataMap */21], getBoxGeometryType(/* () */0));
	}

	function hasGeometryComponent(uid, gameObjectRecord) {
	  return hasComponent$1$1(uid, gameObjectRecord[/* geometryDataMap */21], getCustomGeometryType(/* () */0));
	}

	function hasBasicMaterialComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* basicMaterialMap */27]);
	}

	function hasLightMaterialComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* lightMaterialMap */28]);
	}

	function hasDirectionLightComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* directionLightMap */31]);
	}

	function hasPointLightComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* pointLightMap */32]);
	}

	function hasSourceInstanceComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* sourceInstanceMap */29]);
	}

	function hasObjectInstanceComponent(uid, gameObjectRecord) {
	  return hasComponent$1(uid, gameObjectRecord[/* objectInstanceMap */30]);
	}


	/* ComponentMapService-Wonderjs Not a pure module */

	function getDefaultDrawMode() {
	  return /* Triangles */4;
	}

	function getDrawModesSize() {
	  return 1;
	}

	function getDrawModesLength(meshRendererCount) {
	  return (meshRendererCount << 0);
	}

	function getDrawModesOffset() {
	  return 0;
	}

	function getDrawModeIndex(index) {
	  return (index << 0);
	}

	function getTotalByteLength$2(meshRendererCount) {
	  return (imul(meshRendererCount, Uint8Array.BYTES_PER_ELEMENT) << 0);
	}

	function createBuffer$2(meshRendererCount) {
	  return newSharedArrayBuffer(getTotalByteLength$2(meshRendererCount));
	}


	/* Worker-Wonderjs Not a pure module */

	function getDefaultShaderIndex() {
	  return 429496729;
	}

	function getDefaultSourceInstance() {
	  return 429496729;
	}


	/* No side effect */

	function createTypeArrays$1(buffer, meshRendererCount) {
	  return new Uint8Array(buffer, getDrawModesOffset(meshRendererCount), getDrawModesLength(meshRendererCount));
	}


	/* BufferMeshRendererService-Wonderjs Not a pure module */

	function getDrawMode(index, typeArr) {
	  return getUint8_1(getDrawModeIndex(index), typeArr);
	}

	function setDrawMode(index, data, typeArr) {
	  return setUint8_1(getDrawModeIndex(index), data, typeArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getRecord$2(param) {
	  return unsafeGet$1(param[/* meshRendererRecord */25]);
	}

	function setAllTypeArrDataToDefault$1(meshRendererCount, defaultDrawMode, drawModes) {
	  return reduceOneParam((function (drawModes, index) {
	                return setDrawMode(index, defaultDrawMode, drawModes);
	              }), drawModes, range(0, meshRendererCount - 1 | 0));
	}

	function _setAllTypeArrDataToDefault$1(meshRendererCount, defaultDrawMode, param) {
	  return /* tuple */[
	          param[0],
	          setAllTypeArrDataToDefault$1(meshRendererCount, defaultDrawMode, param[1])
	        ];
	}

	function _initBufferData$1(meshRendererCount, defaultDrawMode) {
	  var buffer = createBuffer$2(meshRendererCount);
	  var drawModes = createTypeArrays$1(buffer, meshRendererCount);
	  return _setAllTypeArrDataToDefault$1(meshRendererCount, defaultDrawMode, /* tuple */[
	              buffer,
	              drawModes
	            ]);
	}

	function create$7(state) {
	  var defaultDrawMode = getDefaultDrawMode(/* () */0);
	  var match = _initBufferData$1(getMeshRendererCount(state[/* settingRecord */1]), defaultDrawMode);
	  state[/* meshRendererRecord */25] = /* record */[
	    /* index */0,
	    /* buffer */match[0],
	    /* drawModes */match[1],
	    /* basicMaterialRenderGameObjectMap */createEmpty$2(/* () */0),
	    /* lightMaterialRenderGameObjectMap */createEmpty$2(/* () */0),
	    /* gameObjectMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$2(state) {
	  var record = getRecord$2(state);
	  var index = record[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* meshRendererRecord */25] = /* record */[
	    /* index */index,
	    /* buffer */record[/* buffer */1],
	    /* drawModes */copyUint8ArrayWithEndIndex(imul(index, getDrawModesSize(/* () */0)), record[/* drawModes */2]),
	    /* basicMaterialRenderGameObjectMap */copy$3(record[/* basicMaterialRenderGameObjectMap */3]),
	    /* lightMaterialRenderGameObjectMap */copy$3(record[/* lightMaterialRenderGameObjectMap */4]),
	    /* gameObjectMap */copy$3(record[/* gameObjectMap */5]),
	    /* disposedIndexArray */record[/* disposedIndexArray */6].slice()
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function handleAddComponent$10(meshRenderer, gameObjectUid, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var meshRendererRecord = getRecord$2(state);
	  var lightMaterialRenderGameObjectMap = meshRendererRecord[/* lightMaterialRenderGameObjectMap */4];
	  var basicMaterialRenderGameObjectMap = meshRendererRecord[/* basicMaterialRenderGameObjectMap */3];
	  var match = hasBasicMaterialComponent(gameObjectUid, gameObjectRecord);
	  var basicMaterialRenderGameObjectMap$1 = match ? set$1(meshRenderer, gameObjectUid, basicMaterialRenderGameObjectMap) : basicMaterialRenderGameObjectMap;
	  var match$1 = hasLightMaterialComponent(gameObjectUid, gameObjectRecord);
	  var lightMaterialRenderGameObjectMap$1 = match$1 ? set$1(meshRenderer, gameObjectUid, lightMaterialRenderGameObjectMap) : lightMaterialRenderGameObjectMap;
	  var newrecord = caml_array_dup(state);
	  return ensureCheck((function (state) {
	                return test(buildAssertMessage("should add material component before add meshRenderer component", "not(the gameObjectUid is " + (String(gameObjectUid) + ")")), (function () {
	                              var match = getRecord$2(state);
	                              return assertTrue(match[/* basicMaterialRenderGameObjectMap */3].includes(gameObjectUid) || match[/* lightMaterialRenderGameObjectMap */4].includes(gameObjectUid));
	                            }));
	              }), getIsDebug(stateData), (newrecord[/* meshRendererRecord */25] = /* record */[
	                /* index */meshRendererRecord[/* index */0],
	                /* buffer */meshRendererRecord[/* buffer */1],
	                /* drawModes */meshRendererRecord[/* drawModes */2],
	                /* basicMaterialRenderGameObjectMap */basicMaterialRenderGameObjectMap$1,
	                /* lightMaterialRenderGameObjectMap */lightMaterialRenderGameObjectMap$1,
	                /* gameObjectMap */addComponentToGameObjectMap(meshRenderer, gameObjectUid, meshRendererRecord[/* gameObjectMap */5]),
	                /* disposedIndexArray */meshRendererRecord[/* disposedIndexArray */6]
	              ], newrecord));
	}


	/* Log-WonderLog Not a pure module */

	function isGroupGeometry$1(geometry, record) {
	  return isGroupComponent(geometry, record[/* groupCountMap */16]);
	}

	function increaseGroupCount$4(geometry, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* vertices */record[/* vertices */2],
	          /* texCoords */record[/* texCoords */3],
	          /* normals */record[/* normals */4],
	          /* indices */record[/* indices */5],
	          /* verticesInfos */record[/* verticesInfos */6],
	          /* texCoordsInfos */record[/* texCoordsInfos */7],
	          /* normalsInfos */record[/* normalsInfos */8],
	          /* indicesInfos */record[/* indicesInfos */9],
	          /* verticesOffset */record[/* verticesOffset */10],
	          /* texCoordsOffset */record[/* texCoordsOffset */11],
	          /* normalsOffset */record[/* normalsOffset */12],
	          /* indicesOffset */record[/* indicesOffset */13],
	          /* disposeCount */record[/* disposeCount */14],
	          /* gameObjectMap */record[/* gameObjectMap */15],
	          /* groupCountMap */increaseGroupCount$1(geometry, record[/* groupCountMap */16]),
	          /* disposedIndexArray */record[/* disposedIndexArray */17],
	          /* disposedIndexMap */record[/* disposedIndexMap */18],
	          /* aliveIndexArray */record[/* aliveIndexArray */19]
	        ];
	}

	function decreaseGroupCount$4(geometry, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* vertices */record[/* vertices */2],
	          /* texCoords */record[/* texCoords */3],
	          /* normals */record[/* normals */4],
	          /* indices */record[/* indices */5],
	          /* verticesInfos */record[/* verticesInfos */6],
	          /* texCoordsInfos */record[/* texCoordsInfos */7],
	          /* normalsInfos */record[/* normalsInfos */8],
	          /* indicesInfos */record[/* indicesInfos */9],
	          /* verticesOffset */record[/* verticesOffset */10],
	          /* texCoordsOffset */record[/* texCoordsOffset */11],
	          /* normalsOffset */record[/* normalsOffset */12],
	          /* indicesOffset */record[/* indicesOffset */13],
	          /* disposeCount */record[/* disposeCount */14],
	          /* gameObjectMap */record[/* gameObjectMap */15],
	          /* groupCountMap */decreaseGroupCount$1(geometry, record[/* groupCountMap */16]),
	          /* disposedIndexArray */record[/* disposedIndexArray */17],
	          /* disposedIndexMap */record[/* disposedIndexMap */18],
	          /* aliveIndexArray */record[/* aliveIndexArray */19]
	        ];
	}


	/* No side effect */

	function getGameObject$2(geometry, param) {
	  return getGameObject$1(geometry, param[/* gameObjectMap */5]);
	}

	function unsafeGetGameObject$2(geometry, param) {
	  return unsafeGetGameObject$1(geometry, param[/* gameObjectMap */5]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getRecord$3(param) {
	  return param[/* boxGeometryRecord */23];
	}

	function create$8() {
	  var match = generateAllFaces(/* () */0);
	  return /* record */[
	          /* index */0,
	          /* vertices */new Float32Array(match[0]),
	          /* texCoords */new Float32Array(match[1]),
	          /* normals */new Float32Array(match[2]),
	          /* indices */new Uint16Array(match[3]),
	          /* gameObjectMap */createEmpty$2(/* () */0),
	          /* groupCountMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty$1(/* () */0)
	        ];
	}

	function deepCopyForRestore$3(state) {
	  var match = getRecord$3(state);
	  var disposedIndexArray = match[/* disposedIndexArray */7];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* boxGeometryRecord */23] = /* record */[
	    /* index */match[/* index */0],
	    /* vertices */match[/* vertices */1],
	    /* texCoords */match[/* texCoords */2],
	    /* normals */match[/* normals */3],
	    /* indices */match[/* indices */4],
	    /* gameObjectMap */copy$3(match[/* gameObjectMap */5]),
	    /* groupCountMap */copy$3(match[/* groupCountMap */6]),
	    /* disposedIndexArray */disposedIndexArray.slice()
	  ];
	  return newrecord;
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function getGameObject$3(material, param) {
	  return getGameObject$1(material, param[/* gameObjectMap */8]);
	}

	function unsafeGetGameObject$3(material, param) {
	  return unsafeGetGameObject$1(material, param[/* gameObjectMap */8]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getGameObject$4(material, param) {
	  return getGameObject$1(material, param[/* gameObjectMap */13]);
	}

	function unsafeGetGameObject$4(material, param) {
	  return unsafeGetGameObject$1(material, param[/* gameObjectMap */13]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getDefaultUnit() {
	  return 255;
	}

	function hasMap(mapUnit) {
	  return mapUnit !== 255;
	}


	/* No side effect */

	function getShaderIndicesSize() {
	  return 1;
	}

	function getShaderIndicesLength(count) {
	  return (count << 0);
	}

	function getShaderIndicesOffset() {
	  return 0;
	}

	function getShaderIndexIndex(index) {
	  return (index << 0);
	}

	function getShaderIndex(index, typeArr) {
	  return getUint32_1((index << 0), typeArr);
	}

	function setShaderIndex(index, data, typeArr) {
	  return setUint32_1((index << 0), data, typeArr);
	}

	function hasShaderIndex(materialIndex, shaderIndices) {
	  return getUint32_1((materialIndex << 0), shaderIndices) !== getDefaultShaderIndex(/* () */0);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getDefaultTextureIndex() {
	  return 0;
	}

	function getTextureIndicesSize(textureCountPerMaterial) {
	  return textureCountPerMaterial;
	}

	var getTextureIndicesLength = imul;

	var getTextureIndicesIndex = imul;

	function getTextureIndexIndex(index, textureIndex, textureCountPerMaterial) {
	  return imul(index, textureCountPerMaterial) + textureIndex | 0;
	}


	/* No side effect */

	function getShaderIndicesSize$1() {
	  return 1;
	}

	function getColorsSize() {
	  return 3;
	}

	function getMapUnitsSize() {
	  return 1;
	}

	function getColorsLength(basicMaterialCount) {
	  return imul(basicMaterialCount, 3);
	}

	function getColorsOffset(basicMaterialCount) {
	  return getShaderIndicesOffset(basicMaterialCount) + imul(getShaderIndicesLength(basicMaterialCount), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getColorIndex(index) {
	  return imul(index, 3);
	}

	function getTextureIndicesOffset(basicMaterialCount, _) {
	  return getColorsOffset(basicMaterialCount) + imul(imul(basicMaterialCount, 3), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMapUnitsLength(basicMaterialCount) {
	  return (basicMaterialCount << 0);
	}

	function getMapUnitsOffset(basicMaterialCount, textureCountPerMaterial) {
	  return getTextureIndicesOffset(basicMaterialCount, textureCountPerMaterial) + imul(getTextureIndicesLength(basicMaterialCount, textureCountPerMaterial), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMapUnitIndex(index) {
	  return (index << 0);
	}

	function getTotalByteLength$3(basicMaterialCount, textureCountPerMaterial) {
	  return imul(basicMaterialCount, ((imul(Uint32Array.BYTES_PER_ELEMENT, getShaderIndicesSize(/* () */0)) + imul(Float32Array.BYTES_PER_ELEMENT, 3) | 0) + imul(Uint32Array.BYTES_PER_ELEMENT, getTextureIndicesSize(textureCountPerMaterial)) | 0) + (Uint8Array.BYTES_PER_ELEMENT << 0) | 0);
	}

	function createBuffer$3(basicMaterialCount, textureCountPerMaterial) {
	  return newSharedArrayBuffer(getTotalByteLength$3(basicMaterialCount, textureCountPerMaterial));
	}

	var getTextureIndicesLength$1 = getTextureIndicesLength;


	/* Worker-Wonderjs Not a pure module */

	function createTypeArrays$2(buffer, basicMaterialCount, textureCountPerMaterial) {
	  return /* tuple */[
	          new Uint32Array(buffer, getShaderIndicesOffset(basicMaterialCount), getShaderIndicesLength(basicMaterialCount)),
	          new Float32Array(buffer, getColorsOffset(basicMaterialCount), getColorsLength(basicMaterialCount)),
	          new Uint32Array(buffer, getTextureIndicesOffset(basicMaterialCount, textureCountPerMaterial), getTextureIndicesLength$1(basicMaterialCount, textureCountPerMaterial)),
	          new Uint8Array(buffer, getMapUnitsOffset(basicMaterialCount, textureCountPerMaterial), getMapUnitsLength(basicMaterialCount))
	        ];
	}


	/* ShaderIndicesService-Wonderjs Not a pure module */

	function getTextureIndex$1(param, typeArr) {
	  return getUint32_1(getTextureIndexIndex(param[0], param[1], param[2]), typeArr);
	}

	function setTextureIndex$1(param, data, typeArr) {
	  return setUint32_1(getTextureIndexIndex(param[0], param[1], param[2]), data, typeArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getColor(index, typeArr) {
	  return getFloat3(getColorIndex(index), typeArr);
	}

	function setColor(index, data, typeArr) {
	  return setFloat3(getColorIndex(index), data, typeArr);
	}

	var setTextureIndex = setTextureIndex$1;

	function getMapUnit(index, typeArr) {
	  return getUint8_1(getMapUnitIndex(index), typeArr);
	}

	function setMapUnit(index, data, typeArr) {
	  return setUint8_1(getMapUnitIndex(index), data, typeArr);
	}

	var getTextureIndex = getTextureIndex$1;


	/* TypeArrayService-Wonderjs Not a pure module */

	function getRecord$4(param) {
	  return unsafeGet$1(param[/* basicMaterialRecord */16]);
	}

	function setAllTypeArrDataToDefault$2(basicMaterialCount, defaultShaderIndex, defaultColor, param) {
	  var defaultUnit = getDefaultUnit(/* () */0);
	  var match = reduceOneParam((function (param, index) {
	          return /* tuple */[
	                  setShaderIndex(index, defaultShaderIndex, param[0]),
	                  setColor(index, defaultColor, param[1]),
	                  setMapUnit(index, defaultUnit, param[2])
	                ];
	        }), /* tuple */[
	        param[0],
	        param[1],
	        param[3]
	      ], range(0, basicMaterialCount - 1 | 0));
	  return /* tuple */[
	          match[0],
	          match[1],
	          param[2].fill(0),
	          match[2]
	        ];
	}

	function _setAllTypeArrDataToDefault$2(basicMaterialCount, defaultShaderIndex, defaultColor, param) {
	  return /* tuple */[
	          param[0],
	          setAllTypeArrDataToDefault$2(basicMaterialCount, defaultShaderIndex, defaultColor, /* tuple */[
	                param[1],
	                param[2],
	                param[3],
	                param[4]
	              ])
	        ];
	}

	function _initBufferData$2(basicMaterialCount, textureCountPerMaterial, defaultShaderIndex, defaultColor) {
	  var buffer = createBuffer$3(basicMaterialCount, textureCountPerMaterial);
	  var match = createTypeArrays$2(buffer, basicMaterialCount, textureCountPerMaterial);
	  return _setAllTypeArrDataToDefault$2(basicMaterialCount, defaultShaderIndex, defaultColor, /* tuple */[
	              buffer,
	              match[0],
	              match[1],
	              match[2],
	              match[3]
	            ]);
	}

	function create$9(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var defaultShaderIndex = getDefaultShaderIndex(/* () */0);
	  var defaultColor = /* array */[
	    1,
	    1,
	    1
	  ];
	  var match = _initBufferData$2(getBasicMaterialCount(settingRecord), getTextureCountPerMaterial(settingRecord), defaultShaderIndex, defaultColor);
	  var match$1 = match[1];
	  state[/* basicMaterialRecord */16] = /* record */[
	    /* index */0,
	    /* buffer */match[0],
	    /* shaderIndices */match$1[0],
	    /* colors */match$1[1],
	    /* textureIndices */match$1[2],
	    /* mapUnits */match$1[3],
	    /* textureCountMap */createEmpty$2(/* () */0),
	    /* defaultColor */defaultColor,
	    /* gameObjectMap */createEmpty$2(/* () */0),
	    /* groupCountMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0),
	    /* nameMap */createEmpty$2(/* () */0),
	    /* materialArrayForWorkerInit */createEmpty$1(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$4(state) {
	  var record = getRecord$4(state);
	  var index = record[/* index */0];
	  var materialArrayForWorkerInit = record[/* materialArrayForWorkerInit */12];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */index,
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */copyUint32ArrayWithEndIndex(imul(index, getShaderIndicesSize$1(/* () */0)), record[/* shaderIndices */2]),
	    /* colors */copyFloat32ArrayWithEndIndex(imul(index, getColorsSize(/* () */0)), record[/* colors */3]),
	    /* textureIndices */copyUint32ArrayWithEndIndex(imul(index, getTextureIndicesSize(getTextureCountPerMaterial(state[/* settingRecord */1]))), record[/* textureIndices */4]),
	    /* mapUnits */copyUint8ArrayWithEndIndex(imul(index, getMapUnitsSize(/* () */0)), record[/* mapUnits */5]),
	    /* textureCountMap */copy$3(record[/* textureCountMap */6]),
	    /* defaultColor */record[/* defaultColor */7],
	    /* gameObjectMap */copy$3(record[/* gameObjectMap */8]),
	    /* groupCountMap */copy$3(record[/* groupCountMap */9]),
	    /* disposedIndexArray */record[/* disposedIndexArray */10].slice(),
	    /* nameMap */copy$3(record[/* nameMap */11]),
	    /* materialArrayForWorkerInit */materialArrayForWorkerInit.slice()
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function getShaderIndicesSize$2() {
	  return 1;
	}

	function getDiffuseColorsSize() {
	  return 3;
	}

	function getMapUnitsSize$1() {
	  return 1;
	}

	function getDiffuseColorsLength(lightMaterialCount) {
	  return imul(lightMaterialCount, 3);
	}

	function getDiffuseColorsOffset(lightMaterialCount) {
	  return imul(getShaderIndicesLength(lightMaterialCount), Uint32Array.BYTES_PER_ELEMENT);
	}

	function getSpecularColorsSize() {
	  return 3;
	}

	function getSpecularColorsLength(lightMaterialCount) {
	  return imul(lightMaterialCount, 3);
	}

	function getSpecularColorsOffset(lightMaterialCount) {
	  return imul(getShaderIndicesLength(lightMaterialCount), Uint32Array.BYTES_PER_ELEMENT) + imul(imul(lightMaterialCount, 3), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getShininessSize() {
	  return 1;
	}

	function getShininessLength(lightMaterialCount) {
	  return (lightMaterialCount << 0);
	}

	function getShininessOffset(lightMaterialCount) {
	  return getSpecularColorsOffset(lightMaterialCount) + imul(imul(lightMaterialCount, 3), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getDiffuseColorIndex(index) {
	  return imul(index, 3);
	}

	function getSpecularColorIndex(index) {
	  return imul(index, 3);
	}

	function getShininessIndex(index) {
	  return (index << 0);
	}

	function getTextureIndicesOffset$1(lightMaterialCount, _) {
	  return getShininessOffset(lightMaterialCount) + imul((lightMaterialCount << 0), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getDiffuseMapUnitsLength(lightMaterialCount) {
	  return (lightMaterialCount << 0);
	}

	function getDiffuseMapUnitsOffset(lightMaterialCount, textureCountPerMaterial) {
	  return getTextureIndicesOffset$1(lightMaterialCount, textureCountPerMaterial) + imul(getTextureIndicesLength(lightMaterialCount, textureCountPerMaterial), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getDiffuseMapUnitIndex(index) {
	  return (index << 0);
	}

	function getSpecularMapUnitsLength(lightMaterialCount) {
	  return (lightMaterialCount << 0);
	}

	function getSpecularMapUnitsOffset(lightMaterialCount, textureCountPerMaterial) {
	  return getDiffuseMapUnitsOffset(lightMaterialCount, textureCountPerMaterial) + imul((lightMaterialCount << 0), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getSpecularMapUnitIndex(index) {
	  return (index << 0);
	}

	function getTotalByteLength$4(lightMaterialCount, textureCountPerMaterial) {
	  return imul(lightMaterialCount, ((imul(Uint32Array.BYTES_PER_ELEMENT, getShaderIndicesSize(/* () */0)) + imul(Float32Array.BYTES_PER_ELEMENT, 7) | 0) + imul(Uint32Array.BYTES_PER_ELEMENT, getTextureIndicesSize(textureCountPerMaterial)) | 0) + (Uint8Array.BYTES_PER_ELEMENT << 1) | 0);
	}

	function createBuffer$4(lightMaterialCount, textureCountPerMaterial) {
	  return newSharedArrayBuffer(getTotalByteLength$4(lightMaterialCount, textureCountPerMaterial));
	}

	var getTextureIndicesLength$2 = getTextureIndicesLength;


	/* Worker-Wonderjs Not a pure module */

	function createTypeArrays$3(buffer, lightMaterialCount, textureCountPerMaterial) {
	  return /* tuple */[
	          new Uint32Array(buffer, getShaderIndicesOffset(lightMaterialCount), getShaderIndicesLength(lightMaterialCount)),
	          new Float32Array(buffer, getDiffuseColorsOffset(lightMaterialCount), getDiffuseColorsLength(lightMaterialCount)),
	          new Float32Array(buffer, getSpecularColorsOffset(lightMaterialCount), getSpecularColorsLength(lightMaterialCount)),
	          new Float32Array(buffer, getShininessOffset(lightMaterialCount), getShininessLength(lightMaterialCount)),
	          new Uint32Array(buffer, getTextureIndicesOffset$1(lightMaterialCount, textureCountPerMaterial), getTextureIndicesLength$2(lightMaterialCount, textureCountPerMaterial)),
	          new Uint8Array(buffer, getDiffuseMapUnitsOffset(lightMaterialCount, textureCountPerMaterial), getDiffuseMapUnitsLength(lightMaterialCount)),
	          new Uint8Array(buffer, getSpecularMapUnitsOffset(lightMaterialCount, textureCountPerMaterial), getSpecularMapUnitsLength(lightMaterialCount))
	        ];
	}


	/* ShaderIndicesService-Wonderjs Not a pure module */

	function getDiffuseColor(index, typeArr) {
	  return getFloat3(getDiffuseColorIndex(index), typeArr);
	}

	function setDiffuseColor(index, data, typeArr) {
	  return setFloat3(getDiffuseColorIndex(index), data, typeArr);
	}

	function getSpecularColor(index, typeArr) {
	  return getFloat3(getSpecularColorIndex(index), typeArr);
	}

	function setSpecularColor(index, data, typeArr) {
	  return setFloat3(getSpecularColorIndex(index), data, typeArr);
	}

	function getShininess(index, typeArr) {
	  return getFloat1(getShininessIndex(index), typeArr);
	}

	function setShininess(index, data, typeArr) {
	  return setFloat1(getShininessIndex(index), data, typeArr);
	}

	var setTextureIndex$2 = setTextureIndex$1;

	function getDiffuseMapUnit(index, typeArr) {
	  return getUint8_1(getDiffuseMapUnitIndex(index), typeArr);
	}

	function setDiffuseMapUnit(index, data, typeArr) {
	  return setUint8_1(getDiffuseMapUnitIndex(index), data, typeArr);
	}

	function getSpecularMapUnit(index, typeArr) {
	  return getUint8_1(getSpecularMapUnitIndex(index), typeArr);
	}

	function setSpecularMapUnit(index, data, typeArr) {
	  return setUint8_1(getSpecularMapUnitIndex(index), data, typeArr);
	}

	var getTextureIndex$2 = getTextureIndex$1;


	/* TypeArrayService-Wonderjs Not a pure module */

	function getRecord$5(param) {
	  return unsafeGet$1(param[/* lightMaterialRecord */17]);
	}

	function setAllTypeArrDataToDefault$3(lightMaterialCount, param, param$1) {
	  var defaultShininess = param[3];
	  var defaultSpecularColor = param[2];
	  var defaultDiffuseColor = param[1];
	  var defaultShaderIndex = param[0];
	  var defaultUnit = getDefaultUnit(/* () */0);
	  var match = reduceOneParam((function (param, index) {
	          return /* tuple */[
	                  setShaderIndex(index, defaultShaderIndex, param[0]),
	                  setDiffuseColor(index, defaultDiffuseColor, param[1]),
	                  setSpecularColor(index, defaultSpecularColor, param[2]),
	                  setShininess(index, defaultShininess, param[3]),
	                  setDiffuseMapUnit(index, defaultUnit, param[4]),
	                  setSpecularMapUnit(index, defaultUnit, param[5])
	                ];
	        }), /* tuple */[
	        param$1[0],
	        param$1[1],
	        param$1[2],
	        param$1[3],
	        param$1[5],
	        param$1[6]
	      ], range(0, lightMaterialCount - 1 | 0));
	  return /* tuple */[
	          match[0],
	          match[1],
	          match[2],
	          match[3],
	          param$1[4].fill(0),
	          match[4],
	          match[5]
	        ];
	}

	function _setAllTypeArrDataToDefault$3(lightMaterialCount, param, param$1) {
	  return /* tuple */[
	          param$1[0],
	          setAllTypeArrDataToDefault$3(lightMaterialCount, /* tuple */[
	                param[0],
	                param[1],
	                param[2],
	                param[3]
	              ], /* tuple */[
	                param$1[1],
	                param$1[2],
	                param$1[3],
	                param$1[4],
	                param$1[5],
	                param$1[6],
	                param$1[7]
	              ])
	        ];
	}

	function _initBufferData$3(lightMaterialCount, textureCountPerMaterial, param) {
	  var buffer = createBuffer$4(lightMaterialCount, textureCountPerMaterial);
	  var match = createTypeArrays$3(buffer, lightMaterialCount, textureCountPerMaterial);
	  return _setAllTypeArrDataToDefault$3(lightMaterialCount, /* tuple */[
	              param[0],
	              param[1],
	              param[2],
	              param[3]
	            ], /* tuple */[
	              buffer,
	              match[0],
	              match[1],
	              match[2],
	              match[3],
	              match[4],
	              match[5],
	              match[6]
	            ]);
	}

	function create$10(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var defaultShaderIndex = getDefaultShaderIndex(/* () */0);
	  var defaultDiffuseColor = /* array */[
	    1,
	    1,
	    1
	  ];
	  var defaultSpecularColor = /* array */[
	    1,
	    1,
	    1
	  ];
	  var match = _initBufferData$3(getLightMaterialCount(settingRecord), getTextureCountPerMaterial(settingRecord), /* tuple */[
	        defaultShaderIndex,
	        defaultDiffuseColor,
	        defaultSpecularColor,
	        32.0
	      ]);
	  var match$1 = match[1];
	  state[/* lightMaterialRecord */17] = /* record */[
	    /* index */0,
	    /* buffer */match[0],
	    /* shaderIndices */match$1[0],
	    /* diffuseColors */match$1[1],
	    /* specularColors */match$1[2],
	    /* shininess */match$1[3],
	    /* textureIndices */match$1[4],
	    /* diffuseMapUnits */match$1[5],
	    /* specularMapUnits */match$1[6],
	    /* textureCountMap */createEmpty$2(/* () */0),
	    /* defaultDiffuseColor */defaultDiffuseColor,
	    /* defaultSpecularColor */defaultSpecularColor,
	    /* defaultShininess */32.0,
	    /* gameObjectMap */createEmpty$2(/* () */0),
	    /* groupCountMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0),
	    /* nameMap */createEmpty$2(/* () */0),
	    /* materialArrayForWorkerInit */createEmpty$1(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$5(state) {
	  var record = getRecord$5(state);
	  var index = record[/* index */0];
	  var materialArrayForWorkerInit = record[/* materialArrayForWorkerInit */17];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */index,
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */copyUint32ArrayWithEndIndex(imul(index, getShaderIndicesSize$2(/* () */0)), record[/* shaderIndices */2]),
	    /* diffuseColors */copyFloat32ArrayWithEndIndex(imul(index, getDiffuseColorsSize(/* () */0)), record[/* diffuseColors */3]),
	    /* specularColors */copyFloat32ArrayWithEndIndex(imul(index, getSpecularColorsSize(/* () */0)), record[/* specularColors */4]),
	    /* shininess */copyFloat32ArrayWithEndIndex(imul(index, getShininessSize(/* () */0)), record[/* shininess */5]),
	    /* textureIndices */copyUint32ArrayWithEndIndex(imul(index, getTextureIndicesSize(getTextureCountPerMaterial(state[/* settingRecord */1]))), record[/* textureIndices */6]),
	    /* diffuseMapUnits */copyUint8ArrayWithEndIndex(imul(index, getMapUnitsSize$1(/* () */0)), record[/* diffuseMapUnits */7]),
	    /* specularMapUnits */copyUint8ArrayWithEndIndex(imul(index, getMapUnitsSize$1(/* () */0)), record[/* specularMapUnits */8]),
	    /* textureCountMap */copy$3(record[/* textureCountMap */9]),
	    /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	    /* defaultShininess */record[/* defaultShininess */12],
	    /* gameObjectMap */copy$3(record[/* gameObjectMap */13]),
	    /* groupCountMap */copy$3(record[/* groupCountMap */14]),
	    /* disposedIndexArray */record[/* disposedIndexArray */15].slice(),
	    /* nameMap */copy$3(record[/* nameMap */16]),
	    /* materialArrayForWorkerInit */materialArrayForWorkerInit.slice()
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function getGameObject$5(geometry, param) {
	  return getGameObject$1(geometry, param[/* gameObjectMap */15]);
	}

	function unsafeGetGameObject$5(geometry, param) {
	  return unsafeGetGameObject$1(geometry, param[/* gameObjectMap */15]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function createTypeArrays$4(buffer, customGeometryPointCount, customGeometryCount) {
	  return /* tuple */[
	          new Float32Array(buffer, getVerticesOffset(customGeometryPointCount), getVertexLength(customGeometryPointCount)),
	          new Float32Array(buffer, getTexCoordsOffset(customGeometryPointCount), getTexCoordsLength(customGeometryPointCount)),
	          new Float32Array(buffer, getNormalsOffset(customGeometryPointCount), getVertexLength(customGeometryPointCount)),
	          new Uint16Array(buffer, getIndicesOffset(customGeometryPointCount), getIndicesLength(customGeometryPointCount)),
	          new Uint32Array(buffer, getVerticesInfosOffset(customGeometryPointCount), getVerticesInfosLength(customGeometryCount)),
	          new Uint32Array(buffer, getTexCoordsInfosOffset(customGeometryPointCount, customGeometryCount), getTexCoordsInfosLength(customGeometryCount)),
	          new Uint32Array(buffer, getNormalsInfosOffset(customGeometryPointCount, customGeometryCount), getNormalsInfosLength(customGeometryCount)),
	          new Uint32Array(buffer, getIndicesInfosOffset(customGeometryPointCount, customGeometryCount), getIndicesInfosLength(customGeometryCount))
	        ];
	}


	/* BufferCustomGeometryService-Wonderjs Not a pure module */

	function getRecord$6(param) {
	  return unsafeGet$1(param[/* customGeometryRecord */24]);
	}

	function setAllTypeArrDataToDefault$4(geometryCount, geometryPointCount, param) {
	  return /* tuple */[
	          param[0].fill(0, 0, imul(imul(geometryCount, geometryPointCount), getVertexSize(/* () */0))),
	          param[1].fill(0, 0, imul(imul(geometryCount, geometryPointCount), getTexCoordsSize(/* () */0))),
	          param[2].fill(0, 0, imul(imul(geometryCount, geometryPointCount), getVertexSize(/* () */0))),
	          param[3].fill(0, 0, imul(imul(geometryCount, geometryPointCount), getIndexSize(/* () */0)))
	        ];
	}

	function _initBufferData$4(geometryPointCount, geometryCount) {
	  var buffer = createBuffer$1(geometryPointCount, geometryCount);
	  var match = createTypeArrays$4(buffer, geometryPointCount, geometryCount);
	  return /* tuple */[
	          buffer,
	          match[0],
	          match[1],
	          match[2],
	          match[3],
	          match[4],
	          match[5],
	          match[6],
	          match[7]
	        ];
	}

	function create$11(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var geometryPointCount = getCustomGeometryPointCount(settingRecord);
	  var geometryCount = getCustomGeometryCount(settingRecord);
	  var match = _initBufferData$4(geometryPointCount, geometryCount);
	  state[/* customGeometryRecord */24] = /* record */[
	    /* index */0,
	    /* buffer */match[0],
	    /* vertices */match[1],
	    /* texCoords */match[2],
	    /* normals */match[3],
	    /* indices */match[4],
	    /* verticesInfos */match[5],
	    /* texCoordsInfos */match[6],
	    /* normalsInfos */match[7],
	    /* indicesInfos */match[8],
	    /* verticesOffset */0,
	    /* texCoordsOffset */0,
	    /* normalsOffset */0,
	    /* indicesOffset */0,
	    /* disposeCount */0,
	    /* gameObjectMap */createEmpty$2(/* () */0),
	    /* groupCountMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0),
	    /* disposedIndexMap */createEmpty$2(/* () */0),
	    /* aliveIndexArray */createEmpty$1(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$6(state) {
	  var record = getRecord$6(state);
	  var verticesOffset = record[/* verticesOffset */10];
	  var texCoordsOffset = record[/* texCoordsOffset */11];
	  var normalsOffset = record[/* normalsOffset */12];
	  var indicesOffset = record[/* indicesOffset */13];
	  var disposeCount = record[/* disposeCount */14];
	  var disposedIndexArray = record[/* disposedIndexArray */17];
	  var disposedIndexMap = record[/* disposedIndexMap */18];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* customGeometryRecord */24] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* vertices */copyFloat32ArrayWithEndIndex(verticesOffset, record[/* vertices */2]),
	    /* texCoords */copyFloat32ArrayWithEndIndex(texCoordsOffset, record[/* texCoords */3]),
	    /* normals */copyFloat32ArrayWithEndIndex(normalsOffset, record[/* normals */4]),
	    /* indices */copyUint16ArrayWithEndIndex(indicesOffset, record[/* indices */5]),
	    /* verticesInfos */record[/* verticesInfos */6],
	    /* texCoordsInfos */record[/* texCoordsInfos */7],
	    /* normalsInfos */record[/* normalsInfos */8],
	    /* indicesInfos */record[/* indicesInfos */9],
	    /* verticesOffset */verticesOffset,
	    /* texCoordsOffset */texCoordsOffset,
	    /* normalsOffset */normalsOffset,
	    /* indicesOffset */indicesOffset,
	    /* disposeCount */disposeCount,
	    /* gameObjectMap */copy$3(record[/* gameObjectMap */15]),
	    /* groupCountMap */copy$3(record[/* groupCountMap */16]),
	    /* disposedIndexArray */disposedIndexArray.slice(),
	    /* disposedIndexMap */copy$3(disposedIndexMap),
	    /* aliveIndexArray */record[/* aliveIndexArray */19].slice()
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function getObjectInstanceTransformCollectionsSize(objectInstanceCountPerSourceInstance) {
	  return objectInstanceCountPerSourceInstance;
	}

	var getObjectInstanceTransformCollectionsLength = imul;

	function getObjectInstanceTransformCollectionsOffset(_, _$1) {
	  return 0;
	}

	function getIsTransformStaticsSize() {
	  return 1;
	}

	function getIsTransformStaticsLength(sourceInstanceCount) {
	  return (sourceInstanceCount << 0);
	}

	function getIsTransformStaticsOffset(sourceInstanceCount, objectInstanceCountPerSourceInstance) {
	  return 0 + imul(imul(sourceInstanceCount, objectInstanceCountPerSourceInstance), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	var getObjectInstanceTransformCollectionsIndex = imul;

	function getIsTransformStaticsIndex(sourceInstance) {
	  return (sourceInstance << 0);
	}

	function getObjectInstanceTransformIndex(sourceInstance, objectInstanceTransformIndex, objectInstanceCountPerSourceInstance) {
	  return imul(sourceInstance, objectInstanceCountPerSourceInstance) + objectInstanceTransformIndex | 0;
	}

	function getTotalByteLength$5(sourceInstanceCount, objectInstanceCountPerSourceInstance) {
	  return imul(sourceInstanceCount, imul(Uint32Array.BYTES_PER_ELEMENT, objectInstanceCountPerSourceInstance) + (Uint8Array.BYTES_PER_ELEMENT << 0) | 0);
	}

	function createBuffer$5(sourceInstanceCount, objectInstanceCountPerSourceInstance) {
	  return newSharedArrayBuffer(getTotalByteLength$5(sourceInstanceCount, objectInstanceCountPerSourceInstance));
	}


	/* Worker-Wonderjs Not a pure module */

	function getDefault() {
	  return 1;
	}

	function markModelMatrixStatic(sourceInstance, isTransformStatics) {
	  return setUint8_1(getIsTransformStaticsIndex(sourceInstance), 1, isTransformStatics);
	}

	function markModelMatrixNotStatic(sourceInstance, isTransformStatics) {
	  return setUint8_1(getIsTransformStaticsIndex(sourceInstance), 0, isTransformStatics);
	}

	function setModelMatrixIsStatic(sourceInstance, isStatic, isTransformStatics) {
	  return setUint8_1(getIsTransformStaticsIndex(sourceInstance), isStatic, isTransformStatics);
	}

	function markModelMatrixIsStatic(sourceInstance, isStatic, isTransformStatics) {
	  if (isStatic) {
	    return markModelMatrixStatic(sourceInstance, isTransformStatics);
	  } else {
	    return markModelMatrixNotStatic(sourceInstance, isTransformStatics);
	  }
	}

	function isTransformStatic(sourceInstance, isTransformStatics) {
	  return getUint8_1(getIsTransformStaticsIndex(sourceInstance), isTransformStatics) === 1;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function createTypeArrays$5(buffer, sourceInstanceCount, objectInstanceCountPerSourceInstance) {
	  return /* tuple */[
	          new Uint32Array(buffer, getObjectInstanceTransformCollectionsOffset(sourceInstanceCount, objectInstanceCountPerSourceInstance), getObjectInstanceTransformCollectionsLength(sourceInstanceCount, objectInstanceCountPerSourceInstance)),
	          new Uint8Array(buffer, getIsTransformStaticsOffset(sourceInstanceCount, objectInstanceCountPerSourceInstance), getIsTransformStaticsLength(sourceInstanceCount))
	        ];
	}


	/* BufferSourceInstanceService-Wonderjs Not a pure module */

	function getRecord$7(param) {
	  return unsafeGet$1(param[/* sourceInstanceRecord */7]);
	}

	function setAllTypeArrDataToDefault$5(sourceInstanceCount, defaultIsTransformStatic, param) {
	  return /* tuple */[
	          param[0].fill(0),
	          reduceOneParam((function (isTransformStatics, index) {
	                  return setModelMatrixIsStatic(index, defaultIsTransformStatic, isTransformStatics);
	                }), param[1], range(0, sourceInstanceCount - 1 | 0))
	        ];
	}

	function _setAllTypeArrDataToDefault$4(sourceInstanceCount, defaultIsTransformStatic, param) {
	  return /* tuple */[
	          param[0],
	          setAllTypeArrDataToDefault$5(sourceInstanceCount, defaultIsTransformStatic, /* tuple */[
	                param[1],
	                param[2]
	              ])
	        ];
	}

	function _initBufferData$5(sourceInstanceCount, objectInstanceCountPerSourceInstance, defaultIsTransformStatic) {
	  var buffer = createBuffer$5(sourceInstanceCount, objectInstanceCountPerSourceInstance);
	  var match = createTypeArrays$5(buffer, sourceInstanceCount, objectInstanceCountPerSourceInstance);
	  return _setAllTypeArrDataToDefault$4(sourceInstanceCount, defaultIsTransformStatic, /* tuple */[
	              buffer,
	              match[0],
	              match[1]
	            ]);
	}

	function create$12(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var sourceInstanceCount = getSourceInstanceCount(settingRecord);
	  var objectInstanceCountPerSourceInstance = getObjectInstanceCountPerSourceInstance(settingRecord);
	  var defaultIsTransformStatic = getDefault(/* () */0);
	  var match = _initBufferData$5(sourceInstanceCount, objectInstanceCountPerSourceInstance, defaultIsTransformStatic);
	  var match$1 = match[1];
	  state[/* sourceInstanceRecord */7] = /* record */[
	    /* index */0,
	    /* objectInstanceTransformIndexMap */createEmpty$2(/* () */0),
	    /* buffer */match[0],
	    /* isTransformStatics */match$1[1],
	    /* objectInstanceTransformCollections */match$1[0],
	    /* matrixInstanceBufferCapacityMap */createEmpty$2(/* () */0),
	    /* matrixFloat32ArrayMap */createEmpty$2(/* () */0),
	    /* isSendTransformMatrixDataMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0),
	    /* gameObjectMap */createEmpty$2(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$7(state) {
	  var record = getRecord$7(state);
	  var index = record[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* sourceInstanceRecord */7] = /* record */[
	    /* index */index,
	    /* objectInstanceTransformIndexMap */copy$3(record[/* objectInstanceTransformIndexMap */1]),
	    /* buffer */record[/* buffer */2],
	    /* isTransformStatics */copyUint8ArrayWithEndIndex(imul(index, getIsTransformStaticsSize(/* () */0)), record[/* isTransformStatics */3]),
	    /* objectInstanceTransformCollections */copyUint32ArrayWithEndIndex(imul(index, getObjectInstanceTransformCollectionsSize(getObjectInstanceCountPerSourceInstance(state[/* settingRecord */1]))), record[/* objectInstanceTransformCollections */4]),
	    /* matrixInstanceBufferCapacityMap */copy$3(record[/* matrixInstanceBufferCapacityMap */5]),
	    /* matrixFloat32ArrayMap */deepCopyFloat32ArrayArray(record[/* matrixFloat32ArrayMap */6]),
	    /* isSendTransformMatrixDataMap */record[/* isSendTransformMatrixDataMap */7],
	    /* disposedIndexArray */record[/* disposedIndexArray */8].slice(),
	    /* gameObjectMap */copy$3(record[/* gameObjectMap */9])
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function handleAddComponent$11(cameraController, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */addComponentToGameObjectMap(cameraController, gameObjectUid, record[/* gameObjectMap */17]),
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}


	/* No side effect */

	function handleAddComponent$12(cameraProjection, gameObjectUid, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* dirtyArray */record[/* dirtyArray */1],
	          /* pMatrixMap */record[/* pMatrixMap */2],
	          /* nearMap */record[/* nearMap */3],
	          /* farMap */record[/* farMap */4],
	          /* fovyMap */record[/* fovyMap */5],
	          /* aspectMap */record[/* aspectMap */6],
	          /* gameObjectMap */addComponentToGameObjectMap(cameraProjection, gameObjectUid, record[/* gameObjectMap */7]),
	          /* disposedIndexArray */record[/* disposedIndexArray */8]
	        ];
	}


	/* No side effect */

	function _addComponent(param, handleAddComponentFunc, componentRecord) {
	  var component = param[1];
	  var uid = param[0];
	  addComponent(uid, component, param[2]);
	  return handleAddComponentFunc(component, uid, componentRecord);
	}

	function _addComponentWithState(param, handleAddComponentFunc, state) {
	  var component = param[1];
	  var uid = param[0];
	  addComponent(uid, component, param[2]);
	  return handleAddComponentFunc(component, uid, state);
	}

	function _addSharableComponent(param, param$1, componentRecord) {
	  var component = param[1];
	  var uid = param[0];
	  addComponent(uid, component, param[2]);
	  if (param[3] !== undefined) {
	    return param$1[0](component, componentRecord);
	  } else {
	    return param$1[1](component, uid, componentRecord);
	  }
	}

	function addBasicCameraViewComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var basicCameraViewRecord = state[/* basicCameraViewRecord */14];
	  state[/* basicCameraViewRecord */14] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* basicCameraViewMap */23]
	      ], handleAddComponent$9, basicCameraViewRecord);
	  return state;
	}

	function addPerspectiveCameraProjectionComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  state[/* perspectiveCameraProjectionRecord */15] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* perspectiveCameraProjectionMap */24]
	      ], handleAddComponent$12, perspectiveCameraProjectionRecord);
	  return state;
	}

	function addArcballCameraControllerComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* arcballCameraControllerMap */25]
	      ], handleAddComponent$11, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function addTransformComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  state[/* transformRecord */12] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* transformMap */22]
	      ], handleAddComponent, getRecord$1(state));
	  return state;
	}

	function _addSharableGeometryComponent(param, param$1, componentRecord) {
	  var component = param[1];
	  if (param[2] !== undefined) {
	    return param$1[0](component, componentRecord);
	  } else {
	    return param$1[1](component, param[0], componentRecord);
	  }
	}

	function _addCurrentBoxGeometryComponentData(uid, component, param) {
	  var geometryDataMap = param[/* geometryDataMap */21];
	  return addToMap(uid, /* tuple */[
	              component,
	              getBoxGeometryType(/* () */0)
	            ], geometryDataMap);
	}

	function addBoxGeometryComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  _addCurrentBoxGeometryComponentData(uid, component, gameObjectRecord);
	  var boxGeometryRecord = getRecord$3(state);
	  state[/* boxGeometryRecord */23] = _addSharableGeometryComponent(/* tuple */[
	        uid,
	        component,
	        getGameObject$2(component, boxGeometryRecord)
	      ], /* tuple */[
	        increaseGroupCount,
	        handleAddComponent$2
	      ], boxGeometryRecord);
	  return state;
	}

	function _addCurrentCustomGeometryComponentData(uid, component, param) {
	  var geometryDataMap = param[/* geometryDataMap */21];
	  return addToMap(uid, /* tuple */[
	              component,
	              getCustomGeometryType(/* () */0)
	            ], geometryDataMap);
	}

	function addCustomGeometryComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  _addCurrentCustomGeometryComponentData(uid, component, gameObjectRecord);
	  var customGeometryRecord = getRecord$6(state);
	  state[/* customGeometryRecord */24] = _addSharableGeometryComponent(/* tuple */[
	        uid,
	        component,
	        getGameObject$5(component, customGeometryRecord)
	      ], /* tuple */[
	        increaseGroupCount$4,
	        handleAddComponent$5
	      ], customGeometryRecord);
	  return state;
	}

	function addBasicMaterialComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var basicMaterialRecord = getRecord$4(state);
	  state[/* basicMaterialRecord */16] = _addSharableComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* basicMaterialMap */27],
	        getGameObject$3(component, basicMaterialRecord)
	      ], /* tuple */[
	        increaseGroupCount$2,
	        handleAddComponent$3
	      ], basicMaterialRecord);
	  return state;
	}

	function addLightMaterialComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var lightMaterialRecord = getRecord$5(state);
	  state[/* lightMaterialRecord */17] = _addSharableComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* lightMaterialMap */28],
	        getGameObject$4(component, lightMaterialRecord)
	      ], /* tuple */[
	        increaseGroupCount$3,
	        handleAddComponent$4
	      ], lightMaterialRecord);
	  return state;
	}

	function addMeshRendererComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return _addComponentWithState(/* tuple */[
	              uid,
	              component,
	              gameObjectRecord[/* meshRendererMap */26]
	            ], handleAddComponent$10, state);
	}

	function addDirectionLightComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var directionLightRecord = state[/* directionLightRecord */21];
	  state[/* directionLightRecord */21] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* directionLightMap */31]
	      ], handleAddComponent$6, directionLightRecord);
	  return state;
	}

	function addPointLightComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  state[/* pointLightRecord */22] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* pointLightMap */32]
	      ], handleAddComponent$1, pointLightRecord);
	  return state;
	}

	function addSourceInstanceComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  state[/* sourceInstanceRecord */7] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* sourceInstanceMap */29]
	      ], handleAddComponent$8, getRecord$7(state));
	  return state;
	}

	function addObjectInstanceComponent(uid, component, state) {
	  var objectInstanceRecord = state[/* objectInstanceRecord */8];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  state[/* objectInstanceRecord */8] = _addComponent(/* tuple */[
	        uid,
	        component,
	        gameObjectRecord[/* objectInstanceMap */30]
	      ], handleAddComponent$7, objectInstanceRecord);
	  return state;
	}


	/* ComponentMapService-Wonderjs Not a pure module */

	function increase(uid) {
	  return uid + 1 | 0;
	}


	/* No side effect */

	function create$13(record) {
	  var uid = record[/* uid */0];
	  var aliveUidArray = record[/* aliveUidArray */20];
	  record[/* uid */0] = increase(uid);
	  aliveUidArray.push(uid);
	  return /* tuple */[
	          record,
	          uid
	        ];
	}


	/* No side effect */

	function create$4(state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = create$13(gameObjectRecord);
	  var uid = match[1];
	  state[/* gameObjectRecord */11] = match[0];
	  var match$1 = create$5(state);
	  return /* tuple */[
	          addTransformComponent(uid, match$1[1], match$1[0]),
	          uid
	        ];
	}


	/* CreateTransformMainService-Wonderjs Not a pure module */

	function getRecord(state) {
	  return unsafeGet$1(state[/* sceneRecord */13]);
	}

	function create$3(state) {
	  var match = create$4(state);
	  var newrecord = caml_array_dup(match[0]);
	  newrecord[/* sceneRecord */13] = /* record */[
	    /* currentCameraGameObject */undefined,
	    /* ambientLight : record */[/* color */getDefaultColor(/* () */0)],
	    /* sceneGameObject */match[1]
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function unsafeGetParent(transform, record) {
	  return unsafeGet$2(transform, record[/* parentMap */15]);
	}

	function getParent(transform, record) {
	  return undefined_to_opt(unsafeGet$2(transform, record[/* parentMap */15]));
	}

	function removeFromParentMap(child, record) {
	  var newrecord = caml_array_dup(record);
	  newrecord[/* parentMap */15] = deleteVal$1(child, record[/* parentMap */15]);
	  return newrecord;
	}

	function unsafeGetChildren(transform, record) {
	  return ensureCheck((function (children) {
	                return test(buildAssertMessage("children exist", "not"), (function () {
	                              return assertNullableExist(children);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(transform, record[/* childMap */16]));
	}

	function _setChildren(record, parent, children) {
	  var newrecord = caml_array_dup(record);
	  newrecord[/* childMap */16] = set$1(parent, children, record[/* childMap */16]);
	  return newrecord;
	}

	function _removeChild(child, _, children) {
	  return deleteBySwap(children.indexOf(child), children.length - 1 | 0, children);
	}

	function removeFromChildMap(parent, child, isKeepOrder, record) {
	  if (isKeepOrder) {
	    return _setChildren(record, parent, unsafeGetChildren(parent, record).filter((function (transform) {
	                      return transform !== child;
	                    })));
	  } else {
	    _removeChild(child, isKeepOrder, unsafeGetChildren(parent, record));
	    return record;
	  }
	}

	function _removeFromParent(currentParent, child, isKeepOrder, record) {
	  return removeFromChildMap(currentParent, child, isKeepOrder, removeFromParentMap(child, record));
	}

	function _setParent(parent, child, record) {
	  var newrecord = caml_array_dup(record);
	  newrecord[/* parentMap */15] = set$1(child, parent, record[/* parentMap */15]);
	  return newrecord;
	}

	function _addChild(parent, child, record) {
	  unsafeGetChildren(parent, record).push(child);
	  return record;
	}

	function addToParent(parent, child, record) {
	  requireCheck((function () {
	          test(buildAssertMessage("child not has parent", "has"), (function () {
	                  return assertNotExist(undefined_to_opt(unsafeGet$2(child, record[/* parentMap */15])));
	                }));
	          return test(buildAssertMessage("parent not already has the child", "has"), (function () {
	                        return assertFalse(unsafeGetChildren(parent, record).includes(child));
	                      }));
	        }), getIsDebug(stateData));
	  return _addChild(parent, child, _setParent(parent, child, record));
	}

	function markHierachyDirty(transform, record) {
	  return reduceOneParam((function (record, child) {
	                return markHierachyDirty(child, record);
	              }), record, unsafeGetChildren(transform, mark(transform, true, record)));
	}

	function _setNewParent(parent, child, isKeepOrder, record) {
	  var match = unsafeGet$2(child, record[/* parentMap */15]);
	  if (match !== undefined) {
	    var match$1 = match !== parent;
	    if (match$1) {
	      return addToParent(parent, child, _removeFromParent(match, child, isKeepOrder, record));
	    } else {
	      return record;
	    }
	  } else {
	    return addToParent(parent, child, record);
	  }
	}

	function _setParent$1(parent, child, isKeepOrder, record) {
	  if (parent !== undefined) {
	    return _setNewParent(parent, child, isKeepOrder, record);
	  } else {
	    var match = unsafeGet$2(child, record[/* parentMap */15]);
	    if (match !== undefined) {
	      return _removeFromParent(match, child, isKeepOrder, record);
	    } else {
	      return record;
	    }
	  }
	}

	function setParent(parent, child, record) {
	  return markHierachyDirty(child, _setParent$1(parent, child, false, record));
	}

	function setParentNotMarkDirty(parent, child, record) {
	  return _setParent$1(parent, child, false, record);
	}

	function setParentKeepOrder(parent, child, record) {
	  return markHierachyDirty(child, _setParent$1(parent, child, true, record));
	}


	/* Log-WonderLog Not a pure module */

	function getBasicCameraViewComponent(uid, param) {
	  var basicCameraViewMap = param[/* basicCameraViewMap */23];
	  return getComponent(uid, basicCameraViewMap);
	}

	function unsafeGetBasicCameraViewComponent(uid, param) {
	  var basicCameraViewMap = param[/* basicCameraViewMap */23];
	  return unsafeGetComponent(uid, basicCameraViewMap);
	}

	function getPerspectiveCameraProjectionComponent(uid, param) {
	  var perspectiveCameraProjectionMap = param[/* perspectiveCameraProjectionMap */24];
	  return getComponent(uid, perspectiveCameraProjectionMap);
	}

	function unsafeGetPerspectiveCameraProjectionComponent(uid, param) {
	  var perspectiveCameraProjectionMap = param[/* perspectiveCameraProjectionMap */24];
	  return unsafeGetComponent(uid, perspectiveCameraProjectionMap);
	}

	function getArcballCameraControllerComponent(uid, param) {
	  var arcballCameraControllerMap = param[/* arcballCameraControllerMap */25];
	  return getComponent(uid, arcballCameraControllerMap);
	}

	function unsafeGetArcballCameraControllerComponent(uid, param) {
	  var arcballCameraControllerMap = param[/* arcballCameraControllerMap */25];
	  return unsafeGetComponent(uid, arcballCameraControllerMap);
	}

	function getTransformComponent(uid, param) {
	  var transformMap = param[/* transformMap */22];
	  return getComponent(uid, transformMap);
	}

	function unsafeGetTransformComponent(uid, param) {
	  var transformMap = param[/* transformMap */22];
	  return unsafeGetComponent(uid, transformMap);
	}

	function unsafeGetGeometryComponentData(uid, param) {
	  var geometryDataMap = param[/* geometryDataMap */21];
	  return unsafeGetComponentData(uid, geometryDataMap);
	}

	function getGeometryComponentData(uid, param) {
	  var geometryDataMap = param[/* geometryDataMap */21];
	  return getComponentData(uid, geometryDataMap);
	}

	function unsafeGetGeometryComponent(uid, param) {
	  var geometryDataMap = param[/* geometryDataMap */21];
	  return unsafeGetComponentData(uid, geometryDataMap)[0];
	}

	function getBasicMaterialComponent(uid, param) {
	  var basicMaterialMap = param[/* basicMaterialMap */27];
	  return getComponent(uid, basicMaterialMap);
	}

	function getLightMaterialComponent(uid, param) {
	  var lightMaterialMap = param[/* lightMaterialMap */28];
	  return getComponent(uid, lightMaterialMap);
	}

	function unsafeGetBasicMaterialComponent(uid, param) {
	  var basicMaterialMap = param[/* basicMaterialMap */27];
	  return unsafeGetComponent(uid, basicMaterialMap);
	}

	function unsafeGetLightMaterialComponent(uid, param) {
	  var lightMaterialMap = param[/* lightMaterialMap */28];
	  return unsafeGetComponent(uid, lightMaterialMap);
	}

	function getMeshRendererComponent(uid, param) {
	  var meshRendererMap = param[/* meshRendererMap */26];
	  return getComponent(uid, meshRendererMap);
	}

	function unsafeGetMeshRendererComponent(uid, param) {
	  var meshRendererMap = param[/* meshRendererMap */26];
	  return unsafeGetComponent(uid, meshRendererMap);
	}

	function getDirectionLightComponent(uid, param) {
	  var directionLightMap = param[/* directionLightMap */31];
	  return getComponent(uid, directionLightMap);
	}

	function unsafeGetDirectionLightComponent(uid, param) {
	  var directionLightMap = param[/* directionLightMap */31];
	  return unsafeGetComponent(uid, directionLightMap);
	}

	function getPointLightComponent(uid, param) {
	  var pointLightMap = param[/* pointLightMap */32];
	  return getComponent(uid, pointLightMap);
	}

	function unsafeGetPointLightComponent(uid, param) {
	  var pointLightMap = param[/* pointLightMap */32];
	  return unsafeGetComponent(uid, pointLightMap);
	}

	function getSourceInstanceComponent(uid, param) {
	  var sourceInstanceMap = param[/* sourceInstanceMap */29];
	  return getComponent(uid, sourceInstanceMap);
	}

	function unsafeGetSourceInstanceComponent(uid, param) {
	  var sourceInstanceMap = param[/* sourceInstanceMap */29];
	  return unsafeGetComponent(uid, sourceInstanceMap);
	}

	function unsafeGetObjectInstanceComponent(uid, param) {
	  var objectInstanceMap = param[/* objectInstanceMap */30];
	  return unsafeGetComponent(uid, objectInstanceMap);
	}


	/* ComponentMapService-Wonderjs Not a pure module */

	function getSceneGameObject$2(state) {
	  return getRecord(state)[/* sceneGameObject */2];
	}

	function addChild(childGameObject, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* transformRecord */12] = setParent(unsafeGetTransformComponent(getRecord(state)[/* sceneGameObject */2], gameObjectRecord), unsafeGetTransformComponent(childGameObject, gameObjectRecord), getRecord$1(state));
	  return newrecord;
	}

	function addChildren(childGameObjectArr, state) {
	  return reduceOneParam((function (state, childGameObject) {
	                return addChild(childGameObject, state);
	              }), state, childGameObjectArr);
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function getAmbientLightColor$2(state) {
	  return getRecord(state)[/* ambientLight */1][/* color */0];
	}

	function setAmbientLightColor$2(color, state) {
	  var newrecord = caml_array_dup(state);
	  var init = getRecord(state);
	  newrecord[/* sceneRecord */13] = /* record */[
	    /* currentCameraGameObject */init[/* currentCameraGameObject */0],
	    /* ambientLight : record */[/* color */color],
	    /* sceneGameObject */init[/* sceneGameObject */2]
	  ];
	  return newrecord;
	}


	/* RecordSceneMainService-Wonderjs Not a pure module */

	function getCurrentCameraGameObject$1(state) {
	  return getCurrentCameraGameObject$2(state[/* basicCameraViewRecord */14], getRecord(state));
	}

	function setCurrentCameraGameObject$1(uid, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* sceneRecord */13] = setCurrentCameraGameObject$2(uid, getRecord(state));
	  return newrecord;
	}

	var getAmbientLightColor$1 = getAmbientLightColor$2;

	var setAmbientLightColor$1 = setAmbientLightColor$2;

	var getSceneGameObject$1 = getSceneGameObject$2;

	var addSceneChild$1 = addChild;

	var addSceneChildren$1 = addChildren;


	/* CameraSceneMainService-Wonderjs Not a pure module */

	function getUnsafeGetStateFunc(state) {
	  return state[/* stateRecord */0][/* unsafeGetStateFunc */0];
	}

	function setUnsafeGetStateFunc$2(unsafeGetStateFunc, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* stateRecord */0];
	  newrecord[/* stateRecord */0] = /* record */[
	    /* unsafeGetStateFunc */unsafeGetStateFunc,
	    /* setStateFunc */init[/* setStateFunc */1]
	  ];
	  return newrecord;
	}

	function getSetStateFunc(state) {
	  return state[/* stateRecord */0][/* setStateFunc */1];
	}

	function setSetStateFunc$2(setStateFunc, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* stateRecord */0];
	  newrecord[/* stateRecord */0] = /* record */[
	    /* unsafeGetStateFunc */init[/* unsafeGetStateFunc */0],
	    /* setStateFunc */setStateFunc
	  ];
	  return newrecord;
	}


	/* No side effect */

	function unsafeGetState$2(stateData) {
	  return unsafeGet$1(stateData[/* state */0]);
	}

	function setState$2(stateData, state) {
	  stateData[/* state */0] = state;
	  return state;
	}

	function unsafeGetStateByFunc(state) {
	  return getUnsafeGetStateFunc(state)();
	}

	function setStateByFunc(state) {
	  var setStateFunc = getSetStateFunc(state);
	  return setStateFunc(state);
	}


	/* OptionService-Wonderjs Not a pure module */

	function create$14() {
	  return /* record */[
	          /* noWorkerInitJobList : [] */0,
	          /* noWorkerLoopJobList : [] */0,
	          /* workerCustomMainInitTargetJobMap */createEmpty(/* () */0),
	          /* workerCustomMainInitSourceJobMap */createEmpty(/* () */0),
	          /* workerCustomMainInitRemovedDefaultJobMap */createEmpty(/* () */0),
	          /* workerCustomMainLoopTargetJobMap */createEmpty(/* () */0),
	          /* workerCustomMainLoopSourceJobMap */createEmpty(/* () */0),
	          /* workerCustomMainLoopRemovedDefaultJobMap */createEmpty(/* () */0)
	        ];
	}


	/* HashMapService-WonderCommonlib Not a pure module */

	function create$15() {
	  return /* record */[/* precision */undefined];
	}

	function deepCopyForRestore$9(param) {
	  var precision = param[/* precision */0];
	  return /* record */[/* precision */precision];
	}


	/* No side effect */

	function create$16() {
	  return /* record */[/* canvas */undefined];
	}


	/* No side effect */

	function getChunk(name, glslChunkRecord) {
	  return getExn(get(name, glslChunkRecord[/* chunkMap */0]));
	}

	function _buildChunk(param, varDeclare, param$1, body) {
	  return /* record */[
	          /* top */param[0],
	          /* define */param[1],
	          /* varDeclare */varDeclare,
	          /* funcDeclare */param$1[0],
	          /* funcDefine */param$1[1],
	          /* body */body
	        ];
	}

	function create$17() {
	  return /* record */[/* chunkMap */set("webgl1_basic_map_fragment", _buildChunk(/* tuple */[
	                    "\n\n",
	                    "\n\n"
	                  ], "\nvarying vec2 v_mapCoord0;\n", /* tuple */[
	                    "\n\n",
	                    "\n\n"
	                  ], "\nvec4 totalColor = vec4(texture2D(u_mapSampler, v_mapCoord0).rgb * u_color, 1.0);\n"), set("webgl1_basic_map_vertex", _buildChunk(/* tuple */[
	                        "\n\n",
	                        "\n\n"
	                      ], "\nvarying vec2 v_mapCoord0;\n", /* tuple */[
	                        "\n\n",
	                        "\n\n"
	                      ], "\n//    vec2 sourceTexCoord0 = a_texCoord * u_map0SourceRegion.zw + u_map0SourceRegion.xy;\n//\n//    v_mapCoord0 = sourceTexCoord0 * u_map0RepeatRegion.zw + u_map0RepeatRegion.xy;\n\n    v_mapCoord0 = a_texCoord;\n"), set("webgl1_no_basic_map_fragment", _buildChunk(/* tuple */[
	                            "\n\n",
	                            "\n\n"
	                          ], "\n\n", /* tuple */[
	                            "\n\n",
	                            "\n\n"
	                          ], "\nvec4 totalColor = vec4(u_color, 1.0);\n"), set("webgl1_basic_end_fragment", _buildChunk(/* tuple */[
	                                "\n\n",
	                                "\n\n"
	                              ], "\n\n", /* tuple */[
	                                "\n\n",
	                                "\n\n"
	                              ], "\ngl_FragColor = vec4(totalColor.rgb, totalColor.a);\n"), set("webgl1_basic_vertex", _buildChunk(/* tuple */[
	                                    "\n\n",
	                                    "\n\n"
	                                  ], "\n\n", /* tuple */[
	                                    "\n\n",
	                                    "\n\n"
	                                  ], "\ngl_Position = u_pMatrix * u_vMatrix * mMatrix * vec4(a_position, 1.0);\n"), set("common_define", _buildChunk(/* tuple */[
	                                        "\n\n",
	                                        "\n\n"
	                                      ], "\n\n", /* tuple */[
	                                        "\n\n",
	                                        "\n\n"
	                                      ], "\n\n"), set("common_fragment", _buildChunk(/* tuple */[
	                                            "\n\n",
	                                            "\n\n"
	                                          ], "\n\n", /* tuple */[
	                                            "\n\n",
	                                            "\n\n"
	                                          ], "\n\n"), set("common_function", _buildChunk(/* tuple */[
	                                                "\n\n",
	                                                "\n\n"
	                                              ], "\n\n", /* tuple */[
	                                                "\n\n",
	                                                "\n// mat2 transpose(mat2 m) {\n//   return mat2(  m[0][0], m[1][0],   // new col 0\n//                 m[0][1], m[1][1]    // new col 1\n//              );\n//   }\n\n// mat3 transpose(mat3 m) {\n//   return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n//                 m[0][1], m[1][1], m[2][1],  // new col 1\n//                 m[0][2], m[1][2], m[2][2]   // new col 1\n//              );\n//   }\n\n//bool isRenderArrayEmpty(int isRenderArrayEmpty){\n//  return isRenderArrayEmpty == 1;\n//}\n"
	                                              ], "\n\n"), set("common_vertex", _buildChunk(/* tuple */[
	                                                    "\n\n",
	                                                    "\n\n"
	                                                  ], "\n\n", /* tuple */[
	                                                    "\n\n",
	                                                    "\n// mat2 transpose(mat2 m) {\n//   return mat2(  m[0][0], m[1][0],   // new col 0\n//                 m[0][1], m[1][1]    // new col 1\n//              );\n//   }\n\n// mat3 transpose(mat3 m) {\n//   return mat3(  m[0][0], m[1][0], m[2][0],  // new col 0\n//                 m[0][1], m[1][1], m[2][1],  // new col 1\n//                 m[0][2], m[1][2], m[2][2]   // new col 1\n//              );\n//   }\n\n//bool isRenderArrayEmpty(int isRenderArrayEmpty){\n//  return isRenderArrayEmpty == 1;\n//}\n"
	                                                  ], "\n\n"), set("highp_fragment", _buildChunk(/* tuple */[
	                                                        "\nprecision highp float;\nprecision highp int;\n",
	                                                        "\n\n"
	                                                      ], "\n\n", /* tuple */[
	                                                        "\n\n",
	                                                        "\n\n"
	                                                      ], "\n\n"), set("lowp_fragment", _buildChunk(/* tuple */[
	                                                            "\nprecision lowp float;\nprecision lowp int;\n",
	                                                            "\n\n"
	                                                          ], "\n\n", /* tuple */[
	                                                            "\n\n",
	                                                            "\n\n"
	                                                          ], "\n\n"), set("mediump_fragment", _buildChunk(/* tuple */[
	                                                                "\nprecision mediump float;\nprecision mediump int;\n",
	                                                                "\n\n"
	                                                              ], "\n\n", /* tuple */[
	                                                                "\n\n",
	                                                                "\n\n"
	                                                              ], "\n\n"), set("webgl1_setPos_mvp", _buildChunk(/* tuple */[
	                                                                    "\n\n",
	                                                                    "\n\n"
	                                                                  ], "\n\n", /* tuple */[
	                                                                    "\n\n",
	                                                                    "\n\n"
	                                                                  ], "\ngl_Position = u_pMatrix * u_vMatrix * mMatrix * vec4(a_position, 1.0);\n"), set("modelMatrix_batch_instance_vertex", _buildChunk(/* tuple */[
	                                                                        "\n\n",
	                                                                        "\n\n"
	                                                                      ], "\n\n", /* tuple */[
	                                                                        "\n\n",
	                                                                        "\n\n"
	                                                                      ], "\nmat4 mMatrix = u_mMatrix;\n"), set("normalMatrix_batch_instance_vertex", _buildChunk(/* tuple */[
	                                                                            "\n\n",
	                                                                            "\n\n"
	                                                                          ], "\n\n", /* tuple */[
	                                                                            "\n\n",
	                                                                            "\n\n"
	                                                                          ], "\nmat3 normalMatrix = u_normalMatrix;\n"), set("modelMatrix_hardware_instance_vertex", _buildChunk(/* tuple */[
	                                                                                "\n\n",
	                                                                                "\n\n"
	                                                                              ], "\n\n", /* tuple */[
	                                                                                "\n\n",
	                                                                                "\n\n"
	                                                                              ], "\nmat4 mMatrix = mat4(a_mVec4_0, a_mVec4_1, a_mVec4_2, a_mVec4_3);\n"), set("normalMatrix_hardware_instance_vertex", _buildChunk(/* tuple */[
	                                                                                    "\n\n",
	                                                                                    "\n\n"
	                                                                                  ], "\n\n", /* tuple */[
	                                                                                    "\n\n",
	                                                                                    "\n\n"
	                                                                                  ], "\nmat3 normalMatrix = mat3(a_normalVec3_0, a_normalVec3_1, a_normalVec3_2);\n"), set("modelMatrix_noInstance_vertex", _buildChunk(/* tuple */[
	                                                                                        "\n\n",
	                                                                                        "\n\n"
	                                                                                      ], "\n\n", /* tuple */[
	                                                                                        "\n\n",
	                                                                                        "\n\n"
	                                                                                      ], "\nmat4 mMatrix = u_mMatrix;\n"), set("normalMatrix_noInstance_vertex", _buildChunk(/* tuple */[
	                                                                                            "\n\n",
	                                                                                            "\n\n"
	                                                                                          ], "\n\n", /* tuple */[
	                                                                                            "\n\n",
	                                                                                            "\n\n"
	                                                                                          ], "\nmat3 normalMatrix = u_normalMatrix;\n"), set("webgl1_diffuse_map_fragment", _buildChunk(/* tuple */[
	                                                                                                "\n\n",
	                                                                                                "\n\n"
	                                                                                              ], "\nvarying vec2 v_diffuseMapTexCoord;\n", /* tuple */[
	                                                                                                "\n\n",
	                                                                                                "\nvec3 getMaterialDiffuse() {\n        return texture2D(u_diffuseMapSampler, v_diffuseMapTexCoord).rgb * u_diffuse;\n    }\n"
	                                                                                              ], "\n\n"), set("webgl1_diffuse_map_vertex", _buildChunk(/* tuple */[
	                                                                                                    "\n\n",
	                                                                                                    "\n\n"
	                                                                                                  ], "\nvarying vec2 v_diffuseMapTexCoord;\n", /* tuple */[
	                                                                                                    "\n\n",
	                                                                                                    "\n\n"
	                                                                                                  ], "\n//TODO optimize(combine, reduce compute numbers)\n    //TODO BasicTexture extract textureMatrix\n//    vec2 sourceTexCoord = a_texCoord * u_diffuseMapSourceRegion.zw + u_diffuseMapSourceRegion.xy;\n//    v_diffuseMapTexCoord = sourceTexCoord * u_diffuseMapRepeatRegion.zw + u_diffuseMapRepeatRegion.xy;\n\n    v_diffuseMapTexCoord = a_texCoord;\n"), set("webgl1_no_diffuse_map_fragment", _buildChunk(/* tuple */[
	                                                                                                        "\n\n",
	                                                                                                        "\n\n"
	                                                                                                      ], "\n\n", /* tuple */[
	                                                                                                        "\n\n",
	                                                                                                        "\nvec3 getMaterialDiffuse() {\n        return u_diffuse;\n    }\n"
	                                                                                                      ], "\n\n"), set("webgl1_no_emission_map_fragment", _buildChunk(/* tuple */[
	                                                                                                            "\n\n",
	                                                                                                            "\n\n"
	                                                                                                          ], "\n\n", /* tuple */[
	                                                                                                            "\n\n",
	                                                                                                            "\nvec3 getMaterialEmission() {\n        return vec3(0.0);\n    }\n"
	                                                                                                          ], "\n\n"), set("webgl1_no_light_map_fragment", _buildChunk(/* tuple */[
	                                                                                                                "\n\n",
	                                                                                                                "\n\n"
	                                                                                                              ], "\n\n", /* tuple */[
	                                                                                                                "\n\n",
	                                                                                                                "\nvec3 getMaterialLight() {\n        return vec3(0.0);\n    }\n"
	                                                                                                              ], "\n\n"), set("webgl1_no_normal_map_fragment", _buildChunk(/* tuple */[
	                                                                                                                    "\n\n",
	                                                                                                                    "\n\n"
	                                                                                                                  ], "\nvarying vec3 v_normal;\n", /* tuple */[
	                                                                                                                    "\nvec3 getNormal();\n",
	                                                                                                                    "\nvec3 getNormal(){\n    return v_normal;\n}\n\n#if POINT_LIGHTS_COUNT > 0\nvec3 getPointLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= POINT_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getPointLightDirByLightPos(u_pointLights[x].position);\n        }\n    }\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n#if DIRECTION_LIGHTS_COUNT > 0\nvec3 getDirectionLightDir(int index){\n    //workaround '[] : Index expression must be constant' error\n    for (int x = 0; x <= DIRECTION_LIGHTS_COUNT; x++) {\n        if(x == index){\n            return getDirectionLightDir(u_directionLights[x].direction);\n        }\n    }\n\n    /*!\n    solve error in window7 chrome/firefox:\n    not all control paths return a value.\n    failed to create d3d shaders\n    */\n    return vec3(0.0);\n}\n#endif\n\n\nvec3 getViewDir(){\n    return normalize(u_cameraPos - v_worldPosition);\n}\n"
	                                                                                                                  ], "\n\n"), set("webgl1_no_normal_map_vertex", _buildChunk(/* tuple */[
	                                                                                                                        "\n\n",
	                                                                                                                        "\n\n"
	                                                                                                                      ], "\nvarying vec3 v_normal;\n", /* tuple */[
	                                                                                                                        "\n\n",
	                                                                                                                        "\n\n"
	                                                                                                                      ], "\nv_normal = normalize(normalMatrix * a_normal);\n"), set("webgl1_no_shadow_map_fragment", _buildChunk(/* tuple */[
	                                                                                                                            "\n\n",
	                                                                                                                            "\n\n"
	                                                                                                                          ], "\n\n", /* tuple */[
	                                                                                                                            "\n\n",
	                                                                                                                            "\nfloat getShadowVisibility() {\n        return 1.0;\n    }\n"
	                                                                                                                          ], "\n\n"), set("webgl1_no_specular_map_fragment", _buildChunk(/* tuple */[
	                                                                                                                                "\n\n",
	                                                                                                                                "\n\n"
	                                                                                                                              ], "\n\n", /* tuple */[
	                                                                                                                                "\n\n",
	                                                                                                                                "\nfloat getSpecularStrength() {\n        return 1.0;\n    }\n"
	                                                                                                                              ], "\n\n"), set("webgl1_specular_map_fragment", _buildChunk(/* tuple */[
	                                                                                                                                    "\n\n",
	                                                                                                                                    "\n\n"
	                                                                                                                                  ], "\nvarying vec2 v_specularMapTexCoord;\n", /* tuple */[
	                                                                                                                                    "\n\n",
	                                                                                                                                    "\nfloat getSpecularStrength() {\n        return texture2D(u_specularMapSampler, v_specularMapTexCoord).r;\n    }\n"
	                                                                                                                                  ], "\n\n"), set("webgl1_specular_map_vertex", _buildChunk(/* tuple */[
	                                                                                                                                        "\n\n",
	                                                                                                                                        "\n\n"
	                                                                                                                                      ], "\nvarying vec2 v_specularMapTexCoord;\n", /* tuple */[
	                                                                                                                                        "\n\n",
	                                                                                                                                        "\n\n"
	                                                                                                                                      ], "\nv_specularMapTexCoord = a_texCoord;\n"), set("webgl1_ambientLight_fragment", _buildChunk(/* tuple */[
	                                                                                                                                            "\n\n",
	                                                                                                                                            "\n\n"
	                                                                                                                                          ], "\nuniform vec3 u_ambient;\n", /* tuple */[
	                                                                                                                                            "\n\n",
	                                                                                                                                            "\n\n"
	                                                                                                                                          ], "\n\n"), set("webgl1_frontLight_common_fragment", _buildChunk(/* tuple */[
	                                                                                                                                                "\n\n",
	                                                                                                                                                "\n\n"
	                                                                                                                                              ], "\nvarying vec3 v_worldPosition;\n\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\nstruct DirectionLight {\n    vec3 direction;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", /* tuple */[
	                                                                                                                                                "\nvec3 getDirectionLightDir(vec3 lightDirection);\nvec3 getPointLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition);\n",
	                                                                                                                                                "\nvec3 getDirectionLightDir(vec3 lightDirection){\n    lightDirection =  normalize(lightDirection);\n\n    return -lightDirection;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos){\n    return lightPos - v_worldPosition;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n"
	                                                                                                                                              ], "\n\n"), set("webgl1_frontLight_common_vertex", _buildChunk(/* tuple */[
	                                                                                                                                                    "\n\n",
	                                                                                                                                                    "\n\n"
	                                                                                                                                                  ], "\nvarying vec3 v_worldPosition;\n\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\nstruct DirectionLight {\n    vec3 direction;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", /* tuple */[
	                                                                                                                                                    "\nvec3 getDirectionLightDir(vec3 lightDirection);\nvec3 getPointLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition);\n",
	                                                                                                                                                    "\nvec3 getDirectionLightDir(vec3 lightDirection){\n    lightDirection =  normalize(lightDirection);\n\n    return -lightDirection;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos){\n    return lightPos - v_worldPosition;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n"
	                                                                                                                                                  ], "\n\n"), set("webgl1_frontLight_common", _buildChunk(/* tuple */[
	                                                                                                                                                        "\n\n",
	                                                                                                                                                        "\n\n"
	                                                                                                                                                      ], "\nvarying vec3 v_worldPosition;\n\n#if POINT_LIGHTS_COUNT > 0\nstruct PointLight {\n    vec3 position;\n    vec3 color;\n    float intensity;\n\n    float range;\n    float constant;\n    float linear;\n    float quadratic;\n};\nuniform PointLight u_pointLights[POINT_LIGHTS_COUNT];\n\n#endif\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\nstruct DirectionLight {\n    vec3 direction;\n\n    float intensity;\n\n    vec3 color;\n};\nuniform DirectionLight u_directionLights[DIRECTION_LIGHTS_COUNT];\n#endif\n", /* tuple */[
	                                                                                                                                                        "\nvec3 getDirectionLightDir(vec3 lightDirection);\nvec3 getPointLightDirByLightPos(vec3 lightPos);\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition);\n",
	                                                                                                                                                        "\nvec3 getDirectionLightDir(vec3 lightDirection){\n    lightDirection =  normalize(lightDirection);\n\n    return -lightDirection;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos){\n    return lightPos - v_worldPosition;\n}\nvec3 getPointLightDirByLightPos(vec3 lightPos, vec3 worldPosition){\n    return lightPos - worldPosition;\n}\n"
	                                                                                                                                                      ], "\n\n"), set("webgl1_frontLight_end_fragment", _buildChunk(/* tuple */[
	                                                                                                                                                            "\n\n",
	                                                                                                                                                            "\n\n"
	                                                                                                                                                          ], "\n\n", /* tuple */[
	                                                                                                                                                            "\n\n",
	                                                                                                                                                            "\n\n"
	                                                                                                                                                          ], "\ngl_FragColor = totalColor;\n"), set("webgl1_frontLight_fragment", _buildChunk(/* tuple */[
	                                                                                                                                                                "\n\n",
	                                                                                                                                                                "\n\n"
	                                                                                                                                                              ], "\n\n", /* tuple */[
	                                                                                                                                                                "\n\n",
	                                                                                                                                                                "\nfloat getBlinnShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n        vec3 halfAngle = normalize(lightDir + viewDir);\n\n        float blinnTerm = dot(normal, halfAngle);\n\n        blinnTerm = clamp(blinnTerm, 0.0, 1.0);\n        blinnTerm = dotResultBetweenNormAndLight != 0.0 ? blinnTerm : 0.0;\n        blinnTerm = pow(blinnTerm, shininess);\n\n        return blinnTerm;\n}\n\n// float getPhongShininess(float shininess, vec3 normal, vec3 lightDir, vec3 viewDir, float dotResultBetweenNormAndLight){\n//         vec3 reflectDir = reflect(-lightDir, normal);\n//         float phongTerm = dot(viewDir, reflectDir);\n\n//         phongTerm = clamp(phongTerm, 0.0, 1.0);\n//         phongTerm = dotResultBetweenNormAndLight != 0.0 ? phongTerm : 0.0;\n//         phongTerm = pow(phongTerm, shininess);\n\n//         return phongTerm;\n// }\n\nvec3 calcAmbientColor(vec3 materialDiffuse){\n        vec3 materialLight = getMaterialLight();\n\n        return (u_ambient + materialLight) * materialDiffuse.rgb;\n}\n\nvec3 calcLight(vec3 lightDir, vec3 color, float intensity, float attenuation, vec3 normal, vec3 viewDir)\n{\n        vec3 materialDiffuse = getMaterialDiffuse();\n        vec3 materialSpecular = u_specular;\n        vec3 materialEmission = getMaterialEmission();\n\n        float specularStrength = getSpecularStrength();\n\n        float dotResultBetweenNormAndLight = dot(normal, lightDir);\n        float diff = max(dotResultBetweenNormAndLight, 0.0);\n\n        vec3 emissionColor = materialEmission;\n\n        vec3 ambientColor = calcAmbientColor(materialDiffuse);\n\n\n        // if(u_lightModel == 3){\n        //     return emissionColor + ambientColor;\n        // }\n\n//        vec4 diffuseColor = vec4(color * materialDiffuse.rgb * diff * intensity, materialDiffuse.a);\n        vec3 diffuseColor = color * materialDiffuse.rgb * diff * intensity;\n\n        float spec = 0.0;\n\n        // if(u_lightModel == 2){\n        //         spec = getPhongShininess(u_shininess, normal, lightDir, viewDir, diff);\n        // }\n        // else if(u_lightModel == 1){\n        //         spec = getBlinnShininess(u_shininess, normal, lightDir, viewDir, diff);\n        // }\n\n        spec = getBlinnShininess(u_shininess, normal, lightDir, viewDir, diff);\n\n\n        vec3 specularColor = spec * materialSpecular * specularStrength * intensity;\n\n//        return vec4(emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor), diffuseColor.a);\n        return emissionColor + ambientColor + attenuation * (diffuseColor.rgb + specularColor);\n}\n\n\n\n\n#if POINT_LIGHTS_COUNT > 0\n        vec3 calcPointLight(vec3 lightDir, PointLight light, vec3 normal, vec3 viewDir)\n{\n        //lightDir is not normalize computing distance\n        float distance = length(lightDir);\n\n        float attenuation = 0.0;\n\n        if(distance < light.range)\n        {\n            attenuation = 1.0 / (light.constant + light.linear * distance + light.quadratic * (distance * distance));\n        }\n\n        lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\n#if DIRECTION_LIGHTS_COUNT > 0\n        vec3 calcDirectionLight(vec3 lightDir, DirectionLight light, vec3 normal, vec3 viewDir)\n{\n        float attenuation = 1.0;\n\n        // lightDir = normalize(lightDir);\n\n        return calcLight(lightDir, light.color, light.intensity, attenuation, normal, viewDir);\n}\n#endif\n\n\n\nvec4 calcTotalLight(vec3 norm, vec3 viewDir){\n    vec4 totalLight = vec4(0.0, 0.0, 0.0, 1.0);\n\n\n    #if (DIRECTION_LIGHTS_COUNT == 0 && POINT_LIGHTS_COUNT == 0 )\n        return vec4(calcAmbientColor(getMaterialDiffuse()), 1.0);\n    #endif\n\n\n    #if POINT_LIGHTS_COUNT > 0\n                for(int i = 0; i < POINT_LIGHTS_COUNT; i++){\n                totalLight += vec4(calcPointLight(getPointLightDir(i), u_pointLights[i], norm, viewDir), 0.0);\n        }\n    #endif\n\n    #if DIRECTION_LIGHTS_COUNT > 0\n                for(int i = 0; i < DIRECTION_LIGHTS_COUNT; i++){\n                totalLight += vec4(calcDirectionLight(getDirectionLightDir(i), u_directionLights[i], norm, viewDir), 0.0);\n        }\n    #endif\n\n        return totalLight;\n}\n"
	                                                                                                                                                              ], "\nvec3 normal = normalize(getNormal());\n\n// #ifdef BOTH_SIdE\n// normal = normal * (-1.0 + 2.0 * float(gl_FrontFacing));\n// #endif\n\nvec3 viewDir = normalize(getViewDir());\n\nvec4 totalColor = calcTotalLight(normal, viewDir);\n\n// totalColor.a *= u_opacity;\n\ntotalColor.rgb = totalColor.rgb * getShadowVisibility();\n"), set("webgl1_frontLight_setWorldPosition_vertex", _buildChunk(/* tuple */[
	                                                                                                                                                                    "\n\n",
	                                                                                                                                                                    "\n\n"
	                                                                                                                                                                  ], "\n\n", /* tuple */[
	                                                                                                                                                                    "\n\n",
	                                                                                                                                                                    "\n\n"
	                                                                                                                                                                  ], "\nv_worldPosition = vec3(mMatrix * vec4(a_position, 1.0));\n"), set("webgl1_frontLight_vertex", _buildChunk(/* tuple */[
	                                                                                                                                                                        "\n\n",
	                                                                                                                                                                        "\n\n"
	                                                                                                                                                                      ], "\n\n", /* tuple */[
	                                                                                                                                                                        "\n\n",
	                                                                                                                                                                        "\n\n"
	                                                                                                                                                                      ], "\ngl_Position = u_pMatrix * u_vMatrix * vec4(v_worldPosition, 1.0);\n"), createEmpty(/* () */0)))))))))))))))))))))))))))))))))))))))];
	}


	/* HashMapService-WonderCommonlib Not a pure module */

	function copy$4(map$$1) {
	  return reduceOneParam((function (newMap, param) {
	                return set(param[0], param[1], newMap);
	              }), createEmpty(/* () */0), entries(map$$1));
	}


	/* Js_dict Not a pure module */

	function create$18() {
	  return /* record */[
	          /* index */0,
	          /* shaderIndexMap */createEmpty(/* () */0),
	          /* usedShaderIndexArray : array */[]
	        ];
	}

	function deepCopyForRestore$10(param) {
	  var index = param[/* index */0];
	  var shaderIndexMap = param[/* shaderIndexMap */1];
	  var usedShaderIndexArray = param[/* usedShaderIndexArray */2];
	  return /* record */[
	          /* index */index,
	          /* shaderIndexMap */copy$4(shaderIndexMap),
	          /* usedShaderIndexArray */usedShaderIndexArray.slice()
	        ];
	}


	/* HashMapService-Wonderjs Not a pure module */

	function iter$1(x, f) {
	  if (x == null) {
	    return /* () */0;
	  } else {
	    return f(x);
	  }
	}


	/* No side effect */

	function checkComponentShouldAlive$1(component, isAliveFunc, record) {
	  return test(buildAssertMessage("component alive", "not"), (function () {
	                return assertTrue(_2(isAliveFunc, component, record));
	              }));
	}


	/* Log-WonderLog Not a pure module */

	function unsafeGetGameObject$6(transform, param) {
	  var gameObjectMap = param[/* gameObjectMap */17];
	  return unsafeGetGameObject$1(transform, gameObjectMap);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getDegToRad() {
	  return Math.PI / 180;
	}

	function getRadToDeg() {
	  return 180 / Math.PI;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	function createIdentityMatrix4$1() {
	  return new Float32Array(/* array */[
	              1,
	              0,
	              0,
	              0,
	              0,
	              1,
	              0,
	              0,
	              0,
	              0,
	              1,
	              0,
	              0,
	              0,
	              0,
	              1
	            ]);
	}

	function ortho(left, right, bottom, top, near, far, resultFloat32Arr) {
	  var lr = 1 / (left - right);
	  var bt = 1 / (bottom - top);
	  var nf = 1 / (near - far);
	  resultFloat32Arr[0] = -2 * lr;
	  resultFloat32Arr[1] = 0;
	  resultFloat32Arr[2] = 0;
	  resultFloat32Arr[3] = 0;
	  resultFloat32Arr[4] = 0;
	  resultFloat32Arr[5] = -2 * bt;
	  resultFloat32Arr[6] = 0;
	  resultFloat32Arr[7] = 0;
	  resultFloat32Arr[8] = 0;
	  resultFloat32Arr[9] = 0;
	  resultFloat32Arr[10] = 2 * nf;
	  resultFloat32Arr[11] = 0;
	  resultFloat32Arr[12] = (left + right) * lr;
	  resultFloat32Arr[13] = (top + bottom) * bt;
	  resultFloat32Arr[14] = (far + near) * nf;
	  resultFloat32Arr[15] = 1;
	  return resultFloat32Arr;
	}


	/* No side effect */

	function createIdentityMatrix4() {
	  return createIdentityMatrix4$1(/* () */0);
	}

	function fromTranslationRotationScale(param, param$1, param$2, resultFloat32Arr) {
	  var sz = param$2[2];
	  var sy = param$2[1];
	  var sx = param$2[0];
	  var w = param$1[3];
	  var z = param$1[2];
	  var y = param$1[1];
	  var x = param$1[0];
	  var x2 = x + x;
	  var y2 = y + y;
	  var z2 = z + z;
	  var xx = x * x2;
	  var xy = x * y2;
	  var xz = x * z2;
	  var yy = y * y2;
	  var yz = y * z2;
	  var zz = z * z2;
	  var wx = w * x2;
	  var wy = w * y2;
	  var wz = w * z2;
	  resultFloat32Arr[0] = (1 - (yy + zz)) * sx;
	  resultFloat32Arr[1] = (xy + wz) * sx;
	  resultFloat32Arr[2] = (xz - wy) * sx;
	  resultFloat32Arr[3] = 0;
	  resultFloat32Arr[4] = (xy - wz) * sy;
	  resultFloat32Arr[5] = (1 - (xx + zz)) * sy;
	  resultFloat32Arr[6] = (yz + wx) * sy;
	  resultFloat32Arr[7] = 0;
	  resultFloat32Arr[8] = (xz + wy) * sz;
	  resultFloat32Arr[9] = (yz - wx) * sz;
	  resultFloat32Arr[10] = (1 - (xx + yy)) * sz;
	  resultFloat32Arr[11] = 0;
	  resultFloat32Arr[12] = param[0];
	  resultFloat32Arr[13] = param[1];
	  resultFloat32Arr[14] = param[2];
	  resultFloat32Arr[15] = 1;
	  return resultFloat32Arr;
	}

	function getX(matTypeArr) {
	  return /* tuple */[
	          matTypeArr[0],
	          matTypeArr[1],
	          matTypeArr[2]
	        ];
	}

	function getY(matTypeArr) {
	  return /* tuple */[
	          matTypeArr[4],
	          matTypeArr[5],
	          matTypeArr[6]
	        ];
	}

	function getTranslationTuple(matTypeArr) {
	  return /* tuple */[
	          matTypeArr[12],
	          matTypeArr[13],
	          matTypeArr[14]
	        ];
	}

	function getRotationTuple(matTypeArr) {
	  var trace = matTypeArr[0] + matTypeArr[5] + matTypeArr[10];
	  if (trace > 0) {
	    var s = Math.sqrt(trace + 1.0) * 2;
	    return /* tuple */[
	            (matTypeArr[6] - matTypeArr[9]) / s,
	            (matTypeArr[8] - matTypeArr[2]) / s,
	            (matTypeArr[1] - matTypeArr[4]) / s,
	            0.25 * s
	          ];
	  } else if (matTypeArr[0] > matTypeArr[5] && matTypeArr[0] > matTypeArr[10]) {
	    var s$1 = Math.sqrt(1.0 + matTypeArr[0] - matTypeArr[5] - matTypeArr[10]) * 2;
	    return /* tuple */[
	            0.25 * s$1,
	            (matTypeArr[1] + matTypeArr[4]) / s$1,
	            (matTypeArr[8] + matTypeArr[2]) / s$1,
	            (matTypeArr[6] - matTypeArr[9]) / s$1
	          ];
	  } else if (matTypeArr[5] > matTypeArr[10]) {
	    var s$2 = Math.sqrt(1.0 + matTypeArr[5] - matTypeArr[0] - matTypeArr[10]) * 2;
	    return /* tuple */[
	            (matTypeArr[1] + matTypeArr[4]) / s$2,
	            0.25 * s$2,
	            (matTypeArr[6] + matTypeArr[9]) / s$2,
	            (matTypeArr[8] - matTypeArr[2]) / s$2
	          ];
	  } else {
	    var s$3 = Math.sqrt(1.0 + matTypeArr[10] - matTypeArr[0] - matTypeArr[5]) * 2;
	    return /* tuple */[
	            (matTypeArr[8] + matTypeArr[2]) / s$3,
	            (matTypeArr[6] + matTypeArr[9]) / s$3,
	            0.25 * s$3,
	            (matTypeArr[1] - matTypeArr[4]) / s$3
	          ];
	  }
	}

	function getScaleTuple(matTypeArr) {
	  var m11 = matTypeArr[0];
	  var m12 = matTypeArr[1];
	  var m13 = matTypeArr[2];
	  var m21 = matTypeArr[4];
	  var m22 = matTypeArr[5];
	  var m23 = matTypeArr[6];
	  var m31 = matTypeArr[8];
	  var m32 = matTypeArr[9];
	  var m33 = matTypeArr[10];
	  return /* tuple */[
	          Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13),
	          Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23),
	          Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33)
	        ];
	}

	function getEulerAngles(matTypeArr) {
	  var match = getScaleTuple(matTypeArr);
	  var sy = match[1];
	  var sx = match[0];
	  var a00 = matTypeArr[0];
	  var a01 = matTypeArr[1];
	  var a02 = matTypeArr[2];
	  var a10 = matTypeArr[4];
	  var a11 = matTypeArr[5];
	  var a12 = matTypeArr[6];
	  var a22 = matTypeArr[10];
	  var y = Math.asin(-a02 / sx);
	  var halfPi = Math.PI * 0.5;
	  var x = 0;
	  var z = 0;
	  if (y < halfPi) {
	    if (y > -halfPi) {
	      x = Math.atan2(a12 / sy, a22 / match[2]);
	      z = Math.atan2(a01 / sx, a00 / sx);
	    } else {
	      z = 0;
	      x = -Math.atan2(a11 / sy, a10 / sy);
	    }
	  } else {
	    z = 0;
	    x = Math.atan2(a11 / sy, a10 / sy);
	  }
	  return scale(/* Float */0, getRadToDeg(/* () */0), /* tuple */[
	              x,
	              y,
	              z
	            ]);
	}

	function multiply$1(aMatTypeArr, bMatTypeArr, resultFloat32Arr) {
	  var a00 = aMatTypeArr[0];
	  var a01 = aMatTypeArr[1];
	  var a02 = aMatTypeArr[2];
	  var a03 = aMatTypeArr[3];
	  var a10 = aMatTypeArr[4];
	  var a11 = aMatTypeArr[5];
	  var a12 = aMatTypeArr[6];
	  var a13 = aMatTypeArr[7];
	  var a20 = aMatTypeArr[8];
	  var a21 = aMatTypeArr[9];
	  var a22 = aMatTypeArr[10];
	  var a23 = aMatTypeArr[11];
	  var a30 = aMatTypeArr[12];
	  var a31 = aMatTypeArr[13];
	  var a32 = aMatTypeArr[14];
	  var a33 = aMatTypeArr[15];
	  var b0 = bMatTypeArr[0];
	  var b1 = bMatTypeArr[1];
	  var b2 = bMatTypeArr[2];
	  var b3 = bMatTypeArr[3];
	  resultFloat32Arr[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = bMatTypeArr[4];
	  b1 = bMatTypeArr[5];
	  b2 = bMatTypeArr[6];
	  b3 = bMatTypeArr[7];
	  resultFloat32Arr[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = bMatTypeArr[8];
	  b1 = bMatTypeArr[9];
	  b2 = bMatTypeArr[10];
	  b3 = bMatTypeArr[11];
	  resultFloat32Arr[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  b0 = bMatTypeArr[12];
	  b1 = bMatTypeArr[13];
	  b2 = bMatTypeArr[14];
	  b3 = bMatTypeArr[15];
	  resultFloat32Arr[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
	  resultFloat32Arr[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
	  resultFloat32Arr[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
	  resultFloat32Arr[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
	  return resultFloat32Arr;
	}

	function buildPerspective(param, resultFloat32Arr) {
	  var far = param[3];
	  var near = param[2];
	  var fovy = param[0];
	  requireCheck((function () {
	          return test(buildAssertMessage("frustum not be null", "be"), (function () {
	                        var fovy$1 = Math.PI * fovy / 180 / 2;
	                        return Operators[/* <>=. */4](Math.sin(fovy$1), 0);
	                      }));
	        }), getIsDebug(stateData));
	  var fovy$1 = Math.PI * fovy / 180 / 2;
	  var s = Math.sin(fovy$1);
	  var rd = 1 / (far - near);
	  var ct = Math.cos(fovy$1) / s;
	  resultFloat32Arr[0] = ct / param[1];
	  resultFloat32Arr[1] = 0;
	  resultFloat32Arr[2] = 0;
	  resultFloat32Arr[3] = 0;
	  resultFloat32Arr[4] = 0;
	  resultFloat32Arr[5] = ct;
	  resultFloat32Arr[6] = 0;
	  resultFloat32Arr[7] = 0;
	  resultFloat32Arr[8] = 0;
	  resultFloat32Arr[9] = 0;
	  resultFloat32Arr[10] = -(far + near) * rd;
	  resultFloat32Arr[11] = -1;
	  resultFloat32Arr[12] = 0;
	  resultFloat32Arr[13] = 0;
	  resultFloat32Arr[14] = -2 * far * near * rd;
	  resultFloat32Arr[15] = 0;
	  return resultFloat32Arr;
	}

	function invert(mat, resultFloat32Arr) {
	  var a00 = mat[0];
	  var a01 = mat[1];
	  var a02 = mat[2];
	  var a03 = mat[3];
	  var a10 = mat[4];
	  var a11 = mat[5];
	  var a12 = mat[6];
	  var a13 = mat[7];
	  var a20 = mat[8];
	  var a21 = mat[9];
	  var a22 = mat[10];
	  var a23 = mat[11];
	  var a30 = mat[12];
	  var a31 = mat[13];
	  var a32 = mat[14];
	  var a33 = mat[15];
	  var b00 = a00 * a11 - a01 * a10;
	  var b01 = a00 * a12 - a02 * a10;
	  var b02 = a00 * a13 - a03 * a10;
	  var b03 = a01 * a12 - a02 * a11;
	  var b04 = a01 * a13 - a03 * a11;
	  var b05 = a02 * a13 - a03 * a12;
	  var b06 = a20 * a31 - a21 * a30;
	  var b07 = a20 * a32 - a22 * a30;
	  var b08 = a20 * a33 - a23 * a30;
	  var b09 = a21 * a32 - a22 * a31;
	  var b10 = a21 * a33 - a23 * a31;
	  var b11 = a22 * a33 - a23 * a32;
	  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	  var match = det;
	  if (match !== 0) {
	    det = 1.0 / det;
	    resultFloat32Arr[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    resultFloat32Arr[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    resultFloat32Arr[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    resultFloat32Arr[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    resultFloat32Arr[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    resultFloat32Arr[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    resultFloat32Arr[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    resultFloat32Arr[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    resultFloat32Arr[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    resultFloat32Arr[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    resultFloat32Arr[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    resultFloat32Arr[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    resultFloat32Arr[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    resultFloat32Arr[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    resultFloat32Arr[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    resultFloat32Arr[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
	    return resultFloat32Arr;
	  } else {
	    return fatal(buildFatalMessage("invert", "det shouldn\'t be 0.", "", "", ""));
	  }
	}

	function invertTo3x3(mat, resultFloat32Arr) {
	  var a00 = mat[0];
	  var a01 = mat[1];
	  var a02 = mat[2];
	  var a10 = mat[4];
	  var a11 = mat[5];
	  var a12 = mat[6];
	  var a20 = mat[8];
	  var a21 = mat[9];
	  var a22 = mat[10];
	  var b11 = a22 * a11 - a12 * a21;
	  var b21 = -a22 * a01 + a02 * a21;
	  var b31 = a12 * a01 - a02 * a11;
	  var b12 = -a22 * a10 + a12 * a20;
	  var b22 = a22 * a00 - a02 * a20;
	  var b32 = -a12 * a00 + a02 * a10;
	  var b13 = a21 * a10 - a11 * a20;
	  var b23 = -a21 * a00 + a01 * a20;
	  var b33 = a11 * a00 - a01 * a10;
	  var det = a00 * b11 + a01 * b12 + a02 * b13;
	  var match = det;
	  if (match !== 0) {
	    det = 1.0 / det;
	    resultFloat32Arr[0] = b11 * det;
	    resultFloat32Arr[1] = b21 * det;
	    resultFloat32Arr[2] = b31 * det;
	    resultFloat32Arr[3] = b12 * det;
	    resultFloat32Arr[4] = b22 * det;
	    resultFloat32Arr[5] = b32 * det;
	    resultFloat32Arr[6] = b13 * det;
	    resultFloat32Arr[7] = b23 * det;
	    resultFloat32Arr[8] = b33 * det;
	    return resultFloat32Arr;
	  } else {
	    return fatal(buildFatalMessage("invertTo3x3", "det shouldn\'t be 0.", "", "", ""));
	  }
	}

	function setLookAt(eye, center, up) {
	  var z = normalize(sub$1(/* Float */0, eye, center));
	  var y = normalize(up);
	  var x = normalize(cross(y, z));
	  var match = cross(z, x);
	  return new Float32Array(/* array */[
	              x[0],
	              x[1],
	              x[2],
	              0,
	              match[0],
	              match[1],
	              match[2],
	              0,
	              z[0],
	              z[1],
	              z[2],
	              0,
	              eye[0],
	              eye[1],
	              eye[2],
	              1
	            ]);
	}


	/* Log-WonderLog Not a pure module */

	function conjugate(param) {
	  return /* tuple */[
	          param[0] * -1.0,
	          param[1] * -1.0,
	          param[2] * -1.0,
	          param[3]
	        ];
	}

	function length$3(param) {
	  var w = param[3];
	  var z = param[2];
	  var y = param[1];
	  var x = param[0];
	  return Math.sqrt(x * x + y * y + z * z + w * w);
	}

	function normalize$1(tuple) {
	  var len = length$3(tuple);
	  if (len !== 0) {
	    return /* tuple */[
	            tuple[0] / len,
	            tuple[1] / len,
	            tuple[2] / len,
	            tuple[3] / len
	          ];
	  } else {
	    return /* tuple */[
	            0,
	            0,
	            0,
	            1
	          ];
	  }
	}

	function invert$1(tuple) {
	  return normalize$1(conjugate(tuple));
	}

	function multiply$2(param, param$1) {
	  var q2w = param$1[3];
	  var q2z = param$1[2];
	  var q2y = param$1[1];
	  var q2x = param$1[0];
	  var q1w = param[3];
	  var q1z = param[2];
	  var q1y = param[1];
	  var q1x = param[0];
	  return /* tuple */[
	          q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y,
	          q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z,
	          q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x,
	          q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z
	        ];
	}

	var setFromMatrix = function (matrixTypeArray){
	             var m00, m01, m02, m10, m11, m12, m20, m21, m22,
	                tr, s, rs, lx, ly, lz, m;
	                var x,y,z,w;

	            m = matrixTypeArray;

	            // Cache matrix values for super-speed
	            m00 = m[0];
	            m01 = m[1];
	            m02 = m[2];
	            m10 = m[4];
	            m11 = m[5];
	            m12 = m[6];
	            m20 = m[8];
	            m21 = m[9];
	            m22 = m[10];

	            // Remove the scale from the matrix
	            lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
	            ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
	            lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);

	            m00 *= lx;
	            m01 *= lx;
	            m02 *= lx;
	            m10 *= ly;
	            m11 *= ly;
	            m12 *= ly;
	            m20 *= lz;
	            m21 *= lz;
	            m22 *= lz;

	            // http://www.cs.ucr.edu/~vbz/resources/quatut.pdf

	            tr = m00 + m11 + m22;
	            if (tr >= 0) {
	                s = Math.sqrt(tr + 1);
	                w = s * 0.5;
	                s = 0.5 / s;
	                x = (m12 - m21) * s;
	                y = (m20 - m02) * s;
	                z = (m01 - m10) * s;
	            } else {
	                if (m00 > m11) {
	                    if (m00 > m22) {
	                        // XDiagDomMatrix
	                        rs = (m00 - (m11 + m22)) + 1;
	                        rs = Math.sqrt(rs);

	                        x = rs * 0.5;
	                        rs = 0.5 / rs;
	                        w = (m12 - m21) * rs;
	                        y = (m01 + m10) * rs;
	                        z = (m02 + m20) * rs;
	                    } else {
	                        // ZDiagDomMatrix
	                        rs = (m22 - (m00 + m11)) + 1;
	                        rs = Math.sqrt(rs);

	                        z = rs * 0.5;
	                        rs = 0.5 / rs;
	                        w = (m01 - m10) * rs;
	                        x = (m20 + m02) * rs;
	                        y = (m21 + m12) * rs;
	                    }
	                } else if (m11 > m22) {
	                    // YDiagDomMatrix
	                    rs = (m11 - (m22 + m00)) + 1;
	                    rs = Math.sqrt(rs);

	                    y = rs * 0.5;
	                    rs = 0.5 / rs;
	                    w = (m20 - m02) * rs;
	                    z = (m12 + m21) * rs;
	                    x = (m10 + m01) * rs;
	                } else {
	                    // ZDiagDomMatrix
	                    rs = (m22 - (m00 + m11)) + 1;
	                    rs = Math.sqrt(rs);

	                    z = rs * 0.5;
	                    rs = 0.5 / rs;
	                    w = (m01 - m10) * rs;
	                    x = (m20 + m02) * rs;
	                    y = (m21 + m12) * rs;
	                }
	            }

	            return [x,y,z,w]
	  };

	function setFromEulerAngles(param) {
	  var halfToRad = 0.5 * getDegToRad(/* () */0);
	  var ex = param[0] * halfToRad;
	  var ey = param[1] * halfToRad;
	  var ez = param[2] * halfToRad;
	  var sx = Math.sin(ex);
	  var cx = Math.cos(ex);
	  var sy = Math.sin(ey);
	  var cy = Math.cos(ey);
	  var sz = Math.sin(ez);
	  var cz = Math.cos(ez);
	  return /* tuple */[
	          sx * cy * cz - cx * sy * sz,
	          cx * sy * cz + sx * cy * sz,
	          cx * cy * sz - sx * sy * cz,
	          cx * cy * cz + sx * sy * sz
	        ];
	}

	var _getEulerAngles = function (quat){
	            var x, y, z, qx, qy, qz, qw, a2;

	            qx = quat[0];
	            qy = quat[1];
	            qz = quat[2];
	            qw = quat[3];

	            a2 = 2 * (qw * qy - qx * qz);
	            if (a2 <= -0.99999) {
	                x = 2 * Math.atan2(qx, qw);
	                y = -Math.PI / 2;
	                z = 0;
	            } else if (a2 >= 0.99999) {
	                x = 2 * Math.atan2(qx, qw);
	                y = Math.PI / 2;
	                z = 0;
	            } else {
	                x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
	                y = Math.asin(a2);
	                z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
	            }

	            //return Vector3.create(x, y, z).scale(RAD_TO_DEG);
	            return [x, y, z];
	    };

	function getEulerAngles$1(quat) {
	  var rad_to_deg = 180 / Math.PI;
	  return scale(/* Float */0, rad_to_deg, _getEulerAngles(quat));
	}


	/* No side effect */

	function getFloat32Array1(record) {
	  return record[/* float16Array1 */0];
	}


	/* No side effect */

	function createIdentityMatrix3() {
	  return new Float32Array(/* array */[
	              1,
	              0,
	              0,
	              1,
	              0,
	              0,
	              1,
	              0,
	              0
	            ]);
	}

	function transposeSelf$1(mat) {
	  var a01 = mat[1];
	  var a02 = mat[2];
	  var a12 = mat[5];
	  mat[1] = mat[3];
	  mat[2] = mat[6];
	  mat[3] = a01;
	  mat[5] = mat[7];
	  mat[6] = a02;
	  mat[7] = a12;
	  return mat;
	}


	/* No side effect */

	function getLocalToWorldMatrixTypeArray$1(transform, localToWorldMatrices, localToWorldMatrixCacheMap) {
	  var match = get$3(transform, localToWorldMatrixCacheMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    var matrix = getLocalToWorldMatrixTypeArray(transform, localToWorldMatrices);
	    set$1(transform, matrix, localToWorldMatrixCacheMap);
	    return matrix;
	  }
	}

	function _getNormalMatrixTypeArray(transform, localToWorldMatrices, param, getLocalToWorldMatrixTypeArrayFunc) {
	  return transposeSelf$1(invertTo3x3(getLocalToWorldMatrixTypeArrayFunc(transform, localToWorldMatrices, param[0]), param[1]));
	}

	function getNormalMatrixTypeArray(transform, localToWorldMatrices, param) {
	  var normalMatrixCacheMap = param[1];
	  var match = get$3(transform, normalMatrixCacheMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    var matrix = _getNormalMatrixTypeArray(transform, localToWorldMatrices, /* tuple */[
	          param[0],
	          createIdentityMatrix3(/* () */0)
	        ], getLocalToWorldMatrixTypeArray$1);
	    set$1(transform, matrix, normalMatrixCacheMap);
	    return matrix;
	  }
	}

	var getLocalPositionTuple$1 = getLocalPositionTuple;

	function setLocalPositionByTuple$1(transform, dataTuple, record) {
	  var localPositions = record[/* localPositions */3];
	  setLocalPositionByTuple(transform, dataTuple, localPositions);
	  return markHierachyDirty(transform, record);
	}

	function setPositionByTuple(transform, parent, position, param) {
	  var record = param[1];
	  var localToWorldMatrixCacheMap = record[/* localToWorldMatrixCacheMap */19];
	  var localToWorldMatrix = getLocalToWorldMatrixTypeArray$1(parent, record[/* localToWorldMatrices */2], localToWorldMatrixCacheMap);
	  return setLocalPositionByTuple$1(transform, transformMat4Tuple(position, invert(localToWorldMatrix, getFloat32Array1(param[0]))), record);
	}

	var getLocalRotationTuple$1 = getLocalRotationTuple;

	function setLocalRotationByTuple$1(transform, dataTuple, record) {
	  var localRotations = record[/* localRotations */4];
	  setLocalRotationByTuple(transform, dataTuple, localRotations);
	  return markHierachyDirty(transform, record);
	}

	function getLocalEulerAnglesTuple(transform, localRotations) {
	  return getEulerAngles$1(getLocalRotationTuple(transform, localRotations));
	}

	function setLocalEulerAnglesByTuple(transform, eulerAngles, record) {
	  var localRotations = record[/* localRotations */4];
	  setLocalRotationByTuple(transform, setFromEulerAngles(eulerAngles), localRotations);
	  return markHierachyDirty(transform, record);
	}

	var getLocalScaleTuple$1 = getLocalScaleTuple;

	function setLocalScaleByTuple$1(transform, dataTuple, record) {
	  var localScales = record[/* localScales */5];
	  setLocalScaleByTuple(transform, dataTuple, localScales);
	  return markHierachyDirty(transform, record);
	}

	function setScaleByTuple(transform, parent, position, param) {
	  var record = param[1];
	  var localToWorldMatrixCacheMap = record[/* localToWorldMatrixCacheMap */19];
	  var localToWorldMatrix = getLocalToWorldMatrixTypeArray$1(parent, record[/* localToWorldMatrices */2], localToWorldMatrixCacheMap);
	  return setLocalScaleByTuple$1(transform, transformMat4Tuple(position, invert(localToWorldMatrix, getFloat32Array1(param[0]))), record);
	}


	/* Matrix4Service-Wonderjs Not a pure module */

	function _clearCache(transform, record) {
	  var normalMatrixCacheMap = record[/* normalMatrixCacheMap */20];
	  deleteVal$1(transform, normalMatrixCacheMap);
	  return record;
	}

	function update(transform, globalTempRecord, transformRecord) {
	  var localPositions = transformRecord[/* localPositions */3];
	  var localRotations = transformRecord[/* localRotations */4];
	  var localScales = transformRecord[/* localScales */5];
	  var match = isDirty(transform, transformRecord);
	  if (match) {
	    var transformRecord$1 = _clearCache(transform, mark(transform, false, transformRecord));
	    var match$1 = getParent(transform, transformRecord$1);
	    if (match$1 !== undefined) {
	      var parent = match$1;
	      var transformRecord$2 = update(parent, globalTempRecord, transformRecord$1);
	      var parentLocalToWorldMatrix = getLocalToWorldMatrixTypeArray$1(parent, transformRecord$2[/* localToWorldMatrices */2], transformRecord$2[/* localToWorldMatrixCacheMap */19]);
	      var childLocalToWorldMatrix = getLocalToWorldMatrixTypeArray$1(transform, transformRecord$2[/* localToWorldMatrices */2], transformRecord$2[/* localToWorldMatrixCacheMap */19]);
	      multiply$1(parentLocalToWorldMatrix, fromTranslationRotationScale(getLocalPositionTuple$1(transform, localPositions), getLocalRotationTuple$1(transform, localRotations), getLocalScaleTuple$1(transform, localScales), getFloat32Array1(globalTempRecord)), childLocalToWorldMatrix);
	      return transformRecord$2;
	    } else {
	      var localToWorldMatrix = getLocalToWorldMatrixTypeArray$1(transform, transformRecord$1[/* localToWorldMatrices */2], transformRecord$1[/* localToWorldMatrixCacheMap */19]);
	      fromTranslationRotationScale(getLocalPositionTuple$1(transform, localPositions), getLocalRotationTuple$1(transform, localRotations), getLocalScaleTuple$1(transform, localScales), localToWorldMatrix);
	      return transformRecord$1;
	    }
	  } else {
	    return transformRecord;
	  }
	}

	function updateAndGetLocalToWorldMatrixTypeArray(transform, globalTempRecord, record) {
	  var record$1 = update(transform, globalTempRecord, record);
	  return getLocalToWorldMatrixTypeArray$1(transform, record$1[/* localToWorldMatrices */2], record$1[/* localToWorldMatrixCacheMap */19]);
	}

	function updateAndGetPositionTuple(transform, globalTempRecord, record) {
	  var match = update(transform, globalTempRecord, record);
	  var localToWorldMatrices = match[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = match[/* localToWorldMatrixCacheMap */19];
	  return getTranslationTuple(getLocalToWorldMatrixTypeArray$1(transform, localToWorldMatrices, localToWorldMatrixCacheMap));
	}

	function updateAndSetPositionByTuple(transform, position, globalTempRecord, record) {
	  var match = getParent(transform, record);
	  if (match !== undefined) {
	    var parent = match;
	    var record$1 = update(parent, globalTempRecord, record);
	    return setPositionByTuple(transform, parent, position, /* tuple */[
	                globalTempRecord,
	                record$1
	              ]);
	  } else {
	    return setLocalPositionByTuple$1(transform, position, record);
	  }
	}

	function updateAndGetRotationTuple(transform, globalTempRecord, record) {
	  var match = update(transform, globalTempRecord, record);
	  var localToWorldMatrices = match[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = match[/* localToWorldMatrixCacheMap */19];
	  return getRotationTuple(getLocalToWorldMatrixTypeArray$1(transform, localToWorldMatrices, localToWorldMatrixCacheMap));
	}

	function updateAndSetRotationByTuple(transform, rotation, globalTempRecord, record) {
	  var match = getParent(transform, record);
	  if (match !== undefined) {
	    return setLocalRotationByTuple$1(transform, multiply$2(invert$1(updateAndGetRotationTuple(match, globalTempRecord, record)), rotation), record);
	  } else {
	    return setLocalRotationByTuple$1(transform, rotation, record);
	  }
	}

	function updateAndGetScaleTuple(transform, globalTempRecord, record) {
	  var match = update(transform, globalTempRecord, record);
	  var localToWorldMatrices = match[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = match[/* localToWorldMatrixCacheMap */19];
	  return getScaleTuple(getLocalToWorldMatrixTypeArray$1(transform, localToWorldMatrices, localToWorldMatrixCacheMap));
	}

	function updateAndSetScaleByTuple(transform, position, globalTempRecord, record) {
	  var match = getParent(transform, record);
	  if (match !== undefined) {
	    var parent = match;
	    var record$1 = update(parent, globalTempRecord, record);
	    return setScaleByTuple(transform, parent, position, /* tuple */[
	                globalTempRecord,
	                record$1
	              ]);
	  } else {
	    return setLocalScaleByTuple$1(transform, position, record);
	  }
	}

	function updateAndGetEulerAnglesTuple(transform, globalTempRecord, record) {
	  var match = update(transform, globalTempRecord, record);
	  var localToWorldMatrices = match[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = match[/* localToWorldMatrixCacheMap */19];
	  return getEulerAngles(getLocalToWorldMatrixTypeArray$1(transform, localToWorldMatrices, localToWorldMatrixCacheMap));
	}

	function updateAndSetEulerAnglesByTuple(transform, eulerAngles, globalTempRecord, record) {
	  return updateAndSetRotationByTuple(transform, setFromEulerAngles(eulerAngles), globalTempRecord, record);
	}


	/* Matrix4Service-Wonderjs Not a pure module */

	function lookAt$2(transform, target, state, $staropt$star, _) {
	  var up = $staropt$star !== undefined ? $staropt$star : /* tuple */[
	      0,
	      1,
	      0
	    ];
	  var globalTempRecord = state[/* globalTempRecord */36];
	  var transformRecord = getRecord$1(state);
	  var __x = setFromMatrix(setLookAt(updateAndGetPositionTuple(transform, globalTempRecord, transformRecord), target, up));
	  state[/* transformRecord */12] = updateAndSetRotationByTuple(transform, __x, globalTempRecord, transformRecord);
	  return state;
	}


	/* Matrix4Service-Wonderjs Not a pure module */

	function deleteBySwapAndResetFloat32TypeArr(param, typeArr, length, defaultValueArr) {
	  var targetIndex = param[1];
	  var sourceIndex = param[0];
	  for(var i = 0 ,i_finish = length - 1 | 0; i <= i_finish; ++i){
	    typeArr[sourceIndex + i | 0] = typeArr[targetIndex + i | 0];
	    typeArr[targetIndex + i | 0] = caml_array_get(defaultValueArr, i);
	  }
	  return typeArr;
	}

	function deleteSingleValueBySwapAndResetFloat32TypeArr(param, typeArr, _, defaultValue) {
	  var targetIndex = param[1];
	  typeArr[param[0]] = typeArr[targetIndex];
	  typeArr[targetIndex] = defaultValue;
	  return typeArr;
	}

	function deleteSingleValueBySwapUint32TypeArr(sourceIndex, lastIndex, typeArr) {
	  typeArr[sourceIndex] = typeArr[lastIndex];
	  return typeArr;
	}

	function deleteAndResetFloat32TypeArr(sourceIndex, length, defaultValueArr, typeArr) {
	  for(var i = 0 ,i_finish = length - 1 | 0; i <= i_finish; ++i){
	    typeArr[sourceIndex + i | 0] = caml_array_get(defaultValueArr, i);
	  }
	  return typeArr;
	}

	function deleteAndResetFloat32(sourceIndex, defaultValue, typeArr) {
	  typeArr[sourceIndex] = defaultValue;
	  return typeArr;
	}

	function deleteAndResetUint32(sourceIndex, defaultValue, typeArr) {
	  typeArr[sourceIndex] = defaultValue;
	  return typeArr;
	}

	function deleteAndResetUint8(sourceIndex, defaultValue, typeArr) {
	  typeArr[sourceIndex] = defaultValue;
	  return typeArr;
	}


	/* No side effect */

	function isAlive$2(transform, param) {
	  var disposedIndexArray = param[/* disposedIndexArray */21];
	  return isAlive$1(transform, disposedIndexArray);
	}

	function _disposeFromParentAndChildMap(transform, isKeepOrder, record) {
	  reduceOneParam((function (record, child) {
	          return removeFromParentMap(child, record);
	        }), record, unsafeGetChildren(transform, record));
	  var match = getParent(transform, record);
	  if (match !== undefined) {
	    return removeFromChildMap(match, transform, isKeepOrder, record);
	  } else {
	    return record;
	  }
	}

	function _disposeData$1(transform, param, transformRecord) {
	  var localToWorldMatrices = transformRecord[/* localToWorldMatrices */2];
	  var localPositions = transformRecord[/* localPositions */3];
	  var localRotations = transformRecord[/* localRotations */4];
	  var localScales = transformRecord[/* localScales */5];
	  var parentMap = transformRecord[/* parentMap */15];
	  var childMap = transformRecord[/* childMap */16];
	  var gameObjectMap = transformRecord[/* gameObjectMap */17];
	  var dirtyMap = transformRecord[/* dirtyMap */18];
	  var transformRecord$1 = _disposeFromParentAndChildMap(transform, param[2], transformRecord);
	  transformRecord$1[/* localToWorldMatrices */2] = deleteAndResetFloat32TypeArr(getLocalToWorldMatrixIndex(transform), getLocalToWorldMatricesSize(/* () */0), transformRecord[/* defaultLocalToWorldMatrix */11], localToWorldMatrices);
	  transformRecord$1[/* localPositions */3] = deleteAndResetFloat32TypeArr(getLocalPositionIndex(transform), getLocalPositionsSize(/* () */0), transformRecord[/* defaultLocalPosition */12], localPositions);
	  transformRecord$1[/* localRotations */4] = deleteAndResetFloat32TypeArr(getLocalRotationIndex(transform), getLocalRotationsSize(/* () */0), transformRecord[/* defaultLocalRotation */13], localRotations);
	  transformRecord$1[/* localScales */5] = deleteAndResetFloat32TypeArr(getLocalScaleIndex(transform), getLocalScalesSize(/* () */0), transformRecord[/* defaultLocalScale */14], localScales);
	  transformRecord$1[/* parentMap */15] = disposeSparseMapData(transform, parentMap);
	  transformRecord$1[/* childMap */16] = disposeSparseMapData(transform, childMap);
	  transformRecord$1[/* dirtyMap */18] = disposeSparseMapData(transform, dirtyMap);
	  transformRecord$1[/* gameObjectMap */17] = disposeSparseMapData(transform, gameObjectMap);
	  return transformRecord$1;
	}

	function handleBatchDisposeComponent$1(transformArray, maxTypeArrayPoolSize, isKeepOrder, state) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(transformArray, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  var transformRecord = getRecord$1(state);
	  var disposedIndexArray = transformRecord[/* disposedIndexArray */21];
	  transformRecord[/* disposedIndexArray */21] = disposedIndexArray.concat(transformArray);
	  var transformCount = getTransformCount(state[/* settingRecord */1]);
	  var dataTuple = /* tuple */[
	    transformCount,
	    maxTypeArrayPoolSize,
	    isKeepOrder
	  ];
	  var transformRecord$1 = reduceOneParam((function (transformRecord, transform) {
	          return _disposeData$1(transform, dataTuple, transformRecord);
	        }), transformRecord, transformArray);
	  state[/* transformRecord */12] = transformRecord$1;
	  return state;
	}


	/* Contract-WonderLog Not a pure module */

	function unsafeGetTransformGameObject$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$6(transform, getRecord$1(state));
	}

	function unsafeGetTransformParent$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return unsafeGetParent(transform, getRecord$1(state));
	}

	function _checkParentAndChildTransformShouldAlive(parent, child, state) {
	  return requireCheck((function () {
	                iter$1(parent, (function (parent) {
	                        return checkComponentShouldAlive$1(parent, isAlive$2, getRecord$1(state));
	                      }));
	                return checkComponentShouldAlive$1(child, isAlive$2, getRecord$1(state));
	              }), getIsDebug(stateData));
	}

	function _setTransformParent(parent, child, setParentFunc, state) {
	  _checkParentAndChildTransformShouldAlive(parent, child, state);
	  state[/* transformRecord */12] = setParentFunc((parent == null) ? undefined : some$1(parent), child, getRecord$1(state));
	  return state;
	}

	function setTransformParent$1(parent, child, state) {
	  return _setTransformParent(parent, child, setParent, state);
	}

	function setTransformParentKeepOrder$1(parent, child, state) {
	  return _setTransformParent(parent, child, setParentKeepOrder, state);
	}

	function unsafeGetTransformChildren$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return unsafeGetChildren(transform, getRecord$1(state));
	}

	function getTransformLocalPosition$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return getLocalPositionTuple$1(transform, getRecord$1(state)[/* localPositions */3]);
	}

	function setTransformLocalPosition$1(transform, localPosition, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = setLocalPositionByTuple$1(transform, localPosition, getRecord$1(state));
	  return state;
	}

	function getTransformPosition$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return updateAndGetPositionTuple(transform, state[/* globalTempRecord */36], getRecord$1(state));
	}

	function setTransformPosition$1(transform, position, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = updateAndSetPositionByTuple(transform, position, state[/* globalTempRecord */36], getRecord$1(state));
	  return state;
	}

	function getTransformLocalRotation$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return getLocalRotationTuple$1(transform, getRecord$1(state)[/* localRotations */4]);
	}

	function setTransformLocalRotation$1(transform, localRotation, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = setLocalRotationByTuple$1(transform, localRotation, getRecord$1(state));
	  return state;
	}

	function getTransformRotation$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return updateAndGetRotationTuple(transform, state[/* globalTempRecord */36], getRecord$1(state));
	}

	function setTransformRotation$1(transform, rotation, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = updateAndSetRotationByTuple(transform, rotation, state[/* globalTempRecord */36], getRecord$1(state));
	  return state;
	}

	function getTransformLocalScale$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return getLocalScaleTuple$1(transform, getRecord$1(state)[/* localScales */5]);
	}

	function setTransformLocalScale$1(transform, localScale, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = setLocalScaleByTuple$1(transform, localScale, getRecord$1(state));
	  return state;
	}

	function getTransformScale$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return updateAndGetScaleTuple(transform, state[/* globalTempRecord */36], getRecord$1(state));
	}

	function setTransformScale$1(transform, scale, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = updateAndSetScaleByTuple(transform, scale, state[/* globalTempRecord */36], getRecord$1(state));
	  return state;
	}

	function getTransformLocalEulerAngles$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return getLocalEulerAnglesTuple(transform, getRecord$1(state)[/* localRotations */4]);
	}

	function setTransformLocalEulerAngles$1(transform, eulerAngles, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = setLocalEulerAnglesByTuple(transform, eulerAngles, getRecord$1(state));
	  return state;
	}

	function getTransformEulerAngles$1(transform, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return updateAndGetEulerAnglesTuple(transform, state[/* globalTempRecord */36], getRecord$1(state));
	}

	function setTransformEulerAngles$1(transform, eulerAngles, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  state[/* transformRecord */12] = updateAndSetEulerAnglesByTuple(transform, eulerAngles, state[/* globalTempRecord */36], getRecord$1(state));
	  return state;
	}

	function lookAt$1(transform, target, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return lookAt$2(transform, target, state, undefined, /* () */0);
	}

	function lookAtWithUp$1(transform, target, up, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(transform, isAlive$2, getRecord$1(state));
	        }), getIsDebug(stateData));
	  return lookAt$2(transform, target, state, up, /* () */0);
	}

	var createTransform$1 = create$5;


	/* Contract-WonderLog Not a pure module */

	function unsafeGetPMatrix(index, pMatrixMap) {
	  return ensureCheck((function (pMatrix) {
	                return test(buildAssertMessage("pMatrix exist", "not"), (function () {
	                              return assertNullableExist(pMatrix);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(index, pMatrixMap));
	}

	function setDefaultPMatrix(index, pMatrixMap) {
	  return set$1(index, createIdentityMatrix4(/* () */0), pMatrixMap);
	}


	/* Log-WonderLog Not a pure module */

	function transformMat4Tuple$1(param, mat4) {
	  var w = param[3];
	  var z = param[2];
	  var y = param[1];
	  var x = param[0];
	  return /* tuple */[
	          mat4[0] * x + mat4[4] * y + mat4[8] * z + mat4[12] * w,
	          mat4[1] * x + mat4[5] * y + mat4[9] * z + mat4[13] * w,
	          mat4[2] * x + mat4[6] * y + mat4[10] * z + mat4[14] * w,
	          mat4[3] * x + mat4[7] * y + mat4[11] * z + mat4[15] * w
	        ];
	}


	/* No side effect */

	function getWorldToCameraMatrix(cameraToWorldMatrix) {
	  return invert(cameraToWorldMatrix, createIdentityMatrix4(/* () */0));
	}


	/* Matrix4Service-Wonderjs Not a pure module */

	function getBasicCameraViewWorldToCameraMatrix$1(cameraView, state) {
	  var match = getRecord$1(state);
	  var localToWorldMatrices = match[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = match[/* localToWorldMatrixCacheMap */19];
	  return getWorldToCameraMatrix(getLocalToWorldMatrixTypeArray$1(unsafeGetTransformComponent(unsafeGetGameObject(cameraView, state[/* basicCameraViewRecord */14]), state[/* gameObjectRecord */11]), localToWorldMatrices, localToWorldMatrixCacheMap));
	}


	/* VMatrixService-Wonderjs Not a pure module */

	function convertWorldToScreen$2(cameraView, cameraProjection, param, state) {
	  var normalizedDeviceCoordinate = transformMat4Tuple$1(/* tuple */[
	        param[0],
	        param[1],
	        param[2],
	        1
	      ], multiply$1(unsafeGetPMatrix(cameraProjection, state[/* perspectiveCameraProjectionRecord */15][/* pMatrixMap */2]), getBasicCameraViewWorldToCameraMatrix$1(cameraView, state), createIdentityMatrix4(/* () */0)));
	  var w = normalizedDeviceCoordinate[3];
	  var ndcSpacePos_000 = normalizedDeviceCoordinate[0] / w;
	  var ndcSpacePos_001 = normalizedDeviceCoordinate[1] / w;
	  return /* tuple */[
	          Math.round((ndcSpacePos_000 + 1) / 2 * param[3]),
	          Math.round((1 - ndcSpacePos_001) / 2 * param[4])
	        ];
	}


	/* Matrix4Service-Wonderjs Not a pure module */

	function convertWorldToScreen$1(cameraView, cameraProjection, param, state) {
	  return convertWorldToScreen$2(cameraView, cameraProjection, /* tuple */[
	              param[0],
	              param[1],
	              param[2],
	              param[3],
	              param[4]
	            ], state);
	}


	/* CoordinateMainService-Wonderjs Not a pure module */

	function unsafeGetGl$1(record) {
	  var gl = record[/* gl */0];
	  requireCheck((function () {
	          return test(buildAssertMessage("gl exist", "not"), (function () {
	                        return assertExist(gl);
	                      }));
	        }), getIsDebug(stateData));
	  return unsafeGet$1(gl);
	}

	function setGl(gl, record) {
	  return /* record */[
	          /* gl */some$1(gl),
	          /* colorWrite */record[/* colorWrite */1],
	          /* clearColor */record[/* clearColor */2],
	          /* side */record[/* side */3],
	          /* depthTest */record[/* depthTest */4],
	          /* viewport */record[/* viewport */5]
	        ];
	}

	function setColorWrite(gl, param, record) {
	  var colorWrite = record[/* colorWrite */1];
	  var writeAlpha = param[3];
	  var writeBlue = param[2];
	  var writeGreen = param[1];
	  var writeRed = param[0];
	  var exit = 0;
	  if (colorWrite !== undefined) {
	    var match = colorWrite;
	    if (match[0] === writeRed && match[1] === writeGreen && match[2] === writeBlue && match[3] === writeAlpha) {
	      return record;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    gl.colorMask(writeRed, writeGreen, writeBlue, writeAlpha);
	    return /* record */[
	            /* gl */record[/* gl */0],
	            /* colorWrite *//* tuple */[
	              writeRed,
	              writeGreen,
	              writeBlue,
	              writeAlpha
	            ],
	            /* clearColor */record[/* clearColor */2],
	            /* side */record[/* side */3],
	            /* depthTest */record[/* depthTest */4],
	            /* viewport */record[/* viewport */5]
	          ];
	  }
	  
	}

	function _setSide(gl, targetSide) {
	  switch (targetSide) {
	    case 0 : 
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.FRONT_AND_BACK);
	        return /* () */0;
	    case 1 : 
	        gl.disable(gl.CULL_FACE);
	        return /* () */0;
	    case 2 : 
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.BACK);
	        return /* () */0;
	    case 3 : 
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.FRONT);
	        return /* () */0;
	    
	  }
	}

	function setSide(gl, targetSide, record) {
	  var side = record[/* side */3];
	  var exit = 0;
	  if (side !== undefined && side === targetSide) {
	    return record;
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    _setSide(gl, targetSide);
	    return /* record */[
	            /* gl */record[/* gl */0],
	            /* colorWrite */record[/* colorWrite */1],
	            /* clearColor */record[/* clearColor */2],
	            /* side */targetSide,
	            /* depthTest */record[/* depthTest */4],
	            /* viewport */record[/* viewport */5]
	          ];
	  }
	  
	}

	function _setDepthTest(gl, targetDepthTest) {
	  if (targetDepthTest) {
	    gl.enable(gl.DEPTH_TEST);
	    return /* () */0;
	  } else {
	    gl.disable(gl.DEPTH_TEST);
	    return /* () */0;
	  }
	}

	function setDepthTest(gl, targetDepthTest, record) {
	  var depthTest = record[/* depthTest */4];
	  var exit = 0;
	  if (depthTest !== undefined && depthTest === targetDepthTest) {
	    return record;
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    _setDepthTest(gl, targetDepthTest);
	    return /* record */[
	            /* gl */record[/* gl */0],
	            /* colorWrite */record[/* colorWrite */1],
	            /* clearColor */record[/* clearColor */2],
	            /* side */record[/* side */3],
	            /* depthTest */targetDepthTest,
	            /* viewport */record[/* viewport */5]
	          ];
	  }
	  
	}

	function clearBuffer(gl, bit, record) {
	  var record$1 = setColorWrite(gl, /* tuple */[
	        true,
	        true,
	        true,
	        true
	      ], record);
	  gl.clear(bit);
	  return record$1;
	}

	function clearColor(gl, param, record) {
	  var clearColor$1 = record[/* clearColor */2];
	  var a = param[3];
	  var b = param[2];
	  var g = param[1];
	  var r = param[0];
	  var exit = 0;
	  if (clearColor$1 !== undefined) {
	    var match = clearColor$1;
	    if (match[0] === r && match[1] === g && match[2] === b && match[3] === a) {
	      return record;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    gl.clearColor(r, g, b, a);
	    return /* record */[
	            /* gl */record[/* gl */0],
	            /* colorWrite */record[/* colorWrite */1],
	            /* clearColor *//* tuple */[
	              r,
	              g,
	              b,
	              a
	            ],
	            /* side */record[/* side */3],
	            /* depthTest */record[/* depthTest */4],
	            /* viewport */record[/* viewport */5]
	          ];
	  }
	  
	}

	function setViewportData(param, record) {
	  return /* record */[
	          /* gl */record[/* gl */0],
	          /* colorWrite */record[/* colorWrite */1],
	          /* clearColor */record[/* clearColor */2],
	          /* side */record[/* side */3],
	          /* depthTest */record[/* depthTest */4],
	          /* viewport *//* tuple */[
	            param[0],
	            param[1],
	            param[2],
	            param[3]
	          ]
	        ];
	}

	function setViewportOfGl(gl, param, record) {
	  var viewport = record[/* viewport */5];
	  var height = param[3];
	  var width = param[2];
	  var y = param[1];
	  var x = param[0];
	  var exit = 0;
	  if (viewport !== undefined) {
	    var match = viewport;
	    if (match[0] === x && match[1] === y && match[2] === width && match[3] === height) {
	      return record;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    gl.viewport(x, y, width, height);
	    return /* record */[
	            /* gl */record[/* gl */0],
	            /* colorWrite */record[/* colorWrite */1],
	            /* clearColor */record[/* clearColor */2],
	            /* side */record[/* side */3],
	            /* depthTest */record[/* depthTest */4],
	            /* viewport *//* tuple */[
	              x,
	              y,
	              width,
	              height
	            ]
	          ];
	  }
	  
	}


	/* Log-WonderLog Not a pure module */

	function _getExtension(name, gl) {
	  var tmp = name === "instanced_arrays" ? gl.getExtension("ANGLE_instanced_arrays") : gl.getExtension(name);
	  if (tmp == null) {
	    return undefined;
	  } else {
	    return some$1(tmp);
	  }
	}

	function _detectExtension(gl, record) {
	  return /* record */[
	          /* extensionInstancedArrays */_getExtension("instanced_arrays", gl),
	          /* precision */record[/* precision */1],
	          /* maxTextureUnit */record[/* maxTextureUnit */2]
	        ];
	}

	function _detectPrecision(gl, record) {
	  var vertexShader = gl.VERTEX_SHADER;
	  var fragmentShader = gl.FRAGMENT_SHADER;
	  var highFloat = gl.HIGH_FLOAT;
	  var mediumFloat = gl.MEDIUM_FLOAT;
	  var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(vertexShader, highFloat);
	  var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(vertexShader, mediumFloat);
	  var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(fragmentShader, highFloat);
	  var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(fragmentShader, mediumFloat);
	  var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
	  var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
	  if (highpAvailable) {
	    return /* record */[
	            /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
	            /* precision *//* HIGHP */0,
	            /* maxTextureUnit */record[/* maxTextureUnit */2]
	          ];
	  } else if (mediumpAvailable) {
	    warn("not support highp, using mediump instead");
	    return /* record */[
	            /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
	            /* precision *//* MEDIUMP */1,
	            /* maxTextureUnit */record[/* maxTextureUnit */2]
	          ];
	  } else {
	    warn("not support highp and mediump, using lowp instead");
	    return /* record */[
	            /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
	            /* precision *//* LOWP */2,
	            /* maxTextureUnit */record[/* maxTextureUnit */2]
	          ];
	  }
	}

	function _getTextureCapability(gl, textureCountPerMaterial, record) {
	  return ensureCheck((function (param) {
	                var maxTextureUnit = unsafeGet$1(param[/* maxTextureUnit */2]);
	                return test(buildAssertMessage("maxTextureUnit:" + (String(maxTextureUnit) + (" >= textureCountPerMaterial:" + (String(textureCountPerMaterial) + ""))), "not"), (function () {
	                              return Operators[/* >= */7](maxTextureUnit, textureCountPerMaterial);
	                            }));
	              }), getIsDebug(stateData), /* record */[
	              /* extensionInstancedArrays */record[/* extensionInstancedArrays */0],
	              /* precision */record[/* precision */1],
	              /* maxTextureUnit */gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)
	            ]);
	}

	function _detectCapability(gl, textureCountPerMaterial, record) {
	  return _detectPrecision(gl, _getTextureCapability(gl, textureCountPerMaterial, record));
	}

	function detect$1(gl, textureCountPerMaterial, record) {
	  return _detectCapability(gl, textureCountPerMaterial, _detectExtension(gl, record));
	}

	var hasExtension = isSome;

	function unsafeGetInstanceExtension(record) {
	  requireCheck((function () {
	          return test(buildAssertMessage("extensionInstancedArrays exist", "not"), (function () {
	                        return assertExist(record[/* extensionInstancedArrays */0]);
	                      }));
	        }), getIsDebug(stateData));
	  return unsafeGet$1(record[/* extensionInstancedArrays */0]);
	}


	/* Log-WonderLog Not a pure module */

	function isSupportInstance$1(useHardwareInstance, gpuDetectRecord) {
	  if (useHardwareInstance) {
	    return hasExtension(gpuDetectRecord[/* extensionInstancedArrays */0]);
	  } else {
	    return false;
	  }
	}

	var unsafeGetIsSourceInstance = unsafeGet$2;


	/* GPUDetectService-Wonderjs Not a pure module */

	function isSupportInstance(state) {
	  return isSupportInstance$1(unsafeGetGPU(state[/* settingRecord */1])[/* useHardwareInstance */0], state[/* gpuDetectRecord */6]);
	}

	function isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord) {
	  return hasSourceInstanceComponent(unsafeGetGameObject$1(materialIndex, gameObjectMap), gameObjectRecord);
	}

	function buildMap(index, gameObjectMap, gameObjectRecord) {
	  return reduceOneParam((function (map, materialIndex) {
	                return set$1(materialIndex, isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord), map);
	              }), createEmpty$2(/* () */0), range$1(0, index - 1 | 0));
	}


	/* ArrayService-Wonderjs Not a pure module */

	var addDisposeIndex = push;

	function disposeData(material, param, defaultShaderIndex) {
	  return /* tuple */[
	          deleteAndResetUint32(getShaderIndexIndex(material), defaultShaderIndex, param[0]),
	          set$1(material, 0, param[1]),
	          disposeSparseMapData(material, param[2])
	        ];
	}

	function isNotDisposed(disposedIndexArray) {
	  return disposedIndexArray.length === 0;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function getShaders(param) {
	  return param[/* shaders */0];
	}

	function getShaderLibs(param) {
	  return param[/* shaderLibs */1];
	}

	function getPass(param) {
	  return param[/* pass */2];
	}

	function getFail(param) {
	  return param[/* fail */3];
	}


	/* No side effect */

	function _initMaterialShader(gl, param, param$1, param$2) {
	  var state = param$2[2];
	  var renderConfigRecord = param$2[1];
	  var materialIndex = param[0];
	  var shaders = getShaders(renderConfigRecord);
	  param$1[2](materialIndex, _4(param$1[0], materialIndex, /* tuple */[
	            gl,
	            param$1[4](materialIndex, /* tuple */[
	                  param[1],
	                  param[2]
	                ], /* tuple */[
	                  shaders,
	                  _1(param$1[3], shaders),
	                  getShaderLibs(renderConfigRecord)
	                ], state)
	          ], param$1[1], state), param$2[0]);
	  return state;
	}

	var initMaterial$1 = _initMaterialShader;

	function reInitMaterial(gl, param, param$1, param$2) {
	  var state = param$2[2];
	  var renderConfigRecord = param$2[1];
	  var materialIndex = param[0];
	  var shaders = getShaders(renderConfigRecord);
	  param$1[2](materialIndex, _4(param$1[0], materialIndex, /* tuple */[
	            gl,
	            param$1[4](materialIndex, /* tuple */[
	                  param[1],
	                  param[2]
	                ], /* tuple */[
	                  shaders,
	                  _1(param$1[3], shaders),
	                  getShaderLibs(renderConfigRecord)
	                ], state)
	          ], param$1[1], state), param$2[0]);
	  return state;
	}

	function init$2(gl, param, initMaterialFunc, param$1) {
	  var disposedIndexArray = param$1[1];
	  var isSupportInstance = param[1];
	  var isSourceInstanceMap = param[0];
	  requireCheck((function () {
	          return test(buildAssertMessage("not dispose any material before init", "do"), (function () {
	                        return assertTrue(isNotDisposed(disposedIndexArray));
	                      }));
	        }), getIsDebug(stateData));
	  return reduceOneParam((function (state, materialIndex) {
	                return initMaterialFunc(gl, /* tuple */[
	                            materialIndex,
	                            unsafeGetIsSourceInstance(materialIndex, isSourceInstanceMap),
	                            isSupportInstance
	                          ], state);
	              }), param$1[2], range$1(0, param$1[0] - 1 | 0));
	}


	/* Log-WonderLog Not a pure module */

	function _compileShader(gl, glslSource, shader) {
	  gl.shaderSource(shader, glslSource);
	  gl.compileShader(shader);
	  debugWithFunc((function () {
	          var match = gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false;
	          if (match) {
	            var message = gl.getShaderInfoLog(shader);
	            var partial_arg = "" + (String(message) + "");
	            debug((function (param) {
	                    return buildDebugMessage("shader info log", partial_arg, param);
	                  }), getIsDebug(stateData));
	            var partial_arg$1 = "" + (String(glslSource) + "");
	            return debug((function (param) {
	                          return buildDebugMessage("glsl source", partial_arg$1, param);
	                        }), getIsDebug(stateData));
	          } else {
	            return /* () */0;
	          }
	        }), getIsDebug(stateData));
	  return shader;
	}

	function _linkProgram(program, gl) {
	  gl.linkProgram(program);
	  debugWithFunc((function () {
	          var match = gl.getProgramParameter(program, gl.LINK_STATUS) === false;
	          if (match) {
	            var message = gl.getProgramInfoLog(program);
	            return fatal(buildFatalMessage("link program error", "" + (String(message) + ""), "", "", ""));
	          } else {
	            return /* () */0;
	          }
	        }), getIsDebug(stateData));
	  return /* () */0;
	}

	function initShader(vsSource, fsSource, gl, program) {
	  var vs = _compileShader(gl, vsSource, gl.createShader(gl.VERTEX_SHADER));
	  var fs = _compileShader(gl, fsSource, gl.createShader(gl.FRAGMENT_SHADER));
	  gl.attachShader(program, vs);
	  gl.attachShader(program, fs);
	  gl.bindAttribLocation(program, 0, "a_position");
	  _linkProgram(program, gl);
	  gl.deleteShader(vs);
	  gl.deleteShader(fs);
	  return program;
	}

	function unsafeGetProgram(shaderIndex, param) {
	  return ensureCheck((function (program) {
	                return test(buildAssertMessage("program exist", "not"), (function () {
	                              return assertNullableExist(program);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(shaderIndex, param[/* programMap */0]));
	}

	function registerProgram(shaderIndex, param, program) {
	  set$1(shaderIndex, program, param[/* programMap */0]);
	  return program;
	}

	function clearLastSendProgram(record) {
	  return /* record */[
	          /* programMap */record[/* programMap */0],
	          /* lastUsedProgram */undefined
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function getShaderIndex$1(key, param) {
	  var shaderIndexMap = param[/* shaderIndexMap */1];
	  return get(key, shaderIndexMap);
	}

	function setShaderIndex$1(key, shaderIndex, param) {
	  var shaderIndexMap = param[/* shaderIndexMap */1];
	  return set(key, shaderIndex, shaderIndexMap);
	}

	function genereateShaderIndex(record) {
	  var index = record[/* index */0];
	  record[/* index */0] = index + 1 | 0;
	  return ensureCheck((function (r) {
	                var defaultShaderIndex = getDefaultShaderIndex(/* () */0);
	                return test(buildAssertMessage("not equal default shader index:" + (String(defaultShaderIndex) + " "), "equal"), (function () {
	                              return Operators[/* <>= */3](r, defaultShaderIndex);
	                            }));
	              }), getIsDebug(stateData), index);
	}

	function useShaderIndex(shaderIndex, record) {
	  var usedShaderIndexArray = record[/* usedShaderIndexArray */2];
	  push(shaderIndex, usedShaderIndexArray);
	  return record;
	}

	function unuseShaderIndex(shaderIndex, record) {
	  var usedShaderIndexArray = record[/* usedShaderIndexArray */2];
	  var index = usedShaderIndexArray.indexOf(shaderIndex);
	  var match = index === -1;
	  if (match) {
	    return record;
	  } else {
	    usedShaderIndexArray.splice(index, 1);
	    return record;
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _join(array) {
	  var output = "";
	  for(var i = 0 ,i_finish = array.length - 1 | 0; i <= i_finish; ++i){
	    output = output + caml_array_get(array, i)[/* name */0];
	  }
	  return output;
	}

	function _createProgramAndInit(gl, shaderIndex, param, programRecord) {
	  return initShader(param[0], param[1], gl, registerProgram(shaderIndex, programRecord, gl.createProgram()));
	}

	function _initNewShader(materialIndex, shaderIndex, key, param, param$1, param$2) {
	  var shaderLibDataArr = param[1];
	  var gl = param[0];
	  setShaderIndex$1(key, shaderIndex, useShaderIndex(shaderIndex, param$2[0]));
	  var match = param$1[0](materialIndex, shaderLibDataArr, param$1[1], /* tuple */[
	        param$2[2],
	        param$2[5]
	      ]);
	  var program = _createProgramAndInit(gl, shaderIndex, /* tuple */[
	        match[0],
	        match[1]
	      ], param$2[1]);
	  var recordTuple = param$1[2](/* tuple */[
	        gl,
	        shaderIndex,
	        program
	      ], shaderLibDataArr, /* tuple */[
	        param$2[3],
	        param$2[4]
	      ]);
	  param$1[3](gl, /* tuple */[
	        program,
	        shaderIndex,
	        shaderLibDataArr
	      ], recordTuple);
	  return shaderIndex;
	}

	function initMaterialShader$1(materialIndex, param, param$1, param$2) {
	  var shaderRecord = param$2[0];
	  var shaderLibDataArr = param[1];
	  var key = _join(shaderLibDataArr);
	  var match = getShaderIndex$1(key, shaderRecord);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return _initNewShader(materialIndex, genereateShaderIndex(shaderRecord), key, /* tuple */[
	                param[0],
	                shaderLibDataArr
	              ], /* tuple */[
	                param$1[0],
	                param$1[1],
	                param$1[2],
	                param$1[3]
	              ], /* tuple */[
	                shaderRecord,
	                param$2[1],
	                param$2[2],
	                param$2[3],
	                param$2[4],
	                param$2[5]
	              ]);
	  }
	}

	function reInitMaterialShader(materialIndex, param, param$1, param$2) {
	  var shaderRecord = param$2[0];
	  var shaderLibDataArr = param[1];
	  var key = _join(shaderLibDataArr);
	  var shaderIndex = genereateShaderIndex(shaderRecord);
	  return _initNewShader(materialIndex, shaderIndex, key, /* tuple */[
	              param[0],
	              shaderLibDataArr
	            ], /* tuple */[
	              param$1[0],
	              param$1[1],
	              param$1[2],
	              param$1[3]
	            ], /* tuple */[
	              shaderRecord,
	              param$2[1],
	              param$2[2],
	              param$2[3],
	              param$2[4],
	              param$2[5]
	            ]);
	}


	/* ProgramService-Wonderjs Not a pure module */

	function getHandle(name) {
	  return fatal(buildFatalMessage("getHandle", "unknown handle name: " + (String(name) + ""), "", "", ""));
	}


	/* Log-WonderLog Not a pure module */

	function _getLocation(param, getGlLocationFunc, gl) {
	  var locationMap = param[2];
	  var name = param[1];
	  var match = get(name, locationMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    var pos = getGlLocationFunc(param[0], name, gl);
	    set(name, pos, locationMap);
	    return pos;
	  }
	}

	function _getGlAttribLocation(program, name, gl) {
	  return gl.getAttribLocation(program, name);
	}

	function _getGlUniformLocation(program, name, gl) {
	  return gl.getUniformLocation(program, name);
	}

	function getAttribLocation(program, name, attributeLocationMap, gl) {
	  return _getLocation(/* tuple */[
	              program,
	              name,
	              attributeLocationMap
	            ], _getGlAttribLocation, gl);
	}

	function getUniformLocation(program, name, uniformLocationMap, gl) {
	  return _getLocation(/* tuple */[
	              program,
	              name,
	              uniformLocationMap
	            ], _getGlUniformLocation, gl);
	}

	function getAttributeLocationMap(shaderIndex, glslLocationRecord) {
	  return get$3(shaderIndex, glslLocationRecord[/* attributeLocationMap */0]);
	}

	function setAttributeLocationMap(shaderIndex, attributeLocationMap, glslLocationRecord) {
	  set$1(shaderIndex, attributeLocationMap, glslLocationRecord[/* attributeLocationMap */0]);
	  return glslLocationRecord;
	}

	function getUniformLocationMap(shaderIndex, glslLocationRecord) {
	  return get$3(shaderIndex, glslLocationRecord[/* uniformLocationMap */1]);
	}

	function setUniformLocationMap(shaderIndex, uniformLocationMap, glslLocationRecord) {
	  set$1(shaderIndex, uniformLocationMap, glslLocationRecord[/* uniformLocationMap */1]);
	  return glslLocationRecord;
	}

	function isAttributeLocationExist(pos) {
	  return pos !== -1;
	}

	function isUniformLocationExist(pos) {
	  return pos !== null;
	}


	/* HashMapService-WonderCommonlib Not a pure module */

	function getBufferSizeByType(type_) {
	  switch (type_) {
	    case "vec2" : 
	        return 2;
	    case "vec3" : 
	        return 3;
	    default:
	      return fatal(buildFatalMessage("getBufferSizeByType", "invalide type_: " + (String(type_) + ""), "", "", ""));
	  }
	}

	function enableVertexAttribArray(gl, pos, vertexAttribHistoryArray) {
	  var match = isNotEqual(pos, true, vertexAttribHistoryArray);
	  if (match) {
	    gl.enableVertexAttribArray(pos);
	    vertexAttribHistoryArray[pos] = true;
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function sendMatrix3(gl, pos, data) {
	  gl.uniformMatrix3fv(pos, false, data);
	  return /* () */0;
	}

	function sendMatrix4(gl, pos, data) {
	  gl.uniformMatrix4fv(pos, false, data);
	  return /* () */0;
	}

	var getCacheMap = get$3;

	function _queryIsNotCacheWithCache(cache, x, y, z) {
	  var isNotCached = false;
	  if (cache[0] !== x) {
	    cache[0] = x;
	    isNotCached = true;
	  }
	  if (cache[1] !== y) {
	    cache[1] = y;
	    isNotCached = true;
	  }
	  if (cache[2] !== z) {
	    cache[2] = z;
	    isNotCached = true;
	  }
	  return isNotCached;
	}

	function _isNotCacheVector3AndSetCache(shaderCacheMap, name, param) {
	  var z = param[2];
	  var y = param[1];
	  var x = param[0];
	  var match = get(name, shaderCacheMap);
	  if (match !== undefined) {
	    return _queryIsNotCacheWithCache(match, x, y, z);
	  } else {
	    set(name, /* array */[
	          x,
	          y,
	          z
	        ], shaderCacheMap);
	    return true;
	  }
	}

	function _isNotCacheNumberAndSetCache(shaderCacheMap, name, value) {
	  var match = get(name, shaderCacheMap);
	  if (match !== undefined) {
	    return valFromOption(match) !== value;
	  } else {
	    set(name, value, shaderCacheMap);
	    return true;
	  }
	}

	function sendFloat(gl, shaderCacheMap, param, value) {
	  if (_isNotCacheNumberAndSetCache(shaderCacheMap, param[0], value)) {
	    gl.uniform1f(param[1], value);
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function sendInt(gl, shaderCacheMap, param, value) {
	  if (_isNotCacheNumberAndSetCache(shaderCacheMap, param[0], value)) {
	    gl.uniform1i(param[1], value);
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function sendFloat3(gl, shaderCacheMap, param, valueArr) {
	  requireCheck((function () {
	          return test(buildAssertMessage("valueArr.length === 3", "not"), (function () {
	                        return Operators[/* = */0](valueArr.length, 3);
	                      }));
	        }), getIsDebug(stateData));
	  var x = caml_array_get(valueArr, 0);
	  var y = caml_array_get(valueArr, 1);
	  var z = caml_array_get(valueArr, 2);
	  if (_isNotCacheVector3AndSetCache(shaderCacheMap, param[0], /* tuple */[
	          x,
	          y,
	          z
	        ])) {
	    gl.uniform3f(param[1], x, y, z);
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}

	function sendVec3(gl, shaderCacheMap, param, dataTuple) {
	  if (_isNotCacheVector3AndSetCache(shaderCacheMap, param[0], dataTuple)) {
	    gl.uniform3f(param[1], dataTuple[0], dataTuple[1], dataTuple[2]);
	    return /* () */0;
	  } else {
	    return /* () */0;
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getLocalToWorldMatrixTypeArray$2(transform, state) {
	  var transformRecord = state[/* transformRecord */15];
	  return getLocalToWorldMatrixTypeArray$1(transform, transformRecord[/* localToWorldMatrices */0], transformRecord[/* localToWorldMatrixCacheMap */1]);
	}

	function getNormalMatrixTypeArray$1(transform, param) {
	  var transformRecord = param[/* transformRecord */15];
	  return getNormalMatrixTypeArray(transform, transformRecord[/* localToWorldMatrices */0], /* tuple */[
	              transformRecord[/* localToWorldMatrixCacheMap */1],
	              transformRecord[/* normalMatrixCacheMap */2]
	            ]);
	}


	/* ModelMatrixTransformService-Wonderjs Not a pure module */

	function getSendNoCachableDataByType(type_) {
	  switch (type_) {
	    case "mat3" : 
	        return sendMatrix3;
	    case "mat4" : 
	        return sendMatrix4;
	    default:
	      return fatal(buildFatalMessage("getSendNoCachableDataByType", "unknown type:" + (String(type_) + ""), "", "", ""));
	  }
	}

	function getSendCachableDataByType(type_) {
	  switch (type_) {
	    case "float" : 
	        return sendFloat;
	    case "float3" : 
	        return sendFloat3;
	    case "sampler2D" : 
	        return sendInt;
	    case "vec3" : 
	        return sendVec3;
	    default:
	      return fatal(buildFatalMessage("getSendCachableDataByType", "unknown type:" + (String(type_) + ""), "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function unsafeGetUniformSendData$1(shaderIndex, map) {
	  return ensureCheck((function (sendData) {
	                return test(buildAssertMessage("uniform send record exist", "not"), (function () {
	                              return assertNullableExist(sendData);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(shaderIndex, map));
	}


	/* Log-WonderLog Not a pure module */

	function addUniformSendDataByType(param, param$1, getDataFunc) {
	  return /* tuple */[
	          push(/* record */[
	                /* pos */param[0],
	                /* getDataFunc */getDataFunc,
	                /* sendDataFunc */getSendNoCachableDataByType(param[1])
	              ], param$1[0]),
	          param$1[1],
	          param$1[2],
	          param$1[3],
	          param$1[4],
	          param$1[5]
	        ];
	}

	function setToUniformSendMap(shaderIndex, uniformRenderObjectSendModelDataMap, renderObjectSendModelDataArr) {
	  set$1(shaderIndex, renderObjectSendModelDataArr, uniformRenderObjectSendModelDataMap);
	  return /* () */0;
	}

	function unsafeGetUniformSendData(shaderIndex, param) {
	  return unsafeGetUniformSendData$1(shaderIndex, param[/* uniformRenderObjectSendModelDataMap */3]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function addUniformSendDataByType$1(pos, param, param$1) {
	  return /* tuple */[
	          param[0],
	          param[1],
	          param[2],
	          param[3],
	          param[4],
	          push(/* record */[
	                /* pos */pos,
	                /* getDataFunc */param$1[0],
	                /* sendDataFunc */param$1[1]
	              ], param[5])
	        ];
	}

	function setToUniformSendMap$1(shaderIndex, uniformInstanceSendNoCachableDataMap, instanceSendNoCachableDataArr) {
	  set$1(shaderIndex, instanceSendNoCachableDataArr, uniformInstanceSendNoCachableDataMap);
	  return /* () */0;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function addModelSendData(param, sendDataArrTuple) {
	  var type_ = param[3];
	  var pos = param[1];
	  var field = param[0];
	  switch (field) {
	    case "instance_mMatrix" : 
	        return addUniformSendDataByType$1(pos, sendDataArrTuple, /* tuple */[
	                    getLocalToWorldMatrixTypeArray$2,
	                    sendMatrix4
	                  ]);
	    case "instance_normalMatrix" : 
	        return addUniformSendDataByType$1(pos, sendDataArrTuple, /* tuple */[
	                    getNormalMatrixTypeArray$1,
	                    sendMatrix3
	                  ]);
	    case "mMatrix" : 
	        return addUniformSendDataByType(/* tuple */[
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getLocalToWorldMatrixTypeArray$2);
	    case "normalMatrix" : 
	        return addUniformSendDataByType(/* tuple */[
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getNormalMatrixTypeArray$1);
	    default:
	      return fatal(buildFatalMessage("_addModelSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getCameraVMatrixData(state) {
	  return unsafeGet$1(state[/* cameraRecord */7])[/* vMatrix */0];
	}

	function getCameraPMatrixData(state) {
	  return unsafeGet$1(state[/* cameraRecord */7])[/* pMatrix */1];
	}

	function getCameraPositionData(state) {
	  return unsafeGet$1(state[/* cameraRecord */7])[/* position */2];
	}


	/* OptionService-Wonderjs Not a pure module */

	function addUniformSendDataByType$2(param, param$1, getDataFunc) {
	  return /* tuple */[
	          param$1[0],
	          param$1[1],
	          param$1[2],
	          push(/* record */[
	                /* shaderCacheMap */param[0],
	                /* name */param[1],
	                /* pos */param[2],
	                /* getDataFunc */getDataFunc,
	                /* sendDataFunc */getSendCachableDataByType(param[3])
	              ], param$1[3]),
	          param$1[4],
	          param$1[5]
	        ];
	}

	function setToUniformSendMap$2(shaderIndex, uniformShaderSendCachableDataMap, shaderSendCachableDataArr) {
	  return set$1(shaderIndex, shaderSendCachableDataArr, uniformShaderSendCachableDataMap);
	}

	function unsafeGetUniformSendData$3(shaderIndex, glslSenderRecord) {
	  return unsafeGetUniformSendData$1(shaderIndex, glslSenderRecord[/* uniformShaderSendCachableDataMap */6]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function addUniformSendDataByType$3(param, param$1, getDataFunc) {
	  return /* tuple */[
	          param$1[0],
	          param$1[1],
	          push(/* record */[
	                /* pos */param[1],
	                /* getDataFunc */getDataFunc,
	                /* sendDataFunc */getSendNoCachableDataByType(param[0])
	              ], param$1[2]),
	          param$1[3],
	          param$1[4],
	          param$1[5]
	        ];
	}

	function setToUniformSendMap$3(shaderIndex, uniformShaderSendNoCachableDataMap, shaderSendNoCachableDataArr) {
	  return set$1(shaderIndex, shaderSendNoCachableDataArr, uniformShaderSendNoCachableDataMap);
	}

	function unsafeGetUniformSendData$4(shaderIndex, glslSenderRecord) {
	  return unsafeGetUniformSendData$1(shaderIndex, glslSenderRecord[/* uniformShaderSendNoCachableDataMap */5]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function addCameraSendData(param, sendDataArrTuple) {
	  var type_ = param[3];
	  var pos = param[1];
	  var field = param[0];
	  switch (field) {
	    case "pMatrix" : 
	        return addUniformSendDataByType$3(/* tuple */[
	                    type_,
	                    pos
	                  ], sendDataArrTuple, getCameraPMatrixData);
	    case "position" : 
	        return addUniformSendDataByType$2(/* tuple */[
	                    param[4],
	                    param[2],
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getCameraPositionData);
	    case "vMatrix" : 
	        return addUniformSendDataByType$3(/* tuple */[
	                    type_,
	                    pos
	                  ], sendDataArrTuple, getCameraVMatrixData);
	    default:
	      return fatal(buildFatalMessage("_addCameraSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getColor$1(material, param) {
	  return getColor(material, param[/* basicMaterialRecord */8][/* colors */1]);
	}

	function getMapUnit$1(material, param) {
	  return getMapUnit(material, param[/* basicMaterialRecord */8][/* mapUnits */3]);
	}


	/* OperateTypeArrayBasicMaterialService-Wonderjs Not a pure module */

	function getDiffuseColor$1(material, param) {
	  return getDiffuseColor(material, param[/* lightMaterialRecord */9][/* diffuseColors */1]);
	}

	function getSpecularColor$1(material, param) {
	  return getSpecularColor(material, param[/* lightMaterialRecord */9][/* specularColors */2]);
	}

	function getShininess$1(material, param) {
	  return getShininess(material, param[/* lightMaterialRecord */9][/* shininess */3]);
	}

	function getDiffuseMapUnit$1(material, param) {
	  return getDiffuseMapUnit(material, param[/* lightMaterialRecord */9][/* diffuseMapUnits */5]);
	}

	function getSpecularMapUnit$1(material, param) {
	  return getSpecularMapUnit(material, param[/* lightMaterialRecord */9][/* specularMapUnits */6]);
	}


	/* OperateTypeArrayLightMaterialService-Wonderjs Not a pure module */

	function addUniformSendDataByType$4(param, param$1, getDataFunc) {
	  return /* tuple */[
	          param$1[0],
	          push(/* record */[
	                /* shaderCacheMap */param[0],
	                /* name */param[1],
	                /* pos */param[2],
	                /* getDataFunc */getDataFunc,
	                /* sendDataFunc */getSendCachableDataByType(param[3])
	              ], param$1[1]),
	          param$1[2],
	          param$1[3],
	          param$1[4],
	          param$1[5]
	        ];
	}

	function addUniformTextureSendDataByType(param, param$1, getDataFunc) {
	  return /* tuple */[
	          param$1[0],
	          push(/* record */[
	                /* shaderCacheMap */param[0],
	                /* name */param[1],
	                /* pos */param[2],
	                /* getDataFunc */getDataFunc,
	                /* sendDataFunc */sendInt
	              ], param$1[1]),
	          param$1[2],
	          param$1[3],
	          param$1[4],
	          param$1[5]
	        ];
	}

	function setToUniformSendMap$4(shaderIndex, uniformRenderObjectSendMaterialDataMap, renderObjectSendMaterialDataArr) {
	  set$1(shaderIndex, renderObjectSendMaterialDataArr, uniformRenderObjectSendMaterialDataMap);
	  return /* () */0;
	}

	function unsafeGetUniformSendData$5(shaderIndex, glslSenderRecord) {
	  return unsafeGetUniformSendData$1(shaderIndex, glslSenderRecord[/* uniformRenderObjectSendMaterialDataMap */4]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function addBasicMaterialSendData(param, sendDataArrTuple) {
	  var uniformCacheMap = param[4];
	  var type_ = param[3];
	  var name = param[2];
	  var pos = param[1];
	  var field = param[0];
	  switch (field) {
	    case "color" : 
	        return addUniformSendDataByType$4(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getColor$1);
	    case "map" : 
	        return addUniformTextureSendDataByType(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getMapUnit$1);
	    default:
	      return fatal(buildFatalMessage("_addBasicMaterialSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}

	function addLightMaterialSendData(param, sendDataArrTuple) {
	  var uniformCacheMap = param[4];
	  var type_ = param[3];
	  var name = param[2];
	  var pos = param[1];
	  var field = param[0];
	  switch (field) {
	    case "diffuseColor" : 
	        return addUniformSendDataByType$4(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getDiffuseColor$1);
	    case "diffuseMap" : 
	        return addUniformTextureSendDataByType(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getDiffuseMapUnit$1);
	    case "shininess" : 
	        return addUniformSendDataByType$4(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getShininess$1);
	    case "specularColor" : 
	        return addUniformSendDataByType$4(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getSpecularColor$1);
	    case "specularMap" : 
	        return addUniformTextureSendDataByType(/* tuple */[
	                    uniformCacheMap,
	                    name,
	                    pos,
	                    type_
	                  ], sendDataArrTuple, getSpecularMapUnit$1);
	    default:
	      return fatal(buildFatalMessage("_addLightMaterialSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getOrCreateHashMap(map) {
	  if (map !== undefined) {
	    return valFromOption(map);
	  } else {
	    return createEmpty(/* () */0);
	  }
	}


	/* HashMapService-WonderCommonlib Not a pure module */

	function addUniformSendDataByType$5(param, param$1, sendDataFunc) {
	  return /* tuple */[
	          param$1[0],
	          param$1[1],
	          param$1[2],
	          param$1[3],
	          push(/* record */[
	                /* program */param[0],
	                /* shaderCacheMap */param[1],
	                /* locationMap */param[2],
	                /* sendCachableFunctionDataFunc */sendDataFunc
	              ], param$1[4]),
	          param$1[5]
	        ];
	}

	function setToUniformSendMap$5(shaderIndex, uniformShaderSendCachableFunctionDataMap, shaderSendCachableFunctionDataArr) {
	  return set$1(shaderIndex, shaderSendCachableFunctionDataArr, uniformShaderSendCachableFunctionDataMap);
	}

	function unsafeGetUniformSendData$6(shaderIndex, glslSenderRecord) {
	  return unsafeGetUniformSendData$1(shaderIndex, glslSenderRecord[/* uniformShaderSendCachableFunctionDataMap */7]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _setToUniformSendMap(shaderIndex, param, param$1) {
	  setToUniformSendMap(shaderIndex, param[/* uniformRenderObjectSendModelDataMap */3], param$1[0]);
	  setToUniformSendMap$4(shaderIndex, param[/* uniformRenderObjectSendMaterialDataMap */4], param$1[1]);
	  setToUniformSendMap$3(shaderIndex, param[/* uniformShaderSendNoCachableDataMap */5], param$1[2]);
	  setToUniformSendMap$2(shaderIndex, param[/* uniformShaderSendCachableDataMap */6], param$1[3]);
	  setToUniformSendMap$5(shaderIndex, param[/* uniformShaderSendCachableFunctionDataMap */7], param$1[4]);
	  setToUniformSendMap$1(shaderIndex, param[/* uniformInstanceSendNoCachableDataMap */8], param$1[5]);
	  return /* () */0;
	}

	function readUniformSendData(shaderLibDataArr, param, readUniformsFunc, param$1) {
	  var uniformCacheMap = param$1[1];
	  var uniformLocationMap = param$1[0];
	  var program = param[1];
	  var gl = param[0];
	  return reduceOneParam((function (sendDataArrTuple, param) {
	                var variables = param[/* variables */2];
	                var match = isJsonSerializedValueNone(variables);
	                if (match) {
	                  return sendDataArrTuple;
	                } else {
	                  var match$1 = unsafeGetJsonSerializedValue(variables);
	                  return readUniformsFunc(/* tuple */[
	                              gl,
	                              program,
	                              uniformLocationMap,
	                              uniformCacheMap
	                            ], sendDataArrTuple, match$1[/* uniforms */0]);
	                }
	              }), /* tuple */[
	              /* array */[],
	              /* array */[],
	              /* array */[],
	              /* array */[],
	              /* array */[],
	              /* array */[]
	            ], shaderLibDataArr);
	}

	function addUniformSendData$1(gl, param, readUniformSendDataFunc, param$1) {
	  var glslLocationRecord = param$1[1];
	  var glslSenderRecord = param$1[0];
	  var shaderIndex = param[1];
	  var uniformLocationMap = getOrCreateHashMap(getUniformLocationMap(shaderIndex, glslLocationRecord));
	  return /* tuple */[
	          _setToUniformSendMap(shaderIndex, glslSenderRecord, readUniformSendDataFunc(param[2], gl, param[0], /* tuple */[
	                    uniformLocationMap,
	                    getOrCreateHashMap(getCacheMap(shaderIndex, glslSenderRecord[/* uniformCacheMap */2]))
	                  ])),
	          setUniformLocationMap(shaderIndex, uniformLocationMap, glslLocationRecord)
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function _readUniforms(param, sendDataArrTuple, uniforms) {
	  var uniformCacheMap = param[3];
	  var uniformLocationMap = param[2];
	  var program = param[1];
	  var gl = param[0];
	  var match = isJsonSerializedValueNone(uniforms);
	  if (match) {
	    return sendDataArrTuple;
	  } else {
	    return reduceOneParam((function (sendDataArrTuple, param) {
	                  var from = param[/* from */3];
	                  var type_ = param[/* type_ */2];
	                  var field = param[/* field */1];
	                  var name = param[/* name */0];
	                  switch (from) {
	                    case "basicMaterial" : 
	                        return addBasicMaterialSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    case "camera" : 
	                        return addCameraSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    case "model" : 
	                        return addModelSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    default:
	                      return fatal(buildFatalMessage("_readUniforms", "unknow from:" + (String(from) + ""), "", "", ""));
	                  }
	                }), sendDataArrTuple, unsafeGetJsonSerializedValue(uniforms));
	  }
	}

	function _readUniformSendData(shaderLibDataArr, gl, program, param) {
	  return readUniformSendData(shaderLibDataArr, /* tuple */[
	              gl,
	              program
	            ], _readUniforms, /* tuple */[
	              param[0],
	              param[1]
	            ]);
	}

	function addUniformSendData(gl, param, recordTuple) {
	  return addUniformSendData$1(gl, /* tuple */[
	              param[0],
	              param[1],
	              param[2]
	            ], _readUniformSendData, recordTuple);
	}


	/* Log-WonderLog Not a pure module */

	function sendBuffer(gl, param, buffer, state) {
	  var pos = param[1];
	  var match = isAttributeLocationExist(pos);
	  if (match) {
	    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	    gl.vertexAttribPointer(pos, param[0], gl.FLOAT, false, 0, 0);
	    enableVertexAttribArray(gl, pos, state[/* glslSenderRecord */3][/* vertexAttribHistoryArray */9]);
	  }
	  return state;
	}


	/* GLSLLocationService-Wonderjs Not a pure module */

	function bindElementArrayBuffer(gl, _, buffer, renderState) {
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
	  return renderState;
	}


	/* No side effect */

	function addModelMatrixInstanceArrayBufferSendData(param, param$1) {
	  return /* tuple */[
	          param$1[0],
	          push(/* record */[
	                /* pos */getAttribLocation(param[1], param[2], param[3], param[0]),
	                /* size */4,
	                /* getOffsetFunc */(function (index) {
	                    return (index << 4);
	                  })
	              ], param$1[1])
	        ];
	}

	function addOtherArrayBufferSendData(param, param$1) {
	  return /* tuple */[
	          push(/* record */[
	                /* pos */getAttribLocation(param[1], param[2], param[5], param[0]),
	                /* size */getBufferSizeByType(param[4]),
	                /* buffer */param[3],
	                /* sendFunc */sendBuffer
	              ], param$1[0]),
	          param$1[1]
	        ];
	}

	function addElementBufferSendData(buffer, param) {
	  return /* tuple */[
	          push(/* record */[
	                /* pos */0,
	                /* size */0,
	                /* buffer */buffer,
	                /* sendFunc */bindElementArrayBuffer
	              ], param[0]),
	          param[1]
	        ];
	}

	function readAttributeSendData(shaderLibDataArr, param, readAttributesFunc, attributeLocationMap) {
	  var program = param[1];
	  var gl = param[0];
	  return reduceOneParam((function (sendDataArrTuple, param) {
	                var variables = param[/* variables */2];
	                var match = isJsonSerializedValueNone(variables);
	                if (match) {
	                  return sendDataArrTuple;
	                } else {
	                  var match$1 = unsafeGetJsonSerializedValue(variables);
	                  return readAttributesFunc(/* tuple */[
	                              gl,
	                              program,
	                              attributeLocationMap
	                            ], sendDataArrTuple, match$1[/* attributes */1]);
	                }
	              }), /* tuple */[
	              /* array */[],
	              /* array */[]
	            ], shaderLibDataArr);
	}

	function _setToAttributeSendMap(shaderIndex, _, glslSenderRecord, param) {
	  set$1(shaderIndex, param[0], glslSenderRecord[/* attributeSendDataMap */0]);
	  set$1(shaderIndex, param[1], glslSenderRecord[/* instanceAttributeSendDataMap */1]);
	  return glslSenderRecord;
	}

	function addAttributeSendData$1(param, shaderLibDataArr, readAttributeSendDataFunc, param$1) {
	  var glslLocationRecord = param$1[1];
	  var shaderIndex = param[1];
	  var attributeLocationMap = getOrCreateHashMap(getAttributeLocationMap(shaderIndex, glslLocationRecord));
	  return /* tuple */[
	          _setToAttributeSendMap(shaderIndex, attributeLocationMap, param$1[0], readAttributeSendDataFunc(shaderLibDataArr, param[0], param[2], attributeLocationMap)),
	          setAttributeLocationMap(shaderIndex, attributeLocationMap, glslLocationRecord)
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _readAttributes(param, sendDataArrTuple, attributes) {
	  var attributeLocationMap = param[2];
	  var program = param[1];
	  var gl = param[0];
	  var match = isJsonSerializedValueNone(attributes);
	  if (match) {
	    return sendDataArrTuple;
	  } else {
	    return reduceOneParam((function (sendDataArrTuple, param) {
	                  var type_ = param[/* type_ */2];
	                  var buffer = param[/* buffer */1];
	                  var name = param[/* name */0];
	                  var match = !isJsonSerializedValueNone(name) && !isJsonSerializedValueNone(type_);
	                  if (match) {
	                    var name$1 = unsafeGetJsonSerializedValue(name);
	                    var type_$1 = unsafeGetJsonSerializedValue(type_);
	                    if (buffer >= 5) {
	                      return addModelMatrixInstanceArrayBufferSendData(/* tuple */[
	                                  gl,
	                                  program,
	                                  name$1,
	                                  attributeLocationMap
	                                ], sendDataArrTuple);
	                    } else {
	                      return addOtherArrayBufferSendData(/* tuple */[
	                                  gl,
	                                  program,
	                                  name$1,
	                                  buffer,
	                                  type_$1,
	                                  attributeLocationMap
	                                ], sendDataArrTuple);
	                    }
	                  } else {
	                    return addElementBufferSendData(buffer, sendDataArrTuple);
	                  }
	                }), sendDataArrTuple, unsafeGetJsonSerializedValue(attributes));
	  }
	}

	function _readAttributeSendData(shaderLibDataArr, gl, program, attributeLocationMap) {
	  return readAttributeSendData(shaderLibDataArr, /* tuple */[
	              gl,
	              program
	            ], _readAttributes, attributeLocationMap);
	}

	function addAttributeSendData(glTuple, shaderLibDataArr, recordTuple) {
	  return addAttributeSendData$1(glTuple, shaderLibDataArr, _readAttributeSendData, recordTuple);
	}


	/* OptionService-Wonderjs Not a pure module */

	function initMaterialShader(materialIndex, param, buildGLSLSourceFunc, state) {
	  return initMaterialShader$1(materialIndex, /* tuple */[
	              param[0],
	              param[1]
	            ], /* tuple */[
	              buildGLSLSourceFunc,
	              getHandle,
	              addAttributeSendData,
	              addUniformSendData
	            ], /* tuple */[
	              state[/* shaderRecord */2],
	              state[/* programRecord */3],
	              state[/* glslRecord */4],
	              state[/* glslSenderRecord */5],
	              state[/* glslLocationRecord */6],
	              state[/* glslChunkRecord */7]
	            ]);
	}


	/* InitShaderInitMaterialService-Wonderjs Not a pure module */

	var webgl1_main_begin = "void main(void){\n";

	var webgl1_main_end = "}\n";

	function _generateAttributeSource(shaderLibDataArr) {
	  return shaderLibDataArr.reduce((function (result, param) {
	                var variables = param[/* variables */2];
	                var match = isJsonSerializedValueNone(variables);
	                if (match) {
	                  return result;
	                } else {
	                  var optionalAttributes = unsafeGetJsonSerializedValue(variables)[/* attributes */1];
	                  var match$1 = isJsonSerializedValueNone(optionalAttributes);
	                  if (match$1) {
	                    return result;
	                  } else {
	                    return result + unsafeGetJsonSerializedValue(optionalAttributes).reduce((function (result, param) {
	                                  var type_ = param[/* type_ */2];
	                                  var name = param[/* name */0];
	                                  var match = !isJsonSerializedValueNone(name) && !isJsonSerializedValueNone(type_);
	                                  if (match) {
	                                    var name$1 = unsafeGetJsonSerializedValue(name);
	                                    var type_$1 = unsafeGetJsonSerializedValue(type_);
	                                    return result + ("attribute " + (String(type_$1) + (" " + (String(name$1) + ";\n  "))));
	                                  } else {
	                                    return result;
	                                  }
	                                }), "");
	                  }
	                }
	              }), "");
	}

	function _isInSource(key, source) {
	  return source.indexOf(key) > -1;
	}

	function _generateUniformSourceType(type_) {
	  if (type_ === "float3") {
	    return "vec3";
	  } else {
	    return type_;
	  }
	}

	function _generateUniformSource(shaderLibDataArr, sourceVarDeclare, sourceFuncDefine, sourceBody) {
	  return shaderLibDataArr.reduce((function (result, param) {
	                var variables = param[/* variables */2];
	                var match = isJsonSerializedValueNone(variables);
	                if (match) {
	                  return result;
	                } else {
	                  var optionalUniforms = unsafeGetJsonSerializedValue(variables)[/* uniforms */0];
	                  var match$1 = isJsonSerializedValueNone(optionalUniforms);
	                  if (match$1) {
	                    return result;
	                  } else {
	                    return result + unsafeGetJsonSerializedValue(optionalUniforms).filter((function (param) {
	                                    var name = param[/* name */0];
	                                    if (_isInSource(name, sourceVarDeclare) || _isInSource(name, sourceFuncDefine)) {
	                                      return true;
	                                    } else {
	                                      return _isInSource(name, sourceBody);
	                                    }
	                                  })).reduce((function (result, param) {
	                                  var type_ = _generateUniformSourceType(param[/* type_ */2]);
	                                  return result + ("uniform " + (String(type_) + (" " + (String(param[/* name */0]) + ";\n"))));
	                                }), "");
	                  }
	                }
	              }), "");
	}

	function _setSource(sourceChunk, param) {
	  var sourceTop = sourceChunk[/* top */0];
	  var sourceDefine = sourceChunk[/* define */1];
	  var sourceVarDeclare = sourceChunk[/* varDeclare */2];
	  var sourceFuncDeclare = sourceChunk[/* funcDeclare */3];
	  var sourceFuncDefine = sourceChunk[/* funcDefine */4];
	  var sourceBody = sourceChunk[/* body */5];
	  var top = param[/* top */0];
	  var define = param[/* define */1];
	  var varDeclare = param[/* varDeclare */2];
	  var funcDeclare = param[/* funcDeclare */3];
	  var funcDefine = param[/* funcDefine */4];
	  var body = param[/* body */5];
	  sourceChunk[/* top */0] = sourceTop + top;
	  sourceChunk[/* define */1] = sourceDefine + define;
	  sourceChunk[/* varDeclare */2] = sourceVarDeclare + varDeclare;
	  sourceChunk[/* funcDeclare */3] = sourceFuncDeclare + funcDeclare;
	  sourceChunk[/* funcDefine */4] = sourceFuncDefine + funcDefine;
	  sourceChunk[/* body */5] = sourceBody + body;
	  return sourceChunk;
	}

	function _buildBody(param, webgl1_main_end) {
	  var body = param[/* body */5];
	  return body + webgl1_main_end;
	}

	function _buildVarDeclare(param, shaderLibDataArr) {
	  var varDeclare = param[/* varDeclare */2];
	  var funcDefine = param[/* funcDefine */4];
	  var body = param[/* body */5];
	  return varDeclare + ("\n" + _generateUniformSource(shaderLibDataArr, varDeclare, funcDefine, body));
	}

	function _addAlllParts(param) {
	  var top = param[/* top */0];
	  var define = param[/* define */1];
	  var varDeclare = param[/* varDeclare */2];
	  var funcDeclare = param[/* funcDeclare */3];
	  var funcDefine = param[/* funcDefine */4];
	  var body = param[/* body */5];
	  return top + (define + (varDeclare + (funcDeclare + (funcDefine + body))));
	}

	function _buildVsAndFsByType(param, param$1, execHandleFunc, glslChunkRecord) {
	  var name = param$1[1];
	  var type_ = param$1[0];
	  var fs = param[1];
	  var vs = param[0];
	  switch (type_) {
	    case "fs" : 
	        return /* tuple */[
	                vs,
	                _setSource(fs, getChunk(name, glslChunkRecord))
	              ];
	    case "fs_function" : 
	        return /* tuple */[
	                vs,
	                _setSource(fs, _1(execHandleFunc, name))
	              ];
	    case "vs" : 
	        return /* tuple */[
	                _setSource(vs, getChunk(name, glslChunkRecord)),
	                fs
	              ];
	    case "vs_function" : 
	        return /* tuple */[
	                _setSource(vs, _1(execHandleFunc, name)),
	                fs
	              ];
	    default:
	      return fatal(buildFatalMessage("buildGLSLSource", "unknown glsl type: " + (String(type_) + ""), "", "", "name: " + (String(name) + "")));
	  }
	}

	function _buildVsAndFs(param, shaderLibDataArr, execHandleFunc, glslChunkRecord) {
	  return reduceOneParam((function (glslTuple, param) {
	                var glsls = param[/* glsls */1];
	                var match = isJsonSerializedValueNone(glsls);
	                if (match) {
	                  return glslTuple;
	                } else {
	                  return reduceOneParam((function (sourceTuple, param) {
	                                return _buildVsAndFsByType(sourceTuple, /* tuple */[
	                                            param[/* type_ */0],
	                                            param[/* name */1]
	                                          ], execHandleFunc, glslChunkRecord);
	                              }), glslTuple, unsafeGetJsonSerializedValue(glsls));
	                }
	              }), /* tuple */[
	              param[0],
	              param[1]
	            ], shaderLibDataArr);
	}

	function buildGLSLSource(_, shaderLibDataArr, execHandleFunc, param) {
	  var precision = param[0][/* precision */0];
	  var vs = /* record */[
	    /* top */"",
	    /* define */"",
	    /* varDeclare */"",
	    /* funcDeclare */"",
	    /* funcDefine */"",
	    /* body */""
	  ];
	  var fs = /* record */[
	    /* top */"",
	    /* define */"",
	    /* varDeclare */"",
	    /* funcDeclare */"",
	    /* funcDefine */"",
	    /* body */""
	  ];
	  vs[/* body */5] = vs[/* body */5] + webgl1_main_begin;
	  fs[/* body */5] = fs[/* body */5] + webgl1_main_begin;
	  var precision$1 = unsafeGet$1(precision);
	  vs[/* top */0] = precision$1 + vs[/* top */0];
	  fs[/* top */0] = precision$1 + fs[/* top */0];
	  var match = _buildVsAndFs(/* tuple */[
	        vs,
	        fs
	      ], shaderLibDataArr, execHandleFunc, param[1]);
	  var fs$1 = match[1];
	  var vs$1 = match[0];
	  vs$1[/* body */5] = _buildBody(vs$1, webgl1_main_end);
	  fs$1[/* body */5] = _buildBody(fs$1, webgl1_main_end);
	  vs$1[/* varDeclare */2] = "\n" + (_generateAttributeSource(shaderLibDataArr) + vs$1[/* varDeclare */2]);
	  vs$1[/* varDeclare */2] = _buildVarDeclare(vs$1, shaderLibDataArr);
	  fs$1[/* varDeclare */2] = _buildVarDeclare(fs$1, shaderLibDataArr);
	  return /* tuple */[
	          _addAlllParts(vs$1),
	          _addAlllParts(fs$1)
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function findFirstShaderData(shaderLibName, shaderLibs) {
	  return unsafeFindFirst(shaderLibs, shaderLibName, (function (item) {
	                return filterTargetName(item[/* name */0], shaderLibName);
	              }));
	}

	function _getMaterialShaderLibDataArrByGroup(groups, name, shaderLibs, resultDataArr) {
	  return resultDataArr.concat(unsafeFindFirst(groups, name, (function (item) {
	                        return filterTargetName(item[/* name */0], name);
	                      }))[/* value */1].map((function (name) {
	                    return findFirstShaderData(name, shaderLibs);
	                  })));
	}

	function handleUnknownNameWhenGetMaterialShaderLibDataArrByStaticBranch(name, staticBranchs) {
	  var partial_arg = "staticBranchs";
	  debugJson((function (param) {
	          return buildDebugJsonMessage(partial_arg, staticBranchs, param);
	        }), getIsDebug(stateData));
	  return fatal(buildFatalMessage("_getMaterialShaderLibDataArrByStaticBranch", "unknown name:" + (String(name) + ""), "", "", ""));
	}

	function getMaterialShaderLibDataArrByStaticBranchInstance(param, param$1, resultDataArr) {
	  var value = param$1[1];
	  return push(findFirstShaderData(param[0] ? (
	                    param[1] ? caml_array_get(value, 1) : caml_array_get(value, 2)
	                  ) : caml_array_get(value, 0), param$1[0]), resultDataArr);
	}

	function getMaterialShaderLibDataArrByDynamicBranch(param, param$1, isPassFunc, resultDataArr) {
	  var name = param[1];
	  var dynamicBranchData = unsafeFindFirst(param$1[0], name, (function (item) {
	          return filterTargetName(item[/* name */0], name);
	        }));
	  var match = isPassFunc(param[0], dynamicBranchData[/* condition */1], param$1[2]);
	  var dynamicBranchShaderLibNameOption = match ? getPass(dynamicBranchData) : getFail(dynamicBranchData);
	  var match$1 = isJsonSerializedValueNone(dynamicBranchShaderLibNameOption);
	  if (match$1) {
	    return resultDataArr;
	  } else {
	    return push(findFirstShaderData(unsafeGetJsonSerializedValue(dynamicBranchShaderLibNameOption), param$1[1]), resultDataArr);
	  }
	}

	function getMaterialShaderLibDataArrByType(param, param$1, param$2, resultDataArr) {
	  var shaderLibs = param$1[0];
	  var name = param[3];
	  var type_ = param[1];
	  switch (type_) {
	    case "dynamic_branch" : 
	        return getMaterialShaderLibDataArrByDynamicBranch(/* tuple */[
	                    param[0],
	                    name
	                  ], /* tuple */[
	                    param$1[2],
	                    shaderLibs,
	                    param$1[3]
	                  ], param$2[1], resultDataArr);
	    case "group" : 
	        return _getMaterialShaderLibDataArrByGroup(param[2], name, shaderLibs, resultDataArr);
	    case "static_branch" : 
	        return param$2[0](/* tuple */[
	                    name,
	                    param[4],
	                    param[5]
	                  ], /* tuple */[
	                    param$1[1],
	                    shaderLibs
	                  ], resultDataArr);
	    default:
	      var partial_arg = "shaderLibs";
	      debugJson((function (param) {
	              return buildDebugJsonMessage(partial_arg, shaderLibs, param);
	            }), getIsDebug(stateData));
	      return fatal(buildFatalMessage("_getMaterialShaderLibDataArrByType", "unknown type_:" + (String(type_) + ""), "", "", ""));
	  }
	}

	function getMaterialShaderLibDataArr$1(param, param$1, param$2, state) {
	  var isPassFunc = param$2[1];
	  var getMaterialShaderLibDataArrByStaticBranchFunc = param$2[0];
	  var shaderLibs = param$1[2];
	  var match = param$1[0];
	  var groups = match[/* groups */2];
	  var dynamicBranchs = match[/* dynamicBranchs */1];
	  var staticBranchs = match[/* staticBranchs */0];
	  var isSupportInstance = param[2];
	  var isSourceInstance = param[1];
	  var materialIndex = param[0];
	  return reduceOneParam((function (resultDataArr, param) {
	                var name = param[/* name */1];
	                var type_ = param[/* type_ */0];
	                var match = isJsonSerializedValueNone(type_);
	                if (match) {
	                  return push(findFirstShaderData(name, shaderLibs), resultDataArr);
	                } else {
	                  return getMaterialShaderLibDataArrByType(/* tuple */[
	                              materialIndex,
	                              unsafeGetJsonSerializedValue(type_),
	                              groups,
	                              name,
	                              isSourceInstance,
	                              isSupportInstance
	                            ], /* tuple */[
	                              shaderLibs,
	                              staticBranchs,
	                              dynamicBranchs,
	                              state
	                            ], /* tuple */[
	                              getMaterialShaderLibDataArrByStaticBranchFunc,
	                              isPassFunc
	                            ], resultDataArr);
	                }
	              }), createEmpty$1(/* () */0), param$1[1]);
	}


	/* Log-WonderLog Not a pure module */

	function _getMaterialShaderLibDataArrByStaticBranch(param, param$1, resultDataArr) {
	  var staticBranchs = param$1[0];
	  var name = param[0];
	  if (name === "modelMatrix_instance") {
	    var match = unsafeFindFirst(staticBranchs, name, (function (item) {
	            return filterTargetName(item[/* name */0], name);
	          }));
	    return getMaterialShaderLibDataArrByStaticBranchInstance(/* tuple */[
	                param[1],
	                param[2]
	              ], /* tuple */[
	                param$1[1],
	                match[/* value */1]
	              ], resultDataArr);
	  } else {
	    return handleUnknownNameWhenGetMaterialShaderLibDataArrByStaticBranch(name, staticBranchs);
	  }
	}

	function _isPass(materialIndex, condition, state) {
	  if (condition === "basic_has_map") {
	    return hasMap(getMapUnit(materialIndex, state[/* materialRecord */0][/* mapUnits */3]));
	  } else {
	    return fatal(buildFatalMessage("_isPass", "unknown condition:" + (String(condition) + ""), "", "", ""));
	  }
	}

	function getMaterialShaderLibDataArr(materialIndex, param, shaderLibTuple, state) {
	  return getMaterialShaderLibDataArr$1(/* tuple */[
	              materialIndex,
	              param[0],
	              param[1]
	            ], shaderLibTuple, /* tuple */[
	              _getMaterialShaderLibDataArrByStaticBranch,
	              _isPass
	            ], state);
	}


	/* Log-WonderLog Not a pure module */

	function _getShaderLibItems(param) {
	  var shaderName = "render_basic";
	  return unsafeFindFirst(param[/* materialShaders */3], shaderName, (function (param) {
	                  return filterTargetName(param[/* name */0], shaderName);
	                }))[/* shaderLibs */1];
	}

	function isNeedInitMaterial(materialIndex, shaderIndices) {
	  return !hasShaderIndex(materialIndex, shaderIndices);
	}

	function initMaterial(gl, dataTuple, state) {
	  return initMaterial$1(gl, dataTuple, /* tuple */[
	              initMaterialShader,
	              buildGLSLSource,
	              setShaderIndex,
	              _getShaderLibItems,
	              getMaterialShaderLibDataArr
	            ], /* tuple */[
	              state[/* materialRecord */0][/* shaderIndices */2],
	              state[/* renderConfigRecord */1],
	              state
	            ]);
	}

	function init$1(gl, instanceTuple, state) {
	  var materialRecord = state[/* materialRecord */0];
	  return init$2(gl, instanceTuple, initMaterial, /* tuple */[
	              materialRecord[/* index */0],
	              materialRecord[/* disposedIndexArray */1],
	              state
	            ]);
	}


	/* JobConfigService-Wonderjs Not a pure module */

	function buildMapFromArray(array, map) {
	  forEach((function (value) {
	          set$1(value, true, map);
	          return /* () */0;
	        }), array);
	  return map;
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function removeDisposedOnesFromMaterialArrayForWorkerInit(materialArray, materialArrayForWorkerInit) {
	  var match = materialArray.length;
	  if (match !== 0) {
	    var materialMap = buildMapFromArray(materialArray, createEmpty$2(/* () */0));
	    return materialArrayForWorkerInit.filter((function (material) {
	                  return !has$1(material, materialMap);
	                }));
	  } else {
	    return materialArrayForWorkerInit;
	  }
	}

	function addMaterialToMaterialArrayForWorkerInit(materialIndex, materialArrayForWorkerInit) {
	  var match = getLast(materialArrayForWorkerInit) === materialIndex;
	  if (match) {
	    return materialArrayForWorkerInit;
	  } else {
	    return push(materialIndex, materialArrayForWorkerInit);
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function getRecord$8(state) {
	  return unsafeGet$1(state[/* renderConfigRecord */5]);
	}


	/* OptionService-Wonderjs Not a pure module */

	function createInitMaterialState(param, state) {
	  var match = getRecord$4(state);
	  return /* record */[
	          /* materialRecord : record */[
	            /* index */param[0],
	            /* disposedIndexArray */param[1],
	            /* shaderIndices */match[/* shaderIndices */2],
	            /* mapUnits */match[/* mapUnits */5]
	          ],
	          /* renderConfigRecord */getRecord$8(state),
	          /* shaderRecord */state[/* shaderRecord */27],
	          /* programRecord */state[/* programRecord */29],
	          /* glslRecord */state[/* glslRecord */28],
	          /* glslSenderRecord */state[/* glslSenderRecord */31],
	          /* glslLocationRecord */state[/* glslLocationRecord */30],
	          /* glslChunkRecord */state[/* glslChunkRecord */32]
	        ];
	}


	/* RecordRenderConfigMainService-Wonderjs Not a pure module */

	function initMaterials(materialIndexArr, gl, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var gameObjectMap = getRecord$4(state)[/* gameObjectMap */8];
	  var isSupportInstance$$1 = isSupportInstance(state);
	  var match = getRecord$4(state);
	  reduceOneParam((function (state, materialIndex) {
	          return initMaterial(gl, /* tuple */[
	                      materialIndex,
	                      isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord),
	                      isSupportInstance$$1
	                    ], state);
	        }), createInitMaterialState(/* tuple */[
	            match[/* index */0],
	            match[/* disposedIndexArray */10]
	          ], state), materialIndexArr);
	  return state;
	}

	function handleInitComponent(materialIndex, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getRecord$4(state);
	  var match$1 = isNeedInitMaterial(materialIndex, match[/* shaderIndices */2]);
	  if (match$1) {
	    var match$2 = isUseWorker(state);
	    if (match$2) {
	      var match$3 = getRecord$4(state);
	      var materialArrayForWorkerInit = match$3[/* materialArrayForWorkerInit */12];
	      addMaterialToMaterialArrayForWorkerInit(materialIndex, materialArrayForWorkerInit);
	      return state;
	    } else {
	      var gl = unsafeGetGl$1(state[/* deviceManagerRecord */10]);
	      var gameObjectMap = getRecord$4(state)[/* gameObjectMap */8];
	      var isSupportInstance$$1 = isSupportInstance(state);
	      var match$4 = getRecord$4(state);
	      initMaterial(gl, /* tuple */[
	            materialIndex,
	            isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord),
	            isSupportInstance$$1
	          ], createInitMaterialState(/* tuple */[
	                match$4[/* index */0],
	                match$4[/* disposedIndexArray */10]
	              ], state));
	      return state;
	    }
	  } else {
	    return state;
	  }
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function getBufferMaxCount() {
	  return 4;
	}

	function getColorsSize$1() {
	  return 3;
	}

	function getIntensitiesSize() {
	  return 1;
	}

	function getColorIndex$1(index) {
	  return imul(index, 3);
	}

	function getIntensityIndex(index) {
	  return (index << 0);
	}

	function getColorsOffset$1() {
	  return 0;
	}

	function getColorsLength$1() {
	  return 12;
	}

	function getIntensitiesOffset() {
	  return imul(getColorsLength$1(/* () */0), Float32Array.BYTES_PER_ELEMENT);
	}

	function getIntensitiesLength() {
	  return 4;
	}

	function getTotalByteLength$6(count) {
	  return (imul(count, Float32Array.BYTES_PER_ELEMENT) << 2);
	}

	function createBuffer$6(count) {
	  return newSharedArrayBuffer(getTotalByteLength$6(count));
	}


	/* Worker-Wonderjs Not a pure module */

	function getLightCount$1(count, _) {
	  return ensureCheck((function (count) {
	                var maxCount = getBufferMaxCount(/* () */0);
	                return test(buildAssertMessage("light count: " + (String(count) + (" <= max buffer count: " + (String(maxCount) + ""))), "not"), (function () {
	                              return assertLte(/* Int */0, count, maxCount);
	                            }));
	              }), getIsDebug(stateData), count);
	}


	/* Log-WonderLog Not a pure module */

	function getBufferMaxCount$1() {
	  return 4;
	}

	function getColorsSize$2() {
	  return 3;
	}

	function getIntensitiesSize$1() {
	  return 1;
	}

	function getConstantsSize() {
	  return 1;
	}

	function getLinearsSize() {
	  return 1;
	}

	function getQuadraticsSize() {
	  return 1;
	}

	function getRangesSize() {
	  return 1;
	}

	function getColorIndex$2(index) {
	  return imul(index, 3);
	}

	function getColorsOffset$2() {
	  return 0;
	}

	function getColorsLength$2() {
	  return 12;
	}

	function getIntensitiesOffset$1() {
	  return imul(getColorsLength$2(/* () */0), Float32Array.BYTES_PER_ELEMENT);
	}

	function getIntensitiesLength$1() {
	  return 4;
	}

	function getConstantsOffset() {
	  return imul(getColorsLength$2(/* () */0), Float32Array.BYTES_PER_ELEMENT) + imul(getIntensitiesLength$1(/* () */0), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getConstantsLength() {
	  return 4;
	}

	function getLinearsOffset() {
	  return getConstantsOffset(/* () */0) + imul(getConstantsLength(/* () */0), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getLinearsLength() {
	  return 4;
	}

	function getQuadraticsOffset() {
	  return getLinearsOffset(/* () */0) + imul(getLinearsLength(/* () */0), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getQuadraticsLength() {
	  return 4;
	}

	function getRangesOffset() {
	  return getQuadraticsOffset(/* () */0) + imul(getQuadraticsLength(/* () */0), Float32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getRangesLength() {
	  return 4;
	}

	function getTotalByteLength$7(count) {
	  return (imul(count, Float32Array.BYTES_PER_ELEMENT) << 3);
	}

	function createBuffer$7(count) {
	  return newSharedArrayBuffer(getTotalByteLength$7(count));
	}


	/* Worker-Wonderjs Not a pure module */

	function getLightCount(param) {
	  return getLightCount$1(param[/* index */0], getBufferMaxCount$1(/* () */0));
	}


	/* CountLightService-Wonderjs Not a pure module */

	function getLightCount$2(param) {
	  return getLightCount$1(param[/* index */0], getBufferMaxCount(/* () */0));
	}


	/* CountLightService-Wonderjs Not a pure module */

	function execHandle(param) {
	  var directionLightCount = getLightCount$2(param[0]);
	  var pointLightCount = getLightCount(param[1]);
	  return /* record */[
	          /* top */"",
	          /* define */"#define DIRECTION_LIGHTS_COUNT " + (String(directionLightCount) + ("\n#define POINT_LIGHTS_COUNT " + (String(pointLightCount) + ""))),
	          /* varDeclare */"",
	          /* funcDeclare */"",
	          /* funcDefine */"",
	          /* body */""
	        ];
	}


	/* CountInitLightMaterialPointLightService-Wonderjs Not a pure module */

	function getHandle$1(recordTuple, name) {
	  if (name === "defineLightCount") {
	    return execHandle(recordTuple);
	  } else {
	    return fatal(buildFatalMessage("getHandle", "unknown handle name: " + (String(name) + ""), "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	var getPosition = unsafeGet$2;


	/* No side effect */

	function createTypeArrays$6(buffer, _) {
	  return /* tuple */[
	          new Float32Array(buffer, getColorsOffset$2(/* () */0), getColorsLength$2(/* () */0)),
	          new Float32Array(buffer, getIntensitiesOffset$1(/* () */0), getIntensitiesLength$1(/* () */0)),
	          new Float32Array(buffer, getConstantsOffset(/* () */0), getConstantsLength(/* () */0)),
	          new Float32Array(buffer, getLinearsOffset(/* () */0), getLinearsLength(/* () */0)),
	          new Float32Array(buffer, getQuadraticsOffset(/* () */0), getQuadraticsLength(/* () */0)),
	          new Float32Array(buffer, getRangesOffset(/* () */0), getRangesLength(/* () */0))
	        ];
	}


	/* BufferPointLightService-Wonderjs Not a pure module */

	function getColor$3(index, typeArr) {
	  return getFloat3(getColorIndex$2(index), typeArr);
	}

	function setColor$1(index, color, typeArr) {
	  return setFloat3(getColorIndex$2(index), color, typeArr);
	}

	function getIntensity$1(index, typeArr) {
	  return typeArr[index];
	}

	function setIntensity(index, intensity, typeArr) {
	  typeArr[index] = intensity;
	  return typeArr;
	}

	function getConstant$1(index, typeArr) {
	  return typeArr[index];
	}

	function setConstant(index, constant, typeArr) {
	  typeArr[index] = constant;
	  return typeArr;
	}

	function getLinear(index, typeArr) {
	  return typeArr[index];
	}

	function setLinear(index, linear, typeArr) {
	  typeArr[index] = linear;
	  return typeArr;
	}

	function getQuadratic$1(index, typeArr) {
	  return typeArr[index];
	}

	function setQuadratic(index, quadratic, typeArr) {
	  typeArr[index] = quadratic;
	  return typeArr;
	}

	function getRange$1(index, typeArr) {
	  return typeArr[index];
	}

	function setRange(index, range$$1, typeArr) {
	  typeArr[index] = range$$1;
	  return typeArr;
	}

	function getDefaultColor$1() {
	  return /* array */[
	          1,
	          1,
	          1
	        ];
	}

	function getDefaultIntensity() {
	  return 1;
	}

	function getDefaultConstant() {
	  return 1;
	}

	function getDefaultLinear() {
	  return 0.07;
	}

	function getDefaultQuadratic() {
	  return 0.017;
	}

	function getDefaultRange() {
	  return 65;
	}

	function setAllTypeArrDataToDefault$6(count, param) {
	  var defaultColor = /* array */[
	    1,
	    1,
	    1
	  ];
	  return reduceOneParam((function (param, index) {
	                return /* tuple */[
	                        setColor$1(index, defaultColor, param[0]),
	                        setIntensity(index, 1, param[1]),
	                        setConstant(index, 1, param[2]),
	                        setLinear(index, 0.07, param[3]),
	                        setQuadratic(index, 0.017, param[4]),
	                        setRange(index, 65, param[5])
	                      ];
	              }), /* tuple */[
	              param[0],
	              param[1],
	              param[2],
	              param[3],
	              param[4],
	              param[5]
	            ], range(0, count - 1 | 0));
	}

	function _setAllTypeArrDataToDefault$5(count, param) {
	  return /* tuple */[
	          param[0],
	          setAllTypeArrDataToDefault$6(count, /* tuple */[
	                param[1],
	                param[2],
	                param[3],
	                param[4],
	                param[5],
	                param[6]
	              ])
	        ];
	}

	function _initBufferData$6() {
	  var count = getBufferMaxCount$1(/* () */0);
	  var buffer = createBuffer$7(count);
	  var match = createTypeArrays$6(buffer, count);
	  return _setAllTypeArrDataToDefault$5(count, /* tuple */[
	              buffer,
	              match[0],
	              match[1],
	              match[2],
	              match[3],
	              match[4],
	              match[5]
	            ]);
	}

	function create$20() {
	  var match = _initBufferData$6(/* () */0);
	  var match$1 = match[1];
	  return /* record */[
	          /* index */0,
	          /* buffer */match[0],
	          /* colors */match$1[0],
	          /* intensities */match$1[1],
	          /* constants */match$1[2],
	          /* linears */match$1[3],
	          /* quadratics */match$1[4],
	          /* ranges */match$1[5],
	          /* mappedIndexMap */createEmpty$2(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0)
	        ];
	}

	function deepCopyForRestore$11(state) {
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var index = pointLightRecord[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = /* record */[
	    /* index */index,
	    /* buffer */pointLightRecord[/* buffer */1],
	    /* colors */copyFloat32ArrayWithEndIndex(imul(index, getColorsSize$2(/* () */0)), pointLightRecord[/* colors */2]),
	    /* intensities */copyFloat32ArrayWithEndIndex(imul(index, getIntensitiesSize$1(/* () */0)), pointLightRecord[/* intensities */3]),
	    /* constants */copyFloat32ArrayWithEndIndex(imul(index, getConstantsSize(/* () */0)), pointLightRecord[/* constants */4]),
	    /* linears */copyFloat32ArrayWithEndIndex(imul(index, getLinearsSize(/* () */0)), pointLightRecord[/* linears */5]),
	    /* quadratics */copyFloat32ArrayWithEndIndex(imul(index, getQuadraticsSize(/* () */0)), pointLightRecord[/* quadratics */6]),
	    /* ranges */copyFloat32ArrayWithEndIndex(imul(index, getRangesSize(/* () */0)), pointLightRecord[/* ranges */7]),
	    /* mappedIndexMap */copy$3(pointLightRecord[/* mappedIndexMap */8]),
	    /* gameObjectMap */copy$3(pointLightRecord[/* gameObjectMap */9])
	  ];
	  return newrecord;
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function getColor$2(mappedIndex, param) {
	  return getColor$3(mappedIndex, param[/* colors */1]);
	}

	function getIntensity(mappedIndex, param) {
	  return getIntensity$1(mappedIndex, param[/* intensities */2]);
	}

	function getConstant(mappedIndex, param) {
	  return getConstant$1(mappedIndex, param[/* constants */3]);
	}

	function getLiear(mappedIndex, param) {
	  return getLinear(mappedIndex, param[/* linears */4]);
	}

	function getQuadratic(mappedIndex, param) {
	  return getQuadratic$1(mappedIndex, param[/* quadratics */5]);
	}

	function getRange(mappedIndex, param) {
	  return getRange$1(mappedIndex, param[/* ranges */6]);
	}


	/* RecordPointLightMainService-Wonderjs Not a pure module */

	function getLightGLSLDataStructureMemberNameArr() {
	  return /* array */[
	          /* record */[
	            /* position */"u_pointLights[0].position",
	            /* color */"u_pointLights[0].color",
	            /* intensity */"u_pointLights[0].intensity",
	            /* constant */"u_pointLights[0].constant",
	            /* linear */"u_pointLights[0].linear",
	            /* quadratic */"u_pointLights[0].quadratic",
	            /* range */"u_pointLights[0].range"
	          ],
	          /* record */[
	            /* position */"u_pointLights[1].position",
	            /* color */"u_pointLights[1].color",
	            /* intensity */"u_pointLights[1].intensity",
	            /* constant */"u_pointLights[1].constant",
	            /* linear */"u_pointLights[1].linear",
	            /* quadratic */"u_pointLights[1].quadratic",
	            /* range */"u_pointLights[1].range"
	          ],
	          /* record */[
	            /* position */"u_pointLights[2].position",
	            /* color */"u_pointLights[2].color",
	            /* intensity */"u_pointLights[2].intensity",
	            /* constant */"u_pointLights[2].constant",
	            /* linear */"u_pointLights[2].linear",
	            /* quadratic */"u_pointLights[2].quadratic",
	            /* range */"u_pointLights[2].range"
	          ],
	          /* record */[
	            /* position */"u_pointLights[3].position",
	            /* color */"u_pointLights[3].color",
	            /* intensity */"u_pointLights[3].intensity",
	            /* constant */"u_pointLights[3].constant",
	            /* linear */"u_pointLights[3].linear",
	            /* quadratic */"u_pointLights[3].quadratic",
	            /* range */"u_pointLights[3].range"
	          ]
	        ];
	}

	function _sendAttenuation(index, param, param$1, pointLightRecord) {
	  var range$$1 = param$1[/* range */6];
	  var quadratic = param$1[/* quadratic */5];
	  var linear = param$1[/* linear */4];
	  var constant = param$1[/* constant */3];
	  var uniformLocationMap = param[3];
	  var uniformCacheMap = param[2];
	  var program = param[1];
	  var gl = param[0];
	  sendFloat(gl, uniformCacheMap, /* tuple */[
	        constant,
	        getUniformLocation(program, constant, uniformLocationMap, gl)
	      ], getConstant(index, pointLightRecord));
	  sendFloat(gl, uniformCacheMap, /* tuple */[
	        linear,
	        getUniformLocation(program, linear, uniformLocationMap, gl)
	      ], getLiear(index, pointLightRecord));
	  sendFloat(gl, uniformCacheMap, /* tuple */[
	        quadratic,
	        getUniformLocation(program, quadratic, uniformLocationMap, gl)
	      ], getQuadratic(index, pointLightRecord));
	  sendFloat(gl, uniformCacheMap, /* tuple */[
	        range$$1,
	        getUniformLocation(program, range$$1, uniformLocationMap, gl)
	      ], getRange(index, pointLightRecord));
	  return pointLightRecord;
	}

	function send(gl, param, param$1) {
	  var pointLightRecord = param$1[/* pointLightRecord */14];
	  var uniformLocationMap = param[2];
	  var uniformCacheMap = param[1];
	  var program = param[0];
	  requireCheck((function () {
	          var maxCount = getBufferMaxCount$1(/* () */0);
	          return test(buildAssertMessage("max buffer count === 4", "is " + (String(maxCount) + "")), (function () {
	                        return Operators[/* = */0](maxCount, 4);
	                      }));
	        }), getIsDebug(stateData));
	  var lightGLSLDataStructureMemberNameArr = getLightGLSLDataStructureMemberNameArr(/* () */0);
	  var positionMap = pointLightRecord[/* positionMap */7];
	  reduceOneParam((function (pointLightRecord, index) {
	          var structureMemberNameData = caml_array_get(lightGLSLDataStructureMemberNameArr, index);
	          var intensity = structureMemberNameData[/* intensity */2];
	          var color = structureMemberNameData[/* color */1];
	          var position = structureMemberNameData[/* position */0];
	          sendVec3(gl, uniformCacheMap, /* tuple */[
	                position,
	                getUniformLocation(program, position, uniformLocationMap, gl)
	              ], getPosition(index, positionMap));
	          sendFloat3(gl, uniformCacheMap, /* tuple */[
	                color,
	                getUniformLocation(program, color, uniformLocationMap, gl)
	              ], getColor$2(index, pointLightRecord));
	          sendFloat(gl, uniformCacheMap, /* tuple */[
	                intensity,
	                getUniformLocation(program, intensity, uniformLocationMap, gl)
	              ], getIntensity(index, pointLightRecord));
	          return _sendAttenuation(index, /* tuple */[
	                      gl,
	                      program,
	                      uniformCacheMap,
	                      uniformLocationMap
	                    ], structureMemberNameData, pointLightRecord);
	        }), pointLightRecord, range(0, pointLightRecord[/* index */0] - 1 | 0));
	  return /* () */0;
	}


	/* Log-WonderLog Not a pure module */

	function getColor$4(param) {
	  return param[/* ambientLight */0][/* color */0];
	}


	/* No side effect */

	function send$1(gl, param, param$1) {
	  var name = "u_ambient";
	  return sendFloat3(gl, param[1], /* tuple */[
	              name,
	              getUniformLocation(param[0], name, param[2], gl)
	            ], getColor$4(param$1[/* sceneRecord */0]));
	}


	/* GLSLLocationService-Wonderjs Not a pure module */

	var getDirection = unsafeGet$2;


	/* No side effect */

	function createTypeArrays$7(buffer, _) {
	  return /* tuple */[
	          new Float32Array(buffer, getColorsOffset$1(/* () */0), getColorsLength$1(/* () */0)),
	          new Float32Array(buffer, getIntensitiesOffset(/* () */0), getIntensitiesLength(/* () */0))
	        ];
	}


	/* BufferDirectionLightService-Wonderjs Not a pure module */

	function getDefaultColor$2() {
	  return /* array */[
	          1,
	          1,
	          1
	        ];
	}

	function getDefaultIntensity$1() {
	  return 1;
	}

	function getColor$6(index, typeArr) {
	  return getFloat3(getColorIndex$1(index), typeArr);
	}

	function setColor$2(index, color, typeArr) {
	  return setFloat3(getColorIndex$1(index), color, typeArr);
	}

	function getIntensity$3(index, typeArr) {
	  return getFloat1(getIntensityIndex(index), typeArr);
	}

	function setIntensity$1(index, intensity, typeArr) {
	  return setFloat1(getIntensityIndex(index), intensity, typeArr);
	}

	function setAllTypeArrDataToDefault$7(count, param) {
	  var defaultColor = /* array */[
	    1,
	    1,
	    1
	  ];
	  return reduceOneParam((function (param, index) {
	                return /* tuple */[
	                        setColor$2(index, defaultColor, param[0]),
	                        setIntensity$1(index, 1, param[1])
	                      ];
	              }), /* tuple */[
	              param[0],
	              param[1]
	            ], range(0, count - 1 | 0));
	}

	function _setAllTypeArrDataToDefault$6(count, param) {
	  return /* tuple */[
	          param[0],
	          setAllTypeArrDataToDefault$7(count, /* tuple */[
	                param[1],
	                param[2]
	              ])
	        ];
	}

	function _initBufferData$7() {
	  var count = getBufferMaxCount(/* () */0);
	  var buffer = createBuffer$6(count);
	  var match = createTypeArrays$7(buffer, count);
	  return _setAllTypeArrDataToDefault$6(count, /* tuple */[
	              buffer,
	              match[0],
	              match[1]
	            ]);
	}

	function create$21() {
	  var match = _initBufferData$7(/* () */0);
	  var match$1 = match[1];
	  return /* record */[
	          /* index */0,
	          /* buffer */match[0],
	          /* colors */match$1[0],
	          /* intensities */match$1[1],
	          /* mappedIndexMap */createEmpty$2(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0)
	        ];
	}

	function deepCopyForRestore$12(state) {
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var index = directionLightRecord[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* directionLightRecord */21] = /* record */[
	    /* index */index,
	    /* buffer */directionLightRecord[/* buffer */1],
	    /* colors */copyFloat32ArrayWithEndIndex(imul(index, getColorsSize$1(/* () */0)), directionLightRecord[/* colors */2]),
	    /* intensities */copyFloat32ArrayWithEndIndex(imul(index, getIntensitiesSize(/* () */0)), directionLightRecord[/* intensities */3]),
	    /* mappedIndexMap */copy$3(directionLightRecord[/* mappedIndexMap */4]),
	    /* gameObjectMap */copy$3(directionLightRecord[/* gameObjectMap */5])
	  ];
	  return newrecord;
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function getColor$5(mappedIndex, param) {
	  return getColor$6(mappedIndex, param[/* colors */1]);
	}

	function getIntensity$2(mappedIndex, param) {
	  return getIntensity$3(mappedIndex, param[/* intensities */2]);
	}


	/* RecordDirectionLightMainService-Wonderjs Not a pure module */

	function send$2(gl, param, param$1) {
	  var directionLightRecord = param$1[/* directionLightRecord */13];
	  var uniformLocationMap = param[2];
	  var uniformCacheMap = param[1];
	  var program = param[0];
	  requireCheck((function () {
	          var maxCount = getBufferMaxCount(/* () */0);
	          return test(buildAssertMessage("max buffer count === 4", "is " + (String(maxCount) + "")), (function () {
	                        return Operators[/* = */0](maxCount, 4);
	                      }));
	        }), getIsDebug(stateData));
	  var lightGLSLDataStructureMemberNameArr = /* array */[
	    /* record */[
	      /* direction */"u_directionLights[0].direction",
	      /* color */"u_directionLights[0].color",
	      /* intensity */"u_directionLights[0].intensity"
	    ],
	    /* record */[
	      /* direction */"u_directionLights[1].direction",
	      /* color */"u_directionLights[1].color",
	      /* intensity */"u_directionLights[1].intensity"
	    ],
	    /* record */[
	      /* direction */"u_directionLights[2].direction",
	      /* color */"u_directionLights[2].color",
	      /* intensity */"u_directionLights[2].intensity"
	    ],
	    /* record */[
	      /* direction */"u_directionLights[3].direction",
	      /* color */"u_directionLights[3].color",
	      /* intensity */"u_directionLights[3].intensity"
	    ]
	  ];
	  var directionMap = directionLightRecord[/* directionMap */3];
	  reduceOneParam((function (directionLightRecord, index) {
	          var match = caml_array_get(lightGLSLDataStructureMemberNameArr, index);
	          var intensity = match[/* intensity */2];
	          var color = match[/* color */1];
	          var direction = match[/* direction */0];
	          sendVec3(gl, uniformCacheMap, /* tuple */[
	                direction,
	                getUniformLocation(program, direction, uniformLocationMap, gl)
	              ], getDirection(index, directionMap));
	          sendFloat3(gl, uniformCacheMap, /* tuple */[
	                color,
	                getUniformLocation(program, color, uniformLocationMap, gl)
	              ], getColor$5(index, directionLightRecord));
	          sendFloat(gl, uniformCacheMap, /* tuple */[
	                intensity,
	                getUniformLocation(program, intensity, uniformLocationMap, gl)
	              ], getIntensity$2(index, directionLightRecord));
	          return directionLightRecord;
	        }), directionLightRecord, range(0, directionLightRecord[/* index */0] - 1 | 0));
	  return /* () */0;
	}


	/* Log-WonderLog Not a pure module */

	function addAmbientLightSendData(param, sendDataArrTuple) {
	  var field = param[0];
	  if (field === "send") {
	    return addUniformSendDataByType$5(/* tuple */[
	                param[1],
	                param[2],
	                param[3]
	              ], sendDataArrTuple, send$1);
	  } else {
	    return fatal(buildFatalMessage("_addAmbientLightSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}

	function addDirectionLightSendData(param, sendDataArrTuple) {
	  var field = param[0];
	  if (field === "send") {
	    return addUniformSendDataByType$5(/* tuple */[
	                param[1],
	                param[2],
	                param[3]
	              ], sendDataArrTuple, send$2);
	  } else {
	    return fatal(buildFatalMessage("_addDirectionLightSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}

	function addPointLightSendData(param, sendDataArrTuple) {
	  var field = param[0];
	  if (field === "send") {
	    return addUniformSendDataByType$5(/* tuple */[
	                param[1],
	                param[2],
	                param[3]
	              ], sendDataArrTuple, send);
	  } else {
	    return fatal(buildFatalMessage("_addPointLightSendData", "unknow field:" + (String(field) + ""), "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _readUniforms$1(param, sendDataArrTuple, uniforms) {
	  var uniformCacheMap = param[3];
	  var uniformLocationMap = param[2];
	  var program = param[1];
	  var gl = param[0];
	  var match = isJsonSerializedValueNone(uniforms);
	  if (match) {
	    return sendDataArrTuple;
	  } else {
	    return reduceOneParam((function (sendDataArrTuple, param) {
	                  var from = param[/* from */3];
	                  var type_ = param[/* type_ */2];
	                  var field = param[/* field */1];
	                  var name = param[/* name */0];
	                  switch (from) {
	                    case "ambientLight" : 
	                        return addAmbientLightSendData(/* tuple */[
	                                    field,
	                                    program,
	                                    uniformCacheMap,
	                                    uniformLocationMap
	                                  ], sendDataArrTuple);
	                    case "basicMaterial" : 
	                        return addBasicMaterialSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    case "camera" : 
	                        return addCameraSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    case "directionLight" : 
	                        return addDirectionLightSendData(/* tuple */[
	                                    field,
	                                    program,
	                                    uniformCacheMap,
	                                    uniformLocationMap
	                                  ], sendDataArrTuple);
	                    case "lightMaterial" : 
	                        return addLightMaterialSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    case "model" : 
	                        return addModelSendData(/* tuple */[
	                                    field,
	                                    getUniformLocation(program, name, uniformLocationMap, gl),
	                                    name,
	                                    type_,
	                                    uniformCacheMap
	                                  ], sendDataArrTuple);
	                    case "pointLight" : 
	                        return addPointLightSendData(/* tuple */[
	                                    field,
	                                    program,
	                                    uniformCacheMap,
	                                    uniformLocationMap
	                                  ], sendDataArrTuple);
	                    default:
	                      return fatal(buildFatalMessage("_readUniforms", "unknow from:" + (String(from) + ""), "", "", ""));
	                  }
	                }), sendDataArrTuple, unsafeGetJsonSerializedValue(uniforms));
	  }
	}

	function _readUniformSendData$1(shaderLibDataArr, gl, program, param) {
	  return readUniformSendData(shaderLibDataArr, /* tuple */[
	              gl,
	              program
	            ], _readUniforms$1, /* tuple */[
	              param[0],
	              param[1]
	            ]);
	}

	function addUniformSendData$2(gl, param, recordTuple) {
	  return addUniformSendData$1(gl, /* tuple */[
	              param[0],
	              param[1],
	              param[2]
	            ], _readUniformSendData$1, recordTuple);
	}


	/* Log-WonderLog Not a pure module */

	function _addNormalMatrixInstanceArrayBufferSendData(param, param$1) {
	  return /* tuple */[
	          param$1[0],
	          push(/* record */[
	                /* pos */getAttribLocation(param[1], param[2], param[3], param[0]),
	                /* size */3,
	                /* getOffsetFunc */(function (index) {
	                    return imul(index - 4 | 0, 12) + 64 | 0;
	                  })
	              ], param$1[1])
	        ];
	}

	function _readAttributes$1(param, sendDataArrTuple, attributes) {
	  var attributeLocationMap = param[2];
	  var program = param[1];
	  var gl = param[0];
	  var match = isJsonSerializedValueNone(attributes);
	  if (match) {
	    return sendDataArrTuple;
	  } else {
	    return reduceOneParam((function (sendDataArrTuple, param) {
	                  var type_ = param[/* type_ */2];
	                  var buffer = param[/* buffer */1];
	                  var name = param[/* name */0];
	                  var match = !isJsonSerializedValueNone(name) && !isJsonSerializedValueNone(type_);
	                  if (match) {
	                    var name$1 = unsafeGetJsonSerializedValue(name);
	                    var type_$1 = unsafeGetJsonSerializedValue(type_);
	                    if (buffer !== 4) {
	                      if (buffer >= 5) {
	                        return addModelMatrixInstanceArrayBufferSendData(/* tuple */[
	                                    gl,
	                                    program,
	                                    name$1,
	                                    attributeLocationMap
	                                  ], sendDataArrTuple);
	                      } else {
	                        return addOtherArrayBufferSendData(/* tuple */[
	                                    gl,
	                                    program,
	                                    name$1,
	                                    buffer,
	                                    type_$1,
	                                    attributeLocationMap
	                                  ], sendDataArrTuple);
	                      }
	                    } else {
	                      return _addNormalMatrixInstanceArrayBufferSendData(/* tuple */[
	                                  gl,
	                                  program,
	                                  name$1,
	                                  attributeLocationMap
	                                ], sendDataArrTuple);
	                    }
	                  } else {
	                    return addElementBufferSendData(buffer, sendDataArrTuple);
	                  }
	                }), sendDataArrTuple, unsafeGetJsonSerializedValue(attributes));
	  }
	}

	function _readAttributeSendData$1(shaderLibDataArr, gl, program, attributeLocationMap) {
	  return readAttributeSendData(shaderLibDataArr, /* tuple */[
	              gl,
	              program
	            ], _readAttributes$1, attributeLocationMap);
	}

	function addAttributeSendData$2(glTuple, shaderLibDataArr, recordTuple) {
	  return addAttributeSendData$1(glTuple, shaderLibDataArr, _readAttributeSendData$1, recordTuple);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function initMaterialShader$2(materialIndex, param, buildGLSLSourceFunc, state) {
	  var partial_arg_000 = state[/* directionLightRecord */1];
	  var partial_arg_001 = state[/* pointLightRecord */2];
	  var partial_arg = /* tuple */[
	    partial_arg_000,
	    partial_arg_001
	  ];
	  return initMaterialShader$1(materialIndex, /* tuple */[
	              param[0],
	              param[1]
	            ], /* tuple */[
	              buildGLSLSourceFunc,
	              (function (param) {
	                  return getHandle$1(partial_arg, param);
	                }),
	              addAttributeSendData$2,
	              addUniformSendData$2
	            ], /* tuple */[
	              state[/* shaderRecord */4],
	              state[/* programRecord */5],
	              state[/* glslRecord */6],
	              state[/* glslSenderRecord */7],
	              state[/* glslLocationRecord */8],
	              state[/* glslChunkRecord */9]
	            ]);
	}

	function reInitMaterialShader$1(materialIndex, param, buildGLSLSourceFunc, state) {
	  var partial_arg_000 = state[/* directionLightRecord */1];
	  var partial_arg_001 = state[/* pointLightRecord */2];
	  var partial_arg = /* tuple */[
	    partial_arg_000,
	    partial_arg_001
	  ];
	  return reInitMaterialShader(materialIndex, /* tuple */[
	              param[0],
	              param[1]
	            ], /* tuple */[
	              buildGLSLSourceFunc,
	              (function (param) {
	                  return getHandle$1(partial_arg, param);
	                }),
	              addAttributeSendData$2,
	              addUniformSendData$2
	            ], /* tuple */[
	              state[/* shaderRecord */4],
	              state[/* programRecord */5],
	              state[/* glslRecord */6],
	              state[/* glslSenderRecord */7],
	              state[/* glslLocationRecord */8],
	              state[/* glslChunkRecord */9]
	            ]);
	}


	/* InitShaderInitMaterialService-Wonderjs Not a pure module */

	function _getMaterialShaderLibDataArrByStaticBranch$1(param, param$1, resultDataArr) {
	  var staticBranchs = param$1[0];
	  var name = param[0];
	  var exit = 0;
	  switch (name) {
	    case "modelMatrix_instance" : 
	    case "normalMatrix_instance" : 
	        exit = 1;
	        break;
	    default:
	      return handleUnknownNameWhenGetMaterialShaderLibDataArrByStaticBranch(name, staticBranchs);
	  }
	  if (exit === 1) {
	    var match = unsafeFindFirst(staticBranchs, name, (function (item) {
	            return filterTargetName(item[/* name */0], name);
	          }));
	    return getMaterialShaderLibDataArrByStaticBranchInstance(/* tuple */[
	                param[1],
	                param[2]
	              ], /* tuple */[
	                param$1[1],
	                match[/* value */1]
	              ], resultDataArr);
	  }
	  
	}

	function _isPass$1(materialIndex, condition, state) {
	  var materialRecord = state[/* materialRecord */0];
	  switch (condition) {
	    case "has_diffuse_map" : 
	        return hasMap(getDiffuseMapUnit(materialIndex, materialRecord[/* diffuseMapUnits */3]));
	    case "has_specular_map" : 
	        return hasMap(getSpecularMapUnit(materialIndex, materialRecord[/* specularMapUnits */4]));
	    case "light_has_map" : 
	        if (hasMap(getDiffuseMapUnit(materialIndex, materialRecord[/* diffuseMapUnits */3]))) {
	          return true;
	        } else {
	          return hasMap(getSpecularMapUnit(materialIndex, materialRecord[/* specularMapUnits */4]));
	        }
	    default:
	      return fatal(buildFatalMessage("_isPass", "unknown condition:" + (String(condition) + ""), "", "", ""));
	  }
	}

	function getMaterialShaderLibDataArr$2(materialIndex, param, shaderLibTuple, state) {
	  return getMaterialShaderLibDataArr$1(/* tuple */[
	              materialIndex,
	              param[0],
	              param[1]
	            ], shaderLibTuple, /* tuple */[
	              _getMaterialShaderLibDataArrByStaticBranch$1,
	              _isPass$1
	            ], state);
	}


	/* Log-WonderLog Not a pure module */

	function _getShaderLibItems$1(param) {
	  var shaderName = "front_render_light";
	  return unsafeFindFirst(param[/* materialShaders */3], shaderName, (function (param) {
	                  return filterTargetName(param[/* name */0], shaderName);
	                }))[/* shaderLibs */1];
	}

	function isNeedInitMaterial$1(materialIndex, shaderIndices) {
	  return !hasShaderIndex(materialIndex, shaderIndices);
	}

	function initMaterial$2(gl, dataTuple, state) {
	  return initMaterial$1(gl, dataTuple, /* tuple */[
	              initMaterialShader$2,
	              buildGLSLSource,
	              setShaderIndex,
	              _getShaderLibItems$1,
	              getMaterialShaderLibDataArr$2
	            ], /* tuple */[
	              state[/* materialRecord */0][/* shaderIndices */2],
	              state[/* renderConfigRecord */3],
	              state
	            ]);
	}

	function reInitMaterial$1(gl, dataTuple, state) {
	  return reInitMaterial(gl, dataTuple, /* tuple */[
	              reInitMaterialShader$1,
	              buildGLSLSource,
	              setShaderIndex,
	              _getShaderLibItems$1,
	              getMaterialShaderLibDataArr$2
	            ], /* tuple */[
	              state[/* materialRecord */0][/* shaderIndices */2],
	              state[/* renderConfigRecord */3],
	              state
	            ]);
	}

	function init$3(gl, instanceTuple, state) {
	  var materialRecord = state[/* materialRecord */0];
	  return init$2(gl, instanceTuple, initMaterial$2, /* tuple */[
	              materialRecord[/* index */0],
	              materialRecord[/* disposedIndexArray */1],
	              state
	            ]);
	}


	/* JobConfigService-Wonderjs Not a pure module */

	function createInitMaterialState$1(param, state) {
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var match = getRecord$5(state);
	  return /* record */[
	          /* materialRecord : record */[
	            /* index */param[0],
	            /* disposedIndexArray */param[1],
	            /* shaderIndices */match[/* shaderIndices */2],
	            /* diffuseMapUnits */match[/* diffuseMapUnits */7],
	            /* specularMapUnits */match[/* specularMapUnits */8]
	          ],
	          /* directionLightRecord : record */[/* index */directionLightRecord[/* index */0]],
	          /* pointLightRecord : record */[/* index */pointLightRecord[/* index */0]],
	          /* renderConfigRecord */getRecord$8(state),
	          /* shaderRecord */state[/* shaderRecord */27],
	          /* programRecord */state[/* programRecord */29],
	          /* glslRecord */state[/* glslRecord */28],
	          /* glslSenderRecord */state[/* glslSenderRecord */31],
	          /* glslLocationRecord */state[/* glslLocationRecord */30],
	          /* glslChunkRecord */state[/* glslChunkRecord */32]
	        ];
	}


	/* RecordRenderConfigMainService-Wonderjs Not a pure module */

	function initMaterials$1(materialIndexArr, gl, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var gameObjectMap = getRecord$5(state)[/* gameObjectMap */13];
	  var isSupportInstance$$1 = isSupportInstance(state);
	  var match = getRecord$5(state);
	  reduceOneParam((function (state, materialIndex) {
	          return initMaterial$2(gl, /* tuple */[
	                      materialIndex,
	                      isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord),
	                      isSupportInstance$$1
	                    ], state);
	        }), createInitMaterialState$1(/* tuple */[
	            match[/* index */0],
	            match[/* disposedIndexArray */15]
	          ], state), materialIndexArr);
	  return state;
	}

	function handleInitComponent$1(materialIndex, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getRecord$5(state);
	  var match$1 = isNeedInitMaterial$1(materialIndex, match[/* shaderIndices */2]);
	  if (match$1) {
	    var match$2 = isUseWorker(state);
	    if (match$2) {
	      var match$3 = getRecord$5(state);
	      var materialArrayForWorkerInit = match$3[/* materialArrayForWorkerInit */17];
	      addMaterialToMaterialArrayForWorkerInit(materialIndex, materialArrayForWorkerInit);
	      return state;
	    } else {
	      var gl = unsafeGetGl$1(state[/* deviceManagerRecord */10]);
	      var gameObjectMap = getRecord$5(state)[/* gameObjectMap */13];
	      var isSupportInstance$$1 = isSupportInstance(state);
	      var match$4 = getRecord$5(state);
	      initMaterial$2(gl, /* tuple */[
	            materialIndex,
	            isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord),
	            isSupportInstance$$1
	          ], createInitMaterialState$1(/* tuple */[
	                match$4[/* index */0],
	                match$4[/* disposedIndexArray */15]
	              ], state));
	      return state;
	    }
	  } else {
	    return state;
	  }
	}

	function reInitComponents(materialIndices, state) {
	  return reduceOneParam((function (state, materialIndex) {
	                var gameObjectRecord = state[/* gameObjectRecord */11];
	                var match = getRecord$5(state);
	                var currentShaderIndex = getShaderIndex(materialIndex, match[/* shaderIndices */2]);
	                unuseShaderIndex(currentShaderIndex, state[/* shaderRecord */27]);
	                var match$1 = isUseWorker(state);
	                if (match$1) {
	                  return fatal(buildFatalMessage("reInitComponents", "not support worker", "", "", ""));
	                } else {
	                  var gl = unsafeGetGl$1(state[/* deviceManagerRecord */10]);
	                  var gameObjectMap = getRecord$5(state)[/* gameObjectMap */13];
	                  var isSupportInstance$$1 = isSupportInstance(state);
	                  var match$2 = getRecord$5(state);
	                  reInitMaterial$1(gl, /* tuple */[
	                        materialIndex,
	                        isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord),
	                        isSupportInstance$$1
	                      ], createInitMaterialState$1(/* tuple */[
	                            match$2[/* index */0],
	                            match$2[/* disposedIndexArray */15]
	                          ], state));
	                  return state;
	                }
	              }), state, materialIndices);
	}


	/* Log-WonderLog Not a pure module */

	var getTexture = get$3;

	var setTexture = set$1;


	/* OptionService-Wonderjs Not a pure module */

	function initTexture$1(gl, texture, glTextureMap) {
	  var match = getTexture(texture, glTextureMap);
	  if (match !== undefined) {
	    return glTextureMap;
	  } else {
	    return setTexture(texture, gl.createTexture(), glTextureMap);
	  }
	}

	function initTexturesWithIndexArray(gl, indexInTypeArrayRange, glTextureMap) {
	  return reduceOneParam((function (glTextureMap, textureInTypeArray) {
	                return initTexture$1(gl, textureInTypeArray, glTextureMap);
	              }), glTextureMap, indexInTypeArrayRange);
	}

	var initTextures = initTexturesWithIndexArray;


	/* ArrayService-WonderCommonlib Not a pure module */

	function getArrayBufferViewSourceTextureIndexOffset(basicSourceTextureCount) {
	  return basicSourceTextureCount;
	}

	function generateBasicSourceTextureIndex(basicSourceTextureIndex) {
	  return 0 + basicSourceTextureIndex | 0;
	}

	function generateArrayBufferViewSourceTextureIndex(arrayBufferViewSourceTextureIndex, basicSourceTextureCount) {
	  return basicSourceTextureCount + arrayBufferViewSourceTextureIndex | 0;
	}

	function getArrayBufferViewSourceTextureIndexInTypeArray(arrayBufferViewSourceTextureIndex, arrayBufferViewSourceTextureIndexOffset) {
	  return ensureCheck((function (index) {
	                return test(buildAssertMessage("index should >= 0", "is " + (String(index) + "")), (function () {
	                              return Operators[/* >= */7](index, 0);
	                            }));
	              }), getIsDebug(stateData), arrayBufferViewSourceTextureIndex - arrayBufferViewSourceTextureIndexOffset | 0);
	}

	function handleByJudgeSourceTextureIndex(textureIndex, arrayBufferViewSourceTextureIndexOffset, funcDataTuple, param) {
	  var match = caml_lessthan(textureIndex, arrayBufferViewSourceTextureIndexOffset);
	  if (match) {
	    return param[0](textureIndex, funcDataTuple);
	  } else {
	    return param[1](getArrayBufferViewSourceTextureIndexInTypeArray(textureIndex, arrayBufferViewSourceTextureIndexOffset), funcDataTuple);
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getArrayBufferViewSourceTextureIndexOffset$1(state) {
	  return getArrayBufferViewSourceTextureIndexOffset(getBasicSourceTextureCount(state[/* settingRecord */1]));
	}

	var generateBasicSourceTextureIndex$1 = generateBasicSourceTextureIndex;

	function generateArrayBufferViewSourceTextureIndex$1(arrayBufferViewSourceTextureIndex, state) {
	  return generateArrayBufferViewSourceTextureIndex(arrayBufferViewSourceTextureIndex, getBasicSourceTextureCount(state[/* settingRecord */1]));
	}


	/* BufferSettingService-Wonderjs Not a pure module */

	function getWrapSsSize() {
	  return 1;
	}

	function getWrapTsSize() {
	  return 1;
	}

	function getMagFiltersSize() {
	  return 1;
	}

	function getMinFiltersSize() {
	  return 1;
	}

	function getFormatsSize() {
	  return 1;
	}

	function getTypesSize() {
	  return 1;
	}

	function getIsNeedUpdatesSize() {
	  return 1;
	}

	function getFlipYsSize() {
	  return 1;
	}

	function getWidthsSize() {
	  return 1;
	}

	function getHeightsSize() {
	  return 1;
	}


	/* No side effect */

	function _getBasicSourceTotalByteLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, imul(Uint8Array.BYTES_PER_ELEMENT, ((((((getWrapSsSize(/* () */0) + getWrapTsSize(/* () */0) | 0) + getMagFiltersSize(/* () */0) | 0) + getMinFiltersSize(/* () */0) | 0) + getFormatsSize(/* () */0) | 0) + getTypesSize(/* () */0) | 0) + getIsNeedUpdatesSize(/* () */0) | 0) + getFlipYsSize(/* () */0) | 0));
	}

	function _getArrayBufferViewSourceTotalByteLength(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, imul(Uint8Array.BYTES_PER_ELEMENT, ((((((getWrapSsSize(/* () */0) + getWrapTsSize(/* () */0) | 0) + getMagFiltersSize(/* () */0) | 0) + getMinFiltersSize(/* () */0) | 0) + getFormatsSize(/* () */0) | 0) + getTypesSize(/* () */0) | 0) + getIsNeedUpdatesSize(/* () */0) | 0) + getFlipYsSize(/* () */0) | 0) + imul(Uint16Array.BYTES_PER_ELEMENT, getWidthsSize(/* () */0) + getHeightsSize(/* () */0) | 0) | 0);
	}

	function getBasicSourceTextureOffset() {
	  return 0;
	}

	var getArrayBufferViewSourceTextureOffset = _getBasicSourceTotalByteLength;

	function getTotalByteLength$8(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return _getBasicSourceTotalByteLength(basicSourceTextureCount) + _getArrayBufferViewSourceTotalByteLength(arrayBufferViewSourceTextureCount) | 0;
	}

	function createBuffer$8(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return newSharedArrayBuffer(getTotalByteLength$8(basicSourceTextureCount, arrayBufferViewSourceTextureCount));
	}

	function getNotNeedUpdate() {
	  return /* NOT_NEEDUPDATE */0;
	}

	function getDefaultIsNeedUpdate() {
	  return /* NEEDUPDATE */1;
	}

	function getFlipY() {
	  return /* FLIPY */1;
	}

	function getFlipYTypeArrayValue(isFlipY) {
	  if (isFlipY) {
	    return /* FLIPY */1;
	  } else {
	    return /* NOT_FLIPY */0;
	  }
	}

	function getFlipYFromTypeArrayValue(isFlipY) {
	  if (isFlipY) {
	    return true;
	  } else {
	    return false;
	  }
	}

	function getDefaultFlipY() {
	  return /* FLIPY */1;
	}

	function getIsNeedUpdateIndex(index) {
	  return imul(index, getIsNeedUpdatesSize(/* () */0));
	}


	/* Worker-Wonderjs Not a pure module */

	function getRecord$10(param) {
	  return unsafeGet$1(param[/* sourceTextureRecord */18]);
	}

	function create$23(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var basicSourceTextureCount = getBasicSourceTextureCount(settingRecord);
	  getArrayBufferViewSourceTextureCount(settingRecord);
	  var arrayBufferViewSourceTextureCount = getArrayBufferViewSourceTextureCount(settingRecord);
	  state[/* sourceTextureRecord */18] = /* record */[/* buffer */createBuffer$8(basicSourceTextureCount, arrayBufferViewSourceTextureCount)];
	  return state;
	}


	/* OptionService-Wonderjs Not a pure module */

	function getUnsignedByte() {
	  return 0;
	}

	function getGlType(gl, type_) {
	  if (type_ === 0) {
	    return gl.UNSIGNED_BYTE;
	  } else if (type_ === 1) {
	    return gl.UNSIGNED_SHORT_5_6_5;
	  } else if (type_ === 2) {
	    return gl.UNSIGNED_SHORT_4_4_4_4;
	  } else {
	    return gl.UNSIGNED_SHORT_5_5_5_1;
	  }
	}


	/* No side effect */

	function getDefaultWrapS() {
	  return /* CLAMP_TO_EDGE */0;
	}

	function getDefaultWrapT() {
	  return /* CLAMP_TO_EDGE */0;
	}

	function getDefaultMagFilter() {
	  return /* LINEAR */1;
	}

	function getDefaultMinFilter() {
	  return /* NEAREST */0;
	}

	function getDefaultFormat() {
	  return /* RGBA */1;
	}

	function getDefaultType() {
	  return getUnsignedByte(/* () */0);
	}

	function getWrapSsLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getWrapSsSize(/* () */0));
	}

	function getWrapSsOffset() {
	  return getBasicSourceTextureOffset(/* () */0) + 0 | 0;
	}

	function getWrapSIndex(index) {
	  return imul(index, getWrapSsSize(/* () */0));
	}

	function getWrapTsLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getWrapTsSize(/* () */0));
	}

	function getWrapTsOffset(basicSourceTextureCount) {
	  return (getBasicSourceTextureOffset(/* () */0) + 0 | 0) + imul(imul(basicSourceTextureCount, getWrapSsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getWrapTIndex(index) {
	  return imul(index, getWrapTsSize(/* () */0));
	}

	function getMagFiltersLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getMagFiltersSize(/* () */0));
	}

	function getMagFiltersOffset(basicSourceTextureCount) {
	  return getWrapTsOffset(basicSourceTextureCount) + imul(imul(basicSourceTextureCount, getWrapTsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMagFilterIndex(index) {
	  return imul(index, getMagFiltersSize(/* () */0));
	}

	function getMinFiltersLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getMinFiltersSize(/* () */0));
	}

	function getMinFiltersOffset(basicSourceTextureCount) {
	  return getMagFiltersOffset(basicSourceTextureCount) + imul(imul(basicSourceTextureCount, getMagFiltersSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMinFilterIndex(index) {
	  return imul(index, getMinFiltersSize(/* () */0));
	}

	function getFormatsLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getFormatsSize(/* () */0));
	}

	function getFormatsOffset(basicSourceTextureCount) {
	  return getMinFiltersOffset(basicSourceTextureCount) + imul(imul(basicSourceTextureCount, getMinFiltersSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getFormatIndex(index) {
	  return imul(index, getFormatsSize(/* () */0));
	}

	function getTypesLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getTypesSize(/* () */0));
	}

	function getTypesOffset(basicSourceTextureCount) {
	  return getFormatsOffset(basicSourceTextureCount) + imul(imul(basicSourceTextureCount, getFormatsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getTypeIndex(index) {
	  return imul(index, getTypesSize(/* () */0));
	}

	function getIsNeedUpdatesLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getIsNeedUpdatesSize(/* () */0));
	}

	function getIsNeedUpdatesOffset(basicSourceTextureCount) {
	  return getTypesOffset(basicSourceTextureCount) + imul(imul(basicSourceTextureCount, getTypesSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getFlipYsLength(basicSourceTextureCount) {
	  return imul(basicSourceTextureCount, getFlipYsSize(/* () */0));
	}

	function getFlipYsOffset(basicSourceTextureCount) {
	  return getIsNeedUpdatesOffset(basicSourceTextureCount) + imul(imul(basicSourceTextureCount, getIsNeedUpdatesSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getFlipYIndex(index) {
	  return imul(index, getFlipYsSize(/* () */0));
	}

	var getDefaultIsNeedUpdate$1 = getDefaultIsNeedUpdate;

	var getDefaultFlipY$1 = getDefaultFlipY;

	var getIsNeedUpdateIndex$1 = getIsNeedUpdateIndex;


	/* BufferSourceTextureService-Wonderjs Not a pure module */

	function createTypeArrays$8(buffer, basicSourceTextureCount) {
	  return /* tuple */[
	          new Uint8Array(buffer, getWrapSsOffset(basicSourceTextureCount), getWrapSsLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getWrapTsOffset(basicSourceTextureCount), getWrapTsLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getMagFiltersOffset(basicSourceTextureCount), getMagFiltersLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getMinFiltersOffset(basicSourceTextureCount), getMinFiltersLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getFormatsOffset(basicSourceTextureCount), getFormatsLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getTypesOffset(basicSourceTextureCount), getTypesLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getIsNeedUpdatesOffset(basicSourceTextureCount), getIsNeedUpdatesLength(basicSourceTextureCount)),
	          new Uint8Array(buffer, getFlipYsOffset(basicSourceTextureCount), getFlipYsLength(basicSourceTextureCount))
	        ];
	}


	/* BufferBasicSourceTextureService-Wonderjs Not a pure module */

	function getWrapS(index, typeArr) {
	  return getUint8_1(getWrapSIndex(index), typeArr);
	}

	function setWrapS(index, data, typeArr) {
	  return setUint8_1(getWrapSIndex(index), data, typeArr);
	}

	function getWrapT(index, typeArr) {
	  return getUint8_1(getWrapTIndex(index), typeArr);
	}

	function setWrapT(index, data, typeArr) {
	  return setUint8_1(getWrapTIndex(index), data, typeArr);
	}

	function getMagFilter(index, typeArr) {
	  return getUint8_1(getMagFilterIndex(index), typeArr);
	}

	function setMagFilter(index, data, typeArr) {
	  return setUint8_1(getMagFilterIndex(index), data, typeArr);
	}

	function getMinFilter(index, typeArr) {
	  return getUint8_1(getMinFilterIndex(index), typeArr);
	}

	function setMinFilter(index, data, typeArr) {
	  return setUint8_1(getMinFilterIndex(index), data, typeArr);
	}

	function getIsNeedUpdate(index, typeArr) {
	  return getUint8_1(getIsNeedUpdateIndex$1(index), typeArr);
	}

	function setIsNeedUpdate(index, data, typeArr) {
	  return setUint8_1(getIsNeedUpdateIndex$1(index), data, typeArr);
	}

	function getFlipY$1(index, typeArr) {
	  return getUint8_1(getFlipYIndex(index), typeArr);
	}

	function setFlipY(index, data, typeArr) {
	  return setUint8_1(getFlipYIndex(index), data, typeArr);
	}

	function isFlipY(index, typeArr) {
	  return getUint8_1(getFlipYIndex(index), typeArr) === getFlipY(/* () */0);
	}

	function getFormat(index, typeArr) {
	  return getUint8_1(getFormatIndex(index), typeArr);
	}

	function setFormat(index, data, typeArr) {
	  return setUint8_1(getFormatIndex(index), data, typeArr);
	}

	function getType(index, typeArr) {
	  return getUint8_1(getTypeIndex(index), typeArr);
	}

	function setType(index, data, typeArr) {
	  return setUint8_1(getTypeIndex(index), data, typeArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getRecord$9(param) {
	  return unsafeGet$1(param[/* basicSourceTextureRecord */19]);
	}

	function setAllTypeArrDataToDefault$8(basicSourceTextureCount, param) {
	  var defaultWrapS = getDefaultWrapS(/* () */0);
	  var defaultWrapT = getDefaultWrapT(/* () */0);
	  var defaultMagFilter = getDefaultMagFilter(/* () */0);
	  var defaultMinFilter = getDefaultMinFilter(/* () */0);
	  var defaultFormat = getDefaultFormat(/* () */0);
	  var defaultType = getDefaultType(/* () */0);
	  var defaultIsNeedUpdate = getDefaultIsNeedUpdate$1(/* () */0);
	  var defaultFlipY = getDefaultFlipY$1(/* () */0);
	  return reduceOneParam((function (param, indexInTypeArray) {
	                return /* tuple */[
	                        setWrapS(indexInTypeArray, defaultWrapS, param[0]),
	                        setWrapT(indexInTypeArray, defaultWrapT, param[1]),
	                        setMagFilter(indexInTypeArray, defaultMagFilter, param[2]),
	                        setMinFilter(indexInTypeArray, defaultMinFilter, param[3]),
	                        setFormat(indexInTypeArray, defaultFormat, param[4]),
	                        setType(indexInTypeArray, defaultType, param[5]),
	                        setIsNeedUpdate(indexInTypeArray, defaultIsNeedUpdate, param[6]),
	                        setFlipY(indexInTypeArray, defaultFlipY, param[7])
	                      ];
	              }), /* tuple */[
	              param[0],
	              param[1],
	              param[2],
	              param[3],
	              param[4],
	              param[5],
	              param[6],
	              param[7]
	            ], range(0, basicSourceTextureCount - 1 | 0));
	}

	function _initBufferData$8(basicSourceTextureCount, buffer) {
	  var match = createTypeArrays$8(buffer, basicSourceTextureCount);
	  return setAllTypeArrDataToDefault$8(basicSourceTextureCount, /* tuple */[
	              match[0],
	              match[1],
	              match[2],
	              match[3],
	              match[4],
	              match[5],
	              match[6],
	              match[7]
	            ]);
	}

	function create$22(state) {
	  var basicSourceTextureCount = getBasicSourceTextureCount(state[/* settingRecord */1]);
	  var match = getRecord$10(state);
	  var match$1 = _initBufferData$8(basicSourceTextureCount, match[/* buffer */0]);
	  state[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */0,
	    /* wrapSs */match$1[0],
	    /* wrapTs */match$1[1],
	    /* magFilters */match$1[2],
	    /* minFilters */match$1[3],
	    /* formats */match$1[4],
	    /* types */match$1[5],
	    /* isNeedUpdates */match$1[6],
	    /* flipYs */match$1[7],
	    /* sourceMap */createEmpty$2(/* () */0),
	    /* glTextureMap */createEmpty$2(/* () */0),
	    /* bindTextureUnitCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0),
	    /* needAddedSourceArray : array */[],
	    /* needInitedTextureIndexArray : array */[],
	    /* nameMap */createEmpty$2(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$13(state) {
	  var record = getRecord$9(state);
	  var index = record[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */index,
	    /* wrapSs */copyUint8ArrayWithEndIndex(imul(index, getWrapSsSize(/* () */0)), record[/* wrapSs */1]),
	    /* wrapTs */copyUint8ArrayWithEndIndex(imul(index, getWrapTsSize(/* () */0)), record[/* wrapTs */2]),
	    /* magFilters */copyUint8ArrayWithEndIndex(imul(index, getMagFiltersSize(/* () */0)), record[/* magFilters */3]),
	    /* minFilters */copyUint8ArrayWithEndIndex(imul(index, getMinFiltersSize(/* () */0)), record[/* minFilters */4]),
	    /* formats */copyUint8ArrayWithEndIndex(imul(index, getFormatsSize(/* () */0)), record[/* formats */5]),
	    /* types */copyUint8ArrayWithEndIndex(imul(index, getTypesSize(/* () */0)), record[/* types */6]),
	    /* isNeedUpdates */copyUint8ArrayWithEndIndex(imul(index, getIsNeedUpdatesSize(/* () */0)), record[/* isNeedUpdates */7]),
	    /* flipYs */copyUint8ArrayWithEndIndex(imul(index, getFlipYsSize(/* () */0)), record[/* flipYs */8]),
	    /* sourceMap */copy$3(record[/* sourceMap */9]),
	    /* glTextureMap */copy$3(record[/* glTextureMap */10]),
	    /* bindTextureUnitCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */record[/* disposedIndexArray */12].slice(),
	    /* needAddedSourceArray */record[/* needAddedSourceArray */13].slice(),
	    /* needInitedTextureIndexArray */record[/* needInitedTextureIndexArray */14].slice(),
	    /* nameMap */copy$3(record[/* nameMap */15])
	  ];
	  return newrecord;
	}


	/* OptionService-Wonderjs Not a pure module */

	function getDefaultWrapS$1() {
	  return /* CLAMP_TO_EDGE */0;
	}

	function getDefaultWrapT$1() {
	  return /* CLAMP_TO_EDGE */0;
	}

	function getDefaultMagFilter$1() {
	  return /* LINEAR */1;
	}

	function getDefaultMinFilter$1() {
	  return /* NEAREST */0;
	}

	function getDefaultFormat$1() {
	  return /* RGBA */1;
	}

	function getDefaultType$1() {
	  return getUnsignedByte(/* () */0);
	}

	function getDefaultWidth() {
	  return 0;
	}

	function getDefaultHeight() {
	  return 0;
	}

	function getWrapSsLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getWrapSsSize(/* () */0));
	}

	function getWrapSsOffset$1(basicSourceTextureCount, _) {
	  return getArrayBufferViewSourceTextureOffset(basicSourceTextureCount) + 0 | 0;
	}

	function getWrapSIndex$1(index) {
	  return imul(index, getWrapSsSize(/* () */0));
	}

	function getWrapTsLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getWrapTsSize(/* () */0));
	}

	function getWrapTsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return (getArrayBufferViewSourceTextureOffset(basicSourceTextureCount) + 0 | 0) + imul(imul(arrayBufferViewSourceTextureCount, getWrapSsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getWrapTIndex$1(index) {
	  return imul(index, getWrapTsSize(/* () */0));
	}

	function getMagFiltersLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getMagFiltersSize(/* () */0));
	}

	function getMagFiltersOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getWrapTsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getWrapTsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMagFilterIndex$1(index) {
	  return imul(index, getMagFiltersSize(/* () */0));
	}

	function getMinFiltersLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getMinFiltersSize(/* () */0));
	}

	function getMinFiltersOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getMagFiltersOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getMagFiltersSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMinFilterIndex$1(index) {
	  return imul(index, getMinFiltersSize(/* () */0));
	}

	function getFormatsLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getFormatsSize(/* () */0));
	}

	function getFormatsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getMinFiltersOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getMinFiltersSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getFormatIndex$1(index) {
	  return imul(index, getFormatsSize(/* () */0));
	}

	function getTypesLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getTypesSize(/* () */0));
	}

	function getTypesOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getFormatsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getFormatsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getTypeIndex$1(index) {
	  return imul(index, getTypesSize(/* () */0));
	}

	function getIsNeedUpdatesLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getIsNeedUpdatesSize(/* () */0));
	}

	function getIsNeedUpdatesOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getTypesOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getTypesSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getFlipYsLength$1(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getFlipYsSize(/* () */0));
	}

	function getFlipYsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getIsNeedUpdatesOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getIsNeedUpdatesSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getFlipYIndex$1(index) {
	  return imul(index, getFlipYsSize(/* () */0));
	}

	function getWidthsLength(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getWidthsSize(/* () */0));
	}

	function getWidthsOffset(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getFlipYsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getFlipYsSize(/* () */0)), Uint8Array.BYTES_PER_ELEMENT) | 0;
	}

	function getWidthIndex(index) {
	  return imul(index, getWidthsSize(/* () */0));
	}

	function getHeightsLength(arrayBufferViewSourceTextureCount) {
	  return imul(arrayBufferViewSourceTextureCount, getHeightsSize(/* () */0));
	}

	function getHeightsOffset(basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return getWidthsOffset(basicSourceTextureCount, arrayBufferViewSourceTextureCount) + imul(imul(arrayBufferViewSourceTextureCount, getWidthsSize(/* () */0)), Uint16Array.BYTES_PER_ELEMENT) | 0;
	}

	function getHeightIndex(index) {
	  return imul(index, getHeightsSize(/* () */0));
	}

	var getDefaultIsNeedUpdate$2 = getDefaultIsNeedUpdate;

	var getDefaultFlipY$2 = getDefaultFlipY;

	var getIsNeedUpdateIndex$2 = getIsNeedUpdateIndex;


	/* BufferSourceTextureService-Wonderjs Not a pure module */

	function createTypeArrays$9(buffer, basicSourceTextureCount, arrayBufferViewSourceTextureCount) {
	  return /* tuple */[
	          new Uint8Array(buffer, getWrapSsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getWrapSsLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getWrapTsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getWrapTsLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getMagFiltersOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getMagFiltersLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getMinFiltersOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getMinFiltersLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getFormatsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getFormatsLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getTypesOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getTypesLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getIsNeedUpdatesOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getIsNeedUpdatesLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint8Array(buffer, getFlipYsOffset$1(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getFlipYsLength$1(arrayBufferViewSourceTextureCount)),
	          new Uint16Array(buffer, getWidthsOffset(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getWidthsLength(arrayBufferViewSourceTextureCount)),
	          new Uint16Array(buffer, getHeightsOffset(basicSourceTextureCount, arrayBufferViewSourceTextureCount), getHeightsLength(arrayBufferViewSourceTextureCount))
	        ];
	}


	/* BufferArrayBufferViewSourceTextureService-Wonderjs Not a pure module */

	function getWrapS$1(index, typeArr) {
	  return getUint8_1(getWrapSIndex$1(index), typeArr);
	}

	function setWrapS$1(index, data, typeArr) {
	  return setUint8_1(getWrapSIndex$1(index), data, typeArr);
	}

	function getWrapT$1(index, typeArr) {
	  return getUint8_1(getWrapTIndex$1(index), typeArr);
	}

	function setWrapT$1(index, data, typeArr) {
	  return setUint8_1(getWrapTIndex$1(index), data, typeArr);
	}

	function getMagFilter$1(index, typeArr) {
	  return getUint8_1(getMagFilterIndex$1(index), typeArr);
	}

	function setMagFilter$1(index, data, typeArr) {
	  return setUint8_1(getMagFilterIndex$1(index), data, typeArr);
	}

	function getMinFilter$1(index, typeArr) {
	  return getUint8_1(getMinFilterIndex$1(index), typeArr);
	}

	function setMinFilter$1(index, data, typeArr) {
	  return setUint8_1(getMinFilterIndex$1(index), data, typeArr);
	}

	function getIsNeedUpdate$1(index, typeArr) {
	  return getUint8_1(getIsNeedUpdateIndex$2(index), typeArr);
	}

	function setIsNeedUpdate$1(index, data, typeArr) {
	  return setUint8_1(getIsNeedUpdateIndex$2(index), data, typeArr);
	}

	function getFlipY$2(index, typeArr) {
	  return getUint8_1(getFlipYIndex$1(index), typeArr);
	}

	function setFlipY$1(index, data, typeArr) {
	  return setUint8_1(getFlipYIndex$1(index), data, typeArr);
	}

	function isFlipY$1(index, typeArr) {
	  return getUint8_1(getFlipYIndex$1(index), typeArr) === getFlipY(/* () */0);
	}

	function getFormat$1(index, typeArr) {
	  return getUint8_1(getFormatIndex$1(index), typeArr);
	}

	function setFormat$1(index, data, typeArr) {
	  return setUint8_1(getFormatIndex$1(index), data, typeArr);
	}

	function getType$1(index, typeArr) {
	  return getUint8_1(getTypeIndex$1(index), typeArr);
	}

	function setType$1(index, data, typeArr) {
	  return setUint8_1(getTypeIndex$1(index), data, typeArr);
	}

	function getWidth(index, typeArr) {
	  return getUint16_1(getWidthIndex(index), typeArr);
	}

	function setWidth(index, data, typeArr) {
	  return setUint16_1(getWidthIndex(index), data, typeArr);
	}

	function getHeight(index, typeArr) {
	  return getUint16_1(getHeightIndex(index), typeArr);
	}

	function setHeight(index, data, typeArr) {
	  return setUint16_1(getHeightIndex(index), data, typeArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getRecord$11(param) {
	  return unsafeGet$1(param[/* arrayBufferViewSourceTextureRecord */20]);
	}

	function setAllTypeArrDataToDefault$9(arrayBufferViewSourceTextureCount, _, param) {
	  var defaultWrapS = getDefaultWrapS$1(/* () */0);
	  var defaultWrapT = getDefaultWrapT$1(/* () */0);
	  var defaultMagFilter = getDefaultMagFilter$1(/* () */0);
	  var defaultMinFilter = getDefaultMinFilter$1(/* () */0);
	  var defaultFormat = getDefaultFormat$1(/* () */0);
	  var defaultType = getDefaultType$1(/* () */0);
	  var defaultIsNeedUpdate = getDefaultIsNeedUpdate$2(/* () */0);
	  var defaultFlipY = getDefaultFlipY$2(/* () */0);
	  var defaultWidth = getDefaultWidth(/* () */0);
	  var defaultHeight = getDefaultHeight(/* () */0);
	  return reduceOneParam((function (param, indexInTypeArray) {
	                return /* tuple */[
	                        setWrapS$1(indexInTypeArray, defaultWrapS, param[0]),
	                        setWrapT$1(indexInTypeArray, defaultWrapT, param[1]),
	                        setMagFilter$1(indexInTypeArray, defaultMagFilter, param[2]),
	                        setMinFilter$1(indexInTypeArray, defaultMinFilter, param[3]),
	                        setFormat$1(indexInTypeArray, defaultFormat, param[4]),
	                        setType$1(indexInTypeArray, defaultType, param[5]),
	                        setIsNeedUpdate$1(indexInTypeArray, defaultIsNeedUpdate, param[6]),
	                        setFlipY$1(indexInTypeArray, defaultFlipY, param[7]),
	                        setWidth(indexInTypeArray, defaultWidth, param[8]),
	                        setHeight(indexInTypeArray, defaultHeight, param[9])
	                      ];
	              }), /* tuple */[
	              param[0],
	              param[1],
	              param[2],
	              param[3],
	              param[4],
	              param[5],
	              param[6],
	              param[7],
	              param[8],
	              param[9]
	            ], range$1(0, arrayBufferViewSourceTextureCount - 1 | 0));
	}

	function _initBufferData$9(basicSourceTextureCount, arrayBufferViewSourceTextureCount, buffer, arrayBufferViewSourceTextureIndexOffset) {
	  var match = createTypeArrays$9(buffer, basicSourceTextureCount, arrayBufferViewSourceTextureCount);
	  return setAllTypeArrDataToDefault$9(arrayBufferViewSourceTextureCount, arrayBufferViewSourceTextureIndexOffset, /* tuple */[
	              match[0],
	              match[1],
	              match[2],
	              match[3],
	              match[4],
	              match[5],
	              match[6],
	              match[7],
	              match[8],
	              match[9]
	            ]);
	}

	function create$24(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var basicSourceTextureCount = getBasicSourceTextureCount(settingRecord);
	  var arrayBufferViewSourceTextureCount = getArrayBufferViewSourceTextureCount(settingRecord);
	  var match = getRecord$10(state);
	  var match$1 = _initBufferData$9(basicSourceTextureCount, arrayBufferViewSourceTextureCount, match[/* buffer */0], getArrayBufferViewSourceTextureIndexOffset$1(state));
	  state[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */0,
	    /* wrapSs */match$1[0],
	    /* wrapTs */match$1[1],
	    /* magFilters */match$1[2],
	    /* minFilters */match$1[3],
	    /* formats */match$1[4],
	    /* types */match$1[5],
	    /* isNeedUpdates */match$1[6],
	    /* flipYs */match$1[7],
	    /* widths */match$1[8],
	    /* heights */match$1[9],
	    /* sourceMap */createEmpty$2(/* () */0),
	    /* glTextureMap */createEmpty$2(/* () */0),
	    /* bindTextureUnitCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */createEmpty$1(/* () */0),
	    /* needAddedSourceArray : array */[],
	    /* needInitedTextureIndexArray : array */[],
	    /* nameMap */createEmpty$2(/* () */0)
	  ];
	  return state;
	}

	function deepCopyForRestore$14(state) {
	  var record = getRecord$11(state);
	  var index = record[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */index,
	    /* wrapSs */copyUint8ArrayWithEndIndex(imul(index, getWrapSsSize(/* () */0)), record[/* wrapSs */1]),
	    /* wrapTs */copyUint8ArrayWithEndIndex(imul(index, getWrapTsSize(/* () */0)), record[/* wrapTs */2]),
	    /* magFilters */copyUint8ArrayWithEndIndex(imul(index, getMagFiltersSize(/* () */0)), record[/* magFilters */3]),
	    /* minFilters */copyUint8ArrayWithEndIndex(imul(index, getMinFiltersSize(/* () */0)), record[/* minFilters */4]),
	    /* formats */copyUint8ArrayWithEndIndex(imul(index, getFormatsSize(/* () */0)), record[/* formats */5]),
	    /* types */copyUint8ArrayWithEndIndex(imul(index, getTypesSize(/* () */0)), record[/* types */6]),
	    /* isNeedUpdates */copyUint8ArrayWithEndIndex(imul(index, getIsNeedUpdatesSize(/* () */0)), record[/* isNeedUpdates */7]),
	    /* flipYs */copyUint8ArrayWithEndIndex(imul(index, getFlipYsSize(/* () */0)), record[/* flipYs */8]),
	    /* widths */copyUint16ArrayWithEndIndex(imul(index, getWidthsSize(/* () */0)), record[/* widths */9]),
	    /* heights */copyUint16ArrayWithEndIndex(imul(index, getHeightsSize(/* () */0)), record[/* heights */10]),
	    /* sourceMap */copy$3(record[/* sourceMap */11]),
	    /* glTextureMap */copy$3(record[/* glTextureMap */12]),
	    /* bindTextureUnitCacheMap */createEmpty$2(/* () */0),
	    /* disposedIndexArray */record[/* disposedIndexArray */14].slice(),
	    /* needAddedSourceArray */record[/* needAddedSourceArray */15].slice(),
	    /* needInitedTextureIndexArray */record[/* needInitedTextureIndexArray */16].slice(),
	    /* nameMap */copy$3(record[/* nameMap */17])
	  ];
	  return newrecord;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _handleInitTextureWorker(texture, state) {
	  if (texture !== undefined) {
	    var texture$1 = texture;
	    return handleByJudgeSourceTextureIndex(texture$1, getArrayBufferViewSourceTextureIndexOffset$1(state), state, /* tuple */[
	                (function (_, state) {
	                    push(texture$1, getRecord$9(state)[/* needInitedTextureIndexArray */14]);
	                    return state;
	                  }),
	                (function (_, state) {
	                    push(texture$1, getRecord$11(state)[/* needInitedTextureIndexArray */16]);
	                    return state;
	                  })
	              ]);
	  } else {
	    return state;
	  }
	}

	function _handleInitTextureNoWorker(texture, state) {
	  if (texture !== undefined) {
	    return handleByJudgeSourceTextureIndex(texture, getArrayBufferViewSourceTextureIndexOffset$1(state), state, /* tuple */[
	                (function (basicSourceTextureInTypeArray, state) {
	                    initTexture$1(unsafeGetGl$1(state[/* deviceManagerRecord */10]), basicSourceTextureInTypeArray, getRecord$9(state)[/* glTextureMap */10]);
	                    return state;
	                  }),
	                (function (arrayBufferViewTextureInTypeArray, state) {
	                    initTexture$1(unsafeGetGl$1(state[/* deviceManagerRecord */10]), arrayBufferViewTextureInTypeArray, getRecord$11(state)[/* glTextureMap */12]);
	                    return state;
	                  })
	              ]);
	  } else {
	    return state;
	  }
	}

	function initTexture(texture, state) {
	  var match = isUseWorker(state);
	  if (match) {
	    return _handleInitTextureWorker(texture, state);
	  } else {
	    return _handleInitTextureNoWorker(texture, state);
	  }
	}

	function clearNeedInitedTextureIndexArray(state) {
	  var newrecord = caml_array_dup(state);
	  var init = getRecord$9(state);
	  newrecord[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */init[/* index */0],
	    /* wrapSs */init[/* wrapSs */1],
	    /* wrapTs */init[/* wrapTs */2],
	    /* magFilters */init[/* magFilters */3],
	    /* minFilters */init[/* minFilters */4],
	    /* formats */init[/* formats */5],
	    /* types */init[/* types */6],
	    /* isNeedUpdates */init[/* isNeedUpdates */7],
	    /* flipYs */init[/* flipYs */8],
	    /* sourceMap */init[/* sourceMap */9],
	    /* glTextureMap */init[/* glTextureMap */10],
	    /* bindTextureUnitCacheMap */init[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */init[/* disposedIndexArray */12],
	    /* needAddedSourceArray */init[/* needAddedSourceArray */13],
	    /* needInitedTextureIndexArray : array */[],
	    /* nameMap */init[/* nameMap */15]
	  ];
	  var init$1 = getRecord$11(state);
	  newrecord[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */init$1[/* index */0],
	    /* wrapSs */init$1[/* wrapSs */1],
	    /* wrapTs */init$1[/* wrapTs */2],
	    /* magFilters */init$1[/* magFilters */3],
	    /* minFilters */init$1[/* minFilters */4],
	    /* formats */init$1[/* formats */5],
	    /* types */init$1[/* types */6],
	    /* isNeedUpdates */init$1[/* isNeedUpdates */7],
	    /* flipYs */init$1[/* flipYs */8],
	    /* widths */init$1[/* widths */9],
	    /* heights */init$1[/* heights */10],
	    /* sourceMap */init$1[/* sourceMap */11],
	    /* glTextureMap */init$1[/* glTextureMap */12],
	    /* bindTextureUnitCacheMap */init$1[/* bindTextureUnitCacheMap */13],
	    /* disposedIndexArray */init$1[/* disposedIndexArray */14],
	    /* needAddedSourceArray */init$1[/* needAddedSourceArray */15],
	    /* needInitedTextureIndexArray : array */[],
	    /* nameMap */init$1[/* nameMap */17]
	  ];
	  return newrecord;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function getDefaultCount() {
	  return 0;
	}

	var unsafeGetCount = unsafeGet$2;

	var setCount = set$1;


	/* No side effect */

	function getMap$2(material, textureCountPerMaterial, param, param$1) {
	  var mapUnit = param[0](material, param$1[1]);
	  var match = hasMap(mapUnit);
	  if (match) {
	    return some$1(param[1](/* tuple */[
	                    material,
	                    mapUnit,
	                    textureCountPerMaterial
	                  ], param$1[0]));
	  }
	  
	}

	function setMap$2(material, texture, param, param$1) {
	  var textureCountMap = param$1[3];
	  var mapUnits = param$1[2];
	  var textureIndices = param$1[1];
	  var textureCountPerMaterial = param$1[0];
	  var setTextureIndexFunc = param[2];
	  var mapUnit = param[0](material, mapUnits);
	  var match = hasMap(mapUnit);
	  if (match) {
	    return /* tuple */[
	            setTextureIndexFunc(/* tuple */[
	                  material,
	                  mapUnit,
	                  textureCountPerMaterial
	                ], texture, textureIndices),
	            mapUnits,
	            textureCountMap
	          ];
	  } else {
	    var mapCount = unsafeGetCount(material, textureCountMap);
	    return /* tuple */[
	            setTextureIndexFunc(/* tuple */[
	                  material,
	                  mapCount,
	                  textureCountPerMaterial
	                ], texture, textureIndices),
	            param[1](material, mapCount, mapUnits),
	            setCount(material, mapCount + 1 | 0, textureCountMap)
	          ];
	  }
	}


	/* No side effect */

	function getMap$1(material, state) {
	  var match = getRecord$4(state);
	  return getMap$2(material, getTextureCountPerMaterial(state[/* settingRecord */1]), /* tuple */[
	              getMapUnit,
	              getTextureIndex
	            ], /* tuple */[
	              match[/* textureIndices */4],
	              match[/* mapUnits */5]
	            ]);
	}

	function unsafeGetMap$1(material, state) {
	  return unsafeGet$1(getMap$1(material, state));
	}

	function setMap$1(material, texture, state) {
	  var basicMaterialRecord = getRecord$4(state);
	  var match = setMap$2(material, texture, /* tuple */[
	        getMapUnit,
	        setMapUnit,
	        setTextureIndex
	      ], /* tuple */[
	        getTextureCountPerMaterial(state[/* settingRecord */1]),
	        basicMaterialRecord[/* textureIndices */4],
	        basicMaterialRecord[/* mapUnits */5],
	        basicMaterialRecord[/* textureCountMap */6]
	      ]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */basicMaterialRecord[/* index */0],
	    /* buffer */basicMaterialRecord[/* buffer */1],
	    /* shaderIndices */basicMaterialRecord[/* shaderIndices */2],
	    /* colors */basicMaterialRecord[/* colors */3],
	    /* textureIndices */match[0],
	    /* mapUnits */match[1],
	    /* textureCountMap */match[2],
	    /* defaultColor */basicMaterialRecord[/* defaultColor */7],
	    /* gameObjectMap */basicMaterialRecord[/* gameObjectMap */8],
	    /* groupCountMap */basicMaterialRecord[/* groupCountMap */9],
	    /* disposedIndexArray */basicMaterialRecord[/* disposedIndexArray */10],
	    /* nameMap */basicMaterialRecord[/* nameMap */11],
	    /* materialArrayForWorkerInit */basicMaterialRecord[/* materialArrayForWorkerInit */12]
	  ];
	  return newrecord;
	}

	function hasMap$2(material, state) {
	  return isSome(getMap$1(material, state));
	}


	/* OptionService-Wonderjs Not a pure module */

	function getColor$7(material, state) {
	  return getColor(material, getRecord$4(state)[/* colors */3]);
	}

	function setColor$3(material, color, state) {
	  var basicMaterialRecord = getRecord$4(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */basicMaterialRecord[/* index */0],
	    /* buffer */basicMaterialRecord[/* buffer */1],
	    /* shaderIndices */basicMaterialRecord[/* shaderIndices */2],
	    /* colors */setColor(material, color, basicMaterialRecord[/* colors */3]),
	    /* textureIndices */basicMaterialRecord[/* textureIndices */4],
	    /* mapUnits */basicMaterialRecord[/* mapUnits */5],
	    /* textureCountMap */basicMaterialRecord[/* textureCountMap */6],
	    /* defaultColor */basicMaterialRecord[/* defaultColor */7],
	    /* gameObjectMap */basicMaterialRecord[/* gameObjectMap */8],
	    /* groupCountMap */basicMaterialRecord[/* groupCountMap */9],
	    /* disposedIndexArray */basicMaterialRecord[/* disposedIndexArray */10],
	    /* nameMap */basicMaterialRecord[/* nameMap */11],
	    /* materialArrayForWorkerInit */basicMaterialRecord[/* materialArrayForWorkerInit */12]
	  ];
	  return newrecord;
	}

	var getMap = getMap$1;

	var unsafeGetMap = unsafeGetMap$1;

	var setMap = setMap$1;

	var hasMap$1 = hasMap$2;


	/* RecordBasicMaterialMainService-Wonderjs Not a pure module */

	function getDiffuseMap$1(material, state) {
	  var match = getRecord$5(state);
	  return getMap$2(material, getTextureCountPerMaterial(state[/* settingRecord */1]), /* tuple */[
	              getDiffuseMapUnit,
	              getTextureIndex$2
	            ], /* tuple */[
	              match[/* textureIndices */6],
	              match[/* diffuseMapUnits */7]
	            ]);
	}

	function unsafeGetDiffuseMap$1(material, state) {
	  return unsafeGet$1(getDiffuseMap$1(material, state));
	}

	function setDiffuseMap$1(material, texture, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var match = setMap$2(material, texture, /* tuple */[
	        getDiffuseMapUnit,
	        setDiffuseMapUnit,
	        setTextureIndex$2
	      ], /* tuple */[
	        getTextureCountPerMaterial(state[/* settingRecord */1]),
	        lightMaterialRecord[/* textureIndices */6],
	        lightMaterialRecord[/* diffuseMapUnits */7],
	        lightMaterialRecord[/* textureCountMap */9]
	      ]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */lightMaterialRecord[/* index */0],
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	    /* specularColors */lightMaterialRecord[/* specularColors */4],
	    /* shininess */lightMaterialRecord[/* shininess */5],
	    /* textureIndices */match[0],
	    /* diffuseMapUnits */match[1],
	    /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	    /* textureCountMap */match[2],
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	function hasDiffuseMap$1(material, state) {
	  return isSome(getDiffuseMap$1(material, state));
	}

	function getSpecularMap$1(material, state) {
	  var match = getRecord$5(state);
	  return getMap$2(material, getTextureCountPerMaterial(state[/* settingRecord */1]), /* tuple */[
	              getSpecularMapUnit,
	              getTextureIndex$2
	            ], /* tuple */[
	              match[/* textureIndices */6],
	              match[/* specularMapUnits */8]
	            ]);
	}

	function unsafeGetSpecularMap$1(material, state) {
	  return unsafeGet$1(getSpecularMap$1(material, state));
	}

	function setSpecularMap$1(material, texture, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var match = setMap$2(material, texture, /* tuple */[
	        getSpecularMapUnit,
	        setSpecularMapUnit,
	        setTextureIndex$2
	      ], /* tuple */[
	        getTextureCountPerMaterial(state[/* settingRecord */1]),
	        lightMaterialRecord[/* textureIndices */6],
	        lightMaterialRecord[/* specularMapUnits */8],
	        lightMaterialRecord[/* textureCountMap */9]
	      ]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */lightMaterialRecord[/* index */0],
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	    /* specularColors */lightMaterialRecord[/* specularColors */4],
	    /* shininess */lightMaterialRecord[/* shininess */5],
	    /* textureIndices */match[0],
	    /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	    /* specularMapUnits */match[1],
	    /* textureCountMap */match[2],
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	function hasSpecularMap$1(material, state) {
	  return isSome(getSpecularMap$1(material, state));
	}


	/* OptionService-Wonderjs Not a pure module */

	function getDiffuseColor$2(material, state) {
	  return getDiffuseColor(material, getRecord$5(state)[/* diffuseColors */3]);
	}

	function setDiffuseColor$1(material, color, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */lightMaterialRecord[/* index */0],
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */setDiffuseColor(material, color, lightMaterialRecord[/* diffuseColors */3]),
	    /* specularColors */lightMaterialRecord[/* specularColors */4],
	    /* shininess */lightMaterialRecord[/* shininess */5],
	    /* textureIndices */lightMaterialRecord[/* textureIndices */6],
	    /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	    /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	    /* textureCountMap */lightMaterialRecord[/* textureCountMap */9],
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	function getSpecularColor$2(material, state) {
	  return getSpecularColor(material, getRecord$5(state)[/* specularColors */4]);
	}

	function setSpecularColor$1(material, color, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */lightMaterialRecord[/* index */0],
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	    /* specularColors */setSpecularColor(material, color, lightMaterialRecord[/* specularColors */4]),
	    /* shininess */lightMaterialRecord[/* shininess */5],
	    /* textureIndices */lightMaterialRecord[/* textureIndices */6],
	    /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	    /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	    /* textureCountMap */lightMaterialRecord[/* textureCountMap */9],
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	function getShininess$2(material, state) {
	  return getShininess(material, getRecord$5(state)[/* shininess */5]);
	}

	function setShininess$1(material, value, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */lightMaterialRecord[/* index */0],
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	    /* specularColors */lightMaterialRecord[/* specularColors */4],
	    /* shininess */setShininess(material, value, lightMaterialRecord[/* shininess */5]),
	    /* textureIndices */lightMaterialRecord[/* textureIndices */6],
	    /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	    /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	    /* textureCountMap */lightMaterialRecord[/* textureCountMap */9],
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	var getDiffuseMap = getDiffuseMap$1;

	var unsafeGetDiffuseMap = unsafeGetDiffuseMap$1;

	var setDiffuseMap = setDiffuseMap$1;

	var hasDiffuseMap = hasDiffuseMap$1;

	var getSpecularMap = getSpecularMap$1;

	var unsafeGetSpecularMap = unsafeGetSpecularMap$1;

	var setSpecularMap = setSpecularMap$1;

	var hasSpecularMap = hasSpecularMap$1;


	/* RecordLightMaterialMainService-Wonderjs Not a pure module */

	function getCanvas(param) {
	  return param[/* canvas */0];
	}

	function unsafeGetCanvas(record) {
	  return unsafeGet$1(record[/* canvas */0]);
	}

	function setCanvas(canvas, _) {
	  return /* record */[/* canvas */some$1(canvas)];
	}

	var getOffset = function (canvas){
	                var offset = [canvas.offsetLeft,  canvas.offsetTop];
	                var offsetParent = canvas;

	            while (offsetParent = offsetParent.offsetParent) {
	                offset[0] += offsetParent.offsetLeft;
	                offset[1] += offsetParent.offsetTop;
	            }

	            return offset;
	};


	/* OptionService-Wonderjs Not a pure module */

	function getPointDownEventName$1() {
	  return "wd_pointdown";
	}

	function getPointUpEventName$1() {
	  return "wd_pointup";
	}

	function getPointTapEventName$1() {
	  return "wd_pointtap";
	}

	function getPointMoveEventName$1() {
	  return "wd_pointmove";
	}

	function getPointScaleEventName$1() {
	  return "wd_pointscale";
	}

	function getPointDragEventName$1() {
	  return "wd_pointdrag";
	}


	/* No side effect */

	function _addEventDataByPriority(eventData, arr) {
	  return push(eventData, arr).sort((function (eventDataA, eventDataB) {
	                return eventDataB[/* priority */0] - eventDataA[/* priority */0] | 0;
	              }));
	}

	function _addToEventArr(eventName, eventData, eventArrMap) {
	  var match = get(eventName, eventArrMap);
	  if (match !== undefined) {
	    return set(eventName, _addEventDataByPriority(eventData, match), eventArrMap);
	  } else {
	    return set(eventName, /* array */[eventData], eventArrMap);
	  }
	}

	function bindGlobalEvent(eventName, priority, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */_addToEventArr(eventName, /* record */[
	          /* priority */priority,
	          /* handleFunc */handleFunc
	        ], eventRecord[/* customGlobalEventArrMap */4]),
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function _removeFromEventArrByHandleFunc(arr, targetHandleFunc) {
	  return arr.filter((function (param) {
	                return param[/* handleFunc */1] !== targetHandleFunc;
	              }));
	}

	function _removeFromEventArrMapByHandleFunc(eventName, handleFunc, eventArrMap) {
	  var match = get(eventName, eventArrMap);
	  if (match !== undefined) {
	    return set(eventName, _removeFromEventArrByHandleFunc(match, handleFunc), eventArrMap);
	  } else {
	    return eventArrMap;
	  }
	}

	function unbindGlobalEventByHandleFunc(eventName, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */_removeFromEventArrMapByHandleFunc(eventName, handleFunc, eventRecord[/* customGlobalEventArrMap */4]),
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function unbindGlobalEventByEventName(eventName, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */deleteVal(eventName, eventRecord[/* customGlobalEventArrMap */4]),
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function bindGameObjectEvent(param, handleFunc, state) {
	  var target = param[2];
	  var eventName = param[0];
	  var eventRecord = state[/* eventRecord */42];
	  var customGameObjectEventArrMap = eventRecord[/* customGameObjectEventArrMap */5];
	  var eventData_000 = /* priority */param[1];
	  var eventData = /* record */[
	    eventData_000,
	    /* handleFunc */handleFunc
	  ];
	  var newrecord = caml_array_dup(state);
	  var match = get(eventName, customGameObjectEventArrMap);
	  var tmp;
	  if (match !== undefined) {
	    var targetEventArrMap = match;
	    var match$1 = get$3(target, targetEventArrMap);
	    tmp = match$1 !== undefined ? set(eventName, set$1(target, _addEventDataByPriority(eventData, match$1), targetEventArrMap), customGameObjectEventArrMap) : set(eventName, set$1(target, /* array */[eventData], targetEventArrMap), customGameObjectEventArrMap);
	  } else {
	    tmp = set(eventName, set$1(target, /* array */[eventData], createEmpty$2(/* () */0)), customGameObjectEventArrMap);
	  }
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */tmp,
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function unbindGameObjectEventByTarget(param, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var customGameObjectEventArrMap = eventRecord[/* customGameObjectEventArrMap */5];
	  var newrecord = caml_array_dup(state);
	  var match = get(param[0], customGameObjectEventArrMap);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */match !== undefined ? deleteVal$1(param[1], match) : customGameObjectEventArrMap,
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function unbindGameObjectEventByHandleFunc(param, handleFunc, state) {
	  var target = param[1];
	  var eventName = param[0];
	  var eventRecord = state[/* eventRecord */42];
	  var customGameObjectEventArrMap = eventRecord[/* customGameObjectEventArrMap */5];
	  var newrecord = caml_array_dup(state);
	  var match = get(eventName, customGameObjectEventArrMap);
	  var tmp;
	  if (match !== undefined) {
	    var targetEventArrMap = match;
	    var match$1 = get$3(target, targetEventArrMap);
	    tmp = match$1 !== undefined ? set(eventName, set$1(target, _removeFromEventArrByHandleFunc(match$1, handleFunc), targetEventArrMap), customGameObjectEventArrMap) : customGameObjectEventArrMap;
	  } else {
	    tmp = customGameObjectEventArrMap;
	  }
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */tmp,
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function addToEventArr(eventName, eventData, getPriorityFunc, eventArrMap) {
	  var match = get$3(eventName, eventArrMap);
	  if (match !== undefined) {
	    return set$1(eventName, push(eventData, match).sort((function (eventDataA, eventDataB) {
	                      return _1(getPriorityFunc, eventDataB) - _1(getPriorityFunc, eventDataA) | 0;
	                    })), eventArrMap);
	  } else {
	    return set$1(eventName, /* array */[eventData], eventArrMap);
	  }
	}

	function removeFromEventArrMapByHandleFunc(eventName, param, eventArrMap) {
	  var targetHandleFunc = param[1];
	  var getHandleFuncFunc = param[0];
	  var match = get$3(eventName, eventArrMap);
	  if (match !== undefined) {
	    return set$1(eventName, match.filter((function (domEventData) {
	                      return _1(getHandleFuncFunc, domEventData) !== targetHandleFunc;
	                    })), eventArrMap);
	  } else {
	    return eventArrMap;
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _addToEventArr$1(eventName, eventData, eventArrMap) {
	  return addToEventArr(eventName, eventData, (function (param) {
	                return param[/* priority */0];
	              }), eventArrMap);
	}

	function _removeFromEventArrMapByHandleFunc$1(eventName, targetHandleFunc, eventArrMap) {
	  return removeFromEventArrMapByHandleFunc(eventName, /* tuple */[
	              (function (param) {
	                  return param[/* handleFunc */1];
	                }),
	              targetHandleFunc
	            ], eventArrMap);
	}

	function bind$1(eventName, priority, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */_addToEventArr$1(eventName, /* record */[
	          /* priority */priority,
	          /* handleFunc */handleFunc
	        ], eventRecord[/* mouseDomEventDataArrMap */1]),
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function unbindByHandleFunc(eventName, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */_removeFromEventArrMapByHandleFunc$1(eventName, handleFunc, eventRecord[/* mouseDomEventDataArrMap */1]),
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}


	/* BindDomEventMainService-Wonderjs Not a pure module */

	function _addToEventArr$2(eventName, eventData, eventArrMap) {
	  return addToEventArr(eventName, eventData, (function (param) {
	                return param[/* priority */0];
	              }), eventArrMap);
	}

	function _removeFromEventArrMapByHandleFunc$2(eventName, targetHandleFunc, eventArrMap) {
	  return removeFromEventArrMapByHandleFunc(eventName, /* tuple */[
	              (function (param) {
	                  return param[/* handleFunc */1];
	                }),
	              targetHandleFunc
	            ], eventArrMap);
	}

	function bind$2(eventName, priority, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */_addToEventArr$2(eventName, /* record */[
	          /* priority */priority,
	          /* handleFunc */handleFunc
	        ], eventRecord[/* touchDomEventDataArrMap */3]),
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function unbindByHandleFunc$1(eventName, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */_removeFromEventArrMapByHandleFunc$2(eventName, handleFunc, eventRecord[/* touchDomEventDataArrMap */3]),
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}


	/* BindDomEventMainService-Wonderjs Not a pure module */

	function _triggerHandleFunc(customEvent, arr, state) {
	  return reduceOneParam((function (param, param$1) {
	                var customEvent = param[1];
	                var state = param[0];
	                var match = customEvent[/* isStopPropagation */2];
	                if (match) {
	                  return /* tuple */[
	                          state,
	                          customEvent
	                        ];
	                } else {
	                  return param$1[/* handleFunc */1](customEvent, state);
	                }
	              }), /* tuple */[
	              state,
	              customEvent
	            ], arr);
	}

	function stopPropagation(customEvent) {
	  return /* record */[
	          /* name */customEvent[/* name */0],
	          /* target */customEvent[/* target */1],
	          /* isStopPropagation */true,
	          /* phase */customEvent[/* phase */3],
	          /* userData */customEvent[/* userData */4]
	        ];
	}

	function triggerGlobalEvent(customEvent, state) {
	  var match = get(customEvent[/* name */0], state[/* eventRecord */42][/* customGlobalEventArrMap */4]);
	  if (match !== undefined) {
	    return _triggerHandleFunc(customEvent, match, state);
	  } else {
	    return /* tuple */[
	            state,
	            customEvent
	          ];
	  }
	}

	function triggerGameObjectEvent(target, customEvent, state) {
	  var match = get(customEvent[/* name */0], state[/* eventRecord */42][/* customGameObjectEventArrMap */5]);
	  if (match !== undefined) {
	    var match$1 = get$3(target, match);
	    if (match$1 !== undefined) {
	      return _triggerHandleFunc(/* record */[
	                  /* name */customEvent[/* name */0],
	                  /* target */target,
	                  /* isStopPropagation */customEvent[/* isStopPropagation */2],
	                  /* phase */customEvent[/* phase */3],
	                  /* userData */customEvent[/* userData */4]
	                ], match$1, state);
	    } else {
	      return /* tuple */[
	              state,
	              customEvent
	            ];
	    }
	  } else {
	    return /* tuple */[
	            state,
	            customEvent
	          ];
	  }
	}

	function _broadcastGameObjectEvent(eventName, target, customEvent, state) {
	  var match = triggerGameObjectEvent(target, customEvent, state);
	  var customEvent$1 = match[1];
	  var state$1 = match[0];
	  var transformRecord = getRecord$1(state$1);
	  return reduceOneParam((function (state, child) {
	                return _broadcastGameObjectEvent(eventName, child, customEvent$1, state);
	              }), state$1, unsafeGetChildren(unsafeGetTransformComponent(target, state$1[/* gameObjectRecord */11]), transformRecord));
	}

	function broadcastGameObjectEvent(target, customEvent, state) {
	  return _broadcastGameObjectEvent(customEvent[/* name */0], target, /* record */[
	              /* name */customEvent[/* name */0],
	              /* target */customEvent[/* target */1],
	              /* isStopPropagation */customEvent[/* isStopPropagation */2],
	              /* phase *//* Broadcast */0,
	              /* userData */customEvent[/* userData */4]
	            ], state);
	}

	function _emitGameObjectEvent(_, _target, _customEvent, _state) {
	  while(true) {
	    var state = _state;
	    var customEvent = _customEvent;
	    var target = _target;
	    var match = triggerGameObjectEvent(target, customEvent, state);
	    var state$1 = match[0];
	    var transformRecord = getRecord$1(state$1);
	    var match$1 = getParent(unsafeGetTransformComponent(target, state$1[/* gameObjectRecord */11]), transformRecord);
	    if (match$1 !== undefined) {
	      _state = state$1;
	      _customEvent = match[1];
	      _target = match$1;
	      continue ;
	    } else {
	      return state$1;
	    }
	  }
	}

	function emitGameObjectEvent(target, customEvent, state) {
	  return _emitGameObjectEvent(customEvent[/* name */0], target, /* record */[
	              /* name */customEvent[/* name */0],
	              /* target */customEvent[/* target */1],
	              /* isStopPropagation */customEvent[/* isStopPropagation */2],
	              /* phase *//* Emit */1,
	              /* userData */customEvent[/* userData */4]
	            ], state);
	}

	function getCustomEventUserData$1(customEvent) {
	  return customEvent[/* userData */4];
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function _addToEventArr$3(eventName, eventData, eventArrMap) {
	  return addToEventArr(eventName, eventData, (function (param) {
	                return param[/* priority */0];
	              }), eventArrMap);
	}

	function _removeFromEventArrMapByHandleFunc$3(eventName, targetHandleFunc, eventArrMap) {
	  return removeFromEventArrMapByHandleFunc(eventName, /* tuple */[
	              (function (param) {
	                  return param[/* handleFunc */1];
	                }),
	              targetHandleFunc
	            ], eventArrMap);
	}

	function bind$3(eventName, priority, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */_addToEventArr$3(eventName, /* record */[
	          /* priority */priority,
	          /* handleFunc */handleFunc
	        ], eventRecord[/* keyboardDomEventDataArrMap */2]),
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function unbindByHandleFunc$2(eventName, handleFunc, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */_removeFromEventArrMapByHandleFunc$3(eventName, handleFunc, eventRecord[/* keyboardDomEventDataArrMap */2]),
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}


	/* BindDomEventMainService-Wonderjs Not a pure module */

	function onMouseEvent$1(eventName, handleFunc, state, $staropt$star, _) {
	  var priority = $staropt$star !== undefined ? $staropt$star : 0;
	  return bind$1(eventName, priority, handleFunc, state);
	}

	function onKeyboardEvent$1(eventName, handleFunc, state, $staropt$star, _) {
	  var priority = $staropt$star !== undefined ? $staropt$star : 0;
	  return bind$3(eventName, priority, handleFunc, state);
	}

	function onTouchEvent$1(eventName, handleFunc, state, $staropt$star, _) {
	  var priority = $staropt$star !== undefined ? $staropt$star : 0;
	  return bind$2(eventName, priority, handleFunc, state);
	}

	var offMouseEventByHandleFunc$1 = unbindByHandleFunc;

	var offKeyboardEventByHandleFunc$1 = unbindByHandleFunc$2;

	var offTouchEventByHandleFunc$1 = unbindByHandleFunc$1;

	function onCustomGlobalEvent$1(eventName, handleFunc, state, $staropt$star, _) {
	  var priority = $staropt$star !== undefined ? $staropt$star : 0;
	  return bindGlobalEvent(eventName, priority, handleFunc, state);
	}

	var offCustomGlobalEventByEventName$1 = unbindGlobalEventByEventName;

	var offCustomGlobalEventByHandleFunc$1 = unbindGlobalEventByHandleFunc;

	function onCustomGameObjectEvent$1(eventName, handleFunc, target, state, $staropt$star, _) {
	  var priority = $staropt$star !== undefined ? $staropt$star : 0;
	  return bindGameObjectEvent(/* tuple */[
	              eventName,
	              priority,
	              target
	            ], handleFunc, state);
	}

	function offCustomGameObjectEventByTarget$1(eventName, target, state) {
	  return unbindGameObjectEventByTarget(/* tuple */[
	              eventName,
	              target
	            ], state);
	}

	function offCustomGameObjectEventByHandleFunc$1(eventName, handleFunc, target, state) {
	  return unbindGameObjectEventByHandleFunc(/* tuple */[
	              eventName,
	              target
	            ], handleFunc, state);
	}

	var stopPropagationCustomEvent$1 = stopPropagation;

	var triggerCustomGlobalEvent$1 = triggerGlobalEvent;

	function triggerCustomGameObjectEvent$1(customEvent, target, state) {
	  return triggerGameObjectEvent(target, customEvent, state);
	}

	function broadcastCustomGameObjectEvent$1(customEvent, target, state) {
	  return broadcastGameObjectEvent(target, customEvent, state);
	}

	function emitCustomGameObjectEvent$1(customEvent, target, state) {
	  return emitGameObjectEvent(target, customEvent, state);
	}

	function setDomEventStreamSubscription(domEventStreamSubscription, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */some$1(domEventStreamSubscription),
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}


	/* BindCustomEventMainService-Wonderjs Not a pure module */

	var _isFirefox = (
	    function(){
	      var userAgent = navigator.userAgent.toLowerCase();

	        return userAgent.indexOf("firefox") > -1 && userAgent.indexOf("mobile") === -1;
	    }
	    );

	var _isChrome = (
	    function(){
	      var userAgent = navigator.userAgent.toLowerCase();

	        return userAgent.indexOf("chrome") > -1 && userAgent.indexOf("mobile") === -1;
	    }
	    );

	var _isAndroid = (
	    function(){
	        return /Android/i.test(navigator.userAgent)
	    }
	    );

	var _isIOS = (
	    function(){
	        return /iPhone|iPad|iPod/i.test(navigator.userAgent)
	    }
	    );

	function detect$2(state) {
	  var newrecord = caml_array_dup(state);
	  var match = _1(_isFirefox, /* () */0) === true;
	  var tmp;
	  if (match) {
	    tmp = /* Firefox */1;
	  } else {
	    var match$1 = _1(_isChrome, /* () */0) === true;
	    if (match$1) {
	      tmp = /* Chrome */0;
	    } else {
	      var match$2 = _1(_isAndroid, /* () */0);
	      if (match$2) {
	        tmp = /* Android */2;
	      } else {
	        var match$3 = _1(_isIOS, /* () */0);
	        tmp = match$3 ? /* IOS */3 : /* Unknown */4;
	      }
	    }
	  }
	  newrecord[/* browserDetectRecord */41] = /* record */[/* browser */tmp];
	  return newrecord;
	}

	function isMobile(state) {
	  var match = state[/* browserDetectRecord */41][/* browser */0];
	  return match === 3 || match === 2;
	}

	function detectMobileNotSupportWorker(state) {
	  var match = isMobile(state);
	  if (match) {
	    return fatal(buildFatalMessage("DetectEnvironmentWorkerJob->execJob", "mobile not support worker", "", "", ""));
	  } else {
	    return /* () */0;
	  }
	}


	/* _isFirefox Not a pure module */

	var preventDefault$1 = function (event){
	    if (event.cancelable) {
	      if (!event.defaultPrevented) {
	          event.preventDefault();
	      }
	  }

	  event.stopPropagation();
	  };


	/* No side effect */

	function getLocationInView(domEvent, getLocationFunc, state) {
	  var viewRecord = state[/* viewRecord */9];
	  var match = getCanvas(viewRecord);
	  if (match !== undefined) {
	    var match$1 = getOffset(unsafeGetCanvas(viewRecord));
	    var match$2 = _2(getLocationFunc, domEvent, state);
	    return /* tuple */[
	            match$2[0] - match$1[0] | 0,
	            match$2[1] - match$1[1] | 0
	          ];
	  } else {
	    return /* tuple */[
	            0,
	            0
	          ];
	  }
	}

	function getMovementDelta($$location, lastXYTuple, _) {
	  var match = lastXYTuple[0];
	  var exit = 0;
	  if (match !== undefined) {
	    var match$1 = lastXYTuple[1];
	    if (match$1 !== undefined) {
	      return /* tuple */[
	              $$location[0] - match | 0,
	              $$location[1] - match$1 | 0
	            ];
	    } else {
	      exit = 1;
	    }
	  } else if (lastXYTuple[1] !== undefined) {
	    exit = 1;
	  } else {
	    return /* tuple */[
	            0,
	            0
	          ];
	  }
	  if (exit === 1) {
	    return fatal(buildFatalMessage("getMovementDelta", "lastX, lastY should all be None or all be Some", "", "", ""));
	  }
	  
	}

	var preventDefault = preventDefault$1;


	/* Log-WonderLog Not a pure module */

	var hexFloat_of_string = (
	function(str) {
	    return parseInt(str, 16);
	}
	);

	function leastFloat(_, num) {
	  var match = num < 0;
	  if (match) {
	    return 0;
	  } else {
	    return num;
	  }
	}

	function bigThan(num, below) {
	  var match = caml_lessthan(num, below);
	  if (match) {
	    return below;
	  } else {
	    return num;
	  }
	}

	function clamp(num, below, up) {
	  requireCheck((function () {
	          return test(buildAssertMessage("below <= up", "not"), (function () {
	                        return Operators[/* <=. */12](below, up);
	                      }));
	        }), getIsDebug(stateData));
	  var match = num < below;
	  if (match) {
	    return below;
	  } else {
	    var match$1 = num > up;
	    if (match$1) {
	      return up;
	    } else {
	      return num;
	    }
	  }
	}


	/* hexFloat_of_string Not a pure module */

	function create$25() {
	  return createEmpty$1(/* () */0);
	}

	var addToDirtyArray = push;

	function getCount(dirtyArray) {
	  return dirtyArray.length;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function unsafeGetDistance(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* distanceMap */7]));
	}

	function unsafeGetWheelSpeed(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* wheelSpeedMap */16]));
	}

	function setWheelSpeed(cameraController, wheelSpeed, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */set$1(cameraController, wheelSpeed, record[/* wheelSpeedMap */16]),
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function unsafeGetMinDistance(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* minDistanceMap */8]));
	}

	function setDistance(cameraController, distance, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */addToDirtyArray(cameraController, record[/* dirtyArray */6]),
	          /* distanceMap */set$1(cameraController, bigThan(distance, unsafeGetMinDistance(cameraController, record)), record[/* distanceMap */7]),
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function setDistanceByEvent(cameraController, pointEvent, record) {
	  var match = pointEvent[/* wheel */4];
	  if (match !== undefined) {
	    return setDistance(cameraController, unsafeGetDistance(cameraController, record) - unsafeGetWheelSpeed(cameraController, record) * match, record);
	  } else {
	    return record;
	  }
	}

	function setMinDistance(cameraController, minDistance, record) {
	  var record_000 = /* index */record[/* index */0];
	  var record_001 = /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1];
	  var record_002 = /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2];
	  var record_003 = /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3];
	  var record_004 = /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4];
	  var record_005 = /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5];
	  var record_006 = /* dirtyArray */addToDirtyArray(cameraController, record[/* dirtyArray */6]);
	  var record_007 = /* distanceMap */record[/* distanceMap */7];
	  var record_008 = /* minDistanceMap */set$1(cameraController, minDistance, record[/* minDistanceMap */8]);
	  var record_009 = /* phiMap */record[/* phiMap */9];
	  var record_010 = /* thetaMap */record[/* thetaMap */10];
	  var record_011 = /* thetaMarginMap */record[/* thetaMarginMap */11];
	  var record_012 = /* targetMap */record[/* targetMap */12];
	  var record_013 = /* moveSpeedXMap */record[/* moveSpeedXMap */13];
	  var record_014 = /* moveSpeedYMap */record[/* moveSpeedYMap */14];
	  var record_015 = /* rotateSpeedMap */record[/* rotateSpeedMap */15];
	  var record_016 = /* wheelSpeedMap */record[/* wheelSpeedMap */16];
	  var record_017 = /* gameObjectMap */record[/* gameObjectMap */17];
	  var record_018 = /* disposedIndexArray */record[/* disposedIndexArray */18];
	  var record$1 = /* record */[
	    record_000,
	    record_001,
	    record_002,
	    record_003,
	    record_004,
	    record_005,
	    record_006,
	    record_007,
	    record_008,
	    record_009,
	    record_010,
	    record_011,
	    record_012,
	    record_013,
	    record_014,
	    record_015,
	    record_016,
	    record_017,
	    record_018
	  ];
	  var match = minDistance > unsafeGetDistance(cameraController, record$1);
	  if (match) {
	    return setDistance(cameraController, minDistance, record$1);
	  } else {
	    return record$1;
	  }
	}

	function unsafeGetPhi(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* phiMap */9]));
	}

	function setPhi(cameraController, phi, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */addToDirtyArray(cameraController, record[/* dirtyArray */6]),
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */set$1(cameraController, phi, record[/* phiMap */9]),
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function _constrainTheta(theta, thetaMargin) {
	  return clamp(theta, thetaMargin, Math.PI - thetaMargin);
	}

	function unsafeGetTheta(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* thetaMap */10]));
	}

	function unsafeGetThetaMargin(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* thetaMarginMap */11]));
	}

	function setThetaMargin(cameraController, thetaMargin, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */addToDirtyArray(cameraController, record[/* dirtyArray */6]),
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */set$1(cameraController, _constrainTheta(unsafeGetTheta(cameraController, record), thetaMargin), record[/* thetaMap */10]),
	          /* thetaMarginMap */set$1(cameraController, thetaMargin, record[/* thetaMarginMap */11]),
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function setTheta(cameraController, theta, record) {
	  var thetaMargin = unsafeGetThetaMargin(cameraController, record);
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */addToDirtyArray(cameraController, record[/* dirtyArray */6]),
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */set$1(cameraController, _constrainTheta(theta, thetaMargin), record[/* thetaMap */10]),
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function unsafeGetTarget(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* targetMap */12]));
	}

	function setTarget(cameraController, target, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */addToDirtyArray(cameraController, record[/* dirtyArray */6]),
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */set$1(cameraController, target, record[/* targetMap */12]),
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function unsafeGetMoveSpeedX(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* moveSpeedXMap */13]));
	}

	function setMoveSpeedX(cameraController, moveSpeedX, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */set$1(cameraController, moveSpeedX, record[/* moveSpeedXMap */13]),
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function unsafeGetMoveSpeedY(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* moveSpeedYMap */14]));
	}

	function setMoveSpeedY(cameraController, moveSpeedY, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */set$1(cameraController, moveSpeedY, record[/* moveSpeedYMap */14]),
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function unsafeGetRotateSpeed(cameraController, record) {
	  return unsafeGet$1(get$3(cameraController, record[/* rotateSpeedMap */15]));
	}

	function setRotateSpeed(cameraController, rotateSpeed, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */set$1(cameraController, rotateSpeed, record[/* rotateSpeedMap */15]),
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}


	/* NumberService-Wonderjs Not a pure module */

	function unsafeGetGameObject$7(cameraController, param) {
	  return unsafeGetGameObject$1(cameraController, param[/* gameObjectMap */17]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function _computeTarget(cameraController, param, state) {
	  var dy = param[1];
	  var dx = param[0];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var target = unsafeGetTarget(cameraController, arcballCameraControllerRecord);
	  var transform = unsafeGetTransformComponent(unsafeGetGameObject$7(cameraController, arcballCameraControllerRecord), gameObjectRecord);
	  var match = getRecord$1(state);
	  var localToWorldMatrices = match[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = match[/* localToWorldMatrixCacheMap */19];
	  var localToWorldMatrixTypeArray = getLocalToWorldMatrixTypeArray$1(transform, localToWorldMatrices, localToWorldMatrixCacheMap);
	  var match$1 = normalize(getX(localToWorldMatrixTypeArray));
	  var match$2 = normalize(getY(localToWorldMatrixTypeArray));
	  var __x = add$1(/* Float */0, target, /* tuple */[
	        match$1[0] * dx,
	        0,
	        match$1[2] * dx
	      ]);
	  return add$1(/* Float */0, __x, /* tuple */[
	              match$2[0] * dy,
	              match$2[1] * dy,
	              0
	            ]);
	}

	function setTargetByKeyboardEvent(cameraController, keyboardEvent, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var moveSpeedX = unsafeGetMoveSpeedX(cameraController, arcballCameraControllerRecord);
	  var moveSpeedY = unsafeGetMoveSpeedY(cameraController, arcballCameraControllerRecord);
	  var match = keyboardEvent[/* key */6];
	  var match$1;
	  switch (match) {
	    case "a" : 
	    case "left" : 
	        match$1 = /* tuple */[
	          -moveSpeedX,
	          0
	        ];
	        break;
	    case "d" : 
	    case "right" : 
	        match$1 = /* tuple */[
	          moveSpeedX,
	          0
	        ];
	        break;
	    case "down" : 
	    case "s" : 
	        match$1 = /* tuple */[
	          0,
	          -moveSpeedY
	        ];
	        break;
	    case "up" : 
	    case "w" : 
	        match$1 = /* tuple */[
	          0,
	          moveSpeedY
	        ];
	        break;
	    default:
	      match$1 = /* tuple */[
	        0,
	        0
	      ];
	  }
	  var dy = match$1[1];
	  var dx = match$1[0];
	  var exit = 0;
	  if (dx !== 0 || dy !== 0) {
	    exit = 1;
	  } else {
	    return state;
	  }
	  if (exit === 1) {
	    var newrecord = caml_array_dup(state);
	    newrecord[/* arcballCameraControllerRecord */26] = setTarget(cameraController, _computeTarget(cameraController, /* tuple */[
	              dx,
	              dy
	            ], state), arcballCameraControllerRecord);
	    return newrecord;
	  }
	  
	}


	/* Matrix4Service-Wonderjs Not a pure module */

	function _setEventHandleFunc(cameraController, handleFunc, eventHandleFuncMap) {
	  var match = length$2(getValidValues(eventHandleFuncMap)) > 0;
	  if (match) {
	    warn("expect only has one arcballCameraController, but actual > 1. please dispose others.");
	  }
	  return set$1(cameraController, handleFunc, eventHandleFuncMap);
	}

	function _setPointDownEventHandleFunc(cameraController, handleFunc, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */_setEventHandleFunc(cameraController, handleFunc, record[/* pointDownEventHandleFuncMap */1]),
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function _setPointUpEventHandleFunc(cameraController, handleFunc, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */_setEventHandleFunc(cameraController, handleFunc, record[/* pointUpEventHandleFuncMap */2]),
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function _setPointDragEventHandleFunc(cameraController, handleFunc, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */_setEventHandleFunc(cameraController, handleFunc, record[/* pointDragEventHandleFuncMap */3]),
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function _setPointScaleEventHandleFunc(cameraController, handleFunc, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */_setEventHandleFunc(cameraController, handleFunc, record[/* pointScaleEventHandleFuncMap */4]),
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function _setKeydownEventHandleFunc(cameraController, handleFunc, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */_setEventHandleFunc(cameraController, handleFunc, record[/* keydownEventHandleFuncMap */5]),
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */record[/* distanceMap */7],
	          /* minDistanceMap */record[/* minDistanceMap */8],
	          /* phiMap */record[/* phiMap */9],
	          /* thetaMap */record[/* thetaMap */10],
	          /* thetaMarginMap */record[/* thetaMarginMap */11],
	          /* targetMap */record[/* targetMap */12],
	          /* moveSpeedXMap */record[/* moveSpeedXMap */13],
	          /* moveSpeedYMap */record[/* moveSpeedYMap */14],
	          /* rotateSpeedMap */record[/* rotateSpeedMap */15],
	          /* wheelSpeedMap */record[/* wheelSpeedMap */16],
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function _changeOrbit(cameraController, param, arcballCameraControllerRecord) {
	  var movementDelta = param[/* movementDelta */5];
	  var rotateSpeed = unsafeGetRotateSpeed(cameraController, arcballCameraControllerRecord);
	  return setTheta(cameraController, unsafeGetTheta(cameraController, arcballCameraControllerRecord) - movementDelta[1] / (100 / rotateSpeed), setPhi(cameraController, unsafeGetPhi(cameraController, arcballCameraControllerRecord) + movementDelta[0] / (100 / rotateSpeed), arcballCameraControllerRecord));
	}

	function bindEvent(cameraController, state) {
	  var pointDownHandleFunc = function ($$event, state) {
	    var viewRecord = state[/* viewRecord */9];
	    var match = isMobile(state);
	    if (match) {
	      return /* tuple */[
	              state,
	              $$event
	            ];
	    } else {
	      var canvas = unsafeGetCanvas(viewRecord);
	      requestPointerLock(canvas);
	      return /* tuple */[
	              state,
	              $$event
	            ];
	    }
	  };
	  var pointUpHandleFunc = function ($$event, state) {
	    var viewRecord = state[/* viewRecord */9];
	    var match = isMobile(state);
	    if (match) {
	      return /* tuple */[
	              state,
	              $$event
	            ];
	    } else {
	      var canvas = unsafeGetCanvas(viewRecord);
	      var $$document$1 = document;
	      var match$1 = $$document$1.pointerLockElement === canvas;
	      if (match$1) {
	        _1(exitPointerLock, /* () */0);
	      }
	      return /* tuple */[
	              state,
	              $$event
	            ];
	    }
	  };
	  var pointDragHandleFunc = function ($$event, state) {
	    var newrecord = caml_array_dup(state);
	    return /* tuple */[
	            (newrecord[/* arcballCameraControllerRecord */26] = _changeOrbit(cameraController, unsafeGet$1($$event[/* userData */4]), state[/* arcballCameraControllerRecord */26]), newrecord),
	            $$event
	          ];
	  };
	  var pointScaleHandleFunc = function ($$event, state) {
	    var pointEvent = unsafeGet$1($$event[/* userData */4]);
	    preventDefault(pointEvent[/* event */6]);
	    var newrecord = caml_array_dup(state);
	    return /* tuple */[
	            (newrecord[/* arcballCameraControllerRecord */26] = setDistanceByEvent(cameraController, pointEvent, state[/* arcballCameraControllerRecord */26]), newrecord),
	            $$event
	          ];
	  };
	  var keydownHandleFunc = function ($$event, state) {
	    return setTargetByKeyboardEvent(cameraController, $$event, state);
	  };
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = _setKeydownEventHandleFunc(cameraController, keydownHandleFunc, _setPointScaleEventHandleFunc(cameraController, pointScaleHandleFunc, _setPointDragEventHandleFunc(cameraController, pointDragHandleFunc, _setPointUpEventHandleFunc(cameraController, pointUpHandleFunc, _setPointDownEventHandleFunc(cameraController, pointDownHandleFunc, state[/* arcballCameraControllerRecord */26])))));
	  var state$1 = onCustomGlobalEvent$1(getPointDownEventName$1(/* () */0), pointDownHandleFunc, newrecord, undefined, /* () */0);
	  var state$2 = onCustomGlobalEvent$1(getPointUpEventName$1(/* () */0), pointUpHandleFunc, state$1, undefined, /* () */0);
	  var state$3 = onCustomGlobalEvent$1(getPointDragEventName$1(/* () */0), pointDragHandleFunc, state$2, undefined, /* () */0);
	  var state$4 = onCustomGlobalEvent$1(getPointScaleEventName$1(/* () */0), pointScaleHandleFunc, state$3, undefined, /* () */0);
	  return onKeyboardEvent$1(/* KeyDown */8, keydownHandleFunc, state$4, undefined, /* () */0);
	}

	function _disposePointDownEventHandleFuncMap(cameraController, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var pointDownEventHandleFuncMap = arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1];
	  var match = get$3(cameraController, pointDownEventHandleFuncMap);
	  if (match !== undefined) {
	    var eventName = getPointDownEventName$1(/* () */0);
	    var state$1 = offCustomGlobalEventByHandleFunc$1(eventName, valFromOption(match), state);
	    var newrecord = caml_array_dup(state$1);
	    newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	      /* index */arcballCameraControllerRecord[/* index */0],
	      /* pointDownEventHandleFuncMap */disposeSparseMapData(cameraController, pointDownEventHandleFuncMap),
	      /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	      /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	      /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	      /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	      /* dirtyArray */arcballCameraControllerRecord[/* dirtyArray */6],
	      /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	      /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	      /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	      /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	      /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	      /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	      /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	      /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	      /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	      /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	      /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	      /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	    ];
	    return newrecord;
	  } else {
	    return state;
	  }
	}

	function _disposePointUpEventHandleFuncMap(cameraController, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var pointUpEventHandleFuncMap = arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2];
	  var match = get$3(cameraController, pointUpEventHandleFuncMap);
	  if (match !== undefined) {
	    var eventName = getPointUpEventName$1(/* () */0);
	    var state$1 = offCustomGlobalEventByHandleFunc$1(eventName, valFromOption(match), state);
	    var newrecord = caml_array_dup(state$1);
	    newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	      /* index */arcballCameraControllerRecord[/* index */0],
	      /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	      /* pointUpEventHandleFuncMap */disposeSparseMapData(cameraController, pointUpEventHandleFuncMap),
	      /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	      /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	      /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	      /* dirtyArray */arcballCameraControllerRecord[/* dirtyArray */6],
	      /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	      /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	      /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	      /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	      /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	      /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	      /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	      /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	      /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	      /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	      /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	      /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	    ];
	    return newrecord;
	  } else {
	    return state;
	  }
	}

	function _disposePointDragEventHandleFuncMap(cameraController, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var pointDragEventHandleFuncMap = arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3];
	  var match = get$3(cameraController, pointDragEventHandleFuncMap);
	  if (match !== undefined) {
	    var eventName = getPointDragEventName$1(/* () */0);
	    var state$1 = offCustomGlobalEventByHandleFunc$1(eventName, valFromOption(match), state);
	    var newrecord = caml_array_dup(state$1);
	    newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	      /* index */arcballCameraControllerRecord[/* index */0],
	      /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	      /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	      /* pointDragEventHandleFuncMap */disposeSparseMapData(cameraController, pointDragEventHandleFuncMap),
	      /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	      /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	      /* dirtyArray */arcballCameraControllerRecord[/* dirtyArray */6],
	      /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	      /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	      /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	      /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	      /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	      /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	      /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	      /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	      /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	      /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	      /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	      /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	    ];
	    return newrecord;
	  } else {
	    return state;
	  }
	}

	function _disposePointScaleEventHandleFuncMap(cameraController, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var pointScaleEventHandleFuncMap = arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4];
	  var match = get$3(cameraController, pointScaleEventHandleFuncMap);
	  if (match !== undefined) {
	    var eventName = getPointScaleEventName$1(/* () */0);
	    var state$1 = offCustomGlobalEventByHandleFunc$1(eventName, valFromOption(match), state);
	    var newrecord = caml_array_dup(state$1);
	    newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	      /* index */arcballCameraControllerRecord[/* index */0],
	      /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	      /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	      /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	      /* pointScaleEventHandleFuncMap */disposeSparseMapData(cameraController, pointScaleEventHandleFuncMap),
	      /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	      /* dirtyArray */arcballCameraControllerRecord[/* dirtyArray */6],
	      /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	      /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	      /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	      /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	      /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	      /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	      /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	      /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	      /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	      /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	      /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	      /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	    ];
	    return newrecord;
	  } else {
	    return state;
	  }
	}

	function _disposeKeyDownEventHandleFuncMap(cameraController, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var keydownEventHandleFuncMap = arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5];
	  var match = get$3(cameraController, keydownEventHandleFuncMap);
	  if (match !== undefined) {
	    var state$1 = offKeyboardEventByHandleFunc$1(/* KeyDown */8, valFromOption(match), state);
	    var newrecord = caml_array_dup(state$1);
	    newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	      /* index */arcballCameraControllerRecord[/* index */0],
	      /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	      /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	      /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	      /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	      /* keydownEventHandleFuncMap */disposeSparseMapData(cameraController, keydownEventHandleFuncMap),
	      /* dirtyArray */arcballCameraControllerRecord[/* dirtyArray */6],
	      /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	      /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	      /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	      /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	      /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	      /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	      /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	      /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	      /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	      /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	      /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	      /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	    ];
	    return newrecord;
	  } else {
	    return state;
	  }
	}

	function unbindEvent(cameraController, state) {
	  return _disposeKeyDownEventHandleFuncMap(cameraController, _disposePointScaleEventHandleFuncMap(cameraController, _disposePointDragEventHandleFuncMap(cameraController, _disposePointUpEventHandleFuncMap(cameraController, _disposePointDownEventHandleFuncMap(cameraController, state)))));
	}


	/* Log-WonderLog Not a pure module */

	var initArcballCameraController = bindEvent;

	function init$4(state) {
	  return reduceOneParam((function (state, dirtyIndex) {
	                return bindEvent(dirtyIndex, state);
	              }), state, removeDuplicateItems(state[/* arcballCameraControllerRecord */26][/* dirtyArray */6]));
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function _setMapValue(cameraProjection, dirtyArray, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* dirtyArray */addToDirtyArray(cameraProjection, dirtyArray),
	          /* pMatrixMap */record[/* pMatrixMap */2],
	          /* nearMap */record[/* nearMap */3],
	          /* farMap */record[/* farMap */4],
	          /* fovyMap */record[/* fovyMap */5],
	          /* aspectMap */record[/* aspectMap */6],
	          /* gameObjectMap */record[/* gameObjectMap */7],
	          /* disposedIndexArray */record[/* disposedIndexArray */8]
	        ];
	}

	function getFovy(cameraProjection, record) {
	  return get$3(cameraProjection, record[/* fovyMap */5]);
	}

	function unsafeGetFovy(cameraProjection, record) {
	  return unsafeGet$1(get$3(cameraProjection, record[/* fovyMap */5]));
	}

	function setFovy(cameraProjection, fovy, record) {
	  return _setMapValue(cameraProjection, record[/* dirtyArray */1], /* record */[
	              /* index */record[/* index */0],
	              /* dirtyArray */record[/* dirtyArray */1],
	              /* pMatrixMap */record[/* pMatrixMap */2],
	              /* nearMap */record[/* nearMap */3],
	              /* farMap */record[/* farMap */4],
	              /* fovyMap */set$1(cameraProjection, fovy, record[/* fovyMap */5]),
	              /* aspectMap */record[/* aspectMap */6],
	              /* gameObjectMap */record[/* gameObjectMap */7],
	              /* disposedIndexArray */record[/* disposedIndexArray */8]
	            ]);
	}

	function getAspect(cameraProjection, record) {
	  return get$3(cameraProjection, record[/* aspectMap */6]);
	}

	function unsafeGetAspect(cameraProjection, record) {
	  return unsafeGet$1(get$3(cameraProjection, record[/* aspectMap */6]));
	}

	function setAspect(cameraProjection, aspect, record) {
	  return _setMapValue(cameraProjection, record[/* dirtyArray */1], /* record */[
	              /* index */record[/* index */0],
	              /* dirtyArray */record[/* dirtyArray */1],
	              /* pMatrixMap */record[/* pMatrixMap */2],
	              /* nearMap */record[/* nearMap */3],
	              /* farMap */record[/* farMap */4],
	              /* fovyMap */record[/* fovyMap */5],
	              /* aspectMap */set$1(cameraProjection, aspect, record[/* aspectMap */6]),
	              /* gameObjectMap */record[/* gameObjectMap */7],
	              /* disposedIndexArray */record[/* disposedIndexArray */8]
	            ]);
	}

	function getNear(cameraProjection, record) {
	  return get$3(cameraProjection, record[/* nearMap */3]);
	}

	function unsafeGetNear(cameraProjection, record) {
	  return unsafeGet$1(get$3(cameraProjection, record[/* nearMap */3]));
	}

	function setNear(cameraProjection, near, record) {
	  return _setMapValue(cameraProjection, record[/* dirtyArray */1], /* record */[
	              /* index */record[/* index */0],
	              /* dirtyArray */record[/* dirtyArray */1],
	              /* pMatrixMap */record[/* pMatrixMap */2],
	              /* nearMap */set$1(cameraProjection, near, record[/* nearMap */3]),
	              /* farMap */record[/* farMap */4],
	              /* fovyMap */record[/* fovyMap */5],
	              /* aspectMap */record[/* aspectMap */6],
	              /* gameObjectMap */record[/* gameObjectMap */7],
	              /* disposedIndexArray */record[/* disposedIndexArray */8]
	            ]);
	}

	function getFar(cameraProjection, record) {
	  return get$3(cameraProjection, record[/* farMap */4]);
	}

	function getInfiniteFar() {
	  return 100000;
	}

	function unsafeGetFar(cameraProjection, record) {
	  return unsafeGet$1(get$3(cameraProjection, record[/* farMap */4]));
	}

	function setFar(cameraProjection, far, record) {
	  return _setMapValue(cameraProjection, record[/* dirtyArray */1], /* record */[
	              /* index */record[/* index */0],
	              /* dirtyArray */record[/* dirtyArray */1],
	              /* pMatrixMap */record[/* pMatrixMap */2],
	              /* nearMap */record[/* nearMap */3],
	              /* farMap */set$1(cameraProjection, far, record[/* farMap */4]),
	              /* fovyMap */record[/* fovyMap */5],
	              /* aspectMap */record[/* aspectMap */6],
	              /* gameObjectMap */record[/* gameObjectMap */7],
	              /* disposedIndexArray */record[/* disposedIndexArray */8]
	            ]);
	}


	/* OptionService-Wonderjs Not a pure module */

	function updateCameraProjection(index, state) {
	  var viewRecord = state[/* viewRecord */9];
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var newrecord = caml_array_dup(state);
	  var match = getFovy(index, perspectiveCameraProjectionRecord);
	  var match$1 = getNear(index, perspectiveCameraProjectionRecord);
	  var match$2 = getFar(index, perspectiveCameraProjectionRecord);
	  var tmp;
	  var exit = 0;
	  if (match !== undefined && match$1 !== undefined && match$2 !== undefined) {
	    var match$3 = getAspect(index, perspectiveCameraProjectionRecord);
	    var match$4;
	    if (match$3 !== undefined) {
	      match$4 = /* tuple */[
	        perspectiveCameraProjectionRecord,
	        match$3
	      ];
	    } else {
	      var canvas = unsafeGetCanvas(viewRecord);
	      var aspect = canvas.width / canvas.height;
	      match$4 = /* tuple */[
	        setAspect(index, aspect, perspectiveCameraProjectionRecord),
	        aspect
	      ];
	    }
	    var perspectiveCameraProjectionRecord$1 = match$4[0];
	    buildPerspective(/* tuple */[
	          match,
	          match$4[1],
	          match$1,
	          match$2
	        ], unsafeGetPMatrix(index, perspectiveCameraProjectionRecord$1[/* pMatrixMap */2]));
	    tmp = perspectiveCameraProjectionRecord$1;
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    fatal(buildFatalMessage("update", "fovy,near,far should all exist", "", "", "cameraProjection: " + (String(index) + "")));
	    tmp = perspectiveCameraProjectionRecord;
	  }
	  newrecord[/* perspectiveCameraProjectionRecord */15] = tmp;
	  return newrecord;
	}

	function _clearDirtyArray(state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = /* record */[
	    /* index */perspectiveCameraProjectionRecord[/* index */0],
	    /* dirtyArray */create$25(/* () */0),
	    /* pMatrixMap */perspectiveCameraProjectionRecord[/* pMatrixMap */2],
	    /* nearMap */perspectiveCameraProjectionRecord[/* nearMap */3],
	    /* farMap */perspectiveCameraProjectionRecord[/* farMap */4],
	    /* fovyMap */perspectiveCameraProjectionRecord[/* fovyMap */5],
	    /* aspectMap */perspectiveCameraProjectionRecord[/* aspectMap */6],
	    /* gameObjectMap */perspectiveCameraProjectionRecord[/* gameObjectMap */7],
	    /* disposedIndexArray */perspectiveCameraProjectionRecord[/* disposedIndexArray */8]
	  ];
	  return newrecord;
	}

	function update$1(state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  return _clearDirtyArray(reduceOneParam((function (state, dirtyIndex) {
	                    return updateCameraProjection(dirtyIndex, state);
	                  }), state, removeDuplicateItems(perspectiveCameraProjectionRecord[/* dirtyArray */1])));
	}


	/* Log-WonderLog Not a pure module */

	var initPerspepctiveCameraProjection = updateCameraProjection;

	function init$5(state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var dirtyArray = perspectiveCameraProjectionRecord[/* dirtyArray */1];
	  var match = getCount(dirtyArray);
	  if (match !== 0) {
	    return reduceOneParam((function (state, dirtyIndex) {
	                  return updateCameraProjection(dirtyIndex, state);
	                }), state, removeDuplicateItems(dirtyArray));
	  } else {
	    return state;
	  }
	}


	/* DirtyArrayService-Wonderjs Not a pure module */

	function _initMaterialComponent(uid, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getBasicMaterialComponent(uid, gameObjectRecord);
	  var state$1;
	  if (match !== undefined) {
	    var material = match;
	    var state$2 = handleInitComponent(material, state);
	    state$1 = initTexture(getMap(material, state$2), state$2);
	  } else {
	    state$1 = state;
	  }
	  var match$1 = getLightMaterialComponent(uid, gameObjectRecord);
	  if (match$1 !== undefined) {
	    var material$1 = match$1;
	    var state$3 = handleInitComponent$1(material$1, state$1);
	    var state$4 = initTexture(getDiffuseMap(material$1, state$3), state$3);
	    return initTexture(getSpecularMap(material$1, state$4), state$4);
	  } else {
	    return state$1;
	  }
	}

	function initGameObject$2(uid, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var state$1 = _initMaterialComponent(uid, state);
	  var match = getPerspectiveCameraProjectionComponent(uid, gameObjectRecord);
	  var state$2 = match !== undefined ? initPerspepctiveCameraProjection(match, state$1) : state$1;
	  var match$1 = getArcballCameraControllerComponent(uid, gameObjectRecord);
	  if (match$1 !== undefined) {
	    return initArcballCameraController(match$1, state$2);
	  } else {
	    return state$2;
	  }
	}


	/* InitBasicMaterialMainService-Wonderjs Not a pure module */

	var getName$1 = get$3;

	function unsafeGetName$1(id, nameMap) {
	  return unsafeGet$1(get$3(id, nameMap));
	}

	var setName$1 = set$1;


	/* OptionService-Wonderjs Not a pure module */

	function getName(uid, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return getName$1(uid, gameObjectRecord[/* nameMap */1]);
	}

	function unsafeGetName(uid, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return unsafeGetName$1(uid, gameObjectRecord[/* nameMap */1]);
	}

	function setName(uid, name, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* nameMap */1] = setName$1(uid, name, gameObjectRecord[/* nameMap */1]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}


	/* NameService-Wonderjs Not a pure module */

	function isAlive$4(uid, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  var disposedUidMap = gameObjectRecord[/* disposedUidMap */3];
	  var transformMap = gameObjectRecord[/* transformMap */22];
	  var match = has$1(uid, disposedUidMap);
	  if (match) {
	    return false;
	  } else {
	    var match$1 = has$1(uid, transformMap);
	    if (match$1) {
	      return true;
	    } else {
	      return false;
	    }
	  }
	}


	/* No side effect */

	function reduceState(func, state, arr) {
	  var mutableState = state;
	  for(var i = 0 ,i_finish = arr.length - 1 | 0; i <= i_finish; ++i){
	    mutableState = func(mutableState, arr[i]);
	  }
	  return mutableState;
	}


	/* No side effect */

	function handleCloneComponent$1(sourceComponent, countRangeArr, param, record) {
	  var setDataFunc = param[2];
	  var createFunc = param[0];
	  var dataTuple = param[1](sourceComponent, record);
	  return reduceOneParam((function (param, _) {
	                var match = createFunc(param[0]);
	                var index = match[1];
	                var record = setDataFunc(index, dataTuple, match[0]);
	                return /* tuple */[
	                        record,
	                        push(index, param[1])
	                      ];
	              }), /* tuple */[
	              record,
	              /* array */[]
	            ], countRangeArr);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function create$26(record) {
	  var index = record[/* index */0];
	  return checkNotExceedMaxCount(getBufferMaxCount$1(/* () */0), /* tuple */[
	              /* record */[
	                /* index */index + 1 | 0,
	                /* buffer */record[/* buffer */1],
	                /* colors */record[/* colors */2],
	                /* intensities */record[/* intensities */3],
	                /* constants */record[/* constants */4],
	                /* linears */record[/* linears */5],
	                /* quadratics */record[/* quadratics */6],
	                /* ranges */record[/* ranges */7],
	                /* mappedIndexMap */setMappedIndex(index, index, record[/* mappedIndexMap */8]),
	                /* gameObjectMap */record[/* gameObjectMap */9]
	              ],
	              index
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function getColor$8(mappedIndex, param) {
	  return getColor$3(mappedIndex, param[/* colors */2]);
	}

	function setColor$4(mappedIndex, color, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */setColor$1(mappedIndex, color, record[/* colors */2]),
	          /* intensities */record[/* intensities */3],
	          /* constants */record[/* constants */4],
	          /* linears */record[/* linears */5],
	          /* quadratics */record[/* quadratics */6],
	          /* ranges */record[/* ranges */7],
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */record[/* gameObjectMap */9]
	        ];
	}

	function getIntensity$4(mappedIndex, param) {
	  return getIntensity$1(mappedIndex, param[/* intensities */3]);
	}

	function setIntensity$2(mappedIndex, intensity, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */setIntensity(mappedIndex, intensity, record[/* intensities */3]),
	          /* constants */record[/* constants */4],
	          /* linears */record[/* linears */5],
	          /* quadratics */record[/* quadratics */6],
	          /* ranges */record[/* ranges */7],
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */record[/* gameObjectMap */9]
	        ];
	}

	function getConstant$2(mappedIndex, param) {
	  return getConstant$1(mappedIndex, param[/* constants */4]);
	}

	function setConstant$1(mappedIndex, constant, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */record[/* intensities */3],
	          /* constants */setIntensity(mappedIndex, constant, record[/* constants */4]),
	          /* linears */record[/* linears */5],
	          /* quadratics */record[/* quadratics */6],
	          /* ranges */record[/* ranges */7],
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */record[/* gameObjectMap */9]
	        ];
	}

	function getLinear$1(mappedIndex, param) {
	  return getLinear(mappedIndex, param[/* linears */5]);
	}

	function setLinear$1(mappedIndex, linear, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */record[/* intensities */3],
	          /* constants */record[/* constants */4],
	          /* linears */setLinear(mappedIndex, linear, record[/* linears */5]),
	          /* quadratics */record[/* quadratics */6],
	          /* ranges */record[/* ranges */7],
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */record[/* gameObjectMap */9]
	        ];
	}

	function getQuadratic$2(mappedIndex, param) {
	  return getQuadratic$1(mappedIndex, param[/* quadratics */6]);
	}

	function setQuadratic$1(mappedIndex, quadratic, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */record[/* intensities */3],
	          /* constants */record[/* constants */4],
	          /* linears */record[/* linears */5],
	          /* quadratics */setQuadratic(mappedIndex, quadratic, record[/* quadratics */6]),
	          /* ranges */record[/* ranges */7],
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */record[/* gameObjectMap */9]
	        ];
	}

	function getRange$2(mappedIndex, param) {
	  return getRange$1(mappedIndex, param[/* ranges */7]);
	}

	function setRange$1(mappedIndex, range, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */record[/* intensities */3],
	          /* constants */record[/* constants */4],
	          /* linears */record[/* linears */5],
	          /* quadratics */record[/* quadratics */6],
	          /* ranges */setRange(mappedIndex, range, record[/* ranges */7]),
	          /* mappedIndexMap */record[/* mappedIndexMap */8],
	          /* gameObjectMap */record[/* gameObjectMap */9]
	        ];
	}

	function setRangeLevel(mappedIndex, level, record) {
	  if (level > 11 || level < 0) {
	    return fatal(buildFatalMessage("setRangeLevel", "shouldn\'t exceed point light range", "level is too large", "level should in [0, 11]", "level: " + (String(level) + "")));
	  } else {
	    switch (level) {
	      case 0 : 
	          return setQuadratic$1(mappedIndex, 1.8, setLinear$1(mappedIndex, 0.7, setRange$1(mappedIndex, 7, record)));
	      case 1 : 
	          return setQuadratic$1(mappedIndex, 0.44, setLinear$1(mappedIndex, 0.35, setRange$1(mappedIndex, 13, record)));
	      case 2 : 
	          return setQuadratic$1(mappedIndex, 0.20, setLinear$1(mappedIndex, 0.22, setRange$1(mappedIndex, 20, record)));
	      case 3 : 
	          return setQuadratic$1(mappedIndex, 0.07, setLinear$1(mappedIndex, 0.14, setRange$1(mappedIndex, 32, record)));
	      case 4 : 
	          return setQuadratic$1(mappedIndex, 0.032, setLinear$1(mappedIndex, 0.09, setRange$1(mappedIndex, 50, record)));
	      case 5 : 
	          return setQuadratic$1(mappedIndex, 0.017, setLinear$1(mappedIndex, 0.07, setRange$1(mappedIndex, 65, record)));
	      case 6 : 
	          return setQuadratic$1(mappedIndex, 0.0075, setLinear$1(mappedIndex, 0.045, setRange$1(mappedIndex, 100, record)));
	      case 7 : 
	          return setQuadratic$1(mappedIndex, 0.0028, setLinear$1(mappedIndex, 0.027, setRange$1(mappedIndex, 160, record)));
	      case 8 : 
	          return setQuadratic$1(mappedIndex, 0.0019, setLinear$1(mappedIndex, 0.022, setRange$1(mappedIndex, 200, record)));
	      case 9 : 
	          return setQuadratic$1(mappedIndex, 0.0007, setLinear$1(mappedIndex, 0.014, setRange$1(mappedIndex, 325, record)));
	      case 10 : 
	          return setQuadratic$1(mappedIndex, 0.0002, setLinear$1(mappedIndex, 0.007, setRange$1(mappedIndex, 600, record)));
	      case 11 : 
	          return setQuadratic$1(mappedIndex, 0.000007, setLinear$1(mappedIndex, 0.0014, setRange$1(mappedIndex, 3250, record)));
	      
	    }
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _getData(sourceComponent, record) {
	  return /* tuple */[
	          getColor$8(sourceComponent, record),
	          getIntensity$4(sourceComponent, record),
	          getConstant$2(sourceComponent, record),
	          getLinear$1(sourceComponent, record),
	          getQuadratic$2(sourceComponent, record),
	          getRange$2(sourceComponent, record)
	        ];
	}

	function _setData(sourceComponent, param, record) {
	  return setRange$1(sourceComponent, param[5], setQuadratic$1(sourceComponent, param[4], setLinear$1(sourceComponent, param[3], setConstant$1(sourceComponent, param[2], setIntensity$2(sourceComponent, param[1], setColor$4(sourceComponent, param[0], record))))));
	}

	function handleCloneComponent(sourceComponent, countRangeArr, record) {
	  return handleCloneComponent$1(sourceComponent, countRangeArr, /* tuple */[
	              create$26,
	              _getData,
	              _setData
	            ], record);
	}


	/* CloneLightService-Wonderjs Not a pure module */

	function handleCloneComponent$2(sourceComponent, countRangeArr, record) {
	  return /* tuple */[
	          record,
	          countRangeArr.map((function () {
	                  return sourceComponent;
	                }))
	        ];
	}


	/* No side effect */

	function handleCloneComponent$3(sourceComponent, countRangeArr, state) {
	  var settingRecord = state[/* settingRecord */1];
	  var transformRecord = getRecord$1(state);
	  var localPosition = getLocalPositionTuple$1(sourceComponent, transformRecord[/* localPositions */3]);
	  var localRotation = getLocalRotationTuple$1(sourceComponent, transformRecord[/* localRotations */4]);
	  var localScale = getLocalScaleTuple$1(sourceComponent, transformRecord[/* localScales */5]);
	  var match = reduceOneParam((function (param, _) {
	          var match = createWithoutMarkNotDirtyWithRecord(settingRecord, param[0]);
	          var index = match[1];
	          return /* tuple */[
	                  mark(index, true, setLocalScaleByTuple$1(index, localScale, setLocalRotationByTuple$1(index, localRotation, setLocalPositionByTuple$1(index, localPosition, match[0])))),
	                  push(index, param[1])
	                ];
	        }), /* tuple */[
	        transformRecord,
	        /* array */[]
	      ], countRangeArr);
	  state[/* transformRecord */12] = mark(sourceComponent, true, match[0]);
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	function handleCloneComponent$4(sourceComponent, countRangeArr, record) {
	  return /* tuple */[
	          record,
	          countRangeArr.map((function () {
	                  return sourceComponent;
	                }))
	        ];
	}


	/* No side effect */

	function create$27(record) {
	  var index = record[/* index */0];
	  return checkNotExceedMaxCount(getBufferMaxCount(/* () */0), /* tuple */[
	              /* record */[
	                /* index */index + 1 | 0,
	                /* buffer */record[/* buffer */1],
	                /* colors */record[/* colors */2],
	                /* intensities */record[/* intensities */3],
	                /* mappedIndexMap */setMappedIndex(index, index, record[/* mappedIndexMap */4]),
	                /* gameObjectMap */record[/* gameObjectMap */5]
	              ],
	              index
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function getColor$9(mappedIndex, param) {
	  return getColor$6(mappedIndex, param[/* colors */2]);
	}

	function setColor$5(mappedIndex, color, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */setColor$2(mappedIndex, color, record[/* colors */2]),
	          /* intensities */record[/* intensities */3],
	          /* mappedIndexMap */record[/* mappedIndexMap */4],
	          /* gameObjectMap */record[/* gameObjectMap */5]
	        ];
	}

	function getIntensity$5(mappedIndex, param) {
	  return getIntensity$3(mappedIndex, param[/* intensities */3]);
	}

	function setIntensity$3(mappedIndex, intensity, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* colors */record[/* colors */2],
	          /* intensities */setIntensity$1(mappedIndex, intensity, record[/* intensities */3]),
	          /* mappedIndexMap */record[/* mappedIndexMap */4],
	          /* gameObjectMap */record[/* gameObjectMap */5]
	        ];
	}


	/* RecordDirectionLightMainService-Wonderjs Not a pure module */

	function _getData$1(sourceComponent, record) {
	  return /* tuple */[
	          getColor$9(sourceComponent, record),
	          getIntensity$5(sourceComponent, record)
	        ];
	}

	function _setData$1(sourceComponent, param, record) {
	  return setIntensity$3(sourceComponent, param[1], setColor$5(sourceComponent, param[0], record));
	}

	function handleCloneComponent$5(sourceComponent, countRangeArr, record) {
	  return handleCloneComponent$1(sourceComponent, countRangeArr, /* tuple */[
	              create$27,
	              _getData$1,
	              _setData$1
	            ], record);
	}


	/* CloneLightService-Wonderjs Not a pure module */

	function create$28(record) {
	  var match = generateIndex(record[/* index */0], record[/* disposedIndexArray */2]);
	  return /* tuple */[
	          /* record */[
	            /* index */match[1],
	            /* gameObjectMap */record[/* gameObjectMap */1],
	            /* disposedIndexArray */match[2]
	          ],
	          match[0]
	        ];
	}


	/* No side effect */

	function handleCloneComponent$6(_, countRangeArr, record) {
	  return reduceOneParam((function (param, _) {
	                var match = create$28(param[0]);
	                return /* tuple */[
	                        match[0],
	                        push(match[1], param[1])
	                      ];
	              }), /* tuple */[
	              record,
	              /* array */[]
	            ], countRangeArr);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function create$29(state) {
	  var meshRendererRecord = getRecord$2(state);
	  var match = generateIndex(meshRendererRecord[/* index */0], meshRendererRecord[/* disposedIndexArray */6]);
	  state[/* meshRendererRecord */25] = /* record */[
	    /* index */match[1],
	    /* buffer */meshRendererRecord[/* buffer */1],
	    /* drawModes */meshRendererRecord[/* drawModes */2],
	    /* basicMaterialRenderGameObjectMap */meshRendererRecord[/* basicMaterialRenderGameObjectMap */3],
	    /* lightMaterialRenderGameObjectMap */meshRendererRecord[/* lightMaterialRenderGameObjectMap */4],
	    /* gameObjectMap */meshRendererRecord[/* gameObjectMap */5],
	    /* disposedIndexArray */match[2]
	  ];
	  return checkNotExceedMaxCount(getMeshRendererCount(state[/* settingRecord */1]), /* tuple */[
	              state,
	              match[0]
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function getDrawMode$1(meshRenderer, state) {
	  return getDrawMode(meshRenderer, getRecord$2(state)[/* drawModes */2]);
	}

	function setDrawMode$1(meshRenderer, drawMode, state) {
	  var meshRendererRecord = getRecord$2(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* meshRendererRecord */25] = /* record */[
	    /* index */meshRendererRecord[/* index */0],
	    /* buffer */meshRendererRecord[/* buffer */1],
	    /* drawModes */setDrawMode(meshRenderer, drawMode, meshRendererRecord[/* drawModes */2]),
	    /* basicMaterialRenderGameObjectMap */meshRendererRecord[/* basicMaterialRenderGameObjectMap */3],
	    /* lightMaterialRenderGameObjectMap */meshRendererRecord[/* lightMaterialRenderGameObjectMap */4],
	    /* gameObjectMap */meshRendererRecord[/* gameObjectMap */5],
	    /* disposedIndexArray */meshRendererRecord[/* disposedIndexArray */6]
	  ];
	  return newrecord;
	}


	/* RecordMeshRendererMainService-Wonderjs Not a pure module */

	var _getData$2 = getDrawMode$1;

	var _setData$2 = setDrawMode$1;

	function handleCloneComponent$7(sourceComponent, countRangeArr, state) {
	  var drawMode = _getData$2(sourceComponent, state);
	  return reduceOneParam((function (param, _) {
	                var match = create$29(param[0]);
	                var index = match[1];
	                var state = _setData$2(index, drawMode, match[0]);
	                return /* tuple */[
	                        state,
	                        push(index, param[1])
	                      ];
	              }), /* tuple */[
	              state,
	              /* array */[]
	            ], countRangeArr);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _handleShareMaterial(sourceComponent, countRangeArr, param) {
	  return /* tuple */[
	          param[1],
	          countRangeArr.map((function () {
	                  return sourceComponent;
	                }))
	        ];
	}

	function _handleNotShareMaterial(sourceComponent, countRangeArr, param, param$1) {
	  var state = param$1[1];
	  var setShaderIndexFunc = param[3];
	  var setDataFunc = param[2];
	  var createFunc = param[0];
	  var shaderIndex = getShaderIndex(sourceComponent, param$1[0]);
	  var dataTuple = param[1](sourceComponent, state);
	  return reduceOneParam((function (param, _) {
	                var match = createFunc(param[0]);
	                var index = match[1];
	                var state = setDataFunc(index, dataTuple, match[0]);
	                var state$1 = setShaderIndexFunc(index, shaderIndex, state);
	                return /* tuple */[
	                        state$1,
	                        push(index, param[1])
	                      ];
	              }), /* tuple */[
	              state,
	              /* array */[]
	            ], countRangeArr);
	}

	function handleCloneComponent$9(param, funcTuple, stateTuple) {
	  var countRangeArr = param[1];
	  var sourceComponent = param[0];
	  if (param[2]) {
	    return _handleShareMaterial(sourceComponent, countRangeArr, stateTuple);
	  } else {
	    return _handleNotShareMaterial(sourceComponent, countRangeArr, funcTuple, stateTuple);
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function getName$2(material, state) {
	  return getName$1(material, getRecord$4(state)[/* nameMap */11]);
	}

	function unsafeGetName$2(material, state) {
	  return unsafeGetName$1(material, getRecord$4(state)[/* nameMap */11]);
	}

	function setName$2(material, name, state) {
	  var record = getRecord$4(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */record[/* shaderIndices */2],
	    /* colors */record[/* colors */3],
	    /* textureIndices */record[/* textureIndices */4],
	    /* mapUnits */record[/* mapUnits */5],
	    /* textureCountMap */record[/* textureCountMap */6],
	    /* defaultColor */record[/* defaultColor */7],
	    /* gameObjectMap */record[/* gameObjectMap */8],
	    /* groupCountMap */record[/* groupCountMap */9],
	    /* disposedIndexArray */record[/* disposedIndexArray */10],
	    /* nameMap */setName$1(material, name, record[/* nameMap */11]),
	    /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */12]
	  ];
	  return newrecord;
	}


	/* NameService-Wonderjs Not a pure module */

	function _initDataWhenCreate$1(index, basicMaterialRecord) {
	  return /* record */[
	          /* index */basicMaterialRecord[/* index */0],
	          /* buffer */basicMaterialRecord[/* buffer */1],
	          /* shaderIndices */basicMaterialRecord[/* shaderIndices */2],
	          /* colors */basicMaterialRecord[/* colors */3],
	          /* textureIndices */basicMaterialRecord[/* textureIndices */4],
	          /* mapUnits */basicMaterialRecord[/* mapUnits */5],
	          /* textureCountMap */setCount(index, getDefaultCount(/* () */0), basicMaterialRecord[/* textureCountMap */6]),
	          /* defaultColor */basicMaterialRecord[/* defaultColor */7],
	          /* gameObjectMap */basicMaterialRecord[/* gameObjectMap */8],
	          /* groupCountMap */basicMaterialRecord[/* groupCountMap */9],
	          /* disposedIndexArray */basicMaterialRecord[/* disposedIndexArray */10],
	          /* nameMap */basicMaterialRecord[/* nameMap */11],
	          /* materialArrayForWorkerInit */basicMaterialRecord[/* materialArrayForWorkerInit */12]
	        ];
	}

	function create$30(state) {
	  var basicMaterialRecord = getRecord$4(state);
	  var match = generateIndex(basicMaterialRecord[/* index */0], basicMaterialRecord[/* disposedIndexArray */10]);
	  var index = match[0];
	  var basicMaterialRecord$1 = _initDataWhenCreate$1(index, basicMaterialRecord);
	  state[/* basicMaterialRecord */16] = /* record */[
	    /* index */match[1],
	    /* buffer */basicMaterialRecord$1[/* buffer */1],
	    /* shaderIndices */basicMaterialRecord$1[/* shaderIndices */2],
	    /* colors */basicMaterialRecord$1[/* colors */3],
	    /* textureIndices */basicMaterialRecord$1[/* textureIndices */4],
	    /* mapUnits */basicMaterialRecord$1[/* mapUnits */5],
	    /* textureCountMap */basicMaterialRecord$1[/* textureCountMap */6],
	    /* defaultColor */basicMaterialRecord$1[/* defaultColor */7],
	    /* gameObjectMap */basicMaterialRecord$1[/* gameObjectMap */8],
	    /* groupCountMap */basicMaterialRecord$1[/* groupCountMap */9],
	    /* disposedIndexArray */match[2],
	    /* nameMap */basicMaterialRecord$1[/* nameMap */11],
	    /* materialArrayForWorkerInit */basicMaterialRecord$1[/* materialArrayForWorkerInit */12]
	  ];
	  return checkNotExceedMaxCount(getBasicMaterialCount(state[/* settingRecord */1]), /* tuple */[
	              state,
	              index
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function setShaderIndex$2(materialIndex, shaderIndex, state) {
	  var record = getRecord$4(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */setShaderIndex(materialIndex, shaderIndex, record[/* shaderIndices */2]),
	    /* colors */record[/* colors */3],
	    /* textureIndices */record[/* textureIndices */4],
	    /* mapUnits */record[/* mapUnits */5],
	    /* textureCountMap */record[/* textureCountMap */6],
	    /* defaultColor */record[/* defaultColor */7],
	    /* gameObjectMap */record[/* gameObjectMap */8],
	    /* groupCountMap */record[/* groupCountMap */9],
	    /* disposedIndexArray */record[/* disposedIndexArray */10],
	    /* nameMap */record[/* nameMap */11],
	    /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */12]
	  ];
	  return newrecord;
	}


	/* ShaderIndicesService-Wonderjs Not a pure module */

	function _getData$3(sourceComponent, state) {
	  return /* tuple */[
	          getName$2(sourceComponent, state),
	          getColor$7(sourceComponent, state),
	          getMap(sourceComponent, state)
	        ];
	}

	function _setData$3(sourceComponent, param, state) {
	  var mapOption = param[2];
	  var nameOption = param[0];
	  var state$1 = nameOption !== undefined ? setName$2(sourceComponent, nameOption, state) : state;
	  var state$2 = setColor$3(sourceComponent, param[1], state$1);
	  if (mapOption !== undefined) {
	    return setMap(sourceComponent, mapOption, state$2);
	  } else {
	    return state$2;
	  }
	}

	function handleCloneComponent$8(sourceComponent, countRangeArr, isShareMaterial, state) {
	  var match = getRecord$4(state);
	  return handleCloneComponent$9(/* tuple */[
	              sourceComponent,
	              countRangeArr,
	              isShareMaterial
	            ], /* tuple */[
	              create$30,
	              _getData$3,
	              _setData$3,
	              setShaderIndex$2
	            ], /* tuple */[
	              match[/* shaderIndices */2],
	              state
	            ]);
	}


	/* CloneMaterialMainService-Wonderjs Not a pure module */

	function getName$3(material, state) {
	  return getName$1(material, getRecord$5(state)[/* nameMap */16]);
	}

	function unsafeGetName$3(material, state) {
	  return unsafeGetName$1(material, getRecord$5(state)[/* nameMap */16]);
	}

	function setName$3(material, name, state) {
	  var record = getRecord$5(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */record[/* shaderIndices */2],
	    /* diffuseColors */record[/* diffuseColors */3],
	    /* specularColors */record[/* specularColors */4],
	    /* shininess */record[/* shininess */5],
	    /* textureIndices */record[/* textureIndices */6],
	    /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	    /* specularMapUnits */record[/* specularMapUnits */8],
	    /* textureCountMap */record[/* textureCountMap */9],
	    /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	    /* defaultShininess */record[/* defaultShininess */12],
	    /* gameObjectMap */record[/* gameObjectMap */13],
	    /* groupCountMap */record[/* groupCountMap */14],
	    /* disposedIndexArray */record[/* disposedIndexArray */15],
	    /* nameMap */setName$1(material, name, record[/* nameMap */16]),
	    /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}


	/* NameService-Wonderjs Not a pure module */

	function _initDataWhenCreate$2(index, lightMaterialRecord) {
	  return /* record */[
	          /* index */lightMaterialRecord[/* index */0],
	          /* buffer */lightMaterialRecord[/* buffer */1],
	          /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	          /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	          /* specularColors */lightMaterialRecord[/* specularColors */4],
	          /* shininess */lightMaterialRecord[/* shininess */5],
	          /* textureIndices */lightMaterialRecord[/* textureIndices */6],
	          /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	          /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	          /* textureCountMap */setCount(index, getDefaultCount(/* () */0), lightMaterialRecord[/* textureCountMap */9]),
	          /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	          /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	          /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	          /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	          /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	          /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	          /* nameMap */lightMaterialRecord[/* nameMap */16],
	          /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	        ];
	}

	function create$31(state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var match = generateIndex(lightMaterialRecord[/* index */0], lightMaterialRecord[/* disposedIndexArray */15]);
	  var index = match[0];
	  var lightMaterialRecord$1 = _initDataWhenCreate$2(index, lightMaterialRecord);
	  state[/* lightMaterialRecord */17] = /* record */[
	    /* index */match[1],
	    /* buffer */lightMaterialRecord$1[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord$1[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord$1[/* diffuseColors */3],
	    /* specularColors */lightMaterialRecord$1[/* specularColors */4],
	    /* shininess */lightMaterialRecord$1[/* shininess */5],
	    /* textureIndices */lightMaterialRecord$1[/* textureIndices */6],
	    /* diffuseMapUnits */lightMaterialRecord$1[/* diffuseMapUnits */7],
	    /* specularMapUnits */lightMaterialRecord$1[/* specularMapUnits */8],
	    /* textureCountMap */lightMaterialRecord$1[/* textureCountMap */9],
	    /* defaultDiffuseColor */lightMaterialRecord$1[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord$1[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord$1[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord$1[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord$1[/* groupCountMap */14],
	    /* disposedIndexArray */match[2],
	    /* nameMap */lightMaterialRecord$1[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord$1[/* materialArrayForWorkerInit */17]
	  ];
	  return checkNotExceedMaxCount(getBasicMaterialCount(state[/* settingRecord */1]), /* tuple */[
	              state,
	              index
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function setShaderIndex$3(materialIndex, shaderIndex, state) {
	  var record = getRecord$5(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */setShaderIndex(materialIndex, shaderIndex, record[/* shaderIndices */2]),
	    /* diffuseColors */record[/* diffuseColors */3],
	    /* specularColors */record[/* specularColors */4],
	    /* shininess */record[/* shininess */5],
	    /* textureIndices */record[/* textureIndices */6],
	    /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	    /* specularMapUnits */record[/* specularMapUnits */8],
	    /* textureCountMap */record[/* textureCountMap */9],
	    /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	    /* defaultShininess */record[/* defaultShininess */12],
	    /* gameObjectMap */record[/* gameObjectMap */13],
	    /* groupCountMap */record[/* groupCountMap */14],
	    /* disposedIndexArray */record[/* disposedIndexArray */15],
	    /* nameMap */record[/* nameMap */16],
	    /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}


	/* ShaderIndicesService-Wonderjs Not a pure module */

	function _getData$4(sourceComponent, state) {
	  return /* tuple */[
	          getName$3(sourceComponent, state),
	          getDiffuseColor$2(sourceComponent, state),
	          getSpecularColor$2(sourceComponent, state),
	          getShininess$2(sourceComponent, state),
	          getDiffuseMap(sourceComponent, state),
	          getSpecularMap(sourceComponent, state)
	        ];
	}

	function _setData$4(sourceComponent, param, state) {
	  var specularMapOption = param[5];
	  var diffuseMapOption = param[4];
	  var nameOption = param[0];
	  var state$1 = nameOption !== undefined ? setName$3(sourceComponent, nameOption, state) : state;
	  var state$2 = setShininess$1(sourceComponent, param[3], setSpecularColor$1(sourceComponent, param[2], setDiffuseColor$1(sourceComponent, param[1], state$1)));
	  var state$3 = diffuseMapOption !== undefined ? setDiffuseMap(sourceComponent, diffuseMapOption, state$2) : state$2;
	  if (specularMapOption !== undefined) {
	    return setSpecularMap(sourceComponent, specularMapOption, state$3);
	  } else {
	    return state$3;
	  }
	}

	function handleCloneComponent$10(sourceComponent, countRangeArr, isShareMaterial, state) {
	  var match = getRecord$5(state);
	  return handleCloneComponent$9(/* tuple */[
	              sourceComponent,
	              countRangeArr,
	              isShareMaterial
	            ], /* tuple */[
	              create$31,
	              _getData$4,
	              _setData$4,
	              setShaderIndex$3
	            ], /* tuple */[
	              match[/* shaderIndices */2],
	              state
	            ]);
	}


	/* CloneMaterialMainService-Wonderjs Not a pure module */

	function _setDefaultValue(index, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* pointDownEventHandleFuncMap */record[/* pointDownEventHandleFuncMap */1],
	          /* pointUpEventHandleFuncMap */record[/* pointUpEventHandleFuncMap */2],
	          /* pointDragEventHandleFuncMap */record[/* pointDragEventHandleFuncMap */3],
	          /* pointScaleEventHandleFuncMap */record[/* pointScaleEventHandleFuncMap */4],
	          /* keydownEventHandleFuncMap */record[/* keydownEventHandleFuncMap */5],
	          /* dirtyArray */record[/* dirtyArray */6],
	          /* distanceMap */set$1(index, 10, record[/* distanceMap */7]),
	          /* minDistanceMap */set$1(index, 0.05, record[/* minDistanceMap */8]),
	          /* phiMap */set$1(index, Math.PI / 2, record[/* phiMap */9]),
	          /* thetaMap */set$1(index, Math.PI / 2, record[/* thetaMap */10]),
	          /* thetaMarginMap */set$1(index, 0.05, record[/* thetaMarginMap */11]),
	          /* targetMap */set$1(index, /* tuple */[
	                0,
	                0,
	                0
	              ], record[/* targetMap */12]),
	          /* moveSpeedXMap */set$1(index, 1, record[/* moveSpeedXMap */13]),
	          /* moveSpeedYMap */set$1(index, 1, record[/* moveSpeedYMap */14]),
	          /* rotateSpeedMap */set$1(index, 1, record[/* rotateSpeedMap */15]),
	          /* wheelSpeedMap */set$1(index, 1, record[/* wheelSpeedMap */16]),
	          /* gameObjectMap */record[/* gameObjectMap */17],
	          /* disposedIndexArray */record[/* disposedIndexArray */18]
	        ];
	}

	function create$32(record) {
	  var match = generateIndex(record[/* index */0], record[/* disposedIndexArray */18]);
	  var index = match[0];
	  var record$1 = _setDefaultValue(index, record);
	  return /* tuple */[
	          /* record */[
	            /* index */match[1],
	            /* pointDownEventHandleFuncMap */record$1[/* pointDownEventHandleFuncMap */1],
	            /* pointUpEventHandleFuncMap */record$1[/* pointUpEventHandleFuncMap */2],
	            /* pointDragEventHandleFuncMap */record$1[/* pointDragEventHandleFuncMap */3],
	            /* pointScaleEventHandleFuncMap */record$1[/* pointScaleEventHandleFuncMap */4],
	            /* keydownEventHandleFuncMap */record$1[/* keydownEventHandleFuncMap */5],
	            /* dirtyArray */addToDirtyArray(index, record[/* dirtyArray */6]),
	            /* distanceMap */record$1[/* distanceMap */7],
	            /* minDistanceMap */record$1[/* minDistanceMap */8],
	            /* phiMap */record$1[/* phiMap */9],
	            /* thetaMap */record$1[/* thetaMap */10],
	            /* thetaMarginMap */record$1[/* thetaMarginMap */11],
	            /* targetMap */record$1[/* targetMap */12],
	            /* moveSpeedXMap */record$1[/* moveSpeedXMap */13],
	            /* moveSpeedYMap */record$1[/* moveSpeedYMap */14],
	            /* rotateSpeedMap */record$1[/* rotateSpeedMap */15],
	            /* wheelSpeedMap */record$1[/* wheelSpeedMap */16],
	            /* gameObjectMap */record$1[/* gameObjectMap */17],
	            /* disposedIndexArray */match[2]
	          ],
	          index
	        ];
	}


	/* DirtyArrayService-Wonderjs Not a pure module */

	function handleCloneComponent$11(sourceComponent, countRangeArr, record) {
	  var distance = unsafeGetDistance(sourceComponent, record);
	  var minDistance = unsafeGetMinDistance(sourceComponent, record);
	  var phi = unsafeGetPhi(sourceComponent, record);
	  var theta = unsafeGetTheta(sourceComponent, record);
	  var thetaMargin = unsafeGetThetaMargin(sourceComponent, record);
	  var target = unsafeGetTarget(sourceComponent, record);
	  var moveSpeedX = unsafeGetMoveSpeedX(sourceComponent, record);
	  var moveSpeedY = unsafeGetMoveSpeedY(sourceComponent, record);
	  var rotateSpeed = unsafeGetRotateSpeed(sourceComponent, record);
	  var wheelSpeed = unsafeGetWheelSpeed(sourceComponent, record);
	  return reduceOneParam((function (param, _) {
	                var match = create$32(param[0]);
	                var index = match[1];
	                return /* tuple */[
	                        setWheelSpeed(index, wheelSpeed, setRotateSpeed(index, rotateSpeed, setMoveSpeedY(index, moveSpeedY, setMoveSpeedX(index, moveSpeedX, setTarget(index, target, setThetaMargin(index, thetaMargin, setTheta(index, theta, setPhi(index, phi, setMinDistance(index, minDistance, setDistance(index, distance, match[0])))))))))),
	                        push(index, param[1])
	                      ];
	              }), /* tuple */[
	              record,
	              /* array */[]
	            ], countRangeArr);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function create$33(record) {
	  var match = generateIndex(record[/* index */0], record[/* disposedIndexArray */8]);
	  var index = match[0];
	  return /* tuple */[
	          /* record */[
	            /* index */match[1],
	            /* dirtyArray */addToDirtyArray(index, record[/* dirtyArray */1]),
	            /* pMatrixMap */setDefaultPMatrix(index, record[/* pMatrixMap */2]),
	            /* nearMap */record[/* nearMap */3],
	            /* farMap */record[/* farMap */4],
	            /* fovyMap */record[/* fovyMap */5],
	            /* aspectMap */record[/* aspectMap */6],
	            /* gameObjectMap */record[/* gameObjectMap */7],
	            /* disposedIndexArray */match[2]
	          ],
	          index
	        ];
	}


	/* PMatrixService-Wonderjs Not a pure module */

	function handleCloneComponent$12(sourceComponent, countRangeArr, record) {
	  var near = unsafeGetNear(sourceComponent, record);
	  var far = unsafeGetFar(sourceComponent, record);
	  var fovy = unsafeGetFovy(sourceComponent, record);
	  var aspect = unsafeGetAspect(sourceComponent, record);
	  return reduceOneParam((function (param, _) {
	                var match = create$33(param[0]);
	                var index = match[1];
	                return /* tuple */[
	                        setAspect(index, aspect, setFovy(index, fovy, setFar(index, far, setNear(index, near, match[0])))),
	                        push(index, param[1])
	                      ];
	              }), /* tuple */[
	              record,
	              /* array */[]
	            ], countRangeArr);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function cloneBasicCameraViewComponent(sourceComponent, countRangeArr, state) {
	  var basicCameraViewRecord = state[/* basicCameraViewRecord */14];
	  var match = handleCloneComponent$6(sourceComponent, countRangeArr, basicCameraViewRecord);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* basicCameraViewRecord */14] = match[0], newrecord),
	          match[1]
	        ];
	}

	function clonePerspectiveCameraProjectionComponent(sourceComponent, countRangeArr, state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var match = handleCloneComponent$12(sourceComponent, countRangeArr, perspectiveCameraProjectionRecord);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* perspectiveCameraProjectionRecord */15] = match[0], newrecord),
	          match[1]
	        ];
	}

	function cloneArcballCameraControllerComponent(sourceComponent, countRangeArr, state) {
	  var match = handleCloneComponent$11(sourceComponent, countRangeArr, state[/* arcballCameraControllerRecord */26]);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* arcballCameraControllerRecord */26] = match[0], newrecord),
	          match[1]
	        ];
	}

	var cloneTransformComponent = handleCloneComponent$3;

	function cloneMeshRendererComponent(sourceComponent, countRangeArr, state) {
	  var match = handleCloneComponent$7(sourceComponent, countRangeArr, state);
	  return /* tuple */[
	          match[0],
	          match[1]
	        ];
	}

	function cloneBoxGeometryComponent(sourceComponent, countRangeArr, state) {
	  var boxGeometryRecord = state[/* boxGeometryRecord */23];
	  var match = handleCloneComponent$2(sourceComponent, countRangeArr, boxGeometryRecord);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* boxGeometryRecord */23] = match[0], newrecord),
	          match[1]
	        ];
	}

	function cloneCustomGeometryComponent(sourceComponent, countRangeArr, state) {
	  var customGeometryRecord = state[/* customGeometryRecord */24];
	  var match = handleCloneComponent$4(sourceComponent, countRangeArr, customGeometryRecord);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* customGeometryRecord */24] = match[0], newrecord),
	          match[1]
	        ];
	}

	function cloneBasicMaterialComponent(isShareMaterial, sourceComponent, countRangeArr, state) {
	  return handleCloneComponent$8(sourceComponent, countRangeArr, isShareMaterial, state);
	}

	function cloneLightMaterialComponent(isShareMaterial, sourceComponent, countRangeArr, state) {
	  return handleCloneComponent$10(sourceComponent, countRangeArr, isShareMaterial, state);
	}

	function cloneDirectionLightComponent(sourceComponent, countRangeArr, state) {
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var match = handleCloneComponent$5(sourceComponent, countRangeArr, directionLightRecord);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* directionLightRecord */21] = match[0], newrecord),
	          match[1]
	        ];
	}

	function clonePointLightComponent(sourceComponent, countRangeArr, state) {
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var match = handleCloneComponent(sourceComponent, countRangeArr, pointLightRecord);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* pointLightRecord */22] = match[0], newrecord),
	          match[1]
	        ];
	}


	/* ClonePointLightService-Wonderjs Not a pure module */

	function _checkBatchAdd(uidArr, componentArr) {
	  return requireCheck((function () {
	                var gameObjectCount = uidArr.length;
	                var componentCount = componentArr.length;
	                return test(buildAssertMessage("one gameObject should add one component", "" + (String(gameObjectCount) + (" gameObject add " + (String(componentCount) + " components")))), (function () {
	                              return Operators[/* = */0](gameObjectCount, componentCount);
	                            }));
	              }), getIsDebug(stateData));
	}

	function _batchAddComponent(param, handleAddComponentFunc, componentRecord) {
	  var componentMap = param[2];
	  var componentArr = param[1];
	  var uidArr = param[0];
	  _checkBatchAdd(uidArr, componentArr);
	  return reduceOneParami((function (componentRecord, uid, index) {
	                var component = componentArr[index];
	                addComponent(uid, component, componentMap);
	                return handleAddComponentFunc(component, uid, componentRecord);
	              }), componentRecord, uidArr);
	}

	function _batchAddComponentWithState(param, handleAddComponentFunc, state) {
	  var componentMap = param[2];
	  var componentArr = param[1];
	  var uidArr = param[0];
	  _checkBatchAdd(uidArr, componentArr);
	  return reduceOneParami((function (state, uid, index) {
	                var component = componentArr[index];
	                addComponent(uid, component, componentMap);
	                return handleAddComponentFunc(component, uid, state);
	              }), state, uidArr);
	}

	function _batchAddBasicCameraViewComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var basicCameraViewRecord = state[/* basicCameraViewRecord */14];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicCameraViewRecord */14] = _batchAddComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* basicCameraViewMap */23]
	      ], handleAddComponent$9, basicCameraViewRecord);
	  return newrecord;
	}

	function _batchAddPerspectiveCameraProjectionComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = _batchAddComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* perspectiveCameraProjectionMap */24]
	      ], handleAddComponent$12, perspectiveCameraProjectionRecord);
	  return newrecord;
	}

	function _batchAddArcballCameraControllerComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = _batchAddComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* arcballCameraControllerMap */25]
	      ], handleAddComponent$11, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function _batchAddTransformComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* transformRecord */12] = _batchAddComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* transformMap */22]
	      ], handleAddComponent, getRecord$1(state));
	  return newrecord;
	}

	function _batchAddMeshRendererComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return _batchAddComponentWithState(/* tuple */[
	              uidArr,
	              componentArr,
	              gameObjectRecord[/* meshRendererMap */26]
	            ], handleAddComponent$10, state);
	}

	function _batchAddSharableComponent(param, param$1, record) {
	  var handleAddComponentFunc = param$1[1];
	  var increaseGroupCountFunc = param$1[0];
	  var componentMap = param[2];
	  var componentArr = param[1];
	  var uidArr = param[0];
	  _checkBatchAdd(uidArr, componentArr);
	  return reduceOneParami((function (record, uid, index) {
	                var component = componentArr[index];
	                addComponent(uid, component, componentMap);
	                var record$1 = increaseGroupCountFunc(component, record);
	                return handleAddComponentFunc(component, uid, record$1);
	              }), record, uidArr);
	}

	function _batchAddSharableGeometryComponent(param, param$1, record) {
	  var batchAddComponentDataFunc = param$1[2];
	  var handleAddComponentFunc = param$1[1];
	  var increaseGroupCountFunc = param$1[0];
	  var dataTupleForBatchAddComponentDataFunc = param[2];
	  var componentArr = param[1];
	  var uidArr = param[0];
	  _checkBatchAdd(uidArr, componentArr);
	  return reduceOneParami((function (record, uid, index) {
	                var component = componentArr[index];
	                batchAddComponentDataFunc(dataTupleForBatchAddComponentDataFunc, component, uid);
	                var record$1 = increaseGroupCountFunc(component, record);
	                return handleAddComponentFunc(component, uid, record$1);
	              }), record, uidArr);
	}

	function _batchAddBoxGeometryComponentDataForClone(param, component, uid) {
	  return addToMap(uid, /* tuple */[
	              component,
	              param[1]
	            ], param[0]);
	}

	function batchAddBoxGeometryComponentForClone(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* boxGeometryRecord */23] = _batchAddSharableGeometryComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        /* tuple */[
	          gameObjectRecord[/* geometryDataMap */21],
	          getBoxGeometryType(/* () */0)
	        ]
	      ], /* tuple */[
	        increaseGroupCount,
	        handleAddComponent$2,
	        _batchAddBoxGeometryComponentDataForClone
	      ], getRecord$3(state));
	  return newrecord;
	}

	function _batchAddCustomGeometryComponentData(param, component, uid) {
	  return addToMap(uid, /* tuple */[
	              component,
	              param[1]
	            ], param[0]);
	}

	function _batchAddCustomGeometryComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* customGeometryRecord */24] = _batchAddSharableGeometryComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        /* tuple */[
	          gameObjectRecord[/* geometryDataMap */21],
	          getCustomGeometryType(/* () */0)
	        ]
	      ], /* tuple */[
	        increaseGroupCount$4,
	        handleAddComponent$5,
	        _batchAddCustomGeometryComponentData
	      ], getRecord$6(state));
	  return newrecord;
	}

	function _batchAddMaterialComponent(param, funcTuple, record) {
	  return _batchAddSharableComponent(/* tuple */[
	              param[0],
	              param[1],
	              param[2]
	            ], funcTuple, record);
	}

	function _batchAddBasicMaterialComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = _batchAddMaterialComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* basicMaterialMap */27]
	      ], /* tuple */[
	        increaseGroupCount$2,
	        handleAddComponent$3
	      ], getRecord$4(state));
	  return newrecord;
	}

	function _batchAddLightMaterialComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = _batchAddMaterialComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* lightMaterialMap */28]
	      ], /* tuple */[
	        increaseGroupCount$3,
	        handleAddComponent$4
	      ], getRecord$5(state));
	  return newrecord;
	}

	function _batchAddDirectionLightComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* directionLightRecord */21] = _batchAddComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* directionLightMap */31]
	      ], handleAddComponent$6, directionLightRecord);
	  return newrecord;
	}

	function _batchAddPointLightComponent(uidArr, componentArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = _batchAddComponent(/* tuple */[
	        uidArr,
	        componentArr,
	        gameObjectRecord[/* pointLightMap */32]
	      ], handleAddComponent$1, pointLightRecord);
	  return newrecord;
	}

	var batchAddBasicCameraViewComponentForClone = _batchAddBasicCameraViewComponent;

	var batchAddPerspectiveCameraProjectionComponentForClone = _batchAddPerspectiveCameraProjectionComponent;

	var batchAddArcballCameraControllerComponentForClone = _batchAddArcballCameraControllerComponent;

	var batchAddTransformComponentForClone = _batchAddTransformComponent;

	var batchAddMeshRendererComponentForClone = _batchAddMeshRendererComponent;

	var batchAddCustomGeometryComponentForClone = _batchAddCustomGeometryComponent;

	var batchAddBasicMaterialComponentForClone = _batchAddBasicMaterialComponent;

	var batchAddLightMaterialComponentForClone = _batchAddLightMaterialComponent;

	var batchAddDirectionLightComponentForClone = _batchAddDirectionLightComponent;

	var batchAddPointLightComponentForClone = _batchAddPointLightComponent;

	var batchAddTransformComponentForCreate = _batchAddTransformComponent;

	var batchAddCustomGeometryComponentForCreate = _batchAddCustomGeometryComponent;

	var batchAddBasicCameraViewComponentForCreate = _batchAddBasicCameraViewComponent;

	var batchAddPerspectiveCameraProjectionComponentForCreate = _batchAddPerspectiveCameraProjectionComponent;

	var batchAddArcballCameraControllerComponentForCreate = _batchAddArcballCameraControllerComponent;

	var batchAddBasicMaterialComponentForCreate = _batchAddBasicMaterialComponent;

	var batchAddLightMaterialComponentForCreate = _batchAddLightMaterialComponent;

	var batchAddMeshRendererComponentForCreate = _batchAddMeshRendererComponent;

	var batchAddDirectionLightComponentForCreate = _batchAddDirectionLightComponent;

	var batchAddPointLightComponentForCreate = _batchAddPointLightComponent;


	/* Log-WonderLog Not a pure module */

	function _clone$1(param, param$1, state) {
	  var component = param[1];
	  if (component !== undefined) {
	    var match = _3(param$1[0], component, param[2], state);
	    return _3(param$1[1], param[3], match[1], match[0]);
	  } else {
	    return state;
	  }
	}

	function _cloneGeometryComponent(uid, countRangeArr, clonedGameObjectArr, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var boxGeometryType = getBoxGeometryType(/* () */0);
	  var customGeometryType = getCustomGeometryType(/* () */0);
	  var match = getGeometryComponentData(uid, gameObjectRecord);
	  if (match !== undefined) {
	    var match$1 = match;
	    var type_ = match$1[1];
	    var component = match$1[0];
	    if (type_ === boxGeometryType) {
	      var match$2 = cloneBoxGeometryComponent(component, countRangeArr, state);
	      return batchAddBoxGeometryComponentForClone(clonedGameObjectArr, match$2[1], state);
	    } else if (type_ === customGeometryType) {
	      var match$3 = cloneCustomGeometryComponent(component, countRangeArr, state);
	      return batchAddCustomGeometryComponentForClone(clonedGameObjectArr, match$3[1], state);
	    } else {
	      throw [
	            match_failure,
	            /* tuple */[
	              "CloneGameObjectComponentMainService.re",
	              43,
	              4
	            ]
	          ];
	    }
	  } else {
	    return state;
	  }
	}

	function _cloneComponentExceptTransform(param, isShareMaterial, state) {
	  var clonedGameObjectArr = param[2];
	  var countRangeArr = param[1];
	  var uid = param[0];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return _clone$1(/* tuple */[
	              uid,
	              getPointLightComponent(uid, gameObjectRecord),
	              countRangeArr,
	              clonedGameObjectArr
	            ], /* tuple */[
	              clonePointLightComponent,
	              batchAddPointLightComponentForClone
	            ], _clone$1(/* tuple */[
	                  uid,
	                  getDirectionLightComponent(uid, gameObjectRecord),
	                  countRangeArr,
	                  clonedGameObjectArr
	                ], /* tuple */[
	                  cloneDirectionLightComponent,
	                  batchAddDirectionLightComponentForClone
	                ], _clone$1(/* tuple */[
	                      uid,
	                      getMeshRendererComponent(uid, gameObjectRecord),
	                      countRangeArr,
	                      clonedGameObjectArr
	                    ], /* tuple */[
	                      cloneMeshRendererComponent,
	                      batchAddMeshRendererComponentForClone
	                    ], _clone$1(/* tuple */[
	                          uid,
	                          getLightMaterialComponent(uid, gameObjectRecord),
	                          countRangeArr,
	                          clonedGameObjectArr
	                        ], /* tuple */[
	                          (function (param, param$1, param$2) {
	                              return cloneLightMaterialComponent(isShareMaterial, param, param$1, param$2);
	                            }),
	                          batchAddLightMaterialComponentForClone
	                        ], _clone$1(/* tuple */[
	                              uid,
	                              getBasicMaterialComponent(uid, gameObjectRecord),
	                              countRangeArr,
	                              clonedGameObjectArr
	                            ], /* tuple */[
	                              (function (param, param$1, param$2) {
	                                  return cloneBasicMaterialComponent(isShareMaterial, param, param$1, param$2);
	                                }),
	                              batchAddBasicMaterialComponentForClone
	                            ], _clone$1(/* tuple */[
	                                  uid,
	                                  getArcballCameraControllerComponent(uid, gameObjectRecord),
	                                  countRangeArr,
	                                  clonedGameObjectArr
	                                ], /* tuple */[
	                                  cloneArcballCameraControllerComponent,
	                                  batchAddArcballCameraControllerComponentForClone
	                                ], _clone$1(/* tuple */[
	                                      uid,
	                                      getPerspectiveCameraProjectionComponent(uid, gameObjectRecord),
	                                      countRangeArr,
	                                      clonedGameObjectArr
	                                    ], /* tuple */[
	                                      clonePerspectiveCameraProjectionComponent,
	                                      batchAddPerspectiveCameraProjectionComponentForClone
	                                    ], _clone$1(/* tuple */[
	                                          uid,
	                                          getBasicCameraViewComponent(uid, gameObjectRecord),
	                                          countRangeArr,
	                                          clonedGameObjectArr
	                                        ], /* tuple */[
	                                          cloneBasicCameraViewComponent,
	                                          batchAddBasicCameraViewComponentForClone
	                                        ], _cloneGeometryComponent(uid, countRangeArr, clonedGameObjectArr, state)))))))));
	}

	function clone$1(param, isShareMaterial, state) {
	  var clonedGameObjectArr = param[3];
	  var countRangeArr = param[2];
	  var match = cloneTransformComponent(param[1], countRangeArr, _cloneComponentExceptTransform(/* tuple */[
	            param[0],
	            countRangeArr,
	            clonedGameObjectArr
	          ], isShareMaterial, state));
	  var clonedTransformArr = match[1];
	  return /* tuple */[
	          batchAddTransformComponentForClone(clonedGameObjectArr, clonedTransformArr, match[0]),
	          clonedTransformArr
	        ];
	}


	/* GetComponentGameObjectService-Wonderjs Not a pure module */

	function _createGameObjectArr(countRangeArr, gameObjectRecord) {
	  return reduceOneParam((function (param, _) {
	                var match = create$13(param[0]);
	                return /* tuple */[
	                        match[0],
	                        push(match[1], param[1])
	                      ];
	              }), /* tuple */[
	              gameObjectRecord,
	              /* array */[]
	            ], countRangeArr);
	}

	function _setParent$1$1(clonedParentTransformArr, clonedTransformArr, transformRecord) {
	  return reduceOneParami((function (transformRecord, clonedParentTransform, i) {
	                return setParentNotMarkDirty(clonedParentTransform, caml_array_get(clonedTransformArr, i), transformRecord);
	              }), transformRecord, clonedParentTransformArr);
	}

	function _clone(param, isShareMaterial, state) {
	  var countRangeArr = param[2];
	  var transform = param[1];
	  var match = _createGameObjectArr(countRangeArr, state[/* gameObjectRecord */11]);
	  var clonedGameObjectArr = match[1];
	  var totalClonedGameObjectArr = push(clonedGameObjectArr, param[4]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* gameObjectRecord */11] = match[0];
	  var match$1 = clone$1(/* tuple */[
	        param[0],
	        transform,
	        countRangeArr,
	        clonedGameObjectArr
	      ], isShareMaterial, newrecord);
	  var clonedTransformArr = match$1[1];
	  var state$1 = match$1[0];
	  reduceState((function (state, childTransform) {
	          return _clone(/* tuple */[
	                      unsafeGetGameObject$6(childTransform, getRecord$1(state)),
	                      childTransform,
	                      countRangeArr,
	                      clonedTransformArr,
	                      totalClonedGameObjectArr
	                    ], isShareMaterial, state);
	        }), state$1, unsafeGetChildren(transform, _setParent$1$1(param[3], clonedTransformArr, getRecord$1(state$1))));
	  return state$1;
	}

	function clone(uid, count, isShareMaterial, state) {
	  requireCheck((function () {
	          test(buildAssertMessage("not clone sourceInstance gameObject", "do"), (function () {
	                  return assertFalse(hasSourceInstanceComponent(uid, state[/* gameObjectRecord */11]));
	                }));
	          return test(buildAssertMessage("not clone objectInstance gameObject", "do"), (function () {
	                        return assertFalse(hasObjectInstanceComponent(uid, state[/* gameObjectRecord */11]));
	                      }));
	        }), getIsDebug(stateData));
	  var totalClonedGameObjectArr = /* array */[];
	  return /* tuple */[
	          _clone(/* tuple */[
	                uid,
	                unsafeGet$1(getTransformComponent(uid, state[/* gameObjectRecord */11])),
	                range$1(0, count - 1 | 0),
	                /* array */[],
	                totalClonedGameObjectArr
	              ], isShareMaterial, state),
	          totalClonedGameObjectArr
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function getMaxDisposeCount(record) {
	  return unsafeGetMemory(record)[/* maxDisposeCount */0];
	}

	function getMaxTypeArrayPoolSize(record) {
	  return unsafeGetMemory(record)[/* maxTypeArrayPoolSize */1];
	}

	function getMaxBigTypeArrayPoolSize(record) {
	  return unsafeGetMemory(record)[/* maxBigTypeArrayPoolSize */2];
	}


	/* OperateSettingService-Wonderjs Not a pure module */

	var isAlive$6 = isComponentAlive;

	function _deleteBySwapGameObjectMapData(mappedSourceIndex, lastComponentIndex, gameObjectMap) {
	  var lastGameObject = unsafeGet$2(lastComponentIndex, gameObjectMap);
	  undefined_to_opt(set$1(mappedSourceIndex, lastGameObject, set$1(lastComponentIndex, unsafeGet$2(mappedSourceIndex, gameObjectMap), gameObjectMap)).pop());
	  return gameObjectMap;
	}

	var disposeData$1 = _deleteBySwapGameObjectMapData;

	function _swapIndex(mappedSourceIndex, lastComponentIndex, mappedIndexMap) {
	  var match = mappedSourceIndex >= lastComponentIndex;
	  if (match) {
	    return mappedIndexMap;
	  } else {
	    return setMappedIndex(lastComponentIndex, mappedSourceIndex, mappedIndexMap);
	  }
	}

	function swapData(param, param$1, deleteBySwapAndResetTypeArrFunc, typeArr) {
	  var dataSize = param$1[1];
	  var lastComponentIndex = param[1];
	  var mappedSourceIndex = param[0];
	  var match = mappedSourceIndex >= lastComponentIndex;
	  if (match) {
	    return typeArr;
	  } else {
	    return deleteBySwapAndResetTypeArrFunc(/* tuple */[
	                imul(mappedSourceIndex, dataSize),
	                imul(lastComponentIndex, dataSize)
	              ], typeArr, dataSize, param$1[2]);
	  }
	}

	function setMappedIndexMap(sourceIndex, mappedSourceIndex, lastComponentIndex, mappedIndexMap) {
	  return markDisposed(sourceIndex, _swapIndex(mappedSourceIndex, lastComponentIndex, mappedIndexMap));
	}

	function handleBatchDisposeComponent$3(lightArray, param, record) {
	  var handleDisposeFunc = param[1];
	  var isAliveFunc = param[0];
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(lightArray, isAliveFunc, record);
	        }), getIsDebug(stateData));
	  return reduceOneParam((function (record, light) {
	                return handleDisposeFunc(light, record);
	              }), record, lightArray);
	}


	/* Contract-WonderLog Not a pure module */

	function getMappedIndexMap$1(param) {
	  return param[/* mappedIndexMap */8];
	}


	/* No side effect */

	function isAlive$5(light, record) {
	  return isAlive$6(light, getMappedIndexMap$1(record));
	}

	function _disposeData$2(sourceIndex, record) {
	  var mappedIndexMap = record[/* mappedIndexMap */8];
	  var index = record[/* index */0];
	  var lastComponentIndex = index - 1 | 0;
	  var mappedSourceIndex = getMappedIndex(sourceIndex, mappedIndexMap);
	  var gameObjectMap = disposeData$1(mappedSourceIndex, lastComponentIndex, record[/* gameObjectMap */9]);
	  return /* record */[
	          /* index */index - 1 | 0,
	          /* buffer */record[/* buffer */1],
	          /* colors */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getColorsSize$2(/* () */0),
	                getDefaultColor$1(/* () */0)
	              ], deleteBySwapAndResetFloat32TypeArr, record[/* colors */2]),
	          /* intensities */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getIntensitiesSize$1(/* () */0),
	                getDefaultIntensity(/* () */0)
	              ], deleteSingleValueBySwapAndResetFloat32TypeArr, record[/* intensities */3]),
	          /* constants */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getConstantsSize(/* () */0),
	                getDefaultConstant(/* () */0)
	              ], deleteSingleValueBySwapAndResetFloat32TypeArr, record[/* constants */4]),
	          /* linears */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getLinearsSize(/* () */0),
	                getDefaultLinear(/* () */0)
	              ], deleteSingleValueBySwapAndResetFloat32TypeArr, record[/* linears */5]),
	          /* quadratics */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getQuadraticsSize(/* () */0),
	                getDefaultQuadratic(/* () */0)
	              ], deleteSingleValueBySwapAndResetFloat32TypeArr, record[/* quadratics */6]),
	          /* ranges */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getRangesSize(/* () */0),
	                getDefaultRange(/* () */0)
	              ], deleteSingleValueBySwapAndResetFloat32TypeArr, record[/* ranges */7]),
	          /* mappedIndexMap */setMappedIndexMap(sourceIndex, mappedSourceIndex, lastComponentIndex, mappedIndexMap),
	          /* gameObjectMap */gameObjectMap
	        ];
	}

	function handleBatchDisposeComponent$2(lightArray, record) {
	  return handleBatchDisposeComponent$3(lightArray, /* tuple */[
	              isAlive$5,
	              _disposeData$2
	            ], record);
	}


	/* DisposeLightService-Wonderjs Not a pure module */

	function isAlive$7(meshRenderer, param) {
	  return isAlive$1(meshRenderer, param[/* disposedIndexArray */6]);
	}

	function _disposeData$3(meshRenderer, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* buffer */record[/* buffer */1],
	          /* drawModes */deleteAndResetUint8(meshRenderer, getDefaultDrawMode(/* () */0), record[/* drawModes */2]),
	          /* basicMaterialRenderGameObjectMap */disposeSparseMapData(meshRenderer, record[/* basicMaterialRenderGameObjectMap */3]),
	          /* lightMaterialRenderGameObjectMap */disposeSparseMapData(meshRenderer, record[/* lightMaterialRenderGameObjectMap */4]),
	          /* gameObjectMap */disposeSparseMapData(meshRenderer, record[/* gameObjectMap */5]),
	          /* disposedIndexArray */record[/* disposedIndexArray */6]
	        ];
	}

	function handleBatchDisposeComponent$4(meshRendererArray, record) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(meshRendererArray, isAlive$7, record);
	        }), getIsDebug(stateData));
	  var match = meshRendererArray.length;
	  if (match !== 0) {
	    var record_000 = /* index */record[/* index */0];
	    var record_001 = /* buffer */record[/* buffer */1];
	    var record_002 = /* drawModes */record[/* drawModes */2];
	    var record_003 = /* basicMaterialRenderGameObjectMap */record[/* basicMaterialRenderGameObjectMap */3];
	    var record_004 = /* lightMaterialRenderGameObjectMap */record[/* lightMaterialRenderGameObjectMap */4];
	    var record_005 = /* gameObjectMap */record[/* gameObjectMap */5];
	    var record_006 = /* disposedIndexArray */record[/* disposedIndexArray */6].concat(meshRendererArray);
	    var record$1 = /* record */[
	      record_000,
	      record_001,
	      record_002,
	      record_003,
	      record_004,
	      record_005,
	      record_006
	    ];
	    return reduceOneParam((function (record, meshRenderer) {
	                  return _disposeData$3(meshRenderer, record);
	                }), record$1, meshRendererArray);
	  } else {
	    return record;
	  }
	}


	/* Contract-WonderLog Not a pure module */

	function isAlive$8(light, record) {
	  return isAlive$6(light, getMappedIndexMap(record));
	}

	function _disposeData$4(sourceIndex, record) {
	  var mappedIndexMap = record[/* mappedIndexMap */4];
	  var index = record[/* index */0];
	  var lastComponentIndex = index - 1 | 0;
	  var mappedSourceIndex = getMappedIndex(sourceIndex, mappedIndexMap);
	  var gameObjectMap = disposeData$1(mappedSourceIndex, lastComponentIndex, record[/* gameObjectMap */5]);
	  return /* record */[
	          /* index */index - 1 | 0,
	          /* buffer */record[/* buffer */1],
	          /* colors */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getColorsSize$1(/* () */0),
	                getDefaultColor$2(/* () */0)
	              ], deleteBySwapAndResetFloat32TypeArr, record[/* colors */2]),
	          /* intensities */swapData(/* tuple */[
	                mappedSourceIndex,
	                lastComponentIndex
	              ], /* tuple */[
	                mappedIndexMap,
	                getIntensitiesSize(/* () */0),
	                getDefaultIntensity$1(/* () */0)
	              ], deleteSingleValueBySwapAndResetFloat32TypeArr, record[/* intensities */3]),
	          /* mappedIndexMap */setMappedIndexMap(sourceIndex, mappedSourceIndex, lastComponentIndex, mappedIndexMap),
	          /* gameObjectMap */gameObjectMap
	        ];
	}

	function handleBatchDisposeComponent$5(lightArray, record) {
	  return handleBatchDisposeComponent$3(lightArray, /* tuple */[
	              isAlive$8,
	              _disposeData$4
	            ], record);
	}


	/* DisposeLightService-Wonderjs Not a pure module */

	function isAlive$9(geometry, param) {
	  var disposedIndexArray = param[/* disposedIndexArray */7];
	  return isAlive$1(geometry, disposedIndexArray);
	}

	function _disposeData$5(geometry, boxGeometryRecord) {
	  var disposedIndexArray = boxGeometryRecord[/* disposedIndexArray */7];
	  return /* record */[
	          /* index */boxGeometryRecord[/* index */0],
	          /* vertices */boxGeometryRecord[/* vertices */1],
	          /* texCoords */boxGeometryRecord[/* texCoords */2],
	          /* normals */boxGeometryRecord[/* normals */3],
	          /* indices */boxGeometryRecord[/* indices */4],
	          /* gameObjectMap */disposeSparseMapData(geometry, boxGeometryRecord[/* gameObjectMap */5]),
	          /* groupCountMap */disposeSparseMapData(geometry, boxGeometryRecord[/* groupCountMap */6]),
	          /* disposedIndexArray */push(geometry, disposedIndexArray)
	        ];
	}

	function handleBatchDisposeComponent$6(geometryArray, state) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(geometryArray, isAlive$9, getRecord$3(state));
	        }), getIsDebug(stateData));
	  var boxGeometryRecord = getRecord$3(state);
	  var match = reduceOneParam((function (param, geometry) {
	          var boxGeometryRecord = param[1];
	          var geometryNeedDisposeVboBufferArr = param[0];
	          var match = isGroupGeometry(geometry, boxGeometryRecord);
	          if (match) {
	            return /* tuple */[
	                    geometryNeedDisposeVboBufferArr,
	                    decreaseGroupCount(geometry, boxGeometryRecord)
	                  ];
	          } else {
	            return /* tuple */[
	                    push(geometry, geometryNeedDisposeVboBufferArr),
	                    _disposeData$5(geometry, boxGeometryRecord)
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        boxGeometryRecord
	      ], geometryArray);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* boxGeometryRecord */23] = match[1], newrecord),
	          match[0]
	        ];
	}


	/* Contract-WonderLog Not a pure module */

	function disposeTextureIndices(material, textureCountPerMaterial, textureIndices) {
	  var sourceIndex = getTextureIndicesIndex(material, textureCountPerMaterial);
	  var defaultIndex = getDefaultTextureIndex(/* () */0);
	  for(var i = 0 ,i_finish = getTextureIndicesSize(textureCountPerMaterial) - 1 | 0; i <= i_finish; ++i){
	    textureIndices[sourceIndex + i | 0] = defaultIndex;
	  }
	  return textureIndices;
	}


	/* No side effect */

	function isAlive$10(material, param) {
	  return isAlive$1(material, param[/* disposedIndexArray */10]);
	}

	function _disposeData$6(material, textureCountPerMaterial, basicMaterialRecord) {
	  var match = disposeData(material, /* tuple */[
	        basicMaterialRecord[/* shaderIndices */2],
	        basicMaterialRecord[/* groupCountMap */9],
	        basicMaterialRecord[/* gameObjectMap */8]
	      ], getDefaultShaderIndex(/* () */0));
	  return /* record */[
	          /* index */basicMaterialRecord[/* index */0],
	          /* buffer */basicMaterialRecord[/* buffer */1],
	          /* shaderIndices */match[0],
	          /* colors */deleteAndResetFloat32TypeArr(getColorIndex(material), getColorsSize(/* () */0), basicMaterialRecord[/* defaultColor */7], basicMaterialRecord[/* colors */3]),
	          /* textureIndices */disposeTextureIndices(material, textureCountPerMaterial, basicMaterialRecord[/* textureIndices */4]),
	          /* mapUnits */deleteAndResetUint8(getMapUnitIndex(material), getDefaultUnit(/* () */0), basicMaterialRecord[/* mapUnits */5]),
	          /* textureCountMap */setCount(material, getDefaultCount(/* () */0), basicMaterialRecord[/* textureCountMap */6]),
	          /* defaultColor */basicMaterialRecord[/* defaultColor */7],
	          /* gameObjectMap */match[2],
	          /* groupCountMap */match[1],
	          /* disposedIndexArray */basicMaterialRecord[/* disposedIndexArray */10],
	          /* nameMap */disposeSparseMapData(material, basicMaterialRecord[/* nameMap */11]),
	          /* materialArrayForWorkerInit */basicMaterialRecord[/* materialArrayForWorkerInit */12]
	        ];
	}

	function _handleDispose(disposedIndexArray, material, textureCountPerMaterial, basicMaterialRecord) {
	  var match = isGroupMaterial(material, basicMaterialRecord);
	  if (match) {
	    return decreaseGroupCount$2(material, basicMaterialRecord);
	  } else {
	    var init = _disposeData$6(material, textureCountPerMaterial, basicMaterialRecord);
	    return /* record */[
	            /* index */init[/* index */0],
	            /* buffer */init[/* buffer */1],
	            /* shaderIndices */init[/* shaderIndices */2],
	            /* colors */init[/* colors */3],
	            /* textureIndices */init[/* textureIndices */4],
	            /* mapUnits */init[/* mapUnits */5],
	            /* textureCountMap */init[/* textureCountMap */6],
	            /* defaultColor */init[/* defaultColor */7],
	            /* gameObjectMap */init[/* gameObjectMap */8],
	            /* groupCountMap */init[/* groupCountMap */9],
	            /* disposedIndexArray */addDisposeIndex(material, disposedIndexArray),
	            /* nameMap */init[/* nameMap */11],
	            /* materialArrayForWorkerInit */init[/* materialArrayForWorkerInit */12]
	          ];
	  }
	}

	function handleBatchDisposeComponent$7(materialArray, state) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(materialArray, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  var basicMaterialRecord = getRecord$4(state);
	  var disposedIndexArray = basicMaterialRecord[/* disposedIndexArray */10];
	  var textureCountPerMaterial = getTextureCountPerMaterial(state[/* settingRecord */1]);
	  reduceOneParam((function (basicMaterialRecord, material) {
	          return _handleDispose(disposedIndexArray, material, textureCountPerMaterial, basicMaterialRecord);
	        }), basicMaterialRecord, materialArray);
	  return state;
	}


	/* Contract-WonderLog Not a pure module */

	function isAlive$11(material, param) {
	  return isAlive$1(material, param[/* disposedIndexArray */15]);
	}

	function _disposeData$7(material, textureCountPerMaterial, lightMaterialRecord) {
	  var match = disposeData(material, /* tuple */[
	        lightMaterialRecord[/* shaderIndices */2],
	        lightMaterialRecord[/* groupCountMap */14],
	        lightMaterialRecord[/* gameObjectMap */13]
	      ], getDefaultShaderIndex(/* () */0));
	  return /* record */[
	          /* index */lightMaterialRecord[/* index */0],
	          /* buffer */lightMaterialRecord[/* buffer */1],
	          /* shaderIndices */match[0],
	          /* diffuseColors */deleteAndResetFloat32TypeArr(getDiffuseColorIndex(material), getDiffuseColorsSize(/* () */0), lightMaterialRecord[/* defaultDiffuseColor */10], lightMaterialRecord[/* diffuseColors */3]),
	          /* specularColors */deleteAndResetFloat32TypeArr(getSpecularColorIndex(material), getSpecularColorsSize(/* () */0), lightMaterialRecord[/* defaultSpecularColor */11], lightMaterialRecord[/* specularColors */4]),
	          /* shininess */deleteAndResetFloat32(getShininessIndex(material), lightMaterialRecord[/* defaultShininess */12], lightMaterialRecord[/* shininess */5]),
	          /* textureIndices */disposeTextureIndices(material, textureCountPerMaterial, lightMaterialRecord[/* textureIndices */6]),
	          /* diffuseMapUnits */deleteAndResetUint8(getDiffuseMapUnitIndex(material), getDefaultUnit(/* () */0), lightMaterialRecord[/* diffuseMapUnits */7]),
	          /* specularMapUnits */deleteAndResetUint8(getDiffuseMapUnitIndex(material), getDefaultUnit(/* () */0), lightMaterialRecord[/* specularMapUnits */8]),
	          /* textureCountMap */setCount(material, getDefaultCount(/* () */0), lightMaterialRecord[/* textureCountMap */9]),
	          /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	          /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	          /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	          /* gameObjectMap */match[2],
	          /* groupCountMap */match[1],
	          /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	          /* nameMap */disposeSparseMapData(material, lightMaterialRecord[/* nameMap */16]),
	          /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	        ];
	}

	function _handleDispose$1(disposedIndexArray, material, textureCountPerMaterial, lightMaterialRecord) {
	  var match = isGroupMaterial$1(material, lightMaterialRecord);
	  if (match) {
	    return decreaseGroupCount$3(material, lightMaterialRecord);
	  } else {
	    var init = _disposeData$7(material, textureCountPerMaterial, lightMaterialRecord);
	    return /* record */[
	            /* index */init[/* index */0],
	            /* buffer */init[/* buffer */1],
	            /* shaderIndices */init[/* shaderIndices */2],
	            /* diffuseColors */init[/* diffuseColors */3],
	            /* specularColors */init[/* specularColors */4],
	            /* shininess */init[/* shininess */5],
	            /* textureIndices */init[/* textureIndices */6],
	            /* diffuseMapUnits */init[/* diffuseMapUnits */7],
	            /* specularMapUnits */init[/* specularMapUnits */8],
	            /* textureCountMap */init[/* textureCountMap */9],
	            /* defaultDiffuseColor */init[/* defaultDiffuseColor */10],
	            /* defaultSpecularColor */init[/* defaultSpecularColor */11],
	            /* defaultShininess */init[/* defaultShininess */12],
	            /* gameObjectMap */init[/* gameObjectMap */13],
	            /* groupCountMap */init[/* groupCountMap */14],
	            /* disposedIndexArray */addDisposeIndex(material, disposedIndexArray),
	            /* nameMap */init[/* nameMap */16],
	            /* materialArrayForWorkerInit */init[/* materialArrayForWorkerInit */17]
	          ];
	  }
	}

	function handleBatchDisposeComponent$8(materialArray, state) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(materialArray, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  var lightMaterialRecord = getRecord$5(state);
	  var disposedIndexArray = lightMaterialRecord[/* disposedIndexArray */15];
	  var textureCountPerMaterial = getTextureCountPerMaterial(state[/* settingRecord */1]);
	  reduceOneParam((function (lightMaterialRecord, material) {
	          return _handleDispose$1(disposedIndexArray, material, textureCountPerMaterial, lightMaterialRecord);
	        }), lightMaterialRecord, materialArray);
	  return state;
	}


	/* Contract-WonderLog Not a pure module */

	function isAlive$12(geometry, param) {
	  var disposedIndexArray = param[/* disposedIndexArray */17];
	  return isAlive$1(geometry, disposedIndexArray);
	}

	function _disposeData$8(geometry, customGeometryRecord) {
	  var disposeCount = customGeometryRecord[/* disposeCount */14];
	  var disposedIndexArray = customGeometryRecord[/* disposedIndexArray */17];
	  var disposedIndexMap = customGeometryRecord[/* disposedIndexMap */18];
	  return /* record */[
	          /* index */customGeometryRecord[/* index */0],
	          /* buffer */customGeometryRecord[/* buffer */1],
	          /* vertices */customGeometryRecord[/* vertices */2],
	          /* texCoords */customGeometryRecord[/* texCoords */3],
	          /* normals */customGeometryRecord[/* normals */4],
	          /* indices */customGeometryRecord[/* indices */5],
	          /* verticesInfos */customGeometryRecord[/* verticesInfos */6],
	          /* texCoordsInfos */customGeometryRecord[/* texCoordsInfos */7],
	          /* normalsInfos */customGeometryRecord[/* normalsInfos */8],
	          /* indicesInfos */customGeometryRecord[/* indicesInfos */9],
	          /* verticesOffset */customGeometryRecord[/* verticesOffset */10],
	          /* texCoordsOffset */customGeometryRecord[/* texCoordsOffset */11],
	          /* normalsOffset */customGeometryRecord[/* normalsOffset */12],
	          /* indicesOffset */customGeometryRecord[/* indicesOffset */13],
	          /* disposeCount */disposeCount + 1 | 0,
	          /* gameObjectMap */disposeSparseMapData(geometry, customGeometryRecord[/* gameObjectMap */15]),
	          /* groupCountMap */disposeSparseMapData(geometry, customGeometryRecord[/* groupCountMap */16]),
	          /* disposedIndexArray */push(geometry, disposedIndexArray),
	          /* disposedIndexMap */set$1(geometry, true, disposedIndexMap),
	          /* aliveIndexArray */customGeometryRecord[/* aliveIndexArray */19]
	        ];
	}

	function handleBatchDisposeComponent$9(geometryArray, state) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(geometryArray, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  var customGeometryRecord = getRecord$6(state);
	  var match = reduceOneParam((function (param, geometry) {
	          var customGeometryRecord = param[1];
	          var geometryNeedDisposeVboBufferArr = param[0];
	          var match = isGroupGeometry$1(geometry, customGeometryRecord);
	          if (match) {
	            return /* tuple */[
	                    geometryNeedDisposeVboBufferArr,
	                    decreaseGroupCount$4(geometry, customGeometryRecord)
	                  ];
	          } else {
	            return /* tuple */[
	                    push(geometry, geometryNeedDisposeVboBufferArr),
	                    _disposeData$8(geometry, customGeometryRecord)
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        customGeometryRecord
	      ], geometryArray);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* customGeometryRecord */24] = match[1], newrecord),
	          match[0]
	        ];
	}


	/* Contract-WonderLog Not a pure module */

	function unsafeGetGameObject$8(objectInstance, param) {
	  return unsafeGetGameObject$1(objectInstance, param[/* gameObjectMap */3]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	var getObjectInstanceTransformIndex$1 = unsafeGet$2;

	function setDefaultObjectInstanceTransformIndex(sourceInstance, objectInstanceTransformIndexMap) {
	  return set$1(sourceInstance, 0, objectInstanceTransformIndexMap);
	}

	function getObjectInstanceTransformCount(objectInstanceTransformIndex) {
	  return objectInstanceTransformIndex;
	}

	function _getStartIndexAndEndIndex(sourceInstance, objectInstanceCountPerSourceInstance, objectInstanceTransformIndex, objectInstanceTransformCollections) {
	  var startIndex = getObjectInstanceTransformCollectionsIndex(sourceInstance, objectInstanceCountPerSourceInstance);
	  return ensureCheck((function (param) {
	                var endIndex = param[1];
	                var startIndex = param[0];
	                test(buildAssertMessage("endIndex should <= objectInstanceTransformCollections->length", "not"), (function () {
	                        return Operators[/* <= */11](endIndex, objectInstanceTransformCollections.length);
	                      }));
	                return test(buildAssertMessage("endIndex + 1 should >= startIndex", "not"), (function () {
	                              return Operators[/* >= */7](endIndex + 1 | 0, startIndex);
	                            }));
	              }), getIsDebug(stateData), /* tuple */[
	              startIndex,
	              startIndex + (objectInstanceTransformIndex - 1 | 0) | 0
	            ]);
	}

	function reduceObjectInstanceTransformCollection(param, initialValue, reduceFunc) {
	  var objectInstanceTransformCollections = param[3];
	  var result = initialValue;
	  var match = _getStartIndexAndEndIndex(param[0], param[1], param[2], objectInstanceTransformCollections);
	  for(var i = match[0] ,i_finish = match[1]; i <= i_finish; ++i){
	    result = reduceFunc(result, getUint32_1(i, objectInstanceTransformCollections));
	  }
	  return result;
	}

	function getObjectInstanceTransformArray(sourceInstance, objectInstanceCountPerSourceInstance, objectInstanceTransformIndexMap, objectInstanceTransformCollections) {
	  var objectInstanceTransformIndex = unsafeGet$2(sourceInstance, objectInstanceTransformIndexMap);
	  return reduceObjectInstanceTransformCollection(/* tuple */[
	              sourceInstance,
	              objectInstanceCountPerSourceInstance,
	              objectInstanceTransformIndex,
	              objectInstanceTransformCollections
	            ], /* array */[], (function (objectInstanceTransformArray, objectInstanceTransform) {
	                return push(objectInstanceTransform, objectInstanceTransformArray);
	              }));
	}

	function addObjectInstanceTransform(sourceInstance, objectInstanceTransform, objectInstanceCountPerSourceInstance, param) {
	  var objectInstanceTransformIndexMap = param[0];
	  var objectInstanceTransformIndex = unsafeGet$2(sourceInstance, objectInstanceTransformIndexMap);
	  return ensureCheck((function (param) {
	                var objectInstanceTransformIndex = unsafeGet$2(sourceInstance, param[0]);
	                return test(buildAssertMessage("objectInstanceTransformIndex should <= objectInstanceCountPerSourceInstance:" + (String(objectInstanceCountPerSourceInstance) + ""), "is " + (String(objectInstanceTransformIndex) + "")), (function () {
	                              return Operators[/* <= */11](objectInstanceTransformIndex, objectInstanceCountPerSourceInstance);
	                            }));
	              }), getIsDebug(stateData), /* tuple */[
	              set$1(sourceInstance, objectInstanceTransformIndex + 1 | 0, objectInstanceTransformIndexMap),
	              setUint32_1(getObjectInstanceTransformIndex(sourceInstance, objectInstanceTransformIndex, objectInstanceCountPerSourceInstance), objectInstanceTransform, param[1])
	            ]);
	}

	function resetObjectInstanceTransformIndexMap(sourceInstance, objectInstanceTransformIndexMap) {
	  return set$1(sourceInstance, 0, objectInstanceTransformIndexMap);
	}

	function batchRemoveObjectInstanceTransform(sourceInstance, objectInstanceTransformArray, objectInstanceCountPerSourceInstance, param) {
	  var objectInstanceTransformCollections = param[1];
	  var objectInstanceTransformIndexMap = param[0];
	  var objectInstanceTransformIndex = unsafeGet$2(sourceInstance, objectInstanceTransformIndexMap);
	  return ensureCheck((function (param) {
	                var objectInstanceTransformIndex = unsafeGet$2(sourceInstance, param[0]);
	                return test(buildAssertMessage("objectInstanceTransformIndex should >= 0", "is " + (String(objectInstanceTransformIndex) + "")), (function () {
	                              return Operators[/* >= */7](objectInstanceTransformIndex, 0);
	                            }));
	              }), getIsDebug(stateData), objectInstanceTransformIndex !== 0 ? /* tuple */[
	                set$1(sourceInstance, objectInstanceTransformIndex - objectInstanceTransformArray.length | 0, objectInstanceTransformIndexMap),
	                objectInstanceTransformArray.reduce((function (objectInstanceTransformCollections, objectInstanceTransform, i) {
	                        return deleteSingleValueBySwapUint32TypeArr(objectInstanceTransformCollections.indexOf(objectInstanceTransform), getObjectInstanceTransformIndex(sourceInstance, objectInstanceTransformIndex - i | 0, objectInstanceCountPerSourceInstance), objectInstanceTransformCollections);
	                      }), objectInstanceTransformCollections)
	              ] : /* tuple */[
	                objectInstanceTransformIndexMap,
	                objectInstanceTransformCollections
	              ]);
	}


	/* Log-WonderLog Not a pure module */

	function isAlive$13(objectInstance, objectInstanceRecord) {
	  return isAlive$1(objectInstance, objectInstanceRecord[/* disposedIndexArray */2]);
	}

	function _unsafeGetSourceInstance(objectInstance, param) {
	  return ensureCheck((function (sourceInstance) {
	                return test(buildAssertMessage("souceInstance exist", "not"), (function () {
	                              return assertNullableExist(sourceInstance);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(objectInstance, param[/* sourceInstanceMap */1]));
	}

	function _disposeData$9(objectInstance, state) {
	  var objectInstanceRecord = state[/* objectInstanceRecord */8];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* objectInstanceRecord */8] = /* record */[
	    /* index */objectInstanceRecord[/* index */0],
	    /* sourceInstanceMap */disposeSparseMapData(objectInstance, objectInstanceRecord[/* sourceInstanceMap */1]),
	    /* disposedIndexArray */objectInstanceRecord[/* disposedIndexArray */2],
	    /* gameObjectMap */disposeSparseMapData(objectInstance, objectInstanceRecord[/* gameObjectMap */3])
	  ];
	  return newrecord;
	}

	function _batchDisposeObjectInstance(sourceInstance, objectInstanceTransformArray, state) {
	  var match = getRecord$7(state);
	  var objectInstanceCountPerSourceInstance = getObjectInstanceCountPerSourceInstance(state[/* settingRecord */1]);
	  batchRemoveObjectInstanceTransform(sourceInstance, objectInstanceTransformArray, objectInstanceCountPerSourceInstance, /* tuple */[
	        match[/* objectInstanceTransformIndexMap */1],
	        match[/* objectInstanceTransformCollections */4]
	      ]);
	  return state;
	}

	function handleBatchDisposeComponent$10(objectInstanceArray, state) {
	  var objectInstanceRecord = state[/* objectInstanceRecord */8];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  requireCheck((function () {
	          var objectInstanceLen = objectInstanceArray.length;
	          checkComponentShouldAliveWithBatchDispose(objectInstanceArray, isAlive$13, objectInstanceRecord);
	          test(buildAssertMessage("objectInstanceArray has one objectInstance at least", "" + (String(objectInstanceLen) + "")), (function () {
	                  return Operators[/* > */5](objectInstanceLen, 0);
	                }));
	          return test(buildAssertMessage("all objectInstance belong to the same sourceInstance", "not"), (function () {
	                        var sourceInstance = _unsafeGetSourceInstance(caml_array_get(objectInstanceArray, 0), objectInstanceRecord);
	                        return forEach((function (objectInstance) {
	                                      return Operators[/* = */0](_unsafeGetSourceInstance(objectInstance, objectInstanceRecord), sourceInstance);
	                                    }), objectInstanceArray);
	                      }));
	        }), getIsDebug(stateData));
	  var objectInstanceRecord_000 = /* index */objectInstanceRecord[/* index */0];
	  var objectInstanceRecord_001 = /* sourceInstanceMap */objectInstanceRecord[/* sourceInstanceMap */1];
	  var objectInstanceRecord_002 = /* disposedIndexArray */objectInstanceRecord[/* disposedIndexArray */2].concat(objectInstanceArray);
	  var objectInstanceRecord_003 = /* gameObjectMap */objectInstanceRecord[/* gameObjectMap */3];
	  var objectInstanceRecord$1 = /* record */[
	    objectInstanceRecord_000,
	    objectInstanceRecord_001,
	    objectInstanceRecord_002,
	    objectInstanceRecord_003
	  ];
	  var objectInstanceTransformArray = objectInstanceArray.map((function (objectInstance) {
	          return unsafeGetTransformComponent(unsafeGetGameObject$8(objectInstance, objectInstanceRecord$1), gameObjectRecord);
	        }));
	  var sourceInstance = _unsafeGetSourceInstance(caml_array_get(objectInstanceArray, 0), objectInstanceRecord$1);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* objectInstanceRecord */8] = objectInstanceRecord$1;
	  var state$1 = _batchDisposeObjectInstance(sourceInstance, objectInstanceTransformArray, newrecord);
	  return reduceState((function (state, objectInstance) {
	                return _disposeData$9(objectInstance, state);
	              }), state$1, objectInstanceArray);
	}


	/* Log-WonderLog Not a pure module */

	function getFloat32ArrayPoolMap(record) {
	  return record[/* float32ArrayPoolMap */0];
	}

	function getUint16ArrayPoolMap(record) {
	  return record[/* uint16ArrayPoolMap */1];
	}

	function _addTypeArrayToPool(count, typeArray, maxSize, map) {
	  var match = get$3(count, map);
	  if (match !== undefined) {
	    var arr = match;
	    var len = arr.length;
	    if (len >= maxSize) {
	      return map;
	    } else {
	      arr.push(typeArray);
	      return map;
	    }
	  } else {
	    return set$1(count, /* array */[typeArray], map);
	  }
	}

	function addFloat32TypeArrayToPool(typeArray, maxSize, map) {
	  return _addTypeArrayToPool(typeArray.length, typeArray, maxSize, map);
	}

	function _getTypeArrayFromPool(count, map) {
	  var match = get$3(count, map);
	  if (match !== undefined) {
	    var arr = match;
	    var match$1 = arr.length;
	    if (match$1 !== 0) {
	      return undefined_to_opt(arr.pop());
	    } else {
	      return undefined;
	    }
	  }
	  
	}

	function getFloat32TypeArrayFromPool(count, record) {
	  return _getTypeArrayFromPool(count, record[/* float32ArrayPoolMap */0]);
	}

	function _addAllTypeArrayToPool(typeArrayMap, maxSize, map, addTypeArrayToPoolFunc) {
	  forEachValid((function (typeArray) {
	          addTypeArrayToPoolFunc(typeArray, maxSize, map);
	          return /* () */0;
	        }), typeArrayMap);
	  return map;
	}

	function addAllFloat32TypeArrayToPool(typeArrayMap, maxSize, map) {
	  return _addAllTypeArrayToPool(typeArrayMap, maxSize, map, addFloat32TypeArrayToPool);
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function disposeMatrixFloat32ArrayMap(sourceInstance, maxBigTypeArrayPoolSize, matrixFloat32ArrayMap, typeArrayPoolRecord) {
	  var match = get$3(sourceInstance, matrixFloat32ArrayMap);
	  if (match !== undefined) {
	    addFloat32TypeArrayToPool(valFromOption(match), maxBigTypeArrayPoolSize, getFloat32ArrayPoolMap(typeArrayPoolRecord));
	  }
	  return disposeSparseMapData(sourceInstance, matrixFloat32ArrayMap);
	}

	var disposeMatrixInstanceBufferCapacityMap = disposeSparseMapData;

	var disposeIsSendTransformMatrixDataMap = disposeSparseMapData;


	/* TypeArrayPoolService-Wonderjs Not a pure module */

	function getObjectInstanceTransformArray$1(sourceInstance, state) {
	  var match = getRecord$7(state);
	  return getObjectInstanceTransformArray(sourceInstance, getObjectInstanceCountPerSourceInstance(state[/* settingRecord */1]), match[/* objectInstanceTransformIndexMap */1], match[/* objectInstanceTransformCollections */4]);
	}

	function getObjectInstanceArray(sourceInstance, state) {
	  var transformRecord = getRecord$1(state);
	  return getObjectInstanceTransformArray$1(sourceInstance, state).map((function (transform) {
	                return unsafeGetGameObject$6(transform, transformRecord);
	              }));
	}


	/* BufferSettingService-Wonderjs Not a pure module */

	function isAlive$14(sourceInstance, param) {
	  return isAlive$1(sourceInstance, param[/* disposedIndexArray */8]);
	}

	function _disposeObjectInstanceGameObject(objectInstanceGameObjectArr, isKeepOrder, batchDisposeGameObjectFunc, state) {
	  return ensureCheck((function (param) {
	                var sourceInstanceNeedDisposeVboBufferArr = param[3];
	                var customGeometryNeedDisposeVboBufferArr = param[2];
	                var boxGeometryNeedDisposeVboBufferArr = param[1];
	                test(buildAssertMessage("boxGeometryNeedDisposeVboBufferArr from object instance gameObject should be empty", "is " + (String(boxGeometryNeedDisposeVboBufferArr) + "")), (function () {
	                        return Operators[/* = */0](boxGeometryNeedDisposeVboBufferArr.length, 0);
	                      }));
	                test(buildAssertMessage("customGeometryNeedDisposeVboBufferArr from object instance gameObject should be empty", "is " + (String(customGeometryNeedDisposeVboBufferArr) + "")), (function () {
	                        return Operators[/* = */0](customGeometryNeedDisposeVboBufferArr.length, 0);
	                      }));
	                return test(buildAssertMessage("sourceInstanceNeedDisposeVboBufferArr from object instance gameObject should be empty", "is " + (String(sourceInstanceNeedDisposeVboBufferArr) + "")), (function () {
	                              return Operators[/* = */0](sourceInstanceNeedDisposeVboBufferArr.length, 0);
	                            }));
	              }), getIsDebug(stateData), _3(batchDisposeGameObjectFunc, objectInstanceGameObjectArr, isKeepOrder, state));
	}

	function _disposeData$10(sourceInstance, isKeepOrder, batchDisposeGameObjectFunc, state) {
	  var record = getRecord$7(state);
	  var objectInstanceGameObjectArr = getObjectInstanceArray(sourceInstance, state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* sourceInstanceRecord */7] = /* record */[
	    /* index */record[/* index */0],
	    /* objectInstanceTransformIndexMap */resetObjectInstanceTransformIndexMap(sourceInstance, record[/* objectInstanceTransformIndexMap */1]),
	    /* buffer */record[/* buffer */2],
	    /* isTransformStatics */deleteAndResetUint8(sourceInstance, getDefault(/* () */0), record[/* isTransformStatics */3]),
	    /* objectInstanceTransformCollections */record[/* objectInstanceTransformCollections */4],
	    /* matrixInstanceBufferCapacityMap */disposeMatrixInstanceBufferCapacityMap(sourceInstance, record[/* matrixInstanceBufferCapacityMap */5]),
	    /* matrixFloat32ArrayMap */disposeMatrixFloat32ArrayMap(sourceInstance, getMaxBigTypeArrayPoolSize(state[/* settingRecord */1]), record[/* matrixFloat32ArrayMap */6], state[/* typeArrayPoolRecord */37]),
	    /* isSendTransformMatrixDataMap */disposeIsSendTransformMatrixDataMap(sourceInstance, record[/* isSendTransformMatrixDataMap */7]),
	    /* disposedIndexArray */record[/* disposedIndexArray */8],
	    /* gameObjectMap */disposeSparseMapData(sourceInstance, record[/* gameObjectMap */9])
	  ];
	  return _disposeObjectInstanceGameObject(objectInstanceGameObjectArr, isKeepOrder, batchDisposeGameObjectFunc, newrecord)[0];
	}

	function handleBatchDisposeComponent$11(sourceInstanceArray, isKeepOrder, batchDisposeGameObjectFunc, state) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(sourceInstanceArray, isAlive$14, getRecord$7(state));
	        }), getIsDebug(stateData));
	  var sourceInstanceRecord = getRecord$7(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* sourceInstanceRecord */7] = /* record */[
	    /* index */sourceInstanceRecord[/* index */0],
	    /* objectInstanceTransformIndexMap */sourceInstanceRecord[/* objectInstanceTransformIndexMap */1],
	    /* buffer */sourceInstanceRecord[/* buffer */2],
	    /* isTransformStatics */sourceInstanceRecord[/* isTransformStatics */3],
	    /* objectInstanceTransformCollections */sourceInstanceRecord[/* objectInstanceTransformCollections */4],
	    /* matrixInstanceBufferCapacityMap */sourceInstanceRecord[/* matrixInstanceBufferCapacityMap */5],
	    /* matrixFloat32ArrayMap */sourceInstanceRecord[/* matrixFloat32ArrayMap */6],
	    /* isSendTransformMatrixDataMap */sourceInstanceRecord[/* isSendTransformMatrixDataMap */7],
	    /* disposedIndexArray */sourceInstanceRecord[/* disposedIndexArray */8].concat(sourceInstanceArray),
	    /* gameObjectMap */sourceInstanceRecord[/* gameObjectMap */9]
	  ];
	  return /* tuple */[
	          reduceOneParam((function (state, sourceInstance) {
	                  return _disposeData$10(sourceInstance, isKeepOrder, batchDisposeGameObjectFunc, state);
	                }), newrecord, sourceInstanceArray),
	          sourceInstanceArray.slice()
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function isAlive$15(cameraController, param) {
	  return isAlive$1(cameraController, param[/* disposedIndexArray */18]);
	}

	function _disposeData$11(cameraController, state) {
	  var state$1 = unbindEvent(cameraController, state);
	  var arcballCameraControllerRecord = state$1[/* arcballCameraControllerRecord */26];
	  var newrecord = caml_array_dup(state$1);
	  newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	    /* index */arcballCameraControllerRecord[/* index */0],
	    /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	    /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	    /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	    /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	    /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	    /* dirtyArray */removeFromArray(cameraController, arcballCameraControllerRecord[/* dirtyArray */6]),
	    /* distanceMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* distanceMap */7]),
	    /* minDistanceMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* minDistanceMap */8]),
	    /* phiMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* phiMap */9]),
	    /* thetaMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* thetaMap */10]),
	    /* thetaMarginMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* thetaMarginMap */11]),
	    /* targetMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* targetMap */12]),
	    /* moveSpeedXMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* moveSpeedXMap */13]),
	    /* moveSpeedYMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* moveSpeedYMap */14]),
	    /* rotateSpeedMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* rotateSpeedMap */15]),
	    /* wheelSpeedMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* wheelSpeedMap */16]),
	    /* gameObjectMap */disposeSparseMapData(cameraController, arcballCameraControllerRecord[/* gameObjectMap */17]),
	    /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	  ];
	  return newrecord;
	}

	function handleBatchDisposeComponent$12(cameraControllerArray, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(cameraControllerArray, isAlive$15, arcballCameraControllerRecord);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	    /* index */arcballCameraControllerRecord[/* index */0],
	    /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	    /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	    /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	    /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	    /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	    /* dirtyArray */arcballCameraControllerRecord[/* dirtyArray */6],
	    /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	    /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	    /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	    /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	    /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	    /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	    /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	    /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	    /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	    /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	    /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	    /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18].concat(cameraControllerArray)
	  ];
	  return reduceOneParam((function (state, cameraController) {
	                return _disposeData$11(cameraController, state);
	              }), newrecord, cameraControllerArray);
	}


	/* Contract-WonderLog Not a pure module */

	function isAlive$16(cameraProjection, param) {
	  return isAlive$1(cameraProjection, param[/* disposedIndexArray */8]);
	}

	function _disposeData$12(cameraProjection, record) {
	  return /* record */[
	          /* index */record[/* index */0],
	          /* dirtyArray */removeFromArray(cameraProjection, record[/* dirtyArray */1]),
	          /* pMatrixMap */disposeSparseMapData(cameraProjection, record[/* pMatrixMap */2]),
	          /* nearMap */disposeSparseMapData(cameraProjection, record[/* nearMap */3]),
	          /* farMap */disposeSparseMapData(cameraProjection, record[/* farMap */4]),
	          /* fovyMap */disposeSparseMapData(cameraProjection, record[/* fovyMap */5]),
	          /* aspectMap */disposeSparseMapData(cameraProjection, record[/* aspectMap */6]),
	          /* gameObjectMap */disposeSparseMapData(cameraProjection, record[/* gameObjectMap */7]),
	          /* disposedIndexArray */record[/* disposedIndexArray */8]
	        ];
	}

	function handleBatchDisposeComponent$13(cameraProjectionArray, record) {
	  requireCheck((function () {
	          return checkComponentShouldAliveWithBatchDispose(cameraProjectionArray, isAlive$16, record);
	        }), getIsDebug(stateData));
	  return reduceOneParam((function (record, cameraProjection) {
	                return _disposeData$12(cameraProjection, record);
	              }), /* record */[
	              /* index */record[/* index */0],
	              /* dirtyArray */record[/* dirtyArray */1],
	              /* pMatrixMap */record[/* pMatrixMap */2],
	              /* nearMap */record[/* nearMap */3],
	              /* farMap */record[/* farMap */4],
	              /* fovyMap */record[/* fovyMap */5],
	              /* aspectMap */record[/* aspectMap */6],
	              /* gameObjectMap */record[/* gameObjectMap */7],
	              /* disposedIndexArray */record[/* disposedIndexArray */8].concat(cameraProjectionArray)
	            ], cameraProjectionArray);
	}


	/* Contract-WonderLog Not a pure module */

	function deferDisposeBasicCameraViewComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedBasicCameraViewArray */6] = push(component, state[/* gameObjectRecord */11][/* disposedBasicCameraViewArray */6]);
	  newrecord$1[/* basicCameraViewMap */23] = removeComponent(uid, gameObjectRecord[/* basicCameraViewMap */23]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposePerspectiveCameraProjectionComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedPerspectiveCameraProjectionArray */9] = push(component, gameObjectRecord[/* disposedPerspectiveCameraProjectionArray */9]);
	  newrecord$1[/* perspectiveCameraProjectionMap */24] = removeComponent(uid, gameObjectRecord[/* perspectiveCameraProjectionMap */24]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeArcballCameraControllerComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedArcballCameraControllerArray */10] = push(component, gameObjectRecord[/* disposedArcballCameraControllerArray */10]);
	  newrecord$1[/* arcballCameraControllerMap */25] = removeComponent(uid, gameObjectRecord[/* arcballCameraControllerMap */25]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeTransformComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedTransformArray */7] = push(component, gameObjectRecord[/* disposedTransformArray */7]);
	  newrecord$1[/* transformMap */22] = removeComponent(uid, gameObjectRecord[/* transformMap */22]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeTransformComponentForKeepOrder(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedTransformArrayForKeepOrder */8] = push(component, gameObjectRecord[/* disposedTransformArrayForKeepOrder */8]);
	  newrecord$1[/* transformMap */22] = removeComponent(uid, gameObjectRecord[/* transformMap */22]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeBasicMaterialComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedBasicMaterialArray */11] = push(component, gameObjectRecord[/* disposedBasicMaterialArray */11]);
	  newrecord$1[/* basicMaterialMap */27] = removeComponent(uid, gameObjectRecord[/* basicMaterialMap */27]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeLightMaterialComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedLightMaterialArray */12] = push(component, gameObjectRecord[/* disposedLightMaterialArray */12]);
	  newrecord$1[/* lightMaterialMap */28] = removeComponent(uid, gameObjectRecord[/* lightMaterialMap */28]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeBoxGeometryComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedBoxGeometryArray */13] = push(component, gameObjectRecord[/* disposedBoxGeometryArray */13]);
	  newrecord$1[/* geometryDataMap */21] = removeComponent(uid, gameObjectRecord[/* geometryDataMap */21]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeCustomGeometryComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedCustomGeometryArray */14] = push(component, gameObjectRecord[/* disposedCustomGeometryArray */14]);
	  newrecord$1[/* geometryDataMap */21] = removeComponent(uid, gameObjectRecord[/* geometryDataMap */21]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeSourceInstanceComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedSourceInstanceArray */15] = push(component, gameObjectRecord[/* disposedSourceInstanceArray */15]);
	  newrecord$1[/* sourceInstanceMap */29] = removeComponent(uid, gameObjectRecord[/* sourceInstanceMap */29]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeObjectInstanceComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedObjectInstanceArray */16] = push(component, gameObjectRecord[/* disposedObjectInstanceArray */16]);
	  newrecord$1[/* objectInstanceMap */30] = removeComponent(uid, gameObjectRecord[/* objectInstanceMap */30]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeDirectionLightComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedDirectionLightArray */17] = push(component, gameObjectRecord[/* disposedDirectionLightArray */17]);
	  newrecord$1[/* directionLightMap */31] = removeComponent(uid, gameObjectRecord[/* directionLightMap */31]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposePointLightComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedPointLightArray */18] = push(component, gameObjectRecord[/* disposedPointLightArray */18]);
	  newrecord$1[/* pointLightMap */32] = removeComponent(uid, gameObjectRecord[/* pointLightMap */32]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function deferDisposeMeshRendererComponent(uid, component, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedMeshRendererComponentArray */19] = push(component, gameObjectRecord[/* disposedMeshRendererComponentArray */19]);
	  newrecord$1[/* meshRendererMap */26] = removeComponent(uid, gameObjectRecord[/* meshRendererMap */26]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function batchDisposeBasicCameraViewComponent(state, componentArray) {
	  var basicCameraViewRecord = state[/* basicCameraViewRecord */14];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicCameraViewRecord */14] = batchDisposeComponent(basicCameraViewRecord, handleBatchDisposeComponent, componentArray);
	  return newrecord;
	}

	function batchDisposePerspectiveCameraProjectionComponent(state, componentArray) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = batchDisposeComponent(perspectiveCameraProjectionRecord, handleBatchDisposeComponent$13, componentArray);
	  return newrecord;
	}

	function batchDisposeArcballCameraControllerComponent(state, componentArray) {
	  return handleBatchDisposeComponent$12(componentArray, state);
	}

	function batchDisposeMeshRendererComponent(state, componentArray) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* meshRendererRecord */25] = handleBatchDisposeComponent$4(componentArray, getRecord$2(state));
	  return newrecord;
	}

	function batchDisposeTransformComponent(state, isKeepOrder, componentArray) {
	  return handleBatchDisposeComponent$1(componentArray, getMaxTypeArrayPoolSize(state[/* settingRecord */1]), isKeepOrder, state);
	}

	function batchDisposeBoxGeometryComponent(state, componentArray) {
	  return handleBatchDisposeComponent$6(componentArray, state);
	}

	function batchDisposeCustomGeometryComponent(state, componentArray) {
	  return handleBatchDisposeComponent$9(componentArray, state);
	}

	function batchDisposeBasicMaterialComponent(state, componentArray) {
	  return handleBatchDisposeComponent$7(componentArray, state);
	}

	function batchDisposeBasicMaterialComponentForWorker(state, componentArray) {
	  var state$1 = handleBatchDisposeComponent$7(componentArray, state);
	  var record = getRecord$4(state$1);
	  var materialArrayForWorkerInit = record[/* materialArrayForWorkerInit */12];
	  var newrecord = caml_array_dup(state$1);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */record[/* shaderIndices */2],
	    /* colors */record[/* colors */3],
	    /* textureIndices */record[/* textureIndices */4],
	    /* mapUnits */record[/* mapUnits */5],
	    /* textureCountMap */record[/* textureCountMap */6],
	    /* defaultColor */record[/* defaultColor */7],
	    /* gameObjectMap */record[/* gameObjectMap */8],
	    /* groupCountMap */record[/* groupCountMap */9],
	    /* disposedIndexArray */record[/* disposedIndexArray */10],
	    /* nameMap */record[/* nameMap */11],
	    /* materialArrayForWorkerInit */removeDisposedOnesFromMaterialArrayForWorkerInit(componentArray, materialArrayForWorkerInit)
	  ];
	  return newrecord;
	}

	function batchDisposeLightMaterialComponentForWorker(state, componentArray) {
	  var state$1 = handleBatchDisposeComponent$8(componentArray, state);
	  var record = getRecord$5(state$1);
	  var materialArrayForWorkerInit = record[/* materialArrayForWorkerInit */17];
	  var newrecord = caml_array_dup(state$1);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */record[/* shaderIndices */2],
	    /* diffuseColors */record[/* diffuseColors */3],
	    /* specularColors */record[/* specularColors */4],
	    /* shininess */record[/* shininess */5],
	    /* textureIndices */record[/* textureIndices */6],
	    /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	    /* specularMapUnits */record[/* specularMapUnits */8],
	    /* textureCountMap */record[/* textureCountMap */9],
	    /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	    /* defaultShininess */record[/* defaultShininess */12],
	    /* gameObjectMap */record[/* gameObjectMap */13],
	    /* groupCountMap */record[/* groupCountMap */14],
	    /* disposedIndexArray */record[/* disposedIndexArray */15],
	    /* nameMap */record[/* nameMap */16],
	    /* materialArrayForWorkerInit */removeDisposedOnesFromMaterialArrayForWorkerInit(componentArray, materialArrayForWorkerInit)
	  ];
	  return newrecord;
	}

	function batchDisposeDirectionLightComponent(state, componentArray) {
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* directionLightRecord */21] = batchDisposeComponent(directionLightRecord, handleBatchDisposeComponent$5, componentArray);
	  return newrecord;
	}

	function batchDisposePointLightComponent(state, componentArray) {
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = batchDisposeComponent(pointLightRecord, handleBatchDisposeComponent$2, componentArray);
	  return newrecord;
	}

	function batchDisposeSourceInstanceComponent(state, isKeepOrder, disposeGameObjectFunc, componentArray) {
	  return handleBatchDisposeComponent$11(componentArray, isKeepOrder, disposeGameObjectFunc, state);
	}

	function batchDisposeObjectInstanceComponent(state, componentArray) {
	  var match = componentArray.length;
	  if (match !== 0) {
	    return handleBatchDisposeComponent$10(componentArray, state);
	  } else {
	    return state;
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function batchGetBasicCameraViewComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* basicCameraViewMap */23]);
	}

	function batchGetPerspectiveCameraProjectionComponent(uidArray, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* perspectiveCameraProjectionMap */24]);
	}

	function batchGetArcballCameraControllerComponent(uidArray, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* arcballCameraControllerMap */25]);
	}

	function batchGetTransformComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* transformMap */22]);
	}

	function batchGetGeometryComponentData(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  var geometryDataMap = gameObjectRecord[/* geometryDataMap */21];
	  var boxGeometryType = getBoxGeometryType(/* () */0);
	  var customGeometryType = getCustomGeometryType(/* () */0);
	  return reduceOneParam((function (arrTuple, uid) {
	                var match = getComponentData(uid, geometryDataMap);
	                if (match !== undefined) {
	                  var match$1 = match;
	                  var type_ = match$1[1];
	                  var component = match$1[0];
	                  if (type_ === boxGeometryType) {
	                    push(component, arrTuple[0]);
	                  } else if (type_ === customGeometryType) {
	                    push(component, arrTuple[1]);
	                  } else {
	                    fatal(buildFatalMessage("unknown type_", "", "", "", "type_: " + (String(type_) + "")));
	                  }
	                  return arrTuple;
	                } else {
	                  return arrTuple;
	                }
	              }), /* tuple */[
	              /* array */[],
	              /* array */[]
	            ], uidArray);
	}

	function batchGetBasicMaterialComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* basicMaterialMap */27]);
	}

	function batchGetLightMaterialComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* lightMaterialMap */28]);
	}

	function batchGetMeshRendererComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* meshRendererMap */26]);
	}

	function batchGetDirectionLightComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* directionLightMap */31]);
	}

	function batchGetPointLightComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* pointLightMap */32]);
	}

	function batchGetSourceInstanceComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* sourceInstanceMap */29]);
	}

	function batchGetObjectInstanceComponent(uidArray, param) {
	  var gameObjectRecord = param[/* gameObjectRecord */11];
	  return batchGetComponent(uidArray, gameObjectRecord[/* objectInstanceMap */30]);
	}


	/* Log-WonderLog Not a pure module */

	function _batchDisposeGeometryComponent(uidArray, state) {
	  var match = batchGetGeometryComponentData(uidArray, state);
	  var match$1 = batchDisposeBoxGeometryComponent(state, match[0]);
	  var match$2 = batchDisposeCustomGeometryComponent(match$1[0], match[1]);
	  return /* tuple */[
	          match$2[0],
	          match$1[1],
	          match$2[1]
	        ];
	}

	function batchDispose$1(param, param$1, state) {
	  var batchDisposeLightMaterialComponentFunc = param$1[1];
	  var batchDisposeBasicMaterialComponentFunc = param$1[0];
	  var isKeepOrder = param[1];
	  var uidArray = param[0];
	  var state$1 = batchDisposeTransformComponent(state, isKeepOrder, batchGetTransformComponent(uidArray, state));
	  var match = _batchDisposeGeometryComponent(uidArray, state$1);
	  var state$2 = match[0];
	  var state$3 = batchDisposeBasicCameraViewComponent(state$2, batchGetBasicCameraViewComponent(uidArray, state$2));
	  var state$4 = batchDisposePerspectiveCameraProjectionComponent(state$3, batchGetPerspectiveCameraProjectionComponent(uidArray, state$3));
	  var state$5 = batchDisposeArcballCameraControllerComponent(state$4, batchGetArcballCameraControllerComponent(uidArray, state$4));
	  var state$6 = batchDisposeMeshRendererComponent(state$5, batchGetMeshRendererComponent(uidArray, state$5));
	  var state$7 = _2(batchDisposeBasicMaterialComponentFunc, state$6, batchGetBasicMaterialComponent(uidArray, state$6));
	  var state$8 = _2(batchDisposeLightMaterialComponentFunc, state$7, batchGetLightMaterialComponent(uidArray, state$7));
	  var state$9 = batchDisposeDirectionLightComponent(state$8, batchGetDirectionLightComponent(uidArray, state$8));
	  var state$10 = batchDisposePointLightComponent(state$9, batchGetPointLightComponent(uidArray, state$9));
	  var match$1 = batchDisposeSourceInstanceComponent(state$10, isKeepOrder, _1(param$1[2], /* tuple */[
	            batchDisposeBasicMaterialComponentFunc,
	            batchDisposeLightMaterialComponentFunc
	          ]), batchGetSourceInstanceComponent(uidArray, state$10));
	  var state$11 = match$1[0];
	  var state$12 = batchDisposeObjectInstanceComponent(state$11, batchGetObjectInstanceComponent(uidArray, state$11));
	  return /* tuple */[
	          state$12,
	          match[1],
	          match[2],
	          match$1[1]
	        ];
	}


	/* DisposeComponentGameObjectMainService-Wonderjs Not a pure module */

	function _disposeNameMap(uidArray, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  gameObjectRecord[/* nameMap */1] = reduceOneParam((function (nameMap, uid) {
	          return disposeSparseMapData(uid, nameMap);
	        }), gameObjectRecord[/* nameMap */1], uidArray);
	  state[/* gameObjectRecord */11] = gameObjectRecord;
	  return state;
	}

	function _setDisposedUidMap(uidArray, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* disposedUidMap */3] = buildMapFromArray(uidArray, gameObjectRecord[/* disposedUidMap */3]);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return newrecord;
	}

	function batchDispose(param, uidArray, isKeepOrder, state) {
	  var state$1 = _setDisposedUidMap(uidArray, _disposeNameMap(uidArray, state));
	  var record = state$1[/* gameObjectRecord */11];
	  var disposeCount = record[/* disposeCount */2];
	  record[/* disposeCount */2] = disposeCount + uidArray.length | 0;
	  var match = batchDispose$1(/* tuple */[
	        uidArray,
	        isKeepOrder
	      ], /* tuple */[
	        param[0],
	        param[1],
	        batchDispose
	      ], state$1);
	  return /* tuple */[
	          match[0],
	          match[1],
	          match[2],
	          match[3]
	        ];
	}

	function deferBatchDispose(uidArray, state) {
	  state[/* gameObjectRecord */11][/* disposedUidArray */4] = state[/* gameObjectRecord */11][/* disposedUidArray */4].concat(uidArray);
	  return state;
	}

	function deferBatchDisposeKeepOrder(uidArray, state) {
	  state[/* gameObjectRecord */11][/* disposedUidArrayForKeepOrder */5] = state[/* gameObjectRecord */11][/* disposedUidArrayForKeepOrder */5].concat(uidArray);
	  return state;
	}

	function clearDeferDisposeData(state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* gameObjectRecord */11];
	  newrecord[/* gameObjectRecord */11] = /* record */[
	    /* uid */init[/* uid */0],
	    /* nameMap */init[/* nameMap */1],
	    /* disposeCount */init[/* disposeCount */2],
	    /* disposedUidMap */init[/* disposedUidMap */3],
	    /* disposedUidArray */createEmpty$1(/* () */0),
	    /* disposedUidArrayForKeepOrder */createEmpty$1(/* () */0),
	    /* disposedBasicCameraViewArray */createEmpty$1(/* () */0),
	    /* disposedTransformArray */createEmpty$1(/* () */0),
	    /* disposedTransformArrayForKeepOrder */createEmpty$1(/* () */0),
	    /* disposedPerspectiveCameraProjectionArray */createEmpty$1(/* () */0),
	    /* disposedArcballCameraControllerArray */init[/* disposedArcballCameraControllerArray */10],
	    /* disposedBasicMaterialArray */createEmpty$1(/* () */0),
	    /* disposedLightMaterialArray */createEmpty$1(/* () */0),
	    /* disposedBoxGeometryArray */createEmpty$1(/* () */0),
	    /* disposedCustomGeometryArray */createEmpty$1(/* () */0),
	    /* disposedSourceInstanceArray */createEmpty$1(/* () */0),
	    /* disposedObjectInstanceArray */createEmpty$1(/* () */0),
	    /* disposedDirectionLightArray */createEmpty$1(/* () */0),
	    /* disposedPointLightArray */createEmpty$1(/* () */0),
	    /* disposedMeshRendererComponentArray */createEmpty$1(/* () */0),
	    /* aliveUidArray */init[/* aliveUidArray */20],
	    /* geometryDataMap */init[/* geometryDataMap */21],
	    /* transformMap */init[/* transformMap */22],
	    /* basicCameraViewMap */init[/* basicCameraViewMap */23],
	    /* perspectiveCameraProjectionMap */init[/* perspectiveCameraProjectionMap */24],
	    /* arcballCameraControllerMap */init[/* arcballCameraControllerMap */25],
	    /* meshRendererMap */init[/* meshRendererMap */26],
	    /* basicMaterialMap */init[/* basicMaterialMap */27],
	    /* lightMaterialMap */init[/* lightMaterialMap */28],
	    /* sourceInstanceMap */init[/* sourceInstanceMap */29],
	    /* objectInstanceMap */init[/* objectInstanceMap */30],
	    /* directionLightMap */init[/* directionLightMap */31],
	    /* pointLightMap */init[/* pointLightMap */32]
	  ];
	  return newrecord;
	}

	function deferDispose(uid, state) {
	  return deferBatchDispose(/* array */[uid], state);
	}

	function deferDisposeKeepOrder(uid, state) {
	  return deferBatchDisposeKeepOrder(/* array */[uid], state);
	}


	/* DisposeECSService-Wonderjs Not a pure module */

	var createGameObject$1 = create$4;

	function _checkGameObjectShouldAlive(gameObject, state) {
	  return test(buildAssertMessage("gameObject alive", "not"), (function () {
	                return assertTrue(isAlive$4(gameObject, state));
	              }));
	}

	function addGameObjectBasicCameraViewComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addBasicCameraViewComponent(gameObject, component, state);
	}

	function disposeGameObjectBasicCameraViewComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeBasicCameraViewComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectBasicCameraViewComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetBasicCameraViewComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectBasicCameraViewComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasBasicCameraViewComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectPerspectiveCameraProjectionComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addPerspectiveCameraProjectionComponent(gameObject, component, state);
	}

	function disposeGameObjectPerspectiveCameraProjectionComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposePerspectiveCameraProjectionComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectPerspectiveCameraProjectionComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetPerspectiveCameraProjectionComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectPerspectiveCameraProjectionComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasPerspectiveCameraProjectionComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectArcballCameraControllerComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addArcballCameraControllerComponent(gameObject, component, state);
	}

	function disposeGameObjectArcballCameraControllerComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeArcballCameraControllerComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectArcballCameraControllerComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetArcballCameraControllerComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectArcballCameraControllerComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasArcballCameraControllerComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectTransformComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addTransformComponent(gameObject, component, state);
	}

	function disposeGameObjectTransformComponent$1(gameObject, component, isKeepOrder, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  if (isKeepOrder) {
	    return deferDisposeTransformComponentForKeepOrder(gameObject, component, state);
	  } else {
	    return deferDisposeTransformComponent(gameObject, component, state);
	  }
	}

	function unsafeGetGameObjectTransformComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetTransformComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectTransformComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasTransformComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectBoxGeometryComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addBoxGeometryComponent(gameObject, component, state);
	}

	function disposeGameObjectBoxGeometryComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeBoxGeometryComponent(gameObject, component, state);
	}

	function hasGameObjectBoxGeometryComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasBoxGeometryComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectCustomGeometryComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addCustomGeometryComponent(gameObject, component, state);
	}

	function disposeGameObjectCustomGeometryComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeCustomGeometryComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectGeometryComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetGeometryComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectGeometryComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasGeometryComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectBasicMaterialComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addBasicMaterialComponent(gameObject, component, state);
	}

	function disposeGameObjectBasicMaterialComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeBasicMaterialComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectBasicMaterialComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetBasicMaterialComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectBasicMaterialComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasBasicMaterialComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectLightMaterialComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addLightMaterialComponent(gameObject, component, state);
	}

	function disposeGameObjectLightMaterialComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeLightMaterialComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectLightMaterialComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetLightMaterialComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectLightMaterialComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasLightMaterialComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectMeshRendererComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addMeshRendererComponent(gameObject, component, state);
	}

	function disposeGameObjectMeshRendererComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeMeshRendererComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectMeshRendererComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetMeshRendererComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectMeshRendererComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasMeshRendererComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectDirectionLightComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addDirectionLightComponent(gameObject, component, state);
	}

	function disposeGameObjectDirectionLightComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeDirectionLightComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectDirectionLightComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetDirectionLightComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectDirectionLightComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasDirectionLightComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectPointLightComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addPointLightComponent(gameObject, component, state);
	}

	function disposeGameObjectPointLightComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposePointLightComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectPointLightComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetPointLightComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectPointLightComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasPointLightComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function addGameObjectSourceInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addSourceInstanceComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectSourceInstanceComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetSourceInstanceComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function hasGameObjectSourceInstanceComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return hasSourceInstanceComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function disposeGameObjectSourceInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeSourceInstanceComponent(gameObject, component, state);
	}

	function addGameObjectObjectInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return addObjectInstanceComponent(gameObject, component, state);
	}

	function unsafeGetGameObjectObjectInstanceComponent$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetObjectInstanceComponent(gameObject, state[/* gameObjectRecord */11]);
	}

	function disposeGameObjectObjectInstanceComponent$1(gameObject, component, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeObjectInstanceComponent(gameObject, component, state);
	}

	var isGameObjectAlive$1 = isAlive$4;

	function disposeGameObject$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDispose(gameObject, state);
	}

	function disposeGameObjectKeepOrder$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return deferDisposeKeepOrder(gameObject, state);
	}

	function initGameObject$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return initGameObject$2(gameObject, state);
	}

	function batchDisposeGameObject$1(gameObjectArray, state) {
	  requireCheck((function () {
	          return forEach((function (gameObject) {
	                        return _checkGameObjectShouldAlive(gameObject, state);
	                      }), gameObjectArray);
	        }), getIsDebug(stateData));
	  return deferBatchDispose(gameObjectArray, state);
	}

	function batchDisposeGameObjectKeepOrder$1(gameObjectArray, state) {
	  requireCheck((function () {
	          return forEach((function (gameObject) {
	                        return _checkGameObjectShouldAlive(gameObject, state);
	                      }), gameObjectArray);
	        }), getIsDebug(stateData));
	  return deferBatchDisposeKeepOrder(gameObjectArray, state);
	}

	var cloneGameObject$1 = clone;

	function getGameObjectName$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return getName(gameObject, state);
	}

	function unsafeGetGameObjectName$1(gameObject, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return unsafeGetName(gameObject, state);
	}

	function setGameObjectName$1(gameObject, name, state) {
	  requireCheck((function () {
	          return _checkGameObjectShouldAlive(gameObject, state);
	        }), getIsDebug(stateData));
	  return setName(gameObject, name, state);
	}


	/* Log-WonderLog Not a pure module */

	function createLightMaterial$1(state) {
	  return create$31(state);
	}

	function unsafeGetLightMaterialGameObject$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$4(material, getRecord$5(state));
	}

	function getLightMaterialDiffuseColor$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return getDiffuseColor$2(material, state);
	}

	function setLightMaterialDiffuseColor$1(material, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return setDiffuseColor$1(material, color, state);
	}

	function getLightMaterialSpecularColor$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return getSpecularColor$2(material, state);
	}

	function setLightMaterialSpecularColor$1(material, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return setSpecularColor$1(material, color, state);
	}

	function getLightMaterialShininess$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return getShininess$2(material, state);
	}

	function setLightMaterialShininess$1(material, shininess, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return setShininess$1(material, shininess, state);
	}

	function unsafeGetLightMaterialDiffuseMap$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return unsafeGetDiffuseMap(material, state);
	}

	function setLightMaterialDiffuseMap$1(material, texture, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return setDiffuseMap(material, texture, state);
	}

	function hasLightMaterialDiffuseMap$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return hasDiffuseMap(material, state);
	}

	function unsafeGetLightMaterialSpecularMap$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return unsafeGetSpecularMap(material, state);
	}

	function setLightMaterialSpecularMap$1(material, texture, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return setSpecularMap(material, texture, state);
	}

	function hasLightMaterialSpecularMap$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return hasSpecularMap(material, state);
	}

	function unsafeGetLightMaterialName$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return unsafeGetName$3(material, state);
	}

	function setLightMaterialName$1(material, name, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	        }), getIsDebug(stateData));
	  return setName$3(material, name, state);
	}

	function reInitMaterials$1(materials, state) {
	  requireCheck((function () {
	          return forEach((function (material) {
	                        return checkComponentShouldAlive$1(material, isAlive$11, getRecord$5(state));
	                      }), materials);
	        }), getIsDebug(stateData));
	  return reInitComponents(materials, state);
	}


	/* Contract-WonderLog Not a pure module */

	function getRenderWorkerCustomData$1(state) {
	  return state[/* workerDataRecord */39][/* renderWorkerData */1][/* customDataFromRenderWorkerToMainWorker */0];
	}

	function setRenderWorkerCustomData(customData, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* workerDataRecord */39];
	  newrecord[/* workerDataRecord */39] = /* record */[
	    /* mainWorkerData */init[/* mainWorkerData */0],
	    /* renderWorkerData : record */[/* customDataFromRenderWorkerToMainWorker */customData]
	  ];
	  return newrecord;
	}

	function getMainWorkerCustomData$1(state) {
	  return state[/* workerDataRecord */39][/* mainWorkerData */0][/* customDataFromMainWorkerToRenderWorker */0];
	}

	function setMainWorkerCustomData$1(customData, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* workerDataRecord */39];
	  newrecord[/* workerDataRecord */39] = /* record */[
	    /* mainWorkerData : record */[/* customDataFromMainWorkerToRenderWorker */customData],
	    /* renderWorkerData */init[/* renderWorkerData */1]
	  ];
	  return newrecord;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function range$2(a, b) {
	  var result = createEmpty$1(/* () */0);
	  for(var i = a; i <= b; ++i){
	    result.push(i);
	  }
	  return result;
	}

	function push$1(item, arr) {
	  arr.push(item);
	  return arr;
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function beginGroup$2(position, record) {
	  var groupData = record[/* layoutData */8][/* groupData */0];
	  groupData[/* positionArr */0][groupData[/* index */1]] = position;
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData : record */[/* groupData : record */[
	              /* positionArr */groupData[/* positionArr */0],
	              /* index */groupData[/* index */1] + 1 | 0
	            ]]
	        ];
	}

	function endGroup$2(record) {
	  var groupData = record[/* layoutData */8][/* groupData */0];
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData : record */[/* groupData : record */[
	              /* positionArr */groupData[/* positionArr */0],
	              /* index */groupData[/* index */1] - 1 | 0
	            ]]
	        ];
	}

	function _getGroupPosition(record) {
	  var groupData = record[/* layoutData */8][/* groupData */0];
	  var match = groupData[/* index */1] <= 0;
	  if (match) {
	    return undefined;
	  } else {
	    var match$1 = reduceOneParam((function (param, index) {
	            var match = param[1];
	            var positionArr = param[0];
	            var match$1 = positionArr[index];
	            return /* tuple */[
	                    positionArr,
	                    /* tuple */[
	                      match[0] + match$1[0] | 0,
	                      match[1] + match$1[1] | 0
	                    ]
	                  ];
	          }), /* tuple */[
	          groupData[/* positionArr */0],
	          /* tuple */[
	            0,
	            0
	          ]
	        ], range$2(0, groupData[/* index */1] - 1 | 0));
	    return match$1[1];
	  }
	}

	function computeRectBasedOnTopLeftOfView(rect, record) {
	  var match = _getGroupPosition(record);
	  if (match !== undefined) {
	    var match$1 = match;
	    return /* tuple */[
	            rect[0] + match$1[0] | 0,
	            rect[1] + match$1[1] | 0,
	            rect[2],
	            rect[3]
	          ];
	  } else {
	    return rect;
	  }
	}


	/* ArrayService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	var beginGroup$1 = beginGroup$2;

	var endGroup$1 = endGroup$2;


	/* GroupLayoutIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	var vs = "\nprecision mediump float;\n\nattribute vec2 a_position;\nattribute vec3 a_color;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_projectionMat;\n\nvarying vec3 v_color;\nvarying vec2 v_texCoord;\n\nvoid main() {\n  gl_Position = u_projectionMat * vec4(a_position, 0, 1);\n  v_color = a_color;\n  v_texCoord = a_texCoord;\n}\n    ";

	var fs = "\nprecision mediump float;\n\nvarying vec3 v_color;\nvarying vec2 v_texCoord;\n\nuniform sampler2D u_sampler2D;\n\nvoid main() {\n  vec4 sample = texture2D(u_sampler2D, v_texCoord);\n\n  //gl_FragColor = vec4(v_color.xyz * sample.xyz, sample.x * vColor.a );\n  gl_FragColor = vec4(v_color * sample.xyz, sample.w);\n}\n    ";


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function unsafeGet$3(optionData) {
	  requireCheck((function () {
	          return test(buildAssertMessage("data exist(get by getExn)", "not"), (function () {
	                        return assertExist(optionData);
	                      }));
	        }), true);
	  return getExn(optionData);
	}


	/* Log-WonderLog Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _compileShader$1(gl, glslSource, shader) {
	  gl.shaderSource(shader, glslSource);
	  gl.compileShader(shader);
	  debugWithFunc((function () {
	          var match = gl.getShaderParameter(shader, gl.COMPILE_STATUS) === false;
	          if (match) {
	            var message = gl.getShaderInfoLog(shader);
	            var partial_arg = "" + (String(message) + "");
	            debug((function (param) {
	                    return buildDebugMessage("shader info log", partial_arg, param);
	                  }), true);
	            var partial_arg$1 = "" + (String(glslSource) + "");
	            return debug((function (param) {
	                          return buildDebugMessage("glsl source", partial_arg$1, param);
	                        }), true);
	          } else {
	            return /* () */0;
	          }
	        }), true);
	  return shader;
	}

	function _linkProgram$1(program, gl) {
	  gl.linkProgram(program);
	  debugWithFunc((function () {
	          var match = gl.getProgramParameter(program, gl.LINK_STATUS) === false;
	          if (match) {
	            var message = gl.getProgramInfoLog(program);
	            return fatal(buildFatalMessage("link program error", "" + (String(message) + ""), "", "", ""));
	          } else {
	            return /* () */0;
	          }
	        }), true);
	  return /* () */0;
	}

	function initShader$1(vsSource, fsSource, gl, program) {
	  var vs = _compileShader$1(gl, vsSource, gl.createShader(gl.VERTEX_SHADER));
	  var fs = _compileShader$1(gl, fsSource, gl.createShader(gl.FRAGMENT_SHADER));
	  gl.attachShader(program, vs);
	  gl.attachShader(program, fs);
	  gl.bindAttribLocation(program, 0, "a_position");
	  _linkProgram$1(program, gl);
	  gl.deleteShader(vs);
	  gl.deleteShader(fs);
	  return program;
	}


	/* Log-WonderLog Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	var createObjectURL = function (blob){
	     return URL.createObjectURL( blob )
	    };

	var revokeObjectURL = function (blob){
	     URL.revokeObjectURL( blob );
	    };


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function createFetchBlobStream(filePath, fetchFunc) {
	  return fromPromise(_1(fetchFunc, filePath).then((function (prim) {
	                    return prim.blob();
	                  })));
	}

	function createFetchTextStream(filePath, fetchFunc) {
	  return fromPromise(_1(fetchFunc, filePath).then((function (prim) {
	                    return prim.text();
	                  })));
	}

	function fetch$1(filePath) {
	  return fetch(filePath);
	}


	/* most Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function extname(path) {
	  var match = (/\.(\w+)$/).exec(path);
	  if (match !== null) {
	    return nullable_to_opt(caml_array_get(match, 0));
	  }
	  
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function getType$2(src) {
	  var match = extname(src);
	  if (match !== undefined) {
	    switch (match) {
	      case ".jpg" : 
	          return /* Jpg */0;
	      case ".png" : 
	          return /* Png */1;
	      default:
	        return /* Unknown */2;
	    }
	  } else {
	    return fatal(buildFatalMessage("getType", "image extname should exist", "", "", ""));
	  }
	}

	var _loadBlobImage = function (objectUrl,resolve,reject){
	          if (typeof window.loadImageBlob_wonder_imgui === "undefined") {
	  window.loadImageBlob_wonder_imgui = function(objectUrl, resolve, reject){
	                      var image = new Image();

	                      image.src = objectUrl;

	                      image.onload = (function () {
	                          return resolve(image);
	                        });

	                      image.onerror = (function (e) {
	                        console.trace();
	                                return reject(new Error(e));
	                              });
	  };
	          }

	  window.loadImageBlob_wonder_imgui(objectUrl, resolve, reject);
	    };

	function loadImageByBlobPromise(objectUrl) {
	  return fromPromise(new Promise((function (resolve, reject) {
	                    return _loadBlobImage(objectUrl, resolve, reject);
	                  })));
	}


	/* most Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function unsafeGetFontData(record) {
	  return unsafeGet$3(record[/* fontData */2]);
	}

	function unsafeGetWebglData(record) {
	  return unsafeGet$3(record[/* webglData */3]);
	}

	function getSetting$4(record) {
	  return record[/* setting */0];
	}

	function setSetting$3(setting, record) {
	  return /* record */[
	          /* setting */setting,
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}

	function getIOData(record) {
	  return record[/* ioData */7];
	}

	function getRadioButtonData(record) {
	  return record[/* controlData */6][/* radioButtonData */0];
	}

	function getFontTextureDrawData(record) {
	  return record[/* drawData */4][/* fontTextureDrawData */0];
	}

	function getCustomTextureDrawDataMap(record) {
	  return record[/* drawData */4][/* customTextureDrawDataMap */1];
	}

	function getControlData(record) {
	  return record[/* controlData */6];
	}

	function setControlData(controlData, record) {
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */controlData,
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}


	/* OptionService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	var toInt = function (str){
	    return parseInt(str);
	    };


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _parseStrToObj(str) {
	  var item_exp = (/\w+=[^ \r\n]+/gi);
	  var int_exp = (/^[\-]?\d+$/);
	  var obj = createEmpty(/* () */0);
	  var $$break = false;
	  while(!$$break) {
	    var match = item_exp.exec(str);
	    if (match !== null) {
	      iter$1(caml_array_get(match, 0), (function (tempStr) {
	              var index = tempStr.indexOf("=");
	              var key = tempStr.substring(0, index);
	              var value = tempStr.substring(index + 1 | 0);
	              var match = int_exp.test(value);
	              var value$1;
	              if (match) {
	                value$1 = value;
	              } else {
	                var match$1 = value[0] === "\"";
	                value$1 = match$1 ? value.substring(1, value.length) : value;
	              }
	              set(key, toInt(value$1), obj);
	              return /* () */0;
	            }));
	    } else {
	      $$break = true;
	    }
	  }
	  return obj;
	}

	function _parseChar(fntStr) {
	  var fontDefDictionary = createEmpty$2(/* () */0);
	  var char_exp = (/char [^\n]*(\n|$)/gi);
	  var $$break = false;
	  while(!$$break) {
	    var match = char_exp.exec(fntStr);
	    if (match !== null) {
	      iter$1(caml_array_get(match, 0), (function ($$char) {
	              var charObj = _parseStrToObj($$char);
	              var charId = unsafeGet("id", charObj);
	              set$1(charId, /* record */[
	                    /* id */charId,
	                    /* rect : tuple */[
	                      unsafeGet("x", charObj),
	                      unsafeGet("y", charObj),
	                      unsafeGet("width", charObj),
	                      unsafeGet("height", charObj)
	                    ],
	                    /* xOffset */unsafeGet("xoffset", charObj),
	                    /* yOffset */unsafeGet("yoffset", charObj),
	                    /* xAdvance */unsafeGet("xadvance", charObj)
	                  ], fontDefDictionary);
	              return /* () */0;
	            }));
	    } else {
	      $$break = true;
	    }
	  }
	  return fontDefDictionary;
	}

	function buildKerningHashMapKey(first, second) {
	  return imul(first, 1000) + second | 0;
	}

	function _changeKerningArrayToHashMap(kerningArray) {
	  return reduceOneParam((function (map, param) {
	                return set$1(buildKerningHashMapKey(param[/* first */0], param[/* second */1]), param[/* amount */2], map);
	              }), createEmpty$2(/* () */0), kerningArray);
	}

	function _parseKerning(fntStr) {
	  var kerningArray = /* array */[];
	  var kerning_exp = (/kerning [^\n]*(\n|$)/gi);
	  var $$break = false;
	  while(!$$break) {
	    var match = kerning_exp.exec(fntStr);
	    if (match !== null) {
	      iter$1(caml_array_get(match, 0), (function (kerning) {
	              var kerningObj = _parseStrToObj(kerning);
	              push$1(/* record */[
	                    /* first */unsafeGet("first", kerningObj),
	                    /* second */unsafeGet("second", kerningObj),
	                    /* amount */unsafeGet("amount", kerningObj)
	                  ], kerningArray);
	              return /* () */0;
	            }));
	    } else {
	      $$break = true;
	    }
	  }
	  return _changeKerningArrayToHashMap(kerningArray);
	}

	function parse(fntStr, _) {
	  var common_exp = (/common [^\n]*(\n|$)/gi);
	  var page_exp = (/page [^\n]*(\n|$)/gi);
	  var match = common_exp.exec(fntStr);
	  var commonObj = _parseStrToObj(match !== null ? unsafeGet$3(nullable_to_opt(caml_array_get(match, 0))) : fatal(buildFatalMessage("parse", "fntStr should match common_exp", "", "", "fntStr: " + (String(fntStr) + ("\n    common_exp: " + (String(common_exp) + " "))))));
	  var match$1 = page_exp.exec(fntStr);
	  var pageObj = _parseStrToObj(match$1 !== null ? unsafeGet$3(nullable_to_opt(caml_array_get(match$1, 0))) : fatal(buildFatalMessage("parse", "fntStr should match page_exp", "", "", "fntStr: " + (String(fntStr) + ("\n    page_exp: " + (String(page_exp) + " "))))));
	  var match$2 = get("id", pageObj);
	  if (match$2 === undefined) {
	    fatal(buildFatalMessage("parse", "file could not be found", "", "", ""));
	  }
	  return /* record */[
	          /* commonHeight */unsafeGet("lineHeight", commonObj),
	          /* commonBase */unsafeGet("base", commonObj),
	          /* scaleW */unsafeGet("scaleW", commonObj),
	          /* scaleH */unsafeGet("scaleH", commonObj),
	          /* fontDefDictionary */_parseChar(fntStr),
	          /* kerningMap */_parseKerning(fntStr)
	        ];
	}


	/* Log-WonderLog Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function addFont(param, record) {
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData *//* record */[
	            /* fntFilePath */param[0],
	            /* bitmapFilePath */param[1]
	          ],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}

	function load$1(fetchFunc, record) {
	  var assetData = record[/* assetData */1];
	  var bitmapId = assetData[/* bitmapId */1];
	  var fntId = assetData[/* fntId */0];
	  var match = unsafeGetFontData(record);
	  var bitmapMap = assetData[/* bitmapMap */3];
	  var fntDataMap = assetData[/* fntDataMap */2];
	  var fntFilePath = match[/* fntFilePath */0];
	  return drain(merge(map$4((function (fntData) {
	                          set(fntId, fntData, fntDataMap);
	                          return /* () */0;
	                        }), map$4((function (fntStr) {
	                              return parse(fntStr, fntFilePath);
	                            }), createFetchTextStream(fntFilePath, fetchFunc))), map$4((function (image) {
	                          set(bitmapId, image, bitmapMap);
	                          return /* () */0;
	                        }), flatMap((function (blob) {
	                              return tap((function () {
	                                            return revokeObjectURL(blob);
	                                          }), loadImageByBlobPromise(createObjectURL(blob)));
	                            }), createFetchBlobStream(match[/* bitmapFilePath */1], fetchFunc))))).then((function () {
	                return Promise.resolve(record);
	              }));
	}


	/* most Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function getFntData(record) {
	  var assetData = record[/* assetData */1];
	  return get(assetData[/* fntId */0], assetData[/* fntDataMap */2]);
	}

	function getBitmap(record) {
	  var assetData = record[/* assetData */1];
	  return get(assetData[/* bitmapId */1], assetData[/* bitmapMap */3]);
	}

	function unsafeGetBitmap(record) {
	  return unsafeGet$3(getBitmap(record));
	}

	function isLoadAsset(record) {
	  return isSome(getBitmap(record));
	}

	function load(customTextureSourceDataArr, fetchFunc, record) {
	  var customImageArr = record[/* assetData */1][/* customImageArr */4];
	  var imguiRecord = /* record */[/* contents */1];
	  return drain(mergeArray(/* array */[fromPromise(load$1(fetchFunc, record).then((function (record) {
	                                  imguiRecord[0] = record;
	                                  return Promise.resolve(/* () */0);
	                                })))].concat(customTextureSourceDataArr.map((function (param) {
	                              var imageId = param[1];
	                              var imagePath = param[0];
	                              return map$4((function (image) {
	                                            push$1(/* tuple */[
	                                                  image,
	                                                  imageId,
	                                                  getType$2(imagePath)
	                                                ], customImageArr);
	                                            return /* () */0;
	                                          }), flatMap((function (blob) {
	                                                return tap((function () {
	                                                              return revokeObjectURL(blob);
	                                                            }), loadImageByBlobPromise(createObjectURL(blob)));
	                                              }), createFetchBlobStream(imagePath, fetchFunc)));
	                            }))))).then((function () {
	                var init = imguiRecord[0];
	                var init$1 = imguiRecord[0][/* assetData */1];
	                return Promise.resolve(/* record */[
	                            /* setting */init[/* setting */0],
	                            /* assetData : record */[
	                              /* fntId */init$1[/* fntId */0],
	                              /* bitmapId */init$1[/* bitmapId */1],
	                              /* fntDataMap */init$1[/* fntDataMap */2],
	                              /* bitmapMap */init$1[/* bitmapMap */3],
	                              /* customImageArr */customImageArr,
	                              /* customTextureMap */init$1[/* customTextureMap */5]
	                            ],
	                            /* fontData */init[/* fontData */2],
	                            /* webglData */init[/* webglData */3],
	                            /* drawData */init[/* drawData */4],
	                            /* imguiFuncData */init[/* imguiFuncData */5],
	                            /* controlData */init[/* controlData */6],
	                            /* ioData */init[/* ioData */7],
	                            /* layoutData */init[/* layoutData */8]
	                          ]);
	              }));
	}

	function createCustomTextures(gl, customImageArr, customTextureMap) {
	  var rgb = gl.RGB;
	  var rgba = gl.RGBA;
	  var target = gl.TEXTURE_2D;
	  return reduceOneParam((function (customTextureMap, data) {
	                var format;
	                switch (data[2]) {
	                  case 0 : 
	                      format = rgb;
	                      break;
	                  case 1 : 
	                      format = rgba;
	                      break;
	                  case 2 : 
	                      format = fatal(buildFatalMessage("createCustomTextures", "unknown image type. type should be jpg or png.", "", "", ""));
	                      break;
	                  
	                }
	                var texture = gl.createTexture();
	                gl.bindTexture(target, texture);
	                gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	                gl.texImage2D(target, 0, format, format, gl.UNSIGNED_BYTE, data[0]);
	                return set(data[1], texture, customTextureMap);
	              }), customTextureMap, customImageArr);
	}

	function unsafeGetCustomTexture(id, param) {
	  return unsafeGet(id, param[/* assetData */1][/* customTextureMap */5]);
	}

	function getCustomImageArr(param) {
	  return param[/* assetData */1][/* customImageArr */4];
	}


	/* most Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function addPoints(points, pointArr) {
	  return reduceOneParam((function (arr, point) {
	                return push$1(point, arr);
	              }), pointArr, points);
	}

	var concatArrays = function (arrays){
	  return [].concat.apply([], arrays);  
	  };

	function getBaseIndex(verticeArr) {
	  return verticeArr.length / 2 | 0;
	}


	/* ArrayService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _bufferArrayBufferData(param, gl) {
	  var $$location = param[2];
	  gl.bindBuffer(gl.ARRAY_BUFFER, param[0]);
	  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(param[1]), gl.DYNAMIC_DRAW);
	  gl.enableVertexAttribArray($$location);
	  gl.vertexAttribPointer($$location, param[3], gl.FLOAT, false, 0, 0);
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  return gl;
	}

	function _bufferElementArrayBufferData(buffer, pointArr, gl) {
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(pointArr), gl.DYNAMIC_DRAW);
	  return gl;
	}

	function bufferAllData(gl, groupedDrawDataArr, record) {
	  var match = unsafeGetWebglData(record);
	  var match$1 = reduceOneParam((function (param, param$1) {
	          var indexArr = param$1[/* indexArr */5];
	          var totalIndexArr = param[5];
	          var totalTexCoordArr = param[4];
	          var totalColorArr = param[3];
	          var totalVerticeArr = param[2];
	          var countOffset = param[1];
	          var drawElementsDataArr = param[0];
	          var count = indexArr.length;
	          if (count !== 0) {
	            var newCountOffset = countOffset + (count << 1) | 0;
	            return /* tuple */[
	                    push$1(/* record */[
	                          /* drawType */param$1[/* drawType */0],
	                          /* customTexture */param$1[/* customTexture */1],
	                          /* count */count,
	                          /* countOffset */countOffset
	                        ], drawElementsDataArr),
	                    newCountOffset,
	                    totalVerticeArr.concat(param$1[/* verticeArr */2]),
	                    totalColorArr.concat(param$1[/* colorArr */3]),
	                    totalTexCoordArr.concat(param$1[/* texCoordArr */4]),
	                    totalIndexArr.concat(indexArr)
	                  ];
	          } else {
	            return /* tuple */[
	                    drawElementsDataArr,
	                    0,
	                    totalVerticeArr,
	                    totalColorArr,
	                    totalTexCoordArr,
	                    totalIndexArr
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        0,
	        /* array */[],
	        /* array */[],
	        /* array */[],
	        /* array */[]
	      ], groupedDrawDataArr);
	  _bufferElementArrayBufferData(match[/* indexBuffer */4], match$1[5], _bufferArrayBufferData(/* tuple */[
	            match[/* texCoordBuffer */3],
	            match$1[4],
	            match[/* aTexCoordLocation */8],
	            2
	          ], _bufferArrayBufferData(/* tuple */[
	                match[/* colorBuffer */2],
	                match$1[3],
	                match[/* aColorLocation */7],
	                3
	              ], _bufferArrayBufferData(/* tuple */[
	                    match[/* positionBuffer */1],
	                    match$1[2],
	                    match[/* aPositonLocation */6],
	                    2
	                  ], gl))));
	  return /* tuple */[
	          record,
	          match$1[0]
	        ];
	}

	function coloredVertex(positionX, positionY, color, param, fontTexUvForWhite) {
	  return /* tuple */[
	          push$1(positionY, push$1(positionX, param[0])),
	          addPoints(color, param[1]),
	          addPoints(fontTexUvForWhite, param[2])
	        ];
	}


	/* ArrayService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	function convertIntRectToFloatRect(param) {
	  return /* tuple */[
	          param[0],
	          param[1],
	          param[2],
	          param[3]
	        ];
	}

	function convertIntPositionToFloatPosition(param) {
	  return /* tuple */[
	          param[0],
	          param[1]
	        ];
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function draw(param, color, record) {
	  var height = param[3];
	  var width = param[2];
	  var y = param[1];
	  var x = param[0];
	  var match = getSetting$4(record);
	  var fontTexUvForWhite = match[/* fontTexUvForWhite */1];
	  var match$1 = getFontTextureDrawData(record);
	  var verticeArr = match$1[/* verticeArr */2];
	  var baseIndex = getBaseIndex(verticeArr);
	  var init = record[/* drawData */4];
	  var init$1 = record[/* drawData */4][/* fontTextureDrawData */0];
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData : record */[
	            /* fontTextureDrawData : record */[
	              /* drawType */init$1[/* drawType */0],
	              /* customTexture */init$1[/* customTexture */1],
	              /* verticeArr */addPoints(/* array */[
	                    x,
	                    y,
	                    x,
	                    y + height,
	                    x + width,
	                    y,
	                    x + width,
	                    y + height
	                  ], verticeArr),
	              /* colorArr */addPoints(concatArrays(/* array */[
	                        color,
	                        color,
	                        color,
	                        color
	                      ]), match$1[/* colorArr */3]),
	              /* texCoordArr */addPoints(concatArrays(/* array */[
	                        fontTexUvForWhite,
	                        fontTexUvForWhite,
	                        fontTexUvForWhite,
	                        fontTexUvForWhite
	                      ]), match$1[/* texCoordArr */4]),
	              /* indexArr */addPoints(/* array */[
	                    baseIndex,
	                    baseIndex + 1 | 0,
	                    baseIndex + 2 | 0,
	                    baseIndex + 3 | 0,
	                    baseIndex + 2 | 0,
	                    baseIndex + 1 | 0
	                  ], match$1[/* indexArr */5])
	            ],
	            /* customTextureDrawDataMap */init[/* customTextureDrawDataMap */1]
	          ],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}


	/* RecordIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function getKerning(fntData, left, right) {
	  var match = get$3(buildKerningHashMapKey(left, right), fntData[/* kerningMap */5]);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return 0;
	  }
	}


	/* ParseFntIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	function length$4(prim) {
	  return prim.length;
	}

	function getValidValues$1(map) {
	  return map.filter((function (value) {
	                return value !== undefined;
	              }));
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _getGlyphById(fntData, id) {
	  var dict = fntData[/* fontDefDictionary */4];
	  return get$3(id, dict);
	}

	function getGlyph(param, fntData, id) {
	  _getGlyphById(fntData, id);
	  var match = _getGlyphById(fntData, id);
	  if (match !== undefined) {
	    return match;
	  } else {
	    var match$1 = id === "\t".charCodeAt(0);
	    if (match$1) {
	      return param[1];
	    } else {
	      var match$2 = id === " ".charCodeAt(0);
	      if (match$2) {
	        return param[0];
	      } else {
	        return undefined;
	      }
	    }
	  }
	}

	function _getMGlyph(fntData) {
	  var m_widthArr = /* array */[
	    "m",
	    "w"
	  ];
	  return reduceOneParam((function (glyph, m_width) {
	                if (glyph !== undefined) {
	                  return glyph;
	                } else {
	                  return _getGlyphById(fntData, m_width.charCodeAt(0));
	                }
	              }), undefined, m_widthArr);
	}

	function _getFirstGlyph(fntData) {
	  return getValidValues$1(fntData[/* fontDefDictionary */4])[0];
	}

	function setupSpaceGlyphs(fntData, tabSize) {
	  var match = _getGlyphById(fntData, " ".charCodeAt(0));
	  var space;
	  if (match !== undefined) {
	    space = match;
	  } else {
	    var match$1 = _getMGlyph(fntData);
	    space = match$1 !== undefined ? match$1 : _getFirstGlyph(fntData);
	  }
	  return /* tuple */[
	          space,
	          /* record */[
	            /* id */"\t".charCodeAt(0),
	            /* rect : tuple */[
	              0,
	              0,
	              0,
	              0
	            ],
	            /* xOffset */0,
	            /* yOffset */0,
	            /* xAdvance */imul(tabSize, space[/* xAdvance */4])
	          ]
	        ];
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function hasFontDefDictionaryData(param) {
	  return length$4(param[/* fontDefDictionary */4]) > 0;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _computeMetrics(fntData, text, letterSpacing, start, end_, width, hasFontDefDictionaryDataFunc, getGlyphFunc, getKerningFunc) {
	  var match = !_1(hasFontDefDictionaryDataFunc, fntData);
	  if (match) {
	    return /* tuple */[
	            start,
	            start,
	            0
	          ];
	  } else {
	    var curPen = 0;
	    var curWidth = 0;
	    var count = 0;
	    var lastGlyph = undefined;
	    var $$break = false;
	    for(var i = start ,i_finish = Math.min(text.length, end_) - 1 | 0; i <= i_finish; ++i){
	      var match$1 = $$break;
	      if (!match$1) {
	        var id = text.charCodeAt(i);
	        var glyph = _2(getGlyphFunc, fntData, id);
	        if (glyph !== undefined) {
	          var glyph$1 = glyph;
	          var match$2 = glyph$1[/* rect */1];
	          var match$3 = lastGlyph;
	          var kern = match$3 !== undefined ? _3(getKerningFunc, fntData, match$3[/* id */0], glyph$1[/* id */0]) : 0;
	          curPen = curPen + kern | 0;
	          var nextPen = (curPen + glyph$1[/* xAdvance */4] | 0) + letterSpacing | 0;
	          var nextWidth = curPen + match$2[2] | 0;
	          var match$4 = nextWidth > width || nextPen > width;
	          if (match$4) {
	            var match$5 = count === 0;
	            if (match$5) {
	              count = 1;
	              curWidth = nextWidth;
	            }
	            $$break = true;
	          }
	          curPen = nextPen;
	          curWidth = nextWidth;
	          lastGlyph = glyph$1;
	        }
	        count = count + 1 | 0;
	      }
	      
	    }
	    var match$6 = lastGlyph;
	    if (match$6 !== undefined) {
	      curWidth = curWidth + match$6[/* xOffset */2] | 0;
	    }
	    return /* tuple */[
	            start,
	            start + count | 0,
	            curWidth
	          ];
	  }
	}

	function _findNewLineIndex(text, $$char, start, end_) {
	  var idx = text.indexOf($$char, start);
	  var match = idx === -1 || idx > end_;
	  if (match) {
	    return end_;
	  } else {
	    return idx;
	  }
	}

	function _isWhitespace($$char) {
	  return (/\s/).test($$char);
	}

	var _greedy = function (fntData,text,letterSpacing,start,end_,width,hasFontDefDictionaryDataFunc,getGlyphFunc,getKerningFunc){
	             /* A greedy word wrapper based on LibGDX algorithm
	            https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/BitmapFontCache.java */
	    const NEWLINE_CHAR = '\n';

	            var lines = [],
	                textWidth = width;

	            while (start < end_ && start < text.length) {
	                /* get next newline position */
	                let newLine = _findNewLineIndex(text, NEWLINE_CHAR, start, end_);

	                /* eat whitespace at start of line */
	                while (start < newLine) {
	                    if (!_isWhitespace( text.charAt(start) )){
	                        break;
	                    }

	                    start++;
	                }

	                /* determine visible # of glyphs for the available width */
	                let measured = _computeMetrics(fntData, text, letterSpacing, start, newLine, textWidth, hasFontDefDictionaryDataFunc, getGlyphFunc, getKerningFunc),
	                    lineEnd = start + (measured[1]-measured[0]),
	                    nextStart = lineEnd + NEWLINE_CHAR.length;


	                /* if we had to cut the line before the next newline... */
	                if (lineEnd < newLine) {
	                    /* find char to break on */
	                    while (lineEnd > start) {
	                        if (_isWhitespace(text.charAt(lineEnd))){
	                            break;
	                        }

	                        lineEnd--;
	                    }

	                    if (lineEnd === start) {
	                        if (nextStart > start + NEWLINE_CHAR.length){
	                            nextStart--;
	                        }

	 /* If no characters to break, show all. */
	                        lineEnd = nextStart ;
	                    }
	                    else {
	                        nextStart = lineEnd;

	                        /* eat whitespace at end_ of line */
	                        while (lineEnd > start) {
	                            if (!_isWhitespace(text.charAt(lineEnd - NEWLINE_CHAR.length))){
	                                break;
	                            }

	                            lineEnd--;
	                        }
	                    }
	                }

	                if (lineEnd >= start) {
	                    lines.push(_computeMetrics(fntData, text, letterSpacing, start, lineEnd, textWidth, hasFontDefDictionaryDataFunc, getGlyphFunc, getKerningFunc));
	                }

	                start = nextStart;
	            }
	            return lines


	            };

	function getLines(fntData, text, param, fallbackGlyphTuple) {
	  return _greedy(fntData, text, param[0], param[2], param[3], param[1], hasFontDefDictionaryData, (function (param, param$1) {
	                return getGlyph(fallbackGlyphTuple, param, param$1);
	              }), getKerning);
	}


	/* BitmapFontParserIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _computeYForCenterYAlignment(totalHeight, lineHeight, lines) {
	  var linesHeight = imul(lines.length, lineHeight);
	  return (totalHeight - linesHeight | 0) / 2 | 0;
	}

	function getLayoutData(text, param, fntData, _) {
	  var align = param[4];
	  var letterSpacing = param[3];
	  var width = param[0];
	  var fallbackGlyphTuple = setupSpaceGlyphs(fntData, param[2]);
	  var lines = getLines(fntData, text, /* tuple */[
	        letterSpacing,
	        width,
	        0,
	        text.length
	      ], fallbackGlyphTuple);
	  var lineHeight = fntData[/* commonHeight */0];
	  var maxLineWidth = reduceOneParam((function (width$1, param) {
	          return Math.max(width$1, param[2], width);
	        }), 0, lines);
	  return reduceOneParami((function (param, param$1, lineIndex) {
	                  var lineWidth = param$1[2];
	                  var layoutDataArr = param[0];
	                  var lastGlyph = undefined;
	                  var x = param[1];
	                  var y = param[2];
	                  for(var i = param$1[0] ,i_finish = param$1[1] - 1 | 0; i <= i_finish; ++i){
	                    var id = text.charCodeAt(i);
	                    var match = getGlyph(fallbackGlyphTuple, fntData, id);
	                    if (match !== undefined) {
	                      var glyph = match;
	                      var match$1 = lastGlyph;
	                      var tx;
	                      if (match$1 !== undefined) {
	                        x = x + getKerning(fntData, match$1[/* id */0], glyph[/* id */0]) | 0;
	                        tx = x;
	                      } else {
	                        tx = x;
	                      }
	                      var tx$1;
	                      switch (align) {
	                        case 0 : 
	                            tx$1 = tx;
	                            break;
	                        case 1 : 
	                            tx$1 = tx + ((maxLineWidth - lineWidth | 0) / 2 | 0) | 0;
	                            break;
	                        case 2 : 
	                            tx$1 = tx + (maxLineWidth - lineWidth | 0) | 0;
	                            break;
	                        
	                      }
	                      push$1(/* record */[
	                            /* position : tuple */[
	                              tx$1 + glyph[/* xOffset */2] | 0,
	                              y + glyph[/* yOffset */3] | 0
	                            ],
	                            /* data */glyph,
	                            /* index */i,
	                            /* line */lineIndex
	                          ], layoutDataArr);
	                      x = (x + glyph[/* xAdvance */4] | 0) + letterSpacing | 0;
	                      lastGlyph = glyph;
	                    }
	                    
	                  }
	                  return /* tuple */[
	                          layoutDataArr,
	                          0,
	                          y + lineHeight | 0,
	                          lastGlyph
	                        ];
	                }), /* tuple */[
	                /* array */[],
	                0,
	                _computeYForCenterYAlignment(param[1], lineHeight, lines),
	                undefined
	              ], lines)[0];
	}


	/* ArrayService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _generateVertices(posX, posY, param, verticeArr) {
	  var position = param[/* position */0];
	  var match = param[/* data */1][/* rect */1];
	  var charHeightInImage = match[3];
	  var charWidthInImage = match[2];
	  var leftUpX = position[0] + posX;
	  var leftUpY = position[1] + posY;
	  return addPoints(/* array */[
	              leftUpX,
	              leftUpY,
	              leftUpX,
	              leftUpY + charHeightInImage,
	              leftUpX + charWidthInImage,
	              leftUpY,
	              leftUpX + charWidthInImage,
	              leftUpY + charHeightInImage
	            ], verticeArr);
	}

	function _generateTexCoords(param, textureWidth, textureHeight, texCoordArr) {
	  var match = param[/* data */1][/* rect */1];
	  var charYInImage = match[1];
	  var charXInImage = match[0];
	  var s0 = charXInImage / textureWidth;
	  var t0 = charYInImage / textureHeight;
	  var s1 = (charXInImage + match[2] | 0) / textureWidth;
	  var t1 = (charYInImage + match[3] | 0) / textureHeight;
	  return addPoints(/* array */[
	              s0,
	              t0,
	              s0,
	              t1,
	              s1,
	              t0,
	              s1,
	              t1
	            ], texCoordArr);
	}

	function _generateIndices(baseIndex, indexArr) {
	  return addPoints(/* array */[
	              baseIndex,
	              baseIndex + 1 | 0,
	              baseIndex + 2 | 0,
	              baseIndex + 3 | 0,
	              baseIndex + 2 | 0,
	              baseIndex + 1 | 0
	            ], indexArr);
	}

	function draw$1(param, str, align, record) {
	  var y = param[1];
	  var x = param[0];
	  var match = getSetting$4(record);
	  var textColor = match[/* textColor */0];
	  var textColorArrPerPoint = concatArrays(/* array */[
	        textColor,
	        textColor,
	        textColor,
	        textColor
	      ]);
	  var match$1 = getFntData(record);
	  if (match$1 !== undefined) {
	    var fntData = match$1;
	    var layoutDataArr = getLayoutData(str, /* tuple */[
	          param[2],
	          param[3],
	          4,
	          0,
	          align
	        ], fntData, record);
	    var match$2 = getFontTextureDrawData(record);
	    var match$3 = reduceOneParam((function (param, layoutData) {
	            var verticeArr = param[0];
	            var baseIndex = getBaseIndex(verticeArr);
	            return /* tuple */[
	                    _generateVertices(x, y, layoutData, verticeArr),
	                    addPoints(textColorArrPerPoint, param[1]),
	                    _generateTexCoords(layoutData, fntData[/* scaleW */2], fntData[/* scaleH */3], param[2]),
	                    _generateIndices(baseIndex, param[3])
	                  ];
	          }), /* tuple */[
	          match$2[/* verticeArr */2],
	          match$2[/* colorArr */3],
	          match$2[/* texCoordArr */4],
	          match$2[/* indexArr */5]
	        ], layoutDataArr);
	    var init = record[/* drawData */4];
	    var init$1 = record[/* drawData */4][/* fontTextureDrawData */0];
	    return /* record */[
	            /* setting */record[/* setting */0],
	            /* assetData */record[/* assetData */1],
	            /* fontData */record[/* fontData */2],
	            /* webglData */record[/* webglData */3],
	            /* drawData : record */[
	              /* fontTextureDrawData : record */[
	                /* drawType */init$1[/* drawType */0],
	                /* customTexture */init$1[/* customTexture */1],
	                /* verticeArr */match$3[0],
	                /* colorArr */match$3[1],
	                /* texCoordArr */match$3[2],
	                /* indexArr */match$3[3]
	              ],
	              /* customTextureDrawDataMap */init[/* customTextureDrawDataMap */1]
	            ],
	            /* imguiFuncData */record[/* imguiFuncData */5],
	            /* controlData */record[/* controlData */6],
	            /* ioData */record[/* ioData */7],
	            /* layoutData */record[/* layoutData */8]
	          ];
	  } else {
	    return fatal(buildFatalMessage("getLayoutData", "impossible to create font: not find fnt file", "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _getOrCreateCustomTextureDrawData(id, record) {
	  var match = get(id, getCustomTextureDrawDataMap(record));
	  if (match !== undefined) {
	    return match;
	  } else {
	    return /* record */[
	            /* drawType : CustomTexture */1,
	            /* customTexture */some$1(unsafeGetCustomTexture(id, record)),
	            /* verticeArr : array */[],
	            /* colorArr : array */[],
	            /* texCoordArr : array */[],
	            /* indexArr : array */[]
	          ];
	  }
	}

	function draw$2(param, param$1, id, record) {
	  var t1 = param$1[3];
	  var s1 = param$1[2];
	  var t0 = param$1[1];
	  var s0 = param$1[0];
	  var height = param[3];
	  var width = param[2];
	  var y = param[1];
	  var x = param[0];
	  var drawData = _getOrCreateCustomTextureDrawData(id, record);
	  var verticeArr = drawData[/* verticeArr */2];
	  var baseIndex = getBaseIndex(verticeArr);
	  var drawData_000 = /* drawType */drawData[/* drawType */0];
	  var drawData_001 = /* customTexture */drawData[/* customTexture */1];
	  var drawData_002 = /* verticeArr */addPoints(/* array */[
	        x,
	        y,
	        x,
	        y + height,
	        x + width,
	        y,
	        x + width,
	        y + height
	      ], verticeArr);
	  var drawData_003 = /* colorArr */addPoints(/* array */[
	        1,
	        1,
	        1,
	        1,
	        1,
	        1,
	        1,
	        1,
	        1,
	        1,
	        1,
	        1
	      ], drawData[/* colorArr */3]);
	  var drawData_004 = /* texCoordArr */addPoints(/* array */[
	        s0,
	        t0,
	        s0,
	        t1,
	        s1,
	        t0,
	        s1,
	        t1
	      ], drawData[/* texCoordArr */4]);
	  var drawData_005 = /* indexArr */addPoints(/* array */[
	        baseIndex,
	        baseIndex + 1 | 0,
	        baseIndex + 2 | 0,
	        baseIndex + 3 | 0,
	        baseIndex + 2 | 0,
	        baseIndex + 1 | 0
	      ], drawData[/* indexArr */5]);
	  var drawData$1 = /* record */[
	    drawData_000,
	    drawData_001,
	    drawData_002,
	    drawData_003,
	    drawData_004,
	    drawData_005
	  ];
	  var init = record[/* drawData */4];
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData : record */[
	            /* fontTextureDrawData */init[/* fontTextureDrawData */0],
	            /* customTextureDrawDataMap */set(id, drawData$1, record[/* drawData */4][/* customTextureDrawDataMap */1])
	          ],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}


	/* AssetIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE


	function isInBox(param, param$1) {
	  var x = param[0];
	  var y = param[1];
	  var posY = param$1[1];
	  var posX = param$1[0];
	  var maxX = x + param[2];
	  var maxY = y + param[3];
	  if (x <= posX && posX <= maxX && y <= posY) {
	    return posY <= maxY;
	  } else {
	    return false;
	  }
	}

	function isInCircle(param, param$1) {
	  var width = param[2];
	  var centerX = param[0] + 0.5 * width;
	  var centerY = param[1] + 0.5 * param[3];
	  var radius = width / 2;
	  var dist = Math.sqrt(Math.pow(param$1[0] - centerX, 2) + Math.pow(param$1[1] - centerY, 2));
	  return dist <= radius;
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function isClick(record) {
	  var match = getIOData(record);
	  if (match[/* pointDown */1]) {
	    return match[/* pointUp */0];
	  } else {
	    return false;
	  }
	}


	/* RecordIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function button$2(rect, str, record) {
	  var match = getSetting$4(record)[/* buttonSetting */2];
	  var clickButtonColor = match[/* clickButtonColor */2];
	  var match$1 = getIOData(record);
	  var match$2 = isInBox(rect, convertIntPositionToFloatPosition(match$1[/* pointPosition */2]));
	  var match$3;
	  if (match$2) {
	    var match$4 = isClick(record);
	    match$3 = match$4 ? /* tuple */[
	        true,
	        clickButtonColor
	      ] : (
	        match$1[/* pointDown */1] ? /* tuple */[
	            false,
	            clickButtonColor
	          ] : /* tuple */[
	            false,
	            match[/* hoverButtonColor */1]
	          ]
	      );
	  } else {
	    match$3 = /* tuple */[
	      false,
	      match[/* buttonColor */0]
	    ];
	  }
	  return /* tuple */[
	          draw$1(rect, str, /* Center */1, draw(rect, match$3[1], record)),
	          match$3[0]
	        ];
	}


	/* IOIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function clamp$1(num, below, up) {
	  var match = caml_lessthan(num, below);
	  if (match) {
	    return below;
	  } else {
	    var match$1 = caml_greaterthan(num, up);
	    if (match$1) {
	      return up;
	    } else {
	      return num;
	    }
	  }
	}


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _addIndex(record) {
	  var init = record[/* controlData */6];
	  var init$1 = record[/* controlData */6][/* sliderData */2];
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData : record */[
	            /* radioButtonData */init[/* radioButtonData */0],
	            /* checkboxData */init[/* checkboxData */1],
	            /* sliderData : record */[
	              /* index */record[/* controlData */6][/* sliderData */2][/* index */0] + 1 | 0,
	              /* valueMap */init$1[/* valueMap */1]
	            ]
	          ],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}

	function _getValue(index, defaultValue, record) {
	  var match = get$3(index, record[/* controlData */6][/* sliderData */2][/* valueMap */1]);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return defaultValue;
	  }
	}

	function _setValue(index, value, record) {
	  set$1(index, value, record[/* controlData */6][/* sliderData */2][/* valueMap */1]);
	  return record;
	}

	function _computeValue(param, param$1, param$2, record) {
	  var min = param$2[0];
	  var x = param$1[0];
	  if (param[0]) {
	    var xMax = x + param$1[2];
	    var mouseX = clamp$1(param[1][0], x, xMax);
	    var value = (param$2[1] - min) * ((mouseX - x) / (xMax - x)) + min;
	    if (param$2[2]) {
	      return Math.round(value);
	    } else {
	      return value;
	    }
	  } else {
	    return _getValue(param[2], param[3], record);
	  }
	}

	function _slider(param, param$1, param$2, record) {
	  var numDecimalDigits = param$1[3];
	  var doRounding = param$1[2];
	  var max = param$1[1];
	  var min = param$1[0];
	  var rect = param[0];
	  var height = rect[3];
	  var width = rect[2];
	  var y = rect[1];
	  var x = rect[0];
	  var match = getSetting$4(record)[/* sliderSetting */5];
	  var sliderFillColorHover = match[/* sliderFillColorHover */3];
	  var sliderBackgroundColorHover = match[/* sliderBackgroundColorHover */2];
	  var match$1 = getIOData(record);
	  var pointPosition = match$1[/* pointPosition */2];
	  var match$2 = isInBox(rect, convertIntPositionToFloatPosition(pointPosition));
	  var match$3 = match$2 ? (
	      match$1[/* pointDown */1] ? /* tuple */[
	          true,
	          sliderBackgroundColorHover,
	          sliderFillColorHover
	        ] : /* tuple */[
	          false,
	          sliderBackgroundColorHover,
	          sliderFillColorHover
	        ]
	    ) : /* tuple */[
	      false,
	      match[/* sliderBackgroundColor */0],
	      match[/* sliderFillColor */1]
	    ];
	  var isSelected = match$3[0];
	  var index = record[/* controlData */6][/* sliderData */2][/* index */0];
	  var value = _computeValue(/* tuple */[
	        isSelected,
	        pointPosition,
	        index,
	        param$2[0]
	      ], rect, /* tuple */[
	        min,
	        max,
	        doRounding,
	        numDecimalDigits
	      ], record);
	  var sliderFill = (value - min) / (max - min);
	  var sliderValueStr = value.toFixed(doRounding ? 0 : numDecimalDigits);
	  var record$1 = draw(rect, match$3[1], record);
	  var record$2 = draw(/* tuple */[
	        x,
	        y,
	        width * sliderFill,
	        height
	      ], match$3[2], record$1);
	  var record$3 = draw$1(rect, sliderValueStr, /* Center */1, record$2);
	  var record$4 = draw$1(/* tuple */[
	        x + width,
	        y,
	        param[1],
	        height
	      ], param$2[1], /* Left */0, record$3);
	  var record$5 = _addIndex(_setValue(index, value, record$4));
	  return /* tuple */[
	          record$5,
	          isSelected,
	          value
	        ];
	}

	function sliderInt$2(param, param$1, param$2, record) {
	  var match = _slider(/* tuple */[
	        param[0],
	        param[1]
	      ], /* tuple */[
	        param$1[0],
	        param$1[1],
	        true,
	        0
	      ], /* tuple */[
	        param$2[0],
	        param$2[1]
	      ], record);
	  return /* tuple */[
	          match[0],
	          match[1],
	          match[2]
	        ];
	}

	function sliderFloat$2(param, param$1, param$2, record) {
	  return _slider(/* tuple */[
	              param[0],
	              param[1]
	            ], /* tuple */[
	              param$1[0],
	              param$1[1],
	              false,
	              param$1[2]
	            ], /* tuple */[
	              param$2[0],
	              param$2[1]
	            ], record);
	}


	/* RecordIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _addIndex$1(record) {
	  var init = record[/* controlData */6];
	  var init$1 = record[/* controlData */6][/* checkboxData */1];
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData : record */[
	            /* radioButtonData */init[/* radioButtonData */0],
	            /* checkboxData : record */[
	              /* index */record[/* controlData */6][/* checkboxData */1][/* index */0] + 1 | 0,
	              /* isSelectedMap */init$1[/* isSelectedMap */1]
	            ],
	            /* sliderData */init[/* sliderData */2]
	          ],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}

	function _getIsSelectedByDefaultAndMap(index, defaultIsSelected, record) {
	  var match = get$3(index, record[/* controlData */6][/* checkboxData */1][/* isSelectedMap */1]);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return defaultIsSelected;
	  }
	}

	function _setIsSlected(index, value, record) {
	  set$1(index, value, record[/* controlData */6][/* checkboxData */1][/* isSelectedMap */1]);
	  return record;
	}

	function checkbox$2(rect, defaultIsSelected, str, record) {
	  var height = rect[3];
	  var y = rect[1];
	  var x = rect[0];
	  var match = getSetting$4(record)[/* checkboxSetting */4];
	  var checkboxInnerColorHover = match[/* checkboxInnerColorHover */3];
	  var checkboxOuterColorHover = match[/* checkboxOuterColorHover */2];
	  var match$1 = getIOData(record);
	  var innerSize = height * match[/* checkboxInnerSizeRatio */4];
	  var outerSize = height * match[/* checkboxOuterSizeRatio */5];
	  var outerBoxRect = /* tuple */[
	    x,
	    y,
	    outerSize,
	    outerSize
	  ];
	  var index = record[/* controlData */6][/* checkboxData */1][/* index */0];
	  var isSelectedByDefaultAndMap = _getIsSelectedByDefaultAndMap(index, defaultIsSelected, record);
	  var isInBox$$1 = isInBox(outerBoxRect, convertIntPositionToFloatPosition(match$1[/* pointPosition */2]));
	  var match$2 = isInBox$$1 && isClick(record);
	  var isSelected = match$2 ? (
	      isSelectedByDefaultAndMap ? false : true
	    ) : isSelectedByDefaultAndMap;
	  var match$3 = isSelected || isInBox$$1 ? /* tuple */[
	      checkboxInnerColorHover,
	      checkboxOuterColorHover
	    ] : /* tuple */[
	      match[/* checkboxInnerColor */1],
	      match[/* checkboxOuterColor */0]
	    ];
	  var record$1 = _setIsSlected(index, isSelected, record);
	  var record$2 = draw(outerBoxRect, match$3[1], record$1);
	  var record$3 = isSelected ? draw(/* tuple */[
	          Math.round(0.5 * (x + (x + outerSize) - innerSize)),
	          Math.round(0.5 * (y + (y + outerSize) - innerSize)),
	          innerSize,
	          innerSize
	        ], match$3[0], record$2) : record$2;
	  var record$4 = draw$1(/* tuple */[
	        x + outerSize,
	        y,
	        rect[2] - outerSize,
	        height
	      ], str, /* Center */1, record$3);
	  var record$5 = _addIndex$1(record$4);
	  return /* tuple */[
	          record$5,
	          isSelected
	        ];
	}


	/* IOIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _drawCircle(_param, _theta, _curIndex, _param$1) {
	  while(true) {
	    var param = _param$1;
	    var param$1 = _param;
	    var curIndex = _curIndex;
	    var theta = _theta;
	    var indexArr = param[3];
	    var texCoordArr = param[2];
	    var colorArr = param[1];
	    var verticeArr = param[0];
	    var max = param$1[7];
	    var stepSize = param$1[6];
	    var radius = param$1[5];
	    var centerVertexIndex = param$1[4];
	    var fontTexUvForWhite = param$1[3];
	    var color = param$1[2];
	    var centerY = param$1[1];
	    var centerX = param$1[0];
	    var match = theta <= max;
	    if (match) {
	      var match$1 = coloredVertex(centerX + radius * Math.cos(theta), centerY + radius * Math.sin(theta), color, /* tuple */[
	            verticeArr,
	            colorArr,
	            texCoordArr
	          ], fontTexUvForWhite);
	      var match$2 = theta !== 0;
	      var indexArr$1 = match$2 ? push$1(centerVertexIndex, push$1(curIndex - 1 | 0, push$1(curIndex + 0 | 0, indexArr))) : indexArr;
	      _param$1 = /* tuple */[
	        match$1[0],
	        match$1[1],
	        match$1[2],
	        indexArr$1
	      ];
	      _curIndex = curIndex + 1 | 0;
	      _theta = theta + stepSize;
	      _param = /* tuple */[
	        centerX,
	        centerY,
	        color,
	        fontTexUvForWhite,
	        centerVertexIndex,
	        radius,
	        stepSize,
	        max
	      ];
	      continue ;
	    } else {
	      return /* tuple */[
	              verticeArr,
	              colorArr,
	              texCoordArr,
	              indexArr
	            ];
	    }
	  }
	}

	function draw$3(param, color, segments, record) {
	  var width = param[2];
	  var match = getSetting$4(record);
	  var fontTexUvForWhite = match[/* fontTexUvForWhite */1];
	  var centerX = param[0] + 0.5 * width;
	  var centerY = param[1] + 0.5 * param[3];
	  var radius = width / 2;
	  var match$1 = getFontTextureDrawData(record);
	  var verticeArr = match$1[/* verticeArr */2];
	  var baseIndex = getBaseIndex(verticeArr);
	  var match$2 = coloredVertex(centerX, centerY, color, /* tuple */[
	        verticeArr,
	        match$1[/* colorArr */3],
	        match$1[/* texCoordArr */4]
	      ], fontTexUvForWhite);
	  var centerVertexIndex = baseIndex + 0 | 0;
	  var match$3 = _drawCircle(/* tuple */[
	        centerX,
	        centerY,
	        color,
	        fontTexUvForWhite,
	        centerVertexIndex,
	        radius,
	        2 * Math.PI / segments,
	        2 * Math.PI + 0.1
	      ], 0, baseIndex + 1 | 0, /* tuple */[
	        match$2[0],
	        match$2[1],
	        match$2[2],
	        match$1[/* indexArr */5]
	      ]);
	  var init = record[/* drawData */4];
	  var init$1 = record[/* drawData */4][/* fontTextureDrawData */0];
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData : record */[
	            /* fontTextureDrawData : record */[
	              /* drawType */init$1[/* drawType */0],
	              /* customTexture */init$1[/* customTexture */1],
	              /* verticeArr */match$3[0],
	              /* colorArr */match$3[1],
	              /* texCoordArr */match$3[2],
	              /* indexArr */match$3[3]
	            ],
	            /* customTextureDrawDataMap */init[/* customTextureDrawDataMap */1]
	          ],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}


	/* ArrayService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _getSelectIndex(defaultSelectIndex, group$$1, record) {
	  var match = get(group$$1, getRadioButtonData(record)[/* isSelectedMap */0]);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return defaultSelectIndex;
	  }
	}

	function _buildDrawData(defaultSelectIndex, groupDataArr, group$$1, record) {
	  var match = getSetting$4(record)[/* radioButtonSetting */3];
	  var radioButtonOuterRadius = match[/* radioButtonOuterRadius */6];
	  var radioButtonInnerRadius = match[/* radioButtonInnerRadius */5];
	  var match$1 = getIOData(record);
	  var pointPosition = match$1[/* pointPosition */2];
	  var selectIndex = _getSelectIndex(defaultSelectIndex, group$$1, record);
	  var match$2 = reduceOneParami((function (param, param$1, index) {
	          var resultInHoverIndex = param[2];
	          var resultSelectIndex = param[1];
	          var match = convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(param$1[0], record));
	          var height = match[3];
	          var y = match[1];
	          var x = match[0];
	          var innerRadius = height / 2 * radioButtonInnerRadius;
	          var outerRadius = height / 2 * radioButtonOuterRadius;
	          var innerCircleWidth = innerRadius * 2;
	          var innerCircleHeight = innerRadius * 2;
	          var outerCircleWidth = outerRadius * 2;
	          var outerCircleHeight = outerRadius * 2;
	          var innerCircleRect = /* tuple */[
	            x,
	            y,
	            innerCircleWidth,
	            innerCircleHeight
	          ];
	          var outerCircleRect = /* tuple */[
	            x,
	            y,
	            outerCircleWidth,
	            outerCircleHeight
	          ];
	          var isInCircle$$1 = isInCircle(outerCircleRect, convertIntPositionToFloatPosition(pointPosition));
	          var isIOSelected = isInCircle$$1 && isClick(record);
	          return /* tuple */[
	                  push$1(/* tuple */[
	                        x,
	                        y,
	                        match[2],
	                        height,
	                        param$1[1],
	                        innerRadius,
	                        outerRadius,
	                        innerCircleWidth,
	                        innerCircleHeight,
	                        outerCircleWidth,
	                        outerCircleHeight,
	                        innerCircleRect,
	                        outerCircleRect
	                      ], param[0]),
	                  resultSelectIndex !== undefined ? resultSelectIndex : (
	                      isIOSelected ? index : undefined
	                    ),
	                  resultInHoverIndex !== undefined ? resultInHoverIndex : (
	                      isInCircle$$1 ? index : undefined
	                    )
	                ];
	        }), /* tuple */[
	        /* array */[],
	        undefined,
	        undefined
	      ], groupDataArr);
	  var ioSelectIndex = match$2[1];
	  return /* tuple */[
	          match$2[0],
	          ioSelectIndex !== undefined ? ioSelectIndex : selectIndex,
	          match$2[2]
	        ];
	}

	function radioButton$2(groupDataArr, defaultSelectIndex, group$$1, record) {
	  requireCheck((function () {
	          return test(buildAssertMessage("defaultSelectIndex < radioButton count", "not"), (function () {
	                        return Operators[/* < */9](defaultSelectIndex, groupDataArr.length);
	                      }));
	        }), true);
	  var match = getSetting$4(record)[/* radioButtonSetting */3];
	  var radioButtonCircleSegments = match[/* radioButtonCircleSegments */4];
	  var radioButtonInnerColorHover = match[/* radioButtonInnerColorHover */3];
	  var radioButtonOuterColorHover = match[/* radioButtonOuterColorHover */2];
	  var radioButtonInnerColor = match[/* radioButtonInnerColor */1];
	  var radioButtonOuterColor = match[/* radioButtonOuterColor */0];
	  var match$1 = _buildDrawData(defaultSelectIndex, groupDataArr, group$$1, record);
	  var ioInHoverIndex = match$1[2];
	  var selectIndex = match$1[1];
	  set(group$$1, selectIndex, getRadioButtonData(record)[/* isSelectedMap */0]);
	  var record$1 = reduceOneParami((function (record, param, index) {
	          var outerCircleWidth = param[9];
	          var innerRadius = param[5];
	          var y = param[1];
	          var x = param[0];
	          var isSelected = selectIndex === index;
	          var match;
	          if (isSelected) {
	            match = /* tuple */[
	              radioButtonInnerColorHover,
	              radioButtonOuterColorHover
	            ];
	          } else if (ioInHoverIndex !== undefined) {
	            var match$1 = ioInHoverIndex === index;
	            match = match$1 ? /* tuple */[
	                radioButtonInnerColorHover,
	                radioButtonOuterColorHover
	              ] : /* tuple */[
	                radioButtonInnerColor,
	                radioButtonOuterColor
	              ];
	          } else {
	            match = /* tuple */[
	              radioButtonInnerColor,
	              radioButtonOuterColor
	            ];
	          }
	          var record$1 = draw$3(param[12], match[1], radioButtonCircleSegments, record);
	          var record$2 = isSelected ? draw$3(/* tuple */[
	                  Math.round(0.5 * (x + (x + outerCircleWidth) - innerRadius * 2)),
	                  Math.round(0.5 * (y + (y + param[10]) - innerRadius * 2)),
	                  param[7],
	                  param[8]
	                ], match[0], radioButtonCircleSegments, record$1) : record$1;
	          return draw$1(/* tuple */[
	                      x + outerCircleWidth,
	                      y,
	                      param[2] - outerCircleWidth,
	                      param[3]
	                    ], param[4], /* Center */1, record$2);
	        }), record, match$1[0]);
	  return /* tuple */[
	          record$1,
	          selectIndex
	        ];
	}


	/* Log-WonderLog Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function label$2(rect, str, align, record) {
	  return draw$1(convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(rect, record)), str, align, record);
	}

	function image$2(rect, uv, id, record) {
	  return draw$2(convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(rect, record)), uv, id, record);
	}

	function button$1(rect, str, record) {
	  return button$2(convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(rect, record)), str, record);
	}

	function box$1(rect, color, record) {
	  return draw(convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(rect, record)), color, record);
	}

	var radioButton$1 = radioButton$2;

	function checkbox$1(rect, defaultSelected, str, record) {
	  return checkbox$2(convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(rect, record)), defaultSelected, str, record);
	}

	function sliderInt$1(param, param$1, param$2, record) {
	  return sliderInt$2(/* tuple */[
	              convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(param[0], record)),
	              param[1]
	            ], /* tuple */[
	              param$1[0],
	              param$1[1]
	            ], /* tuple */[
	              param$2[0],
	              param$2[1]
	            ], record);
	}

	function sliderFloat$1(param, param$1, param$2, record) {
	  return sliderFloat$2(/* tuple */[
	              convertIntRectToFloatRect(computeRectBasedOnTopLeftOfView(param[0], record)),
	              param[1]
	            ], /* tuple */[
	              param$1[0],
	              param$1[1],
	              param$1[2]
	            ], /* tuple */[
	              param$2[0],
	              param$2[1]
	            ], record);
	}


	/* DrawBoxIMGUIService-WonderImgui Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _createArrayBuffer(gl) {
	  var buffer = gl.createBuffer();
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(/* array */[]), gl.DYNAMIC_DRAW);
	  return buffer;
	}

	function _createElementArrayBuffer(gl) {
	  var buffer = gl.createBuffer();
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(/* array */[]), gl.DYNAMIC_DRAW);
	  return buffer;
	}

	function _createFontTexture(gl, source) {
	  var texture = gl.createTexture();
	  var target = gl.TEXTURE_2D;
	  gl.bindTexture(target, texture);
	  gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	  gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	  gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	  gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	  var format = gl.RGBA;
	  gl.texImage2D(target, 0, format, format, gl.UNSIGNED_BYTE, source);
	  return texture;
	}

	function _buildOrthoProjectionMat4TypeArr(param) {
	  return ortho(0, param[0], param[1], 0, -1, 1, createIdentityMatrix4$1(/* () */0));
	}

	function _sendUniformProjectionMatData(gl, program, canvasSize) {
	  gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_projectionMat"), false, _buildOrthoProjectionMat4TypeArr(canvasSize));
	  return /* () */0;
	}

	function _getProgram(record) {
	  return unsafeGet$3(record[/* webglData */3])[/* program */0];
	}

	function _sendUniformData(gl, program, canvasSize) {
	  gl.useProgram(program);
	  _sendUniformProjectionMatData(gl, program, canvasSize);
	  gl.uniform1i(gl.getUniformLocation(program, "u_sampler2D"), 0);
	  return /* () */0;
	}

	function sendUniformProjectionMatData$3(gl, canvasSize, record) {
	  var program = _getProgram(record);
	  gl.useProgram(program);
	  gl.uniformMatrix4fv(gl.getUniformLocation(program, "u_projectionMat"), false, _buildOrthoProjectionMat4TypeArr(canvasSize));
	  return record;
	}

	function init$7(gl, canvasSize, record) {
	  var match = !isLoadAsset(record);
	  if (match) {
	    return record;
	  } else {
	    var program = initShader$1(vs, fs, gl, gl.createProgram());
	    var positionBuffer = _createArrayBuffer(gl);
	    var colorBuffer = _createArrayBuffer(gl);
	    var texCoordBuffer = _createArrayBuffer(gl);
	    var indexBuffer = _createElementArrayBuffer(gl);
	    var fontTexture = _createFontTexture(gl, unsafeGetBitmap(record));
	    _sendUniformData(gl, program, canvasSize);
	    var match$1 = record[/* assetData */1];
	    var init$1 = record[/* assetData */1];
	    return /* record */[
	            /* setting */record[/* setting */0],
	            /* assetData : record */[
	              /* fntId */init$1[/* fntId */0],
	              /* bitmapId */init$1[/* bitmapId */1],
	              /* fntDataMap */init$1[/* fntDataMap */2],
	              /* bitmapMap */init$1[/* bitmapMap */3],
	              /* customImageArr */init$1[/* customImageArr */4],
	              /* customTextureMap */createCustomTextures(gl, match$1[/* customImageArr */4], match$1[/* customTextureMap */5])
	            ],
	            /* fontData */record[/* fontData */2],
	            /* webglData *//* record */[
	              /* program */program,
	              /* positionBuffer */positionBuffer,
	              /* colorBuffer */colorBuffer,
	              /* texCoordBuffer */texCoordBuffer,
	              /* indexBuffer */indexBuffer,
	              /* fontTexture */fontTexture,
	              /* aPositonLocation */gl.getAttribLocation(program, "a_position"),
	              /* aColorLocation */gl.getAttribLocation(program, "a_color"),
	              /* aTexCoordLocation */gl.getAttribLocation(program, "a_texCoord"),
	              /* lastWebglData */undefined
	            ],
	            /* drawData */record[/* drawData */4],
	            /* imguiFuncData */record[/* imguiFuncData */5],
	            /* controlData */record[/* controlData */6],
	            /* ioData */record[/* ioData */7],
	            /* layoutData */record[/* layoutData */8]
	          ];
	  }
	}

	function _createEmptyDrawData() {
	  return /* record */[
	          /* fontTextureDrawData : record */[
	            /* drawType : FontTexture */0,
	            /* customTexture */undefined,
	            /* verticeArr : array */[],
	            /* colorArr : array */[],
	            /* texCoordArr : array */[],
	            /* indexArr : array */[]
	          ],
	          /* customTextureDrawDataMap */createEmpty(/* () */0)
	        ];
	}

	function _prepare(ioData, param, data) {
	  var record = _1(param[0], data);
	  var init = record[/* controlData */6];
	  var init$1 = record[/* controlData */6][/* checkboxData */1];
	  var init$2 = record[/* controlData */6][/* sliderData */2];
	  return _2(param[1], /* record */[
	              /* setting */record[/* setting */0],
	              /* assetData */record[/* assetData */1],
	              /* fontData */record[/* fontData */2],
	              /* webglData */record[/* webglData */3],
	              /* drawData */_createEmptyDrawData(/* () */0),
	              /* imguiFuncData */record[/* imguiFuncData */5],
	              /* controlData : record */[
	                /* radioButtonData */init[/* radioButtonData */0],
	                /* checkboxData : record */[
	                  /* index */0,
	                  /* isSelectedMap */init$1[/* isSelectedMap */1]
	                ],
	                /* sliderData : record */[
	                  /* index */0,
	                  /* valueMap */init$2[/* valueMap */1]
	                ]
	              ],
	              /* ioData */ioData,
	              /* layoutData */record[/* layoutData */8]
	            ], data);
	}

	function _unbindVAO(gl) {
	  var match = gl.getExtension("OES_vertex_array_object");
	  if (match == null) {
	    return /* () */0;
	  } else {
	    match.bindVertexArrayOES(null);
	    return /* () */0;
	  }
	}

	function _backupGlState(gl, record) {
	  var init = unsafeGetWebglData(record);
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData *//* record */[
	            /* program */init[/* program */0],
	            /* positionBuffer */init[/* positionBuffer */1],
	            /* colorBuffer */init[/* colorBuffer */2],
	            /* texCoordBuffer */init[/* texCoordBuffer */3],
	            /* indexBuffer */init[/* indexBuffer */4],
	            /* fontTexture */init[/* fontTexture */5],
	            /* aPositonLocation */init[/* aPositonLocation */6],
	            /* aColorLocation */init[/* aColorLocation */7],
	            /* aTexCoordLocation */init[/* aTexCoordLocation */8],
	            /* lastWebglData *//* record */[
	              /* lastProgram */nullable_to_opt(gl.getParameter(gl.CURRENT_PROGRAM)),
	              /* lastElementArrayBuffer */gl.getParameter(gl.ELEMENT_ARRAY_BUFFER_BINDING),
	              /* lastArrayBuffer */gl.getParameter(gl.ARRAY_BUFFER_BINDING),
	              /* lastTexture */nullable_to_opt(gl.getParameter(gl.TEXTURE_BINDING_2D)),
	              /* lastIsEnableDepthTest */gl.isEnabled(gl.DEPTH_TEST),
	              /* lastIsEnableBlend */gl.isEnabled(gl.BLEND)
	            ]
	          ],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData */record[/* controlData */6],
	          /* ioData */record[/* ioData */7],
	          /* layoutData */record[/* layoutData */8]
	        ];
	}

	function _setGlState(gl) {
	  gl.disable(gl.DEPTH_TEST);
	  gl.enable(gl.BLEND);
	  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	  return /* () */0;
	}

	function _draw(gl, drawElementsDataArr, record) {
	  var match = unsafeGetWebglData(record);
	  var fontTexture = match[/* fontTexture */5];
	  forEach((function (param) {
	          var texture = param[/* drawType */0] ? unsafeGet$3(param[/* customTexture */1]) : fontTexture;
	          gl.bindTexture(gl.TEXTURE_2D, texture);
	          gl.drawElements(gl.TRIANGLES, param[/* count */2], gl.UNSIGNED_SHORT, param[/* countOffset */3]);
	          return /* () */0;
	        }), drawElementsDataArr);
	  return record;
	}

	function _restoreGlState(gl, record) {
	  var match = unsafeGet$3(unsafeGetWebglData(record)[/* lastWebglData */9]);
	  var lastTexture = match[/* lastTexture */3];
	  var lastProgram = match[/* lastProgram */0];
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, match[/* lastElementArrayBuffer */1]);
	  gl.bindBuffer(gl.ARRAY_BUFFER, match[/* lastArrayBuffer */2]);
	  if (lastProgram !== undefined) {
	    gl.useProgram(valFromOption(lastProgram));
	  }
	  if (lastTexture !== undefined) {
	    gl.bindTexture(gl.TEXTURE_2D, valFromOption(lastTexture));
	  }
	  if (match[/* lastIsEnableDepthTest */4]) {
	    gl.enable(gl.DEPTH_TEST);
	  } else {
	    gl.disable(gl.DEPTH_TEST);
	  }
	  if (match[/* lastIsEnableBlend */5]) {
	    gl.enable(gl.BLEND);
	  } else {
	    gl.disable(gl.BLEND);
	  }
	  return record;
	}

	function _buildGroupedDrawDataArr(record) {
	  var fontTextureDrawData = getFontTextureDrawData(record);
	  var customTextureDrawDataMap = getCustomTextureDrawDataMap(record);
	  var match = reduceOneParam((function (param, drawData) {
	          var baseIndex = getBaseIndex(param[0]) + param[1] | 0;
	          return /* tuple */[
	                  drawData[/* verticeArr */2],
	                  baseIndex,
	                  push$1(/* record */[
	                        /* drawType */drawData[/* drawType */0],
	                        /* customTexture */drawData[/* customTexture */1],
	                        /* verticeArr */drawData[/* verticeArr */2],
	                        /* colorArr */drawData[/* colorArr */3],
	                        /* texCoordArr */drawData[/* texCoordArr */4],
	                        /* indexArr */drawData[/* indexArr */5].map((function (index) {
	                                return index + baseIndex | 0;
	                              }))
	                      ], param[2])
	                ];
	        }), /* tuple */[
	        fontTextureDrawData[/* verticeArr */2],
	        0,
	        /* array */[]
	      ], values(customTextureDrawDataMap));
	  return /* tuple */[
	          record,
	          concatArrays(/* array */[
	                /* array */[fontTextureDrawData],
	                match[2]
	              ])
	        ];
	}

	function _finish(gl, param, data) {
	  var record = _1(param[0], data);
	  _unbindVAO(gl);
	  var record$1 = _backupGlState(gl, record);
	  var match = _buildGroupedDrawDataArr(record$1);
	  var match$1 = bufferAllData(gl, match[1], match[0]);
	  var record$2 = match$1[0];
	  var match$2 = unsafeGetWebglData(record$2);
	  gl.useProgram(match$2[/* program */0]);
	  _setGlState(gl);
	  return _2(param[1], _restoreGlState(gl, _draw(gl, match$1[1], record$2)), data);
	}

	function getCustomData$2(param) {
	  return param[/* imguiFuncData */5][/* customDataForIMGUIFunc */1];
	}

	function _clearData(record) {
	  return /* record */[
	          /* setting */record[/* setting */0],
	          /* assetData */record[/* assetData */1],
	          /* fontData */record[/* fontData */2],
	          /* webglData */record[/* webglData */3],
	          /* drawData */record[/* drawData */4],
	          /* imguiFuncData */record[/* imguiFuncData */5],
	          /* controlData : record */[
	            /* radioButtonData : record */[/* isSelectedMap */createEmpty(/* () */0)],
	            /* checkboxData : record */[
	              /* index */0,
	              /* isSelectedMap */createEmpty$2(/* () */0)
	            ],
	            /* sliderData : record */[
	              /* index */0,
	              /* valueMap */createEmpty$2(/* () */0)
	            ]
	          ],
	          /* ioData */record[/* ioData */7],
	          /* layoutData : record */[/* groupData : record */[
	              /* positionArr : array */[],
	              /* index */0
	            ]]
	        ];
	}

	function getIMGUIFunc$2(param) {
	  return param[/* imguiFuncData */5][/* imguiFunc */0];
	}

	function setIMGUIFunc$3(customData, func, record) {
	  var init = record[/* imguiFuncData */5];
	  return _clearData(/* record */[
	              /* setting */record[/* setting */0],
	              /* assetData */record[/* assetData */1],
	              /* fontData */record[/* fontData */2],
	              /* webglData */record[/* webglData */3],
	              /* drawData */record[/* drawData */4],
	              /* imguiFuncData : record */[
	                /* imguiFunc */some$1(func),
	                /* customDataForIMGUIFunc */some$1(customData),
	                /* apiJsObj */init[/* apiJsObj */2]
	              ],
	              /* controlData */record[/* controlData */6],
	              /* ioData */record[/* ioData */7],
	              /* layoutData */record[/* layoutData */8]
	            ]);
	}

	function _buildAPIJsObj() {
	  return {
	          label: label$2,
	          image: image$2,
	          button: button$1,
	          box: box$1,
	          radioButton: radioButton$1,
	          checkbox: checkbox$1,
	          sliderInt: sliderInt$1,
	          sliderFloat: sliderFloat$1,
	          beginGroup: beginGroup$2,
	          endGroup: endGroup$2
	        };
	}

	function _exec(apiJsObj, getRecordFunc, data) {
	  var record = _1(getRecordFunc, data);
	  var match = getIMGUIFunc$2(record);
	  if (match !== undefined) {
	    return valFromOption(match)(unsafeGet$3(record[/* imguiFuncData */5][/* customDataForIMGUIFunc */1]), apiJsObj, data);
	  } else {
	    return data;
	  }
	}

	function render$1(gl, ioData, apiJsObj, param, data) {
	  var setRecordFunc = param[1];
	  var getRecordFunc = param[0];
	  var record = _1(getRecordFunc, data);
	  var match = !isLoadAsset(record);
	  if (match) {
	    return data;
	  } else {
	    return _finish(gl, /* tuple */[
	                getRecordFunc,
	                setRecordFunc
	              ], _exec(apiJsObj, getRecordFunc, _prepare(ioData, /* tuple */[
	                        getRecordFunc,
	                        setRecordFunc
	                      ], data)));
	  }
	}

	function createRecord$1() {
	  return /* record */[
	          /* setting : record */[
	            /* textColor : array */[
	              1,
	              1,
	              1
	            ],
	            /* fontTexUvForWhite : array */[
	              0,
	              0
	            ],
	            /* buttonSetting : record */[
	              /* buttonColor : array */[
	                0.35,
	                0.1,
	                0.1
	              ],
	              /* hoverButtonColor : array */[
	                0.40,
	                0.1,
	                0.1
	              ],
	              /* clickButtonColor : array */[
	                0.50,
	                0.1,
	                0.1
	              ]
	            ],
	            /* radioButtonSetting : record */[
	              /* radioButtonOuterColor : array */[
	                0.3,
	                0.3,
	                0.3
	              ],
	              /* radioButtonInnerColor : array */[
	                0.15,
	                0.15,
	                0.15
	              ],
	              /* radioButtonOuterColorHover : array */[
	                0.33,
	                0.33,
	                0.33
	              ],
	              /* radioButtonInnerColorHover : array */[
	                0.18,
	                0.18,
	                0.18
	              ],
	              /* radioButtonCircleSegments */9,
	              /* radioButtonInnerRadius */0.6,
	              /* radioButtonOuterRadius */1
	            ],
	            /* checkboxSetting : record */[
	              /* checkboxOuterColor : array */[
	                0.3,
	                0.3,
	                0.3
	              ],
	              /* checkboxInnerColor : array */[
	                0.15,
	                0.15,
	                0.15
	              ],
	              /* checkboxOuterColorHover : array */[
	                0.33,
	                0.33,
	                0.33
	              ],
	              /* checkboxInnerColorHover : array */[
	                0.18,
	                0.18,
	                0.18
	              ],
	              /* checkboxInnerSizeRatio */1.4,
	              /* checkboxOuterSizeRatio */2
	            ],
	            /* sliderSetting : record */[
	              /* sliderBackgroundColor : array */[
	                0.16,
	                0.16,
	                0.16
	              ],
	              /* sliderFillColor : array */[
	                0,
	                0.3,
	                0.6
	              ],
	              /* sliderBackgroundColorHover : array */[
	                0.19,
	                0.19,
	                0.19
	              ],
	              /* sliderFillColorHover : array */[
	                0,
	                0.3,
	                0.7
	              ]
	            ]
	          ],
	          /* assetData : record */[
	            /* fntId */"fnt",
	            /* bitmapId */"bitmap",
	            /* fntDataMap */createEmpty(/* () */0),
	            /* bitmapMap */createEmpty(/* () */0),
	            /* customImageArr : array */[],
	            /* customTextureMap */createEmpty(/* () */0)
	          ],
	          /* fontData */undefined,
	          /* webglData */undefined,
	          /* drawData */_createEmptyDrawData(/* () */0),
	          /* imguiFuncData : record */[
	            /* imguiFunc */undefined,
	            /* customDataForIMGUIFunc */undefined,
	            /* apiJsObj */_buildAPIJsObj(/* () */0)
	          ],
	          /* controlData : record */[
	            /* radioButtonData : record */[/* isSelectedMap */createEmpty(/* () */0)],
	            /* checkboxData : record */[
	              /* index */0,
	              /* isSelectedMap */createEmpty$2(/* () */0)
	            ],
	            /* sliderData : record */[
	              /* index */0,
	              /* valueMap */createEmpty$2(/* () */0)
	            ]
	          ],
	          /* ioData : record */[
	            /* pointUp */false,
	            /* pointDown */false,
	            /* pointPosition : tuple */[
	              0,
	              0
	            ],
	            /* pointMovementDelta : tuple */[
	              0,
	              0
	            ]
	          ],
	          /* layoutData : record */[/* groupData : record */[
	              /* positionArr : array */[],
	              /* index */0
	            ]]
	        ];
	}


	/* Js_dict Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function getSetting$3(record) {
	  var match = getSetting$4(record);
	  var sliderSetting = match[/* sliderSetting */5];
	  var checkboxSetting = match[/* checkboxSetting */4];
	  var radioButtonSetting = match[/* radioButtonSetting */3];
	  var buttonSetting = match[/* buttonSetting */2];
	  var buttonSettingJsObj = {
	    buttonColor: buttonSetting[/* buttonColor */0],
	    hoverButtonColor: buttonSetting[/* hoverButtonColor */1],
	    clickButtonColor: buttonSetting[/* clickButtonColor */2]
	  };
	  var radioButtonSettingJsObj = {
	    radioButtonOuterColor: radioButtonSetting[/* radioButtonOuterColor */0],
	    radioButtonInnerColor: radioButtonSetting[/* radioButtonInnerColor */1],
	    radioButtonOuterColorHover: radioButtonSetting[/* radioButtonOuterColorHover */2],
	    radioButtonInnerColorHover: radioButtonSetting[/* radioButtonInnerColorHover */3],
	    radioButtonCircleSegments: radioButtonSetting[/* radioButtonCircleSegments */4],
	    radioButtonInnerRadius: radioButtonSetting[/* radioButtonInnerRadius */5],
	    radioButtonOuterRadius: radioButtonSetting[/* radioButtonOuterRadius */6]
	  };
	  var checkboxSettingJsObj = {
	    checkboxOuterColor: checkboxSetting[/* checkboxOuterColor */0],
	    checkboxInnerColor: checkboxSetting[/* checkboxInnerColor */1],
	    checkboxOuterColorHover: checkboxSetting[/* checkboxOuterColorHover */2],
	    checkboxInnerColorHover: checkboxSetting[/* checkboxInnerColorHover */3],
	    checkboxInnerSizeRatio: checkboxSetting[/* checkboxInnerSizeRatio */4],
	    checkboxOuterSizeRatio: checkboxSetting[/* checkboxOuterSizeRatio */5]
	  };
	  var sliderSettingJsObj = {
	    sliderBackgroundColor: sliderSetting[/* sliderBackgroundColor */0],
	    sliderFillColor: sliderSetting[/* sliderFillColor */1],
	    sliderBackgroundColorHover: sliderSetting[/* sliderBackgroundColorHover */2],
	    sliderFillColorHover: sliderSetting[/* sliderFillColorHover */3]
	  };
	  return {
	          textColor: match[/* textColor */0],
	          buttonSetting: buttonSettingJsObj,
	          radioButtonSetting: radioButtonSettingJsObj,
	          checkboxSetting: checkboxSettingJsObj,
	          sliderSetting: sliderSettingJsObj,
	          fontTexUvForWhite: match[/* fontTexUvForWhite */1]
	        };
	}

	function setSetting$2(settingJsObj, record) {
	  var buttonSettingJsObj = settingJsObj.buttonSetting;
	  var radioButtonSettingJsObj = settingJsObj.radioButtonSetting;
	  var checkboxSettingJsObj = settingJsObj.checkboxSetting;
	  var sliderSettingJsObj = settingJsObj.sliderSetting;
	  var buttonSetting_000 = /* buttonColor */buttonSettingJsObj.buttonColor;
	  var buttonSetting_001 = /* hoverButtonColor */buttonSettingJsObj.hoverButtonColor;
	  var buttonSetting_002 = /* clickButtonColor */buttonSettingJsObj.clickButtonColor;
	  var buttonSetting = /* record */[
	    buttonSetting_000,
	    buttonSetting_001,
	    buttonSetting_002
	  ];
	  var radioButtonSetting_000 = /* radioButtonOuterColor */radioButtonSettingJsObj.radioButtonOuterColor;
	  var radioButtonSetting_001 = /* radioButtonInnerColor */radioButtonSettingJsObj.radioButtonInnerColor;
	  var radioButtonSetting_002 = /* radioButtonOuterColorHover */radioButtonSettingJsObj.radioButtonOuterColorHover;
	  var radioButtonSetting_003 = /* radioButtonInnerColorHover */radioButtonSettingJsObj.radioButtonInnerColorHover;
	  var radioButtonSetting_004 = /* radioButtonCircleSegments */radioButtonSettingJsObj.radioButtonCircleSegments;
	  var radioButtonSetting_005 = /* radioButtonInnerRadius */radioButtonSettingJsObj.radioButtonInnerRadius;
	  var radioButtonSetting_006 = /* radioButtonOuterRadius */radioButtonSettingJsObj.radioButtonOuterRadius;
	  var radioButtonSetting = /* record */[
	    radioButtonSetting_000,
	    radioButtonSetting_001,
	    radioButtonSetting_002,
	    radioButtonSetting_003,
	    radioButtonSetting_004,
	    radioButtonSetting_005,
	    radioButtonSetting_006
	  ];
	  var checkboxSetting_000 = /* checkboxOuterColor */checkboxSettingJsObj.checkboxOuterColor;
	  var checkboxSetting_001 = /* checkboxInnerColor */checkboxSettingJsObj.checkboxInnerColor;
	  var checkboxSetting_002 = /* checkboxOuterColorHover */checkboxSettingJsObj.checkboxOuterColorHover;
	  var checkboxSetting_003 = /* checkboxInnerColorHover */checkboxSettingJsObj.checkboxInnerColorHover;
	  var checkboxSetting_004 = /* checkboxInnerSizeRatio */checkboxSettingJsObj.checkboxInnerSizeRatio;
	  var checkboxSetting_005 = /* checkboxOuterSizeRatio */checkboxSettingJsObj.checkboxOuterSizeRatio;
	  var checkboxSetting = /* record */[
	    checkboxSetting_000,
	    checkboxSetting_001,
	    checkboxSetting_002,
	    checkboxSetting_003,
	    checkboxSetting_004,
	    checkboxSetting_005
	  ];
	  var sliderSetting_000 = /* sliderBackgroundColor */sliderSettingJsObj.sliderBackgroundColor;
	  var sliderSetting_001 = /* sliderFillColor */sliderSettingJsObj.sliderFillColor;
	  var sliderSetting_002 = /* sliderBackgroundColorHover */sliderSettingJsObj.sliderBackgroundColorHover;
	  var sliderSetting_003 = /* sliderFillColorHover */sliderSettingJsObj.sliderFillColorHover;
	  var sliderSetting = /* record */[
	    sliderSetting_000,
	    sliderSetting_001,
	    sliderSetting_002,
	    sliderSetting_003
	  ];
	  return setSetting$3(/* record */[
	              /* textColor */settingJsObj.textColor,
	              /* fontTexUvForWhite */settingJsObj.fontTexUvForWhite,
	              /* buttonSetting */buttonSetting,
	              /* radioButtonSetting */radioButtonSetting,
	              /* checkboxSetting */checkboxSetting,
	              /* sliderSetting */sliderSetting
	            ], record);
	}

	var sendUniformProjectionMatData$2 = sendUniformProjectionMatData$3;

	var init$6 = init$7;

	var getCustomData$1 = getCustomData$2;

	var getIMGUIFunc$1 = getIMGUIFunc$2;

	var setIMGUIFunc$2 = setIMGUIFunc$3;


	/* ManageIMGUIService-WonderImgui Not a pure module */

	function getWonderIMGUIRecord(state) {
	  return state[/* imguiRecord */43][/* wonderImguiIMGUIRecord */1];
	}

	function getIOData$1(state) {
	  return state[/* imguiRecord */43][/* ioData */0];
	}

	function create$34() {
	  return /* record */[
	          /* ioData : record */[
	            /* pointUp */false,
	            /* pointDown */false,
	            /* pointPosition : tuple */[
	              0,
	              0
	            ],
	            /* pointMovementDelta : tuple */[
	              0,
	              0
	            ]
	          ],
	          /* wonderImguiIMGUIRecord */createRecord$1(/* () */0)
	        ];
	}

	function setControlDataFromRenderWorker(imguiData, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* imguiRecord */43];
	  newrecord[/* imguiRecord */43] = /* record */[
	    /* ioData */init[/* ioData */0],
	    /* wonderImguiIMGUIRecord */setControlData(imguiData.controlData, state[/* imguiRecord */43][/* wonderImguiIMGUIRecord */1])
	  ];
	  return newrecord;
	}


	/* ManageIMGUIService-WonderImgui Not a pure module */

	function getIMGUIFunc(state) {
	  return getIMGUIFunc$1(getWonderIMGUIRecord(state));
	}

	function setIMGUIFunc$1(customData, func, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* imguiRecord */43];
	  newrecord[/* imguiRecord */43] = /* record */[
	    /* ioData */init[/* ioData */0],
	    /* wonderImguiIMGUIRecord */setIMGUIFunc$2(customData, func, getWonderIMGUIRecord(state))
	  ];
	  return newrecord;
	}

	function getCustomData(state) {
	  return getCustomData$1(getWonderIMGUIRecord(state));
	}

	function getCanvasSize(param) {
	  var viewRecord = param[/* viewRecord */9];
	  var match = getCanvas(viewRecord);
	  if (match !== undefined) {
	    var canvas = valFromOption(match);
	    return /* tuple */[
	            canvas.width,
	            canvas.height
	          ];
	  } else {
	    return /* tuple */[
	            0,
	            0
	          ];
	  }
	}

	var getRecord$12 = getWonderIMGUIRecord;

	function setRecord(record, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* imguiRecord */43];
	  newrecord[/* imguiRecord */43] = /* record */[
	    /* ioData */init[/* ioData */0],
	    /* wonderImguiIMGUIRecord */record
	  ];
	  return newrecord;
	}

	function sendUniformProjectionMatData$1(gl, canvasSize, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* programRecord */29] = clearLastSendProgram(state[/* programRecord */29]);
	  var init = state[/* imguiRecord */43];
	  newrecord[/* imguiRecord */43] = /* record */[
	    /* ioData */init[/* ioData */0],
	    /* wonderImguiIMGUIRecord */sendUniformProjectionMatData$2(gl, canvasSize, getWonderIMGUIRecord(state))
	  ];
	  return newrecord;
	}


	/* ViewService-Wonderjs Not a pure module */

	function label$1(rect, str, align, state) {
	  var __x = label$2(rect, str, align, getRecord$12(state));
	  return setRecord(__x, state);
	}

	function image$1(rect, uv, id, state) {
	  var __x = image$2(rect, uv, id, getRecord$12(state));
	  return setRecord(__x, state);
	}

	function button(rect, str, state) {
	  var match = button$1(rect, str, getRecord$12(state));
	  return /* tuple */[
	          setRecord(match[0], state),
	          match[1]
	        ];
	}

	function box(rect, color, state) {
	  var __x = box$1(rect, color, getRecord$12(state));
	  return setRecord(__x, state);
	}

	function radioButton(groupDataArr, defaultSelectIndex, group, state) {
	  var match = radioButton$1(groupDataArr, defaultSelectIndex, group, getRecord$12(state));
	  return /* tuple */[
	          setRecord(match[0], state),
	          match[1]
	        ];
	}

	function checkbox(rect, defaultIsSelected, str, state) {
	  var match = checkbox$1(rect, defaultIsSelected, str, getRecord$12(state));
	  return /* tuple */[
	          setRecord(match[0], state),
	          match[1]
	        ];
	}

	function sliderInt(param, param$1, param$2, state) {
	  var match = sliderInt$1(/* tuple */[
	        param[0],
	        param[1]
	      ], /* tuple */[
	        param$1[0],
	        param$1[1]
	      ], /* tuple */[
	        param$2[0],
	        param$2[1]
	      ], getRecord$12(state));
	  return /* tuple */[
	          setRecord(match[0], state),
	          match[1],
	          match[2]
	        ];
	}

	function sliderFloat(param, param$1, param$2, state) {
	  var match = sliderFloat$1(/* tuple */[
	        param[0],
	        param[1]
	      ], /* tuple */[
	        param$1[0],
	        param$1[1],
	        param$1[2]
	      ], /* tuple */[
	        param$2[0],
	        param$2[1]
	      ], getRecord$12(state));
	  return /* tuple */[
	          setRecord(match[0], state),
	          match[1],
	          match[2]
	        ];
	}

	function beginGroup(position, state) {
	  var __x = beginGroup$1(position, getRecord$12(state));
	  return setRecord(__x, state);
	}

	function endGroup(state) {
	  var __x = endGroup$1(getRecord$12(state));
	  return setRecord(__x, state);
	}


	/* GroupLayoutIMGUIAPI-WonderImgui Not a pure module */

	function getAPIJsObj$1(state) {
	  return state[/* apiRecord */44][/* apiJsObj */0];
	}

	function create$19() {
	  return /* record */[/* apiJsObj */{
	            label: label$1,
	            image: image$1,
	            button: button,
	            box: box,
	            radioButton: radioButton,
	            checkbox: checkbox,
	            sliderInt: sliderInt,
	            sliderFloat: sliderFloat,
	            beginGroup: beginGroup,
	            endGroup: endGroup,
	            unsafeGetGameObjectTransformComponent: unsafeGetGameObjectTransformComponent$1,
	            unsafeGetGameObjectLightMaterialComponent: unsafeGetGameObjectLightMaterialComponent$1,
	            unsafeGetGameObjectPerspectiveCameraProjectionComponent: unsafeGetGameObjectPerspectiveCameraProjectionComponent$1,
	            unsafeGetGameObjectBasicCameraViewComponent: unsafeGetGameObjectBasicCameraViewComponent$1,
	            setLightMaterialDiffuseColor: setLightMaterialDiffuseColor$1,
	            getLightMaterialSpecularColor: getLightMaterialSpecularColor$1,
	            setLightMaterialSpecularColor: setLightMaterialSpecularColor$1,
	            getLightMaterialShininess: getLightMaterialShininess$1,
	            setLightMaterialShininess: setLightMaterialShininess$1,
	            getTransformLocalPosition: getTransformLocalPosition$1,
	            setTransformLocalPosition: setTransformLocalPosition$1,
	            getTransformPosition: getTransformPosition$1,
	            unsafeGetTransformChildren: unsafeGetTransformChildren$1,
	            unsafeGetTransformGameObject: unsafeGetTransformGameObject$1,
	            convertWorldToScreen: convertWorldToScreen$1,
	            getRenderWorkerCustomData: getRenderWorkerCustomData$1
	          }];
	}


	/* TransformAPI-Wonderjs Not a pure module */

	function create$35() {
	  return /* record */[
	          /* programMap */createEmpty$2(/* () */0),
	          /* lastUsedProgram */undefined
	        ];
	}


	/* No side effect */

	function create$36() {
	  return /* record */[
	          /* canvasId */undefined,
	          /* memory */undefined,
	          /* buffer */undefined,
	          /* isDebug */undefined,
	          /* context */undefined,
	          /* gpu */undefined,
	          /* worker */undefined
	        ];
	}


	/* No side effect */

	var _createSpecialKeyMap = function (){
	  var resultMap = [];
	  var special_key_map = {
	            8: "backspace",
	            9: "tab",
	            10: "return",
	            13: "return",
	            16: "shift",
	            17: "ctrl",
	            18: "alt",
	            19: "pause",
	            20: "capslock",
	            27: "esc",
	            32: "space",
	            33: "pageup",
	            34: "pagedown",
	            35: "end",
	            36: "home",
	            37: "left",
	            38: "up",
	            39: "right",
	            40: "down",
	            45: "insert",
	            46: "del",
	            59: ";",
	            61: "=",
	            65: "a",
	            66: "b",
	            67: "c",
	            68: "d",
	            69: "e",
	            70: "f",
	            71: "g",
	            72: "h",
	            73: "i",
	            74: "j",
	            75: "k",
	            76: "l",
	            77: "m",
	            78: "n",
	            79: "o",
	            80: "p",
	            81: "q",
	            82: "r",
	            83: "s",
	            84: "t",
	            85: "u",
	            86: "v",
	            87: "w",
	            88: "x",
	            89: "y",
	            90: "z",
	            96: "0",
	            97: "1",
	            98: "2",
	            99: "3",
	            100: "4",
	            101: "5",
	            102: "6",
	            103: "7",
	            104: "8",
	            105: "9",
	            106: "*",
	            107: "+",
	            109: "-",
	            110: ".",
	            111: "/",
	            112: "f1",
	            113: "f2",
	            114: "f3",
	            115: "f4",
	            116: "f5",
	            117: "f6",
	            118: "f7",
	            119: "f8",
	            120: "f9",
	            121: "f10",
	            122: "f11",
	            123: "f12",
	            144: "numlock",
	            145: "scroll",
	            173: "-",
	            186: ";",
	            187: "=",
	            188: ",",
	            189: "-",
	            190: ".",
	            191: "/",
	            192: "`",
	            219: "[",
	            220: "\\",
	            221: "]",
	            222: "'"
	        };

	        for(let key in special_key_map){
	          if(special_key_map.hasOwnProperty(key)){
	resultMap[key] = special_key_map[key];
	          }
	        }

	        return resultMap;
	  };

	var _createShiftKeyByKeyCodeMap = function (){
	  var resultMap = [];
	  var map$$1 = {
	            59: ":",
	            61: "+",
	            65: "A",
	            66: "B",
	            67: "C",
	            68: "D",
	            69: "E",
	            70: "F",
	            71: "G",
	            72: "H",
	            73: "I",
	            74: "J",
	            75: "K",
	            76: "L",
	            77: "M",
	            78: "N",
	            79: "O",
	            80: "P",
	            81: "Q",
	            82: "R",
	            83: "S",
	            84: "T",
	            85: "U",
	            86: "V",
	            87: "W",
	            88: "X",
	            89: "Y",
	            90: "Z",
	            96: ")",
	            97: "!",
	            98: "@",
	            99: "#",
	            100: "$",
	            101: "%",
	            102: "^",
	            103: "&",
	            104: "*",
	            105: "(",
	            173: "_",
	            186: ":",
	            187: "+",
	            188: "<",
	            189: "_",
	            190: ">",
	            191: "?",
	            192: "~",
	            219: "{",
	            220: "|",
	            221: "}",
	            222: "\""
	        };

	        for(let key in map$$1){
	          if(map$$1.hasOwnProperty(key)){
	resultMap[key] = map$$1[key];
	          }
	        }

	        return resultMap;
	  };

	var _createShiftKeyByCharCodeMap = function (){
	  return {
	            "`": "~",
	            "1": "!",
	            "2": "@",
	            "3": "#",
	            "4": "$",
	            "5": "%",
	            "6": "^",
	            "7": "&",
	            "8": "*",
	            "9": "(",
	            "0": ")",
	            "-": "_",
	            "=": "+",
	            ";": ":",
	            "'": "\"",
	            ",": "<",
	            ".": ">",
	            "/": "?",
	            "\\": "|"
	        }
	  };

	function create$37() {
	  return /* record */[
	          /* domEventStreamSubscription */undefined,
	          /* mouseDomEventDataArrMap */createEmpty$2(/* () */0),
	          /* keyboardDomEventDataArrMap */createEmpty$2(/* () */0),
	          /* touchDomEventDataArrMap */createEmpty$2(/* () */0),
	          /* customGlobalEventArrMap */createEmpty(/* () */0),
	          /* customGameObjectEventArrMap */createEmpty(/* () */0),
	          /* mouseEventData : record */[
	            /* lastX */undefined,
	            /* lastY */undefined,
	            /* isDrag */false
	          ],
	          /* keyboardEventData : record */[
	            /* specialKeyMap */_createSpecialKeyMap(),
	            /* shiftKeyByKeyCodeMap */_createShiftKeyByKeyCodeMap(),
	            /* shiftKeyByCharCodeMap */_createShiftKeyByCharCodeMap()
	          ],
	          /* touchEventData : record */[
	            /* lastX */undefined,
	            /* lastY */undefined,
	            /* isDrag */false
	          ]
	        ];
	}

	function _deepCopyDomEventArrMap(domEventArrMap) {
	  return copy$3(domEventArrMap).map((function (arr) {
	                return arr.slice();
	              }));
	}

	function _deepCopyCustomGlobalEventArrMap(customGlobalEventArrMap) {
	  return map(copy$3, customGlobalEventArrMap);
	}

	function _deepCopyCustomGameObjectEventArrMap(customGameObjectEventArrMap) {
	  return map((function (eventArrMap) {
	                return copy$3(eventArrMap).map((function (arr) {
	                              return arr.slice();
	                            }));
	              }), customGameObjectEventArrMap);
	}

	function deepCopyForRestore$15(state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */_deepCopyDomEventArrMap(eventRecord[/* mouseDomEventDataArrMap */1]),
	    /* keyboardDomEventDataArrMap */_deepCopyDomEventArrMap(eventRecord[/* keyboardDomEventDataArrMap */2]),
	    /* touchDomEventDataArrMap */_deepCopyDomEventArrMap(eventRecord[/* touchDomEventDataArrMap */3]),
	    /* customGlobalEventArrMap */_deepCopyCustomGlobalEventArrMap(eventRecord[/* customGlobalEventArrMap */4]),
	    /* customGameObjectEventArrMap */_deepCopyCustomGameObjectEventArrMap(eventRecord[/* customGameObjectEventArrMap */5]),
	    /* mouseEventData : record */[
	      /* lastX */undefined,
	      /* lastY */undefined,
	      /* isDrag */false
	    ],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData : record */[
	      /* lastX */undefined,
	      /* lastY */undefined,
	      /* isDrag */false
	    ]
	  ];
	  return newrecord;
	}


	/* Js_dict Not a pure module */

	function create$38() {
	  return /* record */[
	          /* extensionInstancedArrays */undefined,
	          /* precision */undefined,
	          /* maxTextureUnit */undefined
	        ];
	}


	/* No side effect */

	function create$39() {
	  return /* record */[
	          /* boxGeometryVertexBufferMap */createEmpty$2(/* () */0),
	          /* boxGeometryTexCoordBufferMap */createEmpty$2(/* () */0),
	          /* boxGeometryNormalBufferMap */createEmpty$2(/* () */0),
	          /* boxGeometryElementArrayBufferMap */createEmpty$2(/* () */0),
	          /* customGeometryVertexBufferMap */createEmpty$2(/* () */0),
	          /* customGeometryTexCoordBufferMap */createEmpty$2(/* () */0),
	          /* customGeometryNormalBufferMap */createEmpty$2(/* () */0),
	          /* customGeometryElementArrayBufferMap */createEmpty$2(/* () */0),
	          /* matrixInstanceBufferMap */createEmpty$2(/* () */0),
	          /* vertexArrayBufferPool */createEmpty$1(/* () */0),
	          /* elementArrayBufferPool */createEmpty$1(/* () */0),
	          /* matrixInstanceBufferPool */createEmpty$1(/* () */0)
	        ];
	}

	function deepCopyForRestore$16() {
	  return /* record */[
	          /* boxGeometryVertexBufferMap : array */[],
	          /* boxGeometryTexCoordBufferMap : array */[],
	          /* boxGeometryNormalBufferMap : array */[],
	          /* boxGeometryElementArrayBufferMap : array */[],
	          /* customGeometryVertexBufferMap : array */[],
	          /* customGeometryTexCoordBufferMap : array */[],
	          /* customGeometryNormalBufferMap : array */[],
	          /* customGeometryElementArrayBufferMap : array */[],
	          /* matrixInstanceBufferMap : array */[],
	          /* vertexArrayBufferPool : array */[],
	          /* elementArrayBufferPool : array */[],
	          /* matrixInstanceBufferPool : array */[]
	        ];
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function create$40() {
	  return /* record */[
	          /* uid */0,
	          /* nameMap */createEmpty$2(/* () */0),
	          /* disposeCount */0,
	          /* disposedUidMap */createEmpty$2(/* () */0),
	          /* disposedUidArray */createEmpty$1(/* () */0),
	          /* disposedUidArrayForKeepOrder */createEmpty$1(/* () */0),
	          /* disposedBasicCameraViewArray */createEmpty$1(/* () */0),
	          /* disposedTransformArray */createEmpty$1(/* () */0),
	          /* disposedTransformArrayForKeepOrder */createEmpty$1(/* () */0),
	          /* disposedPerspectiveCameraProjectionArray */createEmpty$1(/* () */0),
	          /* disposedArcballCameraControllerArray */createEmpty$1(/* () */0),
	          /* disposedBasicMaterialArray */createEmpty$1(/* () */0),
	          /* disposedLightMaterialArray */createEmpty$1(/* () */0),
	          /* disposedBoxGeometryArray */createEmpty$1(/* () */0),
	          /* disposedCustomGeometryArray */createEmpty$1(/* () */0),
	          /* disposedSourceInstanceArray */createEmpty$1(/* () */0),
	          /* disposedObjectInstanceArray */createEmpty$1(/* () */0),
	          /* disposedDirectionLightArray */createEmpty$1(/* () */0),
	          /* disposedPointLightArray */createEmpty$1(/* () */0),
	          /* disposedMeshRendererComponentArray */createEmpty$1(/* () */0),
	          /* aliveUidArray */createEmpty$1(/* () */0),
	          /* geometryDataMap */createEmpty$2(/* () */0),
	          /* transformMap */createEmpty$2(/* () */0),
	          /* basicCameraViewMap */createEmpty$2(/* () */0),
	          /* perspectiveCameraProjectionMap */createEmpty$2(/* () */0),
	          /* arcballCameraControllerMap */createEmpty$2(/* () */0),
	          /* meshRendererMap */createEmpty$2(/* () */0),
	          /* basicMaterialMap */createEmpty$2(/* () */0),
	          /* lightMaterialMap */createEmpty$2(/* () */0),
	          /* sourceInstanceMap */createEmpty$2(/* () */0),
	          /* objectInstanceMap */createEmpty$2(/* () */0),
	          /* directionLightMap */createEmpty$2(/* () */0),
	          /* pointLightMap */createEmpty$2(/* () */0)
	        ];
	}

	function deepCopyForRestore$17(record) {
	  var uid = record[/* uid */0];
	  var nameMap = record[/* nameMap */1];
	  var disposeCount = record[/* disposeCount */2];
	  var disposedUidMap = record[/* disposedUidMap */3];
	  var disposedUidArray = record[/* disposedUidArray */4];
	  var disposedUidArrayForKeepOrder = record[/* disposedUidArrayForKeepOrder */5];
	  var disposedBasicCameraViewArray = record[/* disposedBasicCameraViewArray */6];
	  var disposedTransformArray = record[/* disposedTransformArray */7];
	  var disposedTransformArrayForKeepOrder = record[/* disposedTransformArrayForKeepOrder */8];
	  var disposedPerspectiveCameraProjectionArray = record[/* disposedPerspectiveCameraProjectionArray */9];
	  var disposedBasicMaterialArray = record[/* disposedBasicMaterialArray */11];
	  var disposedLightMaterialArray = record[/* disposedLightMaterialArray */12];
	  var disposedBoxGeometryArray = record[/* disposedBoxGeometryArray */13];
	  var disposedCustomGeometryArray = record[/* disposedCustomGeometryArray */14];
	  var disposedSourceInstanceArray = record[/* disposedSourceInstanceArray */15];
	  var disposedObjectInstanceArray = record[/* disposedObjectInstanceArray */16];
	  var disposedDirectionLightArray = record[/* disposedDirectionLightArray */17];
	  var disposedPointLightArray = record[/* disposedPointLightArray */18];
	  var disposedMeshRendererComponentArray = record[/* disposedMeshRendererComponentArray */19];
	  var aliveUidArray = record[/* aliveUidArray */20];
	  var geometryDataMap = record[/* geometryDataMap */21];
	  var transformMap = record[/* transformMap */22];
	  var basicCameraViewMap = record[/* basicCameraViewMap */23];
	  var perspectiveCameraProjectionMap = record[/* perspectiveCameraProjectionMap */24];
	  var arcballCameraControllerMap = record[/* arcballCameraControllerMap */25];
	  var meshRendererMap = record[/* meshRendererMap */26];
	  var basicMaterialMap = record[/* basicMaterialMap */27];
	  var lightMaterialMap = record[/* lightMaterialMap */28];
	  var sourceInstanceMap = record[/* sourceInstanceMap */29];
	  var objectInstanceMap = record[/* objectInstanceMap */30];
	  var directionLightMap = record[/* directionLightMap */31];
	  var pointLightMap = record[/* pointLightMap */32];
	  return /* record */[
	          /* uid */uid,
	          /* nameMap */copy$3(nameMap),
	          /* disposeCount */disposeCount,
	          /* disposedUidMap */copy$3(disposedUidMap),
	          /* disposedUidArray */copy$3(disposedUidArray),
	          /* disposedUidArrayForKeepOrder */copy$3(disposedUidArrayForKeepOrder),
	          /* disposedBasicCameraViewArray */copy$3(disposedBasicCameraViewArray),
	          /* disposedTransformArray */copy$3(disposedTransformArray),
	          /* disposedTransformArrayForKeepOrder */copy$3(disposedTransformArrayForKeepOrder),
	          /* disposedPerspectiveCameraProjectionArray */copy$3(disposedPerspectiveCameraProjectionArray),
	          /* disposedArcballCameraControllerArray */copy$3(disposedPerspectiveCameraProjectionArray),
	          /* disposedBasicMaterialArray */copy$3(disposedBasicMaterialArray),
	          /* disposedLightMaterialArray */copy$3(disposedLightMaterialArray),
	          /* disposedBoxGeometryArray */copy$3(disposedBoxGeometryArray),
	          /* disposedCustomGeometryArray */copy$3(disposedCustomGeometryArray),
	          /* disposedSourceInstanceArray */copy$3(disposedSourceInstanceArray),
	          /* disposedObjectInstanceArray */copy$3(disposedObjectInstanceArray),
	          /* disposedDirectionLightArray */copy$3(disposedDirectionLightArray),
	          /* disposedPointLightArray */copy$3(disposedPointLightArray),
	          /* disposedMeshRendererComponentArray */copy$3(disposedMeshRendererComponentArray),
	          /* aliveUidArray */copy$3(aliveUidArray),
	          /* geometryDataMap */copy$3(geometryDataMap),
	          /* transformMap */copy$3(transformMap),
	          /* basicCameraViewMap */copy$3(basicCameraViewMap),
	          /* perspectiveCameraProjectionMap */copy$3(perspectiveCameraProjectionMap),
	          /* arcballCameraControllerMap */copy$3(arcballCameraControllerMap),
	          /* meshRendererMap */copy$3(meshRendererMap),
	          /* basicMaterialMap */copy$3(basicMaterialMap),
	          /* lightMaterialMap */copy$3(lightMaterialMap),
	          /* sourceInstanceMap */copy$3(sourceInstanceMap),
	          /* objectInstanceMap */copy$3(objectInstanceMap),
	          /* directionLightMap */copy$3(directionLightMap),
	          /* pointLightMap */copy$3(pointLightMap)
	        ];
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function create$41() {
	  return /* record */[
	          /* float16Array1 */new Float32Array(/* array */[
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1,
	                0,
	                0,
	                0,
	                0,
	                1
	              ]),
	          /* float9Array1 */new Float32Array(/* array */[
	                1,
	                0,
	                0,
	                1,
	                0,
	                0,
	                1,
	                0,
	                0
	              ])
	        ];
	}


	/* No side effect */

	function create$42() {
	  return /* record */[
	          /* mainWorkerData : record */[/* customDataFromMainWorkerToRenderWorker */-1],
	          /* renderWorkerData : record */[/* customDataFromRenderWorkerToMainWorker */-1]
	        ];
	}


	/* No side effect */

	function create$43() {
	  return /* record */[
	          /* attributeLocationMap */createEmpty$2(/* () */0),
	          /* uniformLocationMap */createEmpty$2(/* () */0)
	        ];
	}


	/* No side effect */

	function create$44() {
	  return /* record */[
	          /* isSupportSharedArrayBuffer */false,
	          /* isSupportRenderWorkerAndSharedArrayBuffer */false
	        ];
	}


	/* No side effect */

	function create$45() {
	  return /* record */[
	          /* gl */undefined,
	          /* colorWrite */undefined,
	          /* clearColor */undefined,
	          /* side */undefined,
	          /* depthTest */undefined,
	          /* viewport */undefined
	        ];
	}

	function deepCopyForRestore$18(param) {
	  return /* record */[
	          /* gl */undefined,
	          /* colorWrite */param[/* colorWrite */1],
	          /* clearColor */param[/* clearColor */2],
	          /* side */param[/* side */3],
	          /* depthTest */param[/* depthTest */4],
	          /* viewport */param[/* viewport */5]
	        ];
	}


	/* No side effect */

	function create$46() {
	  return /* record */[
	          /* attributeSendDataMap */createEmpty$2(/* () */0),
	          /* instanceAttributeSendDataMap */createEmpty$2(/* () */0),
	          /* uniformCacheMap */createEmpty$2(/* () */0),
	          /* uniformRenderObjectSendModelDataMap */createEmpty$2(/* () */0),
	          /* uniformRenderObjectSendMaterialDataMap */createEmpty$2(/* () */0),
	          /* uniformShaderSendNoCachableDataMap */createEmpty$2(/* () */0),
	          /* uniformShaderSendCachableDataMap */createEmpty$2(/* () */0),
	          /* uniformShaderSendCachableFunctionDataMap */createEmpty$2(/* () */0),
	          /* uniformInstanceSendNoCachableDataMap */createEmpty$2(/* () */0),
	          /* vertexAttribHistoryArray */createEmpty$1(/* () */0),
	          /* lastSendMaterialData */undefined,
	          /* lastSendGeometryData */undefined
	        ];
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function deepCopyForRestore$19() {
	  return /* record */[
	          /* float32ArrayPoolMap */createEmpty$2(/* () */0),
	          /* uint16ArrayPoolMap */createEmpty$2(/* () */0)
	        ];
	}

	function create$47() {
	  return /* record */[
	          /* float32ArrayPoolMap */createEmpty$2(/* () */0),
	          /* uint16ArrayPoolMap */createEmpty$2(/* () */0)
	        ];
	}


	/* No side effect */

	function create$48() {
	  return /* record */[
	          /* index */0,
	          /* sourceInstanceMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty$1(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0)
	        ];
	}

	function deepCopyForRestore$20(param) {
	  return /* record */[
	          /* index */param[/* index */0],
	          /* sourceInstanceMap */copy$3(param[/* sourceInstanceMap */1]),
	          /* disposedIndexArray */param[/* disposedIndexArray */2].slice(),
	          /* gameObjectMap */copy$3(param[/* gameObjectMap */3])
	        ];
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function create$49() {
	  return /* record */[
	          /* elapsed */0,
	          /* startTime */0,
	          /* deltaTime */0,
	          /* lastTime */undefined,
	          /* gameTime */0,
	          /* fps */0
	        ];
	}


	/* No side effect */

	function create$50() {
	  return /* record */[/* renderWorker */undefined];
	}


	/* No side effect */

	function create$51() {
	  return /* record */[
	          /* index */0,
	          /* gameObjectMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty$1(/* () */0)
	        ];
	}

	function deepCopyForRestore$21(param) {
	  return /* record */[
	          /* index */param[/* index */0],
	          /* gameObjectMap */copy$3(param[/* gameObjectMap */1]),
	          /* disposedIndexArray */param[/* disposedIndexArray */2].slice()
	        ];
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function create$52() {
	  return /* record */[/* browser : Unknown */4];
	}

	function fatalUnknownBrowser(title, browser) {
	  return fatal(buildFatalMessage(title, "unknown browser", "", "", "browser: " + (String(browser) + "")));
	}


	/* Log-WonderLog Not a pure module */

	function create$53() {
	  return /* record */[
	          /* index */0,
	          /* pointDownEventHandleFuncMap */createEmpty$2(/* () */0),
	          /* pointUpEventHandleFuncMap */createEmpty$2(/* () */0),
	          /* pointDragEventHandleFuncMap */createEmpty$2(/* () */0),
	          /* pointScaleEventHandleFuncMap */createEmpty$2(/* () */0),
	          /* keydownEventHandleFuncMap */createEmpty$2(/* () */0),
	          /* dirtyArray */createEmpty$2(/* () */0),
	          /* distanceMap */createEmpty$2(/* () */0),
	          /* minDistanceMap */createEmpty$2(/* () */0),
	          /* phiMap */createEmpty$2(/* () */0),
	          /* thetaMap */createEmpty$2(/* () */0),
	          /* thetaMarginMap */createEmpty$2(/* () */0),
	          /* targetMap */createEmpty$2(/* () */0),
	          /* moveSpeedXMap */createEmpty$2(/* () */0),
	          /* moveSpeedYMap */createEmpty$2(/* () */0),
	          /* rotateSpeedMap */createEmpty$2(/* () */0),
	          /* wheelSpeedMap */createEmpty$2(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty$1(/* () */0)
	        ];
	}

	function deepCopyForRestore$22(param) {
	  return /* record */[
	          /* index */param[/* index */0],
	          /* pointDownEventHandleFuncMap */copy$3(param[/* pointDownEventHandleFuncMap */1]),
	          /* pointUpEventHandleFuncMap */copy$3(param[/* pointUpEventHandleFuncMap */2]),
	          /* pointDragEventHandleFuncMap */copy$3(param[/* pointDragEventHandleFuncMap */3]),
	          /* pointScaleEventHandleFuncMap */copy$3(param[/* pointScaleEventHandleFuncMap */4]),
	          /* keydownEventHandleFuncMap */copy$3(param[/* keydownEventHandleFuncMap */5]),
	          /* dirtyArray */copy$3(param[/* dirtyArray */6]),
	          /* distanceMap */copy$3(param[/* distanceMap */7]),
	          /* minDistanceMap */copy$3(param[/* minDistanceMap */8]),
	          /* phiMap */copy$3(param[/* phiMap */9]),
	          /* thetaMap */copy$3(param[/* thetaMap */10]),
	          /* thetaMarginMap */copy$3(param[/* thetaMarginMap */11]),
	          /* targetMap */copy$3(param[/* targetMap */12]),
	          /* moveSpeedXMap */copy$3(param[/* moveSpeedXMap */13]),
	          /* moveSpeedYMap */copy$3(param[/* moveSpeedYMap */14]),
	          /* rotateSpeedMap */copy$3(param[/* rotateSpeedMap */15]),
	          /* wheelSpeedMap */copy$3(param[/* wheelSpeedMap */16]),
	          /* gameObjectMap */copy$3(param[/* gameObjectMap */17]),
	          /* disposedIndexArray */param[/* disposedIndexArray */18].slice()
	        ];
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function create$54() {
	  return /* record */[
	          /* index */0,
	          /* dirtyArray */createEmpty$1(/* () */0),
	          /* pMatrixMap */createEmpty$2(/* () */0),
	          /* nearMap */createEmpty$2(/* () */0),
	          /* farMap */createEmpty$2(/* () */0),
	          /* fovyMap */createEmpty$2(/* () */0),
	          /* aspectMap */createEmpty$2(/* () */0),
	          /* gameObjectMap */createEmpty$2(/* () */0),
	          /* disposedIndexArray */createEmpty$1(/* () */0)
	        ];
	}

	function deepCopyForRestore$23(param) {
	  return /* record */[
	          /* index */param[/* index */0],
	          /* dirtyArray */copy$3(param[/* dirtyArray */1]),
	          /* pMatrixMap */deepCopyFloat32ArrayArray(param[/* pMatrixMap */2]),
	          /* nearMap */copy$3(param[/* nearMap */3]),
	          /* farMap */copy$3(param[/* farMap */4]),
	          /* fovyMap */copy$3(param[/* fovyMap */5]),
	          /* aspectMap */copy$3(param[/* aspectMap */6]),
	          /* gameObjectMap */copy$3(param[/* gameObjectMap */7]),
	          /* disposedIndexArray */param[/* disposedIndexArray */8].slice()
	        ];
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function createState$2() {
	  return /* record */[
	          /* stateRecord : record */[
	            /* unsafeGetStateFunc */(function () {
	                return unsafeGetState$2(stateData);
	              }),
	            /* setStateFunc */(function (state) {
	                return setState$2(stateData, state);
	              })
	          ],
	          /* settingRecord */create$36(/* () */0),
	          /* jobRecord */create$14(/* () */0),
	          /* noWorkerJobRecord */undefined,
	          /* workerJobRecord */undefined,
	          /* renderConfigRecord */undefined,
	          /* gpuDetectRecord */create$38(/* () */0),
	          /* sourceInstanceRecord */undefined,
	          /* objectInstanceRecord */create$48(/* () */0),
	          /* viewRecord */create$16(/* () */0),
	          /* deviceManagerRecord */create$45(/* () */0),
	          /* gameObjectRecord */create$40(/* () */0),
	          /* transformRecord */undefined,
	          /* sceneRecord */undefined,
	          /* basicCameraViewRecord */create$51(/* () */0),
	          /* perspectiveCameraProjectionRecord */create$54(/* () */0),
	          /* basicMaterialRecord */undefined,
	          /* lightMaterialRecord */undefined,
	          /* sourceTextureRecord */undefined,
	          /* basicSourceTextureRecord */undefined,
	          /* arrayBufferViewSourceTextureRecord */undefined,
	          /* directionLightRecord */create$21(/* () */0),
	          /* pointLightRecord */create$20(/* () */0),
	          /* boxGeometryRecord */create$8(/* () */0),
	          /* customGeometryRecord */undefined,
	          /* meshRendererRecord */undefined,
	          /* arcballCameraControllerRecord */create$53(/* () */0),
	          /* shaderRecord */create$18(/* () */0),
	          /* glslRecord */create$15(/* () */0),
	          /* programRecord */create$35(/* () */0),
	          /* glslLocationRecord */create$43(/* () */0),
	          /* glslSenderRecord */create$46(/* () */0),
	          /* glslChunkRecord */create$17(/* () */0),
	          /* renderRecord */undefined,
	          /* timeControllerRecord */create$49(/* () */0),
	          /* vboBufferRecord */create$39(/* () */0),
	          /* globalTempRecord */create$41(/* () */0),
	          /* typeArrayPoolRecord */create$47(/* () */0),
	          /* workerInstanceRecord */create$50(/* () */0),
	          /* workerDataRecord */create$42(/* () */0),
	          /* workerDetectRecord */create$44(/* () */0),
	          /* browserDetectRecord */create$52(/* () */0),
	          /* eventRecord */create$37(/* () */0),
	          /* imguiRecord */create$34(/* () */0),
	          /* apiRecord */create$19(/* () */0)
	        ];
	}


	/* StateDataMain-Wonderjs Not a pure module */

	function getComponentSize() {
	  return 1;
	}

	function getGeometryTypeSize() {
	  return 1;
	}

	function getTransformIndicesLength(count) {
	  return (count << 0);
	}

	function getTransformIndicesOffset() {
	  return 0;
	}

	function getMaterialIndicesLength(count) {
	  return (count << 0);
	}

	function getMaterialIndicesOffset(count) {
	  return 0 + imul((count << 0), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getMeshRendererIndicesLength(count) {
	  return (count << 0);
	}

	function getMeshRendererIndicesOffset(count) {
	  return getMaterialIndicesOffset(count) + imul((count << 0), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getGeometryIndicesLength(count) {
	  return (count << 0);
	}

	function getGeometryIndicesOffset(count) {
	  return getMeshRendererIndicesOffset(count) + imul((count << 0), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getSourceInstanceIndicesLength(count) {
	  return (count << 0);
	}

	function getSourceInstanceIndicesOffset(count) {
	  return getGeometryIndicesOffset(count) + imul((count << 0), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	function getGeometryTypesLength(count) {
	  return (count << 0);
	}

	function getGeometryTypesOffset(count) {
	  return getSourceInstanceIndicesOffset(count) + imul((count << 0), Uint32Array.BYTES_PER_ELEMENT) | 0;
	}

	var getComponent$1 = getUint32_1;

	var setComponent = setUint32_1;

	var getGeometryType = getUint8_1;

	function hasSourceInstance(sourceInstance) {
	  return sourceInstance !== getDefaultSourceInstance(/* () */0);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function createTypeArrays$10(buffer, count) {
	  return /* tuple */[
	          new Uint32Array(buffer, getTransformIndicesOffset(count), getTransformIndicesLength(count)),
	          new Uint32Array(buffer, getMaterialIndicesOffset(count), getMaterialIndicesLength(count)),
	          new Uint32Array(buffer, getMeshRendererIndicesOffset(count), getMeshRendererIndicesLength(count)),
	          new Uint32Array(buffer, getGeometryIndicesOffset(count), getGeometryIndicesLength(count)),
	          new Uint32Array(buffer, getSourceInstanceIndicesOffset(count), getSourceInstanceIndicesLength(count)),
	          new Uint8Array(buffer, getGeometryTypesOffset(count), getGeometryTypesLength(count))
	        ];
	}

	function setAllTypeArrDataToDefault$10(count, typeArrTuple) {
	  var defaultSourceInstance = getDefaultSourceInstance(/* () */0);
	  return reduceOneParam((function (param, index) {
	                return /* tuple */[
	                        param[0],
	                        param[1],
	                        param[2],
	                        param[3],
	                        setComponent(index, defaultSourceInstance, param[4]),
	                        param[5]
	                      ];
	              }), typeArrTuple, range(0, count - 1 | 0));
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function getRecord$14(param) {
	  return unsafeGet$1(param[/* basicRenderObjectRecord */0]);
	}

	function _initBufferData$10(count) {
	  var buffer = newSharedArrayBuffer(imul(count, imul(Uint32Array.BYTES_PER_ELEMENT, imul(getComponentSize(/* () */0), 5)) + imul(Uint8Array.BYTES_PER_ELEMENT, getGeometryTypeSize(/* () */0)) | 0));
	  return /* tuple */[
	          buffer,
	          setAllTypeArrDataToDefault$10(count, createTypeArrays$10(buffer, count))
	        ];
	}

	function create$56(state) {
	  var basicMaterialCount = getBasicMaterialCount(state[/* settingRecord */1]);
	  var match = _initBufferData$10(basicMaterialCount);
	  var match$1 = match[1];
	  return /* record */[
	          /* buffer */match[0],
	          /* count */basicMaterialCount,
	          /* transformIndices */match$1[0],
	          /* materialIndices */match$1[1],
	          /* meshRendererIndices */match$1[2],
	          /* geometryIndices */match$1[3],
	          /* geometryTypes */match$1[5],
	          /* sourceInstanceIndices */match$1[4]
	        ];
	}


	/* Worker-Wonderjs Not a pure module */

	function getRecord$15(param) {
	  return unsafeGet$1(param[/* lightRenderObjectRecord */1]);
	}

	function _initBufferData$11(count) {
	  var buffer = newSharedArrayBuffer(imul(count, imul(Uint32Array.BYTES_PER_ELEMENT, imul(getComponentSize(/* () */0), 5)) + imul(Uint8Array.BYTES_PER_ELEMENT, getGeometryTypeSize(/* () */0)) | 0));
	  return /* tuple */[
	          buffer,
	          setAllTypeArrDataToDefault$10(count, createTypeArrays$10(buffer, count))
	        ];
	}

	function create$57(state) {
	  var lightMaterialCount = getLightMaterialCount(state[/* settingRecord */1]);
	  var match = _initBufferData$11(lightMaterialCount);
	  var match$1 = match[1];
	  return /* record */[
	          /* buffer */match[0],
	          /* count */lightMaterialCount,
	          /* transformIndices */match$1[0],
	          /* materialIndices */match$1[1],
	          /* meshRendererIndices */match$1[2],
	          /* geometryIndices */match$1[3],
	          /* geometryTypes */match$1[5],
	          /* sourceInstanceIndices */match$1[4]
	        ];
	}


	/* Worker-Wonderjs Not a pure module */

	function getRecord$13(state) {
	  return unsafeGet$1(state[/* renderRecord */33]);
	}

	function create$55(state) {
	  state[/* renderRecord */33] = /* record */[
	    /* basicRenderObjectRecord */create$56(state),
	    /* lightRenderObjectRecord */create$57(state),
	    /* cameraRecord */undefined
	  ];
	  return state;
	}


	/* OptionService-Wonderjs Not a pure module */

	function restore$1(_, targetState) {
	  var match = getRecord$13(targetState);
	  var basicRenderObjectRecord = match[/* basicRenderObjectRecord */0];
	  var lightRenderObjectRecord = match[/* lightRenderObjectRecord */1];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* renderRecord */33] = /* record */[
	    /* basicRenderObjectRecord */basicRenderObjectRecord,
	    /* lightRenderObjectRecord */lightRenderObjectRecord,
	    /* cameraRecord */undefined
	  ];
	  return newrecord;
	}


	/* RecordRenderMainService-Wonderjs Not a pure module */

	function restore$2(currentState, targetState) {
	  requireCheck((function () {
	          var currentPrecision = currentState[/* glslRecord */28][/* precision */0];
	          var targetPrecision = targetState[/* glslRecord */28][/* precision */0];
	          return test(buildAssertMessage("currentState->glslRecord->precision and targetState->glslRecord->precision be the same", "not"), (function () {
	                        if (currentPrecision !== undefined) {
	                          if (targetPrecision !== undefined) {
	                            return Operators[/* ==^ */2](currentPrecision, targetPrecision);
	                          } else {
	                            return assertFail(/* () */0);
	                          }
	                        } else if (targetPrecision !== undefined) {
	                          return assertFail(/* () */0);
	                        } else {
	                          return assertPass(/* () */0);
	                        }
	                      }));
	        }), getIsDebug(stateData));
	  var match = currentState[/* shaderRecord */27];
	  var currentIndex = match[/* index */0];
	  var targetShaderData = targetState[/* shaderRecord */27];
	  var targetIndex = targetShaderData[/* index */0];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* shaderRecord */27] = /* record */[
	    /* index */Math.max(currentIndex, targetIndex),
	    /* shaderIndexMap */targetShaderData[/* shaderIndexMap */1],
	    /* usedShaderIndexArray */targetShaderData[/* usedShaderIndexArray */2]
	  ];
	  return newrecord;
	}


	/* Log-WonderLog Not a pure module */

	function restore$3(_, targetState) {
	  var newrecord = caml_array_dup(targetState);
	  var init = targetState[/* programRecord */29];
	  newrecord[/* programRecord */29] = /* record */[
	    /* programMap */init[/* programMap */0],
	    /* lastUsedProgram */undefined
	  ];
	  return newrecord;
	}


	/* No side effect */

	function _restoreTypeArrays(currentTransformRecord, targetTransformRecord) {
	  var match = currentTransformRecord[/* localPositions */3] === targetTransformRecord[/* localPositions */3] && currentTransformRecord[/* localRotations */4] === targetTransformRecord[/* localRotations */4] && currentTransformRecord[/* localScales */5] === targetTransformRecord[/* localScales */5] && currentTransformRecord[/* localToWorldMatrices */2] === targetTransformRecord[/* localToWorldMatrices */2];
	  if (match) {
	    return /* tuple */[
	            currentTransformRecord,
	            targetTransformRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault(currentTransformRecord[/* index */0], /* tuple */[
	          currentTransformRecord[/* defaultLocalToWorldMatrix */11],
	          currentTransformRecord[/* defaultLocalPosition */12],
	          currentTransformRecord[/* defaultLocalRotation */13],
	          currentTransformRecord[/* defaultLocalScale */14]
	        ], /* tuple */[
	          currentTransformRecord[/* localToWorldMatrices */2],
	          currentTransformRecord[/* localPositions */3],
	          currentTransformRecord[/* localRotations */4],
	          currentTransformRecord[/* localScales */5]
	        ]);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentTransformRecord[/* localPositions */3],
	          0
	        ], /* tuple */[
	          targetTransformRecord[/* localPositions */3],
	          0
	        ], targetTransformRecord[/* localPositions */3].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentTransformRecord[/* localRotations */4],
	          0
	        ], /* tuple */[
	          targetTransformRecord[/* localRotations */4],
	          0
	        ], targetTransformRecord[/* localRotations */4].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentTransformRecord[/* localScales */5],
	          0
	        ], /* tuple */[
	          targetTransformRecord[/* localScales */5],
	          0
	        ], targetTransformRecord[/* localScales */5].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentTransformRecord[/* localToWorldMatrices */2],
	          0
	        ], /* tuple */[
	          targetTransformRecord[/* localToWorldMatrices */2],
	          0
	        ], targetTransformRecord[/* localToWorldMatrices */2].length);
	    return /* tuple */[
	            currentTransformRecord,
	            targetTransformRecord
	          ];
	  }
	}

	function restore$4(currentState, targetState) {
	  var currentTransformRecord = getRecord$1(currentState);
	  var targetTransformRecord = getRecord$1(targetState);
	  var match = _restoreTypeArrays(currentTransformRecord, targetTransformRecord);
	  var currentTransformRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  var newrecord$1 = caml_array_dup(match[1]);
	  newrecord[/* transformRecord */12] = (newrecord$1[/* buffer */1] = currentTransformRecord$1[/* buffer */1], newrecord$1[/* localToWorldMatrices */2] = currentTransformRecord$1[/* localToWorldMatrices */2], newrecord$1[/* localPositions */3] = currentTransformRecord$1[/* localPositions */3], newrecord$1[/* localRotations */4] = currentTransformRecord$1[/* localRotations */4], newrecord$1[/* localScales */5] = currentTransformRecord$1[/* localScales */5], newrecord$1);
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _getBufferAndSetBufferMap(gl, bufferPool) {
	  var match = bufferPool.pop();
	  if (match !== undefined) {
	    return match;
	  } else {
	    return gl.createBuffer();
	  }
	}

	function getArrayBuffer(gl, param) {
	  return _getBufferAndSetBufferMap(gl, param[/* vertexArrayBufferPool */9]);
	}

	function getElementArrayBuffer(gl, param) {
	  return _getBufferAndSetBufferMap(gl, param[/* elementArrayBufferPool */10]);
	}

	function getInstanceBuffer(gl, param) {
	  return _getBufferAndSetBufferMap(gl, param[/* matrixInstanceBufferPool */11]);
	}

	function addAllBufferToPool(param) {
	  var matrixInstanceBufferPool = param[/* matrixInstanceBufferPool */11];
	  var elementArrayBufferPool = param[/* elementArrayBufferPool */10];
	  var vertexArrayBufferPool = param[/* vertexArrayBufferPool */9];
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* boxGeometryVertexBufferMap */0]);
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* boxGeometryTexCoordBufferMap */1]);
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* boxGeometryNormalBufferMap */2]);
	  forEachValid((function (buffer) {
	          elementArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* boxGeometryElementArrayBufferMap */3]);
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* customGeometryVertexBufferMap */4]);
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* customGeometryTexCoordBufferMap */5]);
	  forEachValid((function (buffer) {
	          vertexArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* customGeometryNormalBufferMap */6]);
	  forEachValid((function (buffer) {
	          elementArrayBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* customGeometryElementArrayBufferMap */7]);
	  forEachValid((function (buffer) {
	          matrixInstanceBufferPool.push(buffer);
	          return /* () */0;
	        }), param[/* matrixInstanceBufferMap */8]);
	  return /* tuple */[
	          vertexArrayBufferPool,
	          elementArrayBufferPool,
	          matrixInstanceBufferPool
	        ];
	}

	function _addBufferToPool(geometryIndex, bufferMap, pool) {
	  var match = get$3(geometryIndex, bufferMap);
	  if (match !== undefined) {
	    return push(valFromOption(match), pool);
	  } else {
	    return pool;
	  }
	}

	function addBoxGeometryBufferToPool(geometryIndex, record) {
	  return /* record */[
	          /* boxGeometryVertexBufferMap */record[/* boxGeometryVertexBufferMap */0],
	          /* boxGeometryTexCoordBufferMap */record[/* boxGeometryTexCoordBufferMap */1],
	          /* boxGeometryNormalBufferMap */record[/* boxGeometryNormalBufferMap */2],
	          /* boxGeometryElementArrayBufferMap */record[/* boxGeometryElementArrayBufferMap */3],
	          /* customGeometryVertexBufferMap */record[/* customGeometryVertexBufferMap */4],
	          /* customGeometryTexCoordBufferMap */record[/* customGeometryTexCoordBufferMap */5],
	          /* customGeometryNormalBufferMap */record[/* customGeometryNormalBufferMap */6],
	          /* customGeometryElementArrayBufferMap */record[/* customGeometryElementArrayBufferMap */7],
	          /* matrixInstanceBufferMap */record[/* matrixInstanceBufferMap */8],
	          /* vertexArrayBufferPool */_addBufferToPool(geometryIndex, record[/* boxGeometryNormalBufferMap */2], _addBufferToPool(geometryIndex, record[/* boxGeometryTexCoordBufferMap */1], _addBufferToPool(geometryIndex, record[/* boxGeometryVertexBufferMap */0], record[/* vertexArrayBufferPool */9]))),
	          /* elementArrayBufferPool */_addBufferToPool(geometryIndex, record[/* boxGeometryElementArrayBufferMap */3], record[/* elementArrayBufferPool */10]),
	          /* matrixInstanceBufferPool */record[/* matrixInstanceBufferPool */11]
	        ];
	}

	function addCustomGeometryBufferToPool(geometryIndex, record) {
	  return /* record */[
	          /* boxGeometryVertexBufferMap */record[/* boxGeometryVertexBufferMap */0],
	          /* boxGeometryTexCoordBufferMap */record[/* boxGeometryTexCoordBufferMap */1],
	          /* boxGeometryNormalBufferMap */record[/* boxGeometryNormalBufferMap */2],
	          /* boxGeometryElementArrayBufferMap */record[/* boxGeometryElementArrayBufferMap */3],
	          /* customGeometryVertexBufferMap */record[/* customGeometryVertexBufferMap */4],
	          /* customGeometryTexCoordBufferMap */record[/* customGeometryTexCoordBufferMap */5],
	          /* customGeometryNormalBufferMap */record[/* customGeometryNormalBufferMap */6],
	          /* customGeometryElementArrayBufferMap */record[/* customGeometryElementArrayBufferMap */7],
	          /* matrixInstanceBufferMap */record[/* matrixInstanceBufferMap */8],
	          /* vertexArrayBufferPool */_addBufferToPool(geometryIndex, record[/* customGeometryNormalBufferMap */6], _addBufferToPool(geometryIndex, record[/* customGeometryTexCoordBufferMap */5], _addBufferToPool(geometryIndex, record[/* customGeometryVertexBufferMap */4], record[/* vertexArrayBufferPool */9]))),
	          /* elementArrayBufferPool */_addBufferToPool(geometryIndex, record[/* customGeometryElementArrayBufferMap */7], record[/* elementArrayBufferPool */10]),
	          /* matrixInstanceBufferPool */record[/* matrixInstanceBufferPool */11]
	        ];
	}

	function addInstanceBufferToPool(sourceInstanceIndex, record) {
	  var match = get$3(sourceInstanceIndex, record[/* matrixInstanceBufferMap */8]);
	  if (match !== undefined) {
	    return /* record */[
	            /* boxGeometryVertexBufferMap */record[/* boxGeometryVertexBufferMap */0],
	            /* boxGeometryTexCoordBufferMap */record[/* boxGeometryTexCoordBufferMap */1],
	            /* boxGeometryNormalBufferMap */record[/* boxGeometryNormalBufferMap */2],
	            /* boxGeometryElementArrayBufferMap */record[/* boxGeometryElementArrayBufferMap */3],
	            /* customGeometryVertexBufferMap */record[/* customGeometryVertexBufferMap */4],
	            /* customGeometryTexCoordBufferMap */record[/* customGeometryTexCoordBufferMap */5],
	            /* customGeometryNormalBufferMap */record[/* customGeometryNormalBufferMap */6],
	            /* customGeometryElementArrayBufferMap */record[/* customGeometryElementArrayBufferMap */7],
	            /* matrixInstanceBufferMap */record[/* matrixInstanceBufferMap */8],
	            /* vertexArrayBufferPool */record[/* vertexArrayBufferPool */9],
	            /* elementArrayBufferPool */record[/* elementArrayBufferPool */10],
	            /* matrixInstanceBufferPool */push(valFromOption(match), record[/* matrixInstanceBufferPool */11])
	          ];
	  } else {
	    return record;
	  }
	}


	/* Log-WonderLog Not a pure module */

	function restore$5(currentState, targetState) {
	  var match = addAllBufferToPool(currentState[/* vboBufferRecord */35]);
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* vboBufferRecord */35] = /* record */[
	    /* boxGeometryVertexBufferMap : array */[],
	    /* boxGeometryTexCoordBufferMap : array */[],
	    /* boxGeometryNormalBufferMap : array */[],
	    /* boxGeometryElementArrayBufferMap : array */[],
	    /* customGeometryVertexBufferMap : array */[],
	    /* customGeometryTexCoordBufferMap : array */[],
	    /* customGeometryNormalBufferMap : array */[],
	    /* customGeometryElementArrayBufferMap : array */[],
	    /* matrixInstanceBufferMap : array */[],
	    /* vertexArrayBufferPool */match[0],
	    /* elementArrayBufferPool */match[1],
	    /* matrixInstanceBufferPool */match[2]
	  ];
	  return newrecord;
	}


	/* PoolVboBufferService-Wonderjs Not a pure module */

	function restore$6(_, targetState) {
	  var newrecord = caml_array_dup(targetState);
	  var init = targetState[/* glslSenderRecord */31];
	  newrecord[/* glslSenderRecord */31] = /* record */[
	    /* attributeSendDataMap */init[/* attributeSendDataMap */0],
	    /* instanceAttributeSendDataMap */init[/* instanceAttributeSendDataMap */1],
	    /* uniformCacheMap */init[/* uniformCacheMap */2],
	    /* uniformRenderObjectSendModelDataMap */init[/* uniformRenderObjectSendModelDataMap */3],
	    /* uniformRenderObjectSendMaterialDataMap */init[/* uniformRenderObjectSendMaterialDataMap */4],
	    /* uniformShaderSendNoCachableDataMap */init[/* uniformShaderSendNoCachableDataMap */5],
	    /* uniformShaderSendCachableDataMap */init[/* uniformShaderSendCachableDataMap */6],
	    /* uniformShaderSendCachableFunctionDataMap */init[/* uniformShaderSendCachableFunctionDataMap */7],
	    /* uniformInstanceSendNoCachableDataMap */init[/* uniformInstanceSendNoCachableDataMap */8],
	    /* vertexAttribHistoryArray */createEmpty$1(/* () */0),
	    /* lastSendMaterialData */undefined,
	    /* lastSendGeometryData */undefined
	  ];
	  return newrecord;
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function restore$7(currentState, targetState) {
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* globalTempRecord */36] = currentState[/* globalTempRecord */36];
	  return newrecord;
	}


	/* No side effect */

	function _restoreTypeArrays$1(currentPointLightRecord, targetPointLightRecord) {
	  var match = currentPointLightRecord[/* colors */2] === targetPointLightRecord[/* colors */2] && currentPointLightRecord[/* intensities */3] === targetPointLightRecord[/* intensities */3] && currentPointLightRecord[/* constants */4] === targetPointLightRecord[/* constants */4] && currentPointLightRecord[/* linears */5] === targetPointLightRecord[/* linears */5] && currentPointLightRecord[/* quadratics */6] === targetPointLightRecord[/* quadratics */6] && currentPointLightRecord[/* ranges */7] === targetPointLightRecord[/* ranges */7];
	  if (match) {
	    return /* tuple */[
	            currentPointLightRecord,
	            targetPointLightRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$6(currentPointLightRecord[/* index */0], /* tuple */[
	          currentPointLightRecord[/* colors */2],
	          currentPointLightRecord[/* intensities */3],
	          currentPointLightRecord[/* constants */4],
	          currentPointLightRecord[/* linears */5],
	          currentPointLightRecord[/* quadratics */6],
	          currentPointLightRecord[/* ranges */7]
	        ]);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentPointLightRecord[/* colors */2],
	          0
	        ], /* tuple */[
	          targetPointLightRecord[/* colors */2],
	          0
	        ], targetPointLightRecord[/* colors */2].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentPointLightRecord[/* intensities */3],
	          0
	        ], /* tuple */[
	          targetPointLightRecord[/* intensities */3],
	          0
	        ], targetPointLightRecord[/* intensities */3].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentPointLightRecord[/* constants */4],
	          0
	        ], /* tuple */[
	          targetPointLightRecord[/* constants */4],
	          0
	        ], targetPointLightRecord[/* constants */4].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentPointLightRecord[/* linears */5],
	          0
	        ], /* tuple */[
	          targetPointLightRecord[/* linears */5],
	          0
	        ], targetPointLightRecord[/* linears */5].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentPointLightRecord[/* quadratics */6],
	          0
	        ], /* tuple */[
	          targetPointLightRecord[/* quadratics */6],
	          0
	        ], targetPointLightRecord[/* quadratics */6].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentPointLightRecord[/* ranges */7],
	          0
	        ], /* tuple */[
	          targetPointLightRecord[/* ranges */7],
	          0
	        ], targetPointLightRecord[/* ranges */7].length);
	    return /* tuple */[
	            currentPointLightRecord,
	            targetPointLightRecord
	          ];
	  }
	}

	function restore$8(currentState, targetState) {
	  var currentPointLightRecord = currentState[/* pointLightRecord */22];
	  var targetPointLightRecord = targetState[/* pointLightRecord */22];
	  var match = _restoreTypeArrays$1(currentPointLightRecord, targetPointLightRecord);
	  var targetPointLightRecord$1 = match[1];
	  var currentPointLightRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* pointLightRecord */22] = /* record */[
	    /* index */targetPointLightRecord$1[/* index */0],
	    /* buffer */currentPointLightRecord$1[/* buffer */1],
	    /* colors */currentPointLightRecord$1[/* colors */2],
	    /* intensities */currentPointLightRecord$1[/* intensities */3],
	    /* constants */currentPointLightRecord$1[/* constants */4],
	    /* linears */currentPointLightRecord$1[/* linears */5],
	    /* quadratics */currentPointLightRecord$1[/* quadratics */6],
	    /* ranges */currentPointLightRecord$1[/* ranges */7],
	    /* mappedIndexMap */targetPointLightRecord$1[/* mappedIndexMap */8],
	    /* gameObjectMap */targetPointLightRecord$1[/* gameObjectMap */9]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function restore$9(_, targetState) {
	  return targetState;
	}


	/* No side effect */

	var getAllAliveMaterials = getValidKeys;


	/* SparseMapService-Wonderjs Not a pure module */

	function resetShaderIndices(index, defaultShaderIndex, shaderIndices) {
	  return reduceOneParam((function (shaderIndices, i) {
	                return setUint32_1(i, defaultShaderIndex, shaderIndices);
	              }), shaderIndices, range$1(0, index));
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _resetShaderIndices(state) {
	  var record = getRecord$4(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */resetShaderIndices(record[/* index */0], getDefaultShaderIndex(/* () */0), record[/* shaderIndices */2]),
	    /* colors */record[/* colors */3],
	    /* textureIndices */record[/* textureIndices */4],
	    /* mapUnits */record[/* mapUnits */5],
	    /* textureCountMap */record[/* textureCountMap */6],
	    /* defaultColor */record[/* defaultColor */7],
	    /* gameObjectMap */record[/* gameObjectMap */8],
	    /* groupCountMap */record[/* groupCountMap */9],
	    /* disposedIndexArray */record[/* disposedIndexArray */10],
	    /* nameMap */record[/* nameMap */11],
	    /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */12]
	  ];
	  return newrecord;
	}

	function _restoreTypeArrays$2(currentBasicMaterialRecord, targetBasicMaterialRecord) {
	  var match = currentBasicMaterialRecord[/* shaderIndices */2] === targetBasicMaterialRecord[/* shaderIndices */2] && currentBasicMaterialRecord[/* colors */3] === targetBasicMaterialRecord[/* colors */3] && currentBasicMaterialRecord[/* textureIndices */4] === targetBasicMaterialRecord[/* textureIndices */4] && currentBasicMaterialRecord[/* mapUnits */5] === targetBasicMaterialRecord[/* mapUnits */5];
	  if (match) {
	    return /* tuple */[
	            currentBasicMaterialRecord,
	            targetBasicMaterialRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$2(currentBasicMaterialRecord[/* index */0], getDefaultShaderIndex(/* () */0), currentBasicMaterialRecord[/* defaultColor */7], /* tuple */[
	          currentBasicMaterialRecord[/* shaderIndices */2],
	          currentBasicMaterialRecord[/* colors */3],
	          currentBasicMaterialRecord[/* textureIndices */4],
	          currentBasicMaterialRecord[/* mapUnits */5]
	        ]);
	    fillUint32ArrayWithUint32Array(/* tuple */[
	          currentBasicMaterialRecord[/* shaderIndices */2],
	          0
	        ], /* tuple */[
	          targetBasicMaterialRecord[/* shaderIndices */2],
	          0
	        ], targetBasicMaterialRecord[/* shaderIndices */2].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentBasicMaterialRecord[/* colors */3],
	          0
	        ], /* tuple */[
	          targetBasicMaterialRecord[/* colors */3],
	          0
	        ], targetBasicMaterialRecord[/* colors */3].length);
	    fillUint32ArrayWithUint32Array(/* tuple */[
	          currentBasicMaterialRecord[/* textureIndices */4],
	          0
	        ], /* tuple */[
	          targetBasicMaterialRecord[/* textureIndices */4],
	          0
	        ], targetBasicMaterialRecord[/* textureIndices */4].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentBasicMaterialRecord[/* mapUnits */5],
	          0
	        ], /* tuple */[
	          targetBasicMaterialRecord[/* mapUnits */5],
	          0
	        ], targetBasicMaterialRecord[/* mapUnits */5].length);
	    return /* tuple */[
	            currentBasicMaterialRecord,
	            targetBasicMaterialRecord
	          ];
	  }
	}

	function restore$10(gl, currentState, targetState) {
	  var targetState$1 = _resetShaderIndices(targetState);
	  var targetState$2 = initMaterials(getAllAliveMaterials(getRecord$4(targetState$1)[/* gameObjectMap */8]), gl, targetState$1);
	  var currentBasicMaterialRecord = getRecord$4(currentState);
	  var targetBasicMaterialRecord = getRecord$4(targetState$2);
	  var match = _restoreTypeArrays$2(currentBasicMaterialRecord, targetBasicMaterialRecord);
	  var targetBasicMaterialRecord$1 = match[1];
	  var currentBasicMaterialRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState$2);
	  newrecord[/* basicMaterialRecord */16] = /* record */[
	    /* index */targetBasicMaterialRecord$1[/* index */0],
	    /* buffer */currentBasicMaterialRecord$1[/* buffer */1],
	    /* shaderIndices */currentBasicMaterialRecord$1[/* shaderIndices */2],
	    /* colors */currentBasicMaterialRecord$1[/* colors */3],
	    /* textureIndices */currentBasicMaterialRecord$1[/* textureIndices */4],
	    /* mapUnits */currentBasicMaterialRecord$1[/* mapUnits */5],
	    /* textureCountMap */targetBasicMaterialRecord$1[/* textureCountMap */6],
	    /* defaultColor */targetBasicMaterialRecord$1[/* defaultColor */7],
	    /* gameObjectMap */targetBasicMaterialRecord$1[/* gameObjectMap */8],
	    /* groupCountMap */targetBasicMaterialRecord$1[/* groupCountMap */9],
	    /* disposedIndexArray */targetBasicMaterialRecord$1[/* disposedIndexArray */10],
	    /* nameMap */targetBasicMaterialRecord$1[/* nameMap */11],
	    /* materialArrayForWorkerInit */targetBasicMaterialRecord$1[/* materialArrayForWorkerInit */12]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function restore$11(_, param, targetState) {
	  var newrecord = caml_array_dup(targetState);
	  var init = targetState[/* deviceManagerRecord */10];
	  newrecord[/* deviceManagerRecord */10] = /* record */[
	    /* gl */some$1(param[/* gl */0]),
	    /* colorWrite */init[/* colorWrite */1],
	    /* clearColor */init[/* clearColor */2],
	    /* side */init[/* side */3],
	    /* depthTest */init[/* depthTest */4],
	    /* viewport */init[/* viewport */5]
	  ];
	  return newrecord;
	}


	/* No side effect */

	function _resetShaderIndices$1(state) {
	  var record = getRecord$5(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */record[/* index */0],
	    /* buffer */record[/* buffer */1],
	    /* shaderIndices */resetShaderIndices(record[/* index */0], getDefaultShaderIndex(/* () */0), record[/* shaderIndices */2]),
	    /* diffuseColors */record[/* diffuseColors */3],
	    /* specularColors */record[/* specularColors */4],
	    /* shininess */record[/* shininess */5],
	    /* textureIndices */record[/* textureIndices */6],
	    /* diffuseMapUnits */record[/* diffuseMapUnits */7],
	    /* specularMapUnits */record[/* specularMapUnits */8],
	    /* textureCountMap */record[/* textureCountMap */9],
	    /* defaultDiffuseColor */record[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */record[/* defaultSpecularColor */11],
	    /* defaultShininess */record[/* defaultShininess */12],
	    /* gameObjectMap */record[/* gameObjectMap */13],
	    /* groupCountMap */record[/* groupCountMap */14],
	    /* disposedIndexArray */record[/* disposedIndexArray */15],
	    /* nameMap */record[/* nameMap */16],
	    /* materialArrayForWorkerInit */record[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	function _restoreTypeArrays$3(currentLightMaterialRecord, targetLightMaterialRecord) {
	  var match = currentLightMaterialRecord[/* shaderIndices */2] === targetLightMaterialRecord[/* shaderIndices */2] && currentLightMaterialRecord[/* diffuseColors */3] === targetLightMaterialRecord[/* diffuseColors */3] && currentLightMaterialRecord[/* specularColors */4] === targetLightMaterialRecord[/* specularColors */4] && currentLightMaterialRecord[/* textureIndices */6] === targetLightMaterialRecord[/* textureIndices */6] && currentLightMaterialRecord[/* diffuseMapUnits */7] === targetLightMaterialRecord[/* diffuseMapUnits */7] && currentLightMaterialRecord[/* specularMapUnits */8] === targetLightMaterialRecord[/* specularMapUnits */8];
	  if (match) {
	    return /* tuple */[
	            currentLightMaterialRecord,
	            targetLightMaterialRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$3(currentLightMaterialRecord[/* index */0], /* tuple */[
	          getDefaultShaderIndex(/* () */0),
	          currentLightMaterialRecord[/* defaultDiffuseColor */10],
	          currentLightMaterialRecord[/* defaultSpecularColor */11],
	          currentLightMaterialRecord[/* defaultShininess */12]
	        ], /* tuple */[
	          currentLightMaterialRecord[/* shaderIndices */2],
	          currentLightMaterialRecord[/* diffuseColors */3],
	          currentLightMaterialRecord[/* specularColors */4],
	          currentLightMaterialRecord[/* shininess */5],
	          currentLightMaterialRecord[/* textureIndices */6],
	          currentLightMaterialRecord[/* diffuseMapUnits */7],
	          currentLightMaterialRecord[/* specularMapUnits */8]
	        ]);
	    fillUint32ArrayWithUint32Array(/* tuple */[
	          currentLightMaterialRecord[/* shaderIndices */2],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* shaderIndices */2],
	          0
	        ], targetLightMaterialRecord[/* shaderIndices */2].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentLightMaterialRecord[/* diffuseColors */3],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* diffuseColors */3],
	          0
	        ], targetLightMaterialRecord[/* diffuseColors */3].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentLightMaterialRecord[/* specularColors */4],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* specularColors */4],
	          0
	        ], targetLightMaterialRecord[/* specularColors */4].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentLightMaterialRecord[/* shininess */5],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* shininess */5],
	          0
	        ], targetLightMaterialRecord[/* shininess */5].length);
	    fillUint32ArrayWithUint32Array(/* tuple */[
	          currentLightMaterialRecord[/* textureIndices */6],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* textureIndices */6],
	          0
	        ], targetLightMaterialRecord[/* textureIndices */6].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentLightMaterialRecord[/* diffuseMapUnits */7],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* diffuseMapUnits */7],
	          0
	        ], targetLightMaterialRecord[/* diffuseMapUnits */7].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentLightMaterialRecord[/* specularMapUnits */8],
	          0
	        ], /* tuple */[
	          targetLightMaterialRecord[/* specularMapUnits */8],
	          0
	        ], targetLightMaterialRecord[/* specularMapUnits */8].length);
	    return /* tuple */[
	            currentLightMaterialRecord,
	            targetLightMaterialRecord
	          ];
	  }
	}

	function restore$12(gl, currentState, targetState) {
	  var targetState$1 = _resetShaderIndices$1(targetState);
	  var targetState$2 = initMaterials$1(getAllAliveMaterials(getRecord$5(targetState$1)[/* gameObjectMap */13]), gl, targetState$1);
	  var currentLightMaterialRecord = getRecord$5(currentState);
	  var targetLightMaterialRecord = getRecord$5(targetState$2);
	  var match = _restoreTypeArrays$3(currentLightMaterialRecord, targetLightMaterialRecord);
	  var targetLightMaterialRecord$1 = match[1];
	  var currentLightMaterialRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState$2);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */targetLightMaterialRecord$1[/* index */0],
	    /* buffer */currentLightMaterialRecord$1[/* buffer */1],
	    /* shaderIndices */currentLightMaterialRecord$1[/* shaderIndices */2],
	    /* diffuseColors */currentLightMaterialRecord$1[/* diffuseColors */3],
	    /* specularColors */currentLightMaterialRecord$1[/* specularColors */4],
	    /* shininess */currentLightMaterialRecord$1[/* shininess */5],
	    /* textureIndices */currentLightMaterialRecord$1[/* textureIndices */6],
	    /* diffuseMapUnits */currentLightMaterialRecord$1[/* diffuseMapUnits */7],
	    /* specularMapUnits */currentLightMaterialRecord$1[/* specularMapUnits */8],
	    /* textureCountMap */targetLightMaterialRecord$1[/* textureCountMap */9],
	    /* defaultDiffuseColor */targetLightMaterialRecord$1[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */targetLightMaterialRecord$1[/* defaultSpecularColor */11],
	    /* defaultShininess */targetLightMaterialRecord$1[/* defaultShininess */12],
	    /* gameObjectMap */targetLightMaterialRecord$1[/* gameObjectMap */13],
	    /* groupCountMap */targetLightMaterialRecord$1[/* groupCountMap */14],
	    /* disposedIndexArray */targetLightMaterialRecord$1[/* disposedIndexArray */15],
	    /* nameMap */targetLightMaterialRecord$1[/* nameMap */16],
	    /* materialArrayForWorkerInit */targetLightMaterialRecord$1[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function restore$13(currentState, targetState) {
	  var currentTextureRecord = getRecord$10(currentState);
	  getRecord$10(targetState);
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* sourceTextureRecord */18] = /* record */[/* buffer */currentTextureRecord[/* buffer */0]];
	  return newrecord;
	}


	/* RecordSourceTextureMainService-Wonderjs Not a pure module */

	function restore$14(_, param, targetState) {
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* typeArrayPoolRecord */37] = /* record */[
	    /* float32ArrayPoolMap */param[/* float32ArrayPoolMap */1],
	    /* uint16ArrayPoolMap */param[/* uint16ArrayPoolMap */2]
	  ];
	  return newrecord;
	}


	/* No side effect */

	function _restoreTypeArrays$4(customGeometryPointCount, currentCustomGeometryRecord, targetCustomGeometryRecord) {
	  var match = currentCustomGeometryRecord[/* vertices */2] === targetCustomGeometryRecord[/* vertices */2] && currentCustomGeometryRecord[/* normals */4] === targetCustomGeometryRecord[/* normals */4] && currentCustomGeometryRecord[/* texCoords */3] === targetCustomGeometryRecord[/* texCoords */3] && currentCustomGeometryRecord[/* indices */5] === targetCustomGeometryRecord[/* indices */5];
	  if (match) {
	    return /* tuple */[
	            currentCustomGeometryRecord,
	            targetCustomGeometryRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$4(currentCustomGeometryRecord[/* index */0], customGeometryPointCount, /* tuple */[
	          currentCustomGeometryRecord[/* vertices */2],
	          currentCustomGeometryRecord[/* texCoords */3],
	          currentCustomGeometryRecord[/* normals */4],
	          currentCustomGeometryRecord[/* indices */5]
	        ]);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentCustomGeometryRecord[/* vertices */2],
	          0
	        ], /* tuple */[
	          targetCustomGeometryRecord[/* vertices */2],
	          0
	        ], targetCustomGeometryRecord[/* vertices */2].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentCustomGeometryRecord[/* texCoords */3],
	          0
	        ], /* tuple */[
	          targetCustomGeometryRecord[/* texCoords */3],
	          0
	        ], targetCustomGeometryRecord[/* texCoords */3].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentCustomGeometryRecord[/* normals */4],
	          0
	        ], /* tuple */[
	          targetCustomGeometryRecord[/* normals */4],
	          0
	        ], targetCustomGeometryRecord[/* normals */4].length);
	    fillUint16ArrayWithUint16Array(/* tuple */[
	          currentCustomGeometryRecord[/* indices */5],
	          0
	        ], /* tuple */[
	          targetCustomGeometryRecord[/* indices */5],
	          0
	        ], targetCustomGeometryRecord[/* indices */5].length);
	    return /* tuple */[
	            currentCustomGeometryRecord,
	            targetCustomGeometryRecord
	          ];
	  }
	}

	function restore$15(currentState, targetState) {
	  var currentCustomGeometryRecord = getRecord$6(currentState);
	  var targetCustomGeometryRecord = getRecord$6(targetState);
	  var match = _restoreTypeArrays$4(getCustomGeometryPointCount(currentState[/* settingRecord */1]), currentCustomGeometryRecord, targetCustomGeometryRecord);
	  var targetCustomGeometryRecord$1 = match[1];
	  var currentCustomGeometryRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* customGeometryRecord */24] = /* record */[
	    /* index */targetCustomGeometryRecord$1[/* index */0],
	    /* buffer */currentCustomGeometryRecord$1[/* buffer */1],
	    /* vertices */currentCustomGeometryRecord$1[/* vertices */2],
	    /* texCoords */currentCustomGeometryRecord$1[/* texCoords */3],
	    /* normals */currentCustomGeometryRecord$1[/* normals */4],
	    /* indices */currentCustomGeometryRecord$1[/* indices */5],
	    /* verticesInfos */targetCustomGeometryRecord$1[/* verticesInfos */6],
	    /* texCoordsInfos */targetCustomGeometryRecord$1[/* texCoordsInfos */7],
	    /* normalsInfos */targetCustomGeometryRecord$1[/* normalsInfos */8],
	    /* indicesInfos */targetCustomGeometryRecord$1[/* indicesInfos */9],
	    /* verticesOffset */targetCustomGeometryRecord$1[/* verticesOffset */10],
	    /* texCoordsOffset */targetCustomGeometryRecord$1[/* texCoordsOffset */11],
	    /* normalsOffset */targetCustomGeometryRecord$1[/* normalsOffset */12],
	    /* indicesOffset */targetCustomGeometryRecord$1[/* indicesOffset */13],
	    /* disposeCount */targetCustomGeometryRecord$1[/* disposeCount */14],
	    /* gameObjectMap */targetCustomGeometryRecord$1[/* gameObjectMap */15],
	    /* groupCountMap */targetCustomGeometryRecord$1[/* groupCountMap */16],
	    /* disposedIndexArray */targetCustomGeometryRecord$1[/* disposedIndexArray */17],
	    /* disposedIndexMap */targetCustomGeometryRecord$1[/* disposedIndexMap */18],
	    /* aliveIndexArray */targetCustomGeometryRecord$1[/* aliveIndexArray */19]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _restoreTypeArrays$5(currentDirectionLightRecord, targetDirectionLightRecord) {
	  var match = currentDirectionLightRecord[/* colors */2] === targetDirectionLightRecord[/* colors */2] && currentDirectionLightRecord[/* intensities */3] === targetDirectionLightRecord[/* intensities */3];
	  if (match) {
	    return /* tuple */[
	            currentDirectionLightRecord,
	            targetDirectionLightRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$7(currentDirectionLightRecord[/* index */0], /* tuple */[
	          currentDirectionLightRecord[/* colors */2],
	          currentDirectionLightRecord[/* intensities */3]
	        ]);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentDirectionLightRecord[/* colors */2],
	          0
	        ], /* tuple */[
	          targetDirectionLightRecord[/* colors */2],
	          0
	        ], targetDirectionLightRecord[/* colors */2].length);
	    fillFloat32ArrayWithFloat32Array(/* tuple */[
	          currentDirectionLightRecord[/* intensities */3],
	          0
	        ], /* tuple */[
	          targetDirectionLightRecord[/* intensities */3],
	          0
	        ], targetDirectionLightRecord[/* intensities */3].length);
	    return /* tuple */[
	            currentDirectionLightRecord,
	            targetDirectionLightRecord
	          ];
	  }
	}

	function restore$16(currentState, targetState) {
	  var currentDirectionLightRecord = currentState[/* directionLightRecord */21];
	  var targetDirectionLightRecord = targetState[/* directionLightRecord */21];
	  var match = _restoreTypeArrays$5(currentDirectionLightRecord, targetDirectionLightRecord);
	  var targetDirectionLightRecord$1 = match[1];
	  var currentDirectionLightRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* directionLightRecord */21] = /* record */[
	    /* index */targetDirectionLightRecord$1[/* index */0],
	    /* buffer */currentDirectionLightRecord$1[/* buffer */1],
	    /* colors */currentDirectionLightRecord$1[/* colors */2],
	    /* intensities */currentDirectionLightRecord$1[/* intensities */3],
	    /* mappedIndexMap */targetDirectionLightRecord$1[/* mappedIndexMap */4],
	    /* gameObjectMap */targetDirectionLightRecord$1[/* gameObjectMap */5]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _buildIsNotSendTransformMatrixDataMap(isSendTransformMatrixDataMap) {
	  return reduceiValid((function (newMap, _, index) {
	                return set$1(index, false, newMap);
	              }), createEmpty$2(/* () */0), isSendTransformMatrixDataMap);
	}

	function _restoreTypeArrays$6(currentSourceInstanceRecord, targetSourceInstanceRecord) {
	  var match = currentSourceInstanceRecord[/* objectInstanceTransformCollections */4] === targetSourceInstanceRecord[/* objectInstanceTransformCollections */4] && currentSourceInstanceRecord[/* isTransformStatics */3] === targetSourceInstanceRecord[/* isTransformStatics */3];
	  if (match) {
	    return /* tuple */[
	            currentSourceInstanceRecord,
	            targetSourceInstanceRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$5(currentSourceInstanceRecord[/* index */0], getDefault(/* () */0), /* tuple */[
	          currentSourceInstanceRecord[/* objectInstanceTransformCollections */4],
	          currentSourceInstanceRecord[/* isTransformStatics */3]
	        ]);
	    fillUint32ArrayWithUint32Array(/* tuple */[
	          currentSourceInstanceRecord[/* objectInstanceTransformCollections */4],
	          0
	        ], /* tuple */[
	          targetSourceInstanceRecord[/* objectInstanceTransformCollections */4],
	          0
	        ], targetSourceInstanceRecord[/* objectInstanceTransformCollections */4].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentSourceInstanceRecord[/* isTransformStatics */3],
	          0
	        ], /* tuple */[
	          targetSourceInstanceRecord[/* isTransformStatics */3],
	          0
	        ], targetSourceInstanceRecord[/* isTransformStatics */3].length);
	    return /* tuple */[
	            currentSourceInstanceRecord,
	            targetSourceInstanceRecord
	          ];
	  }
	}

	function restore$17(currentState, sharedData, targetState) {
	  var currentSourceInstanceRecord = getRecord$7(currentState);
	  var targetSourceInstanceRecord = getRecord$7(targetState);
	  var float32ArrayPoolMap = addAllFloat32TypeArrayToPool(currentSourceInstanceRecord[/* matrixFloat32ArrayMap */6], getMaxBigTypeArrayPoolSize(targetState[/* settingRecord */1]), sharedData[/* float32ArrayPoolMap */1]);
	  var match = _restoreTypeArrays$6(currentSourceInstanceRecord, targetSourceInstanceRecord);
	  var targetSourceInstanceRecord$1 = match[1];
	  var currentSourceInstanceRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  return /* tuple */[
	          (newrecord[/* sourceInstanceRecord */7] = /* record */[
	              /* index */targetSourceInstanceRecord$1[/* index */0],
	              /* objectInstanceTransformIndexMap */targetSourceInstanceRecord$1[/* objectInstanceTransformIndexMap */1],
	              /* buffer */currentSourceInstanceRecord$1[/* buffer */2],
	              /* isTransformStatics */currentSourceInstanceRecord$1[/* isTransformStatics */3],
	              /* objectInstanceTransformCollections */currentSourceInstanceRecord$1[/* objectInstanceTransformCollections */4],
	              /* matrixInstanceBufferCapacityMap */targetSourceInstanceRecord$1[/* matrixInstanceBufferCapacityMap */5],
	              /* matrixFloat32ArrayMap */targetSourceInstanceRecord$1[/* matrixFloat32ArrayMap */6],
	              /* isSendTransformMatrixDataMap */_buildIsNotSendTransformMatrixDataMap(targetSourceInstanceRecord$1[/* isSendTransformMatrixDataMap */7]),
	              /* disposedIndexArray */targetSourceInstanceRecord$1[/* disposedIndexArray */8],
	              /* gameObjectMap */targetSourceInstanceRecord$1[/* gameObjectMap */9]
	            ], newrecord),
	          /* record */[
	            /* gl */sharedData[/* gl */0],
	            /* float32ArrayPoolMap */float32ArrayPoolMap,
	            /* uint16ArrayPoolMap */sharedData[/* uint16ArrayPoolMap */2]
	          ]
	        ];
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function _restoreTypeArrays$7(currentTextureRecord, targetTextureRecord) {
	  var match = currentTextureRecord[/* wrapSs */1] === targetTextureRecord[/* wrapSs */1] && currentTextureRecord[/* wrapTs */2] === targetTextureRecord[/* wrapTs */2] && currentTextureRecord[/* magFilters */3] === targetTextureRecord[/* magFilters */3] && currentTextureRecord[/* minFilters */4] === targetTextureRecord[/* minFilters */4] && currentTextureRecord[/* formats */5] === targetTextureRecord[/* formats */5] && currentTextureRecord[/* types */6] === targetTextureRecord[/* types */6] && currentTextureRecord[/* isNeedUpdates */7] === targetTextureRecord[/* isNeedUpdates */7] && currentTextureRecord[/* flipYs */8] === targetTextureRecord[/* flipYs */8];
	  if (match) {
	    return /* tuple */[
	            currentTextureRecord,
	            targetTextureRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$8(currentTextureRecord[/* index */0], /* tuple */[
	          currentTextureRecord[/* wrapSs */1],
	          currentTextureRecord[/* wrapTs */2],
	          currentTextureRecord[/* magFilters */3],
	          currentTextureRecord[/* minFilters */4],
	          currentTextureRecord[/* formats */5],
	          currentTextureRecord[/* types */6],
	          currentTextureRecord[/* isNeedUpdates */7],
	          currentTextureRecord[/* flipYs */8]
	        ]);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* wrapSs */1],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* wrapSs */1],
	          0
	        ], targetTextureRecord[/* wrapSs */1].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* wrapTs */2],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* wrapTs */2],
	          0
	        ], targetTextureRecord[/* wrapTs */2].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* magFilters */3],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* magFilters */3],
	          0
	        ], targetTextureRecord[/* magFilters */3].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* minFilters */4],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* minFilters */4],
	          0
	        ], targetTextureRecord[/* minFilters */4].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* formats */5],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* formats */5],
	          0
	        ], targetTextureRecord[/* formats */5].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* types */6],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* types */6],
	          0
	        ], targetTextureRecord[/* types */6].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* isNeedUpdates */7],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* isNeedUpdates */7],
	          0
	        ], targetTextureRecord[/* isNeedUpdates */7].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* flipYs */8],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* flipYs */8],
	          0
	        ], targetTextureRecord[/* flipYs */8].length);
	    return /* tuple */[
	            currentTextureRecord,
	            targetTextureRecord
	          ];
	  }
	}

	function restore$18(currentState, targetState) {
	  var currentTextureRecord = getRecord$9(currentState);
	  var targetTextureRecord = getRecord$9(targetState);
	  var match = _restoreTypeArrays$7(currentTextureRecord, targetTextureRecord);
	  var targetTextureRecord$1 = match[1];
	  var currentTextureRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */targetTextureRecord$1[/* index */0],
	    /* wrapSs */currentTextureRecord$1[/* wrapSs */1],
	    /* wrapTs */currentTextureRecord$1[/* wrapTs */2],
	    /* magFilters */currentTextureRecord$1[/* magFilters */3],
	    /* minFilters */currentTextureRecord$1[/* minFilters */4],
	    /* formats */currentTextureRecord$1[/* formats */5],
	    /* types */currentTextureRecord$1[/* types */6],
	    /* isNeedUpdates */currentTextureRecord$1[/* isNeedUpdates */7],
	    /* flipYs */currentTextureRecord$1[/* flipYs */8],
	    /* sourceMap */targetTextureRecord$1[/* sourceMap */9],
	    /* glTextureMap */targetTextureRecord$1[/* glTextureMap */10],
	    /* bindTextureUnitCacheMap */targetTextureRecord$1[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */targetTextureRecord$1[/* disposedIndexArray */12],
	    /* needAddedSourceArray */targetTextureRecord$1[/* needAddedSourceArray */13],
	    /* needInitedTextureIndexArray */targetTextureRecord$1[/* needInitedTextureIndexArray */14],
	    /* nameMap */targetTextureRecord$1[/* nameMap */15]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _restoreTypeArrays$8(currentTextureRecord, targetTextureRecord, arrayBufferViewSourceTextureIndexOffset) {
	  var match = currentTextureRecord[/* wrapSs */1] === targetTextureRecord[/* wrapSs */1] && currentTextureRecord[/* wrapTs */2] === targetTextureRecord[/* wrapTs */2] && currentTextureRecord[/* magFilters */3] === targetTextureRecord[/* magFilters */3] && currentTextureRecord[/* minFilters */4] === targetTextureRecord[/* minFilters */4] && currentTextureRecord[/* formats */5] === targetTextureRecord[/* formats */5] && currentTextureRecord[/* types */6] === targetTextureRecord[/* types */6] && currentTextureRecord[/* isNeedUpdates */7] === targetTextureRecord[/* isNeedUpdates */7] && currentTextureRecord[/* flipYs */8] === targetTextureRecord[/* flipYs */8] && currentTextureRecord[/* widths */9] === targetTextureRecord[/* widths */9] && currentTextureRecord[/* heights */10] === targetTextureRecord[/* heights */10];
	  if (match) {
	    return /* tuple */[
	            currentTextureRecord,
	            targetTextureRecord
	          ];
	  } else {
	    setAllTypeArrDataToDefault$9(currentTextureRecord[/* index */0], arrayBufferViewSourceTextureIndexOffset, /* tuple */[
	          currentTextureRecord[/* wrapSs */1],
	          currentTextureRecord[/* wrapTs */2],
	          currentTextureRecord[/* magFilters */3],
	          currentTextureRecord[/* minFilters */4],
	          currentTextureRecord[/* formats */5],
	          currentTextureRecord[/* types */6],
	          currentTextureRecord[/* isNeedUpdates */7],
	          currentTextureRecord[/* flipYs */8],
	          currentTextureRecord[/* widths */9],
	          currentTextureRecord[/* heights */10]
	        ]);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* wrapSs */1],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* wrapSs */1],
	          0
	        ], targetTextureRecord[/* wrapSs */1].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* wrapTs */2],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* wrapTs */2],
	          0
	        ], targetTextureRecord[/* wrapTs */2].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* magFilters */3],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* magFilters */3],
	          0
	        ], targetTextureRecord[/* magFilters */3].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* minFilters */4],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* minFilters */4],
	          0
	        ], targetTextureRecord[/* minFilters */4].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* formats */5],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* formats */5],
	          0
	        ], targetTextureRecord[/* formats */5].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* types */6],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* types */6],
	          0
	        ], targetTextureRecord[/* types */6].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* isNeedUpdates */7],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* isNeedUpdates */7],
	          0
	        ], targetTextureRecord[/* isNeedUpdates */7].length);
	    fillUint8ArrayWithUint8Array(/* tuple */[
	          currentTextureRecord[/* flipYs */8],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* flipYs */8],
	          0
	        ], targetTextureRecord[/* flipYs */8].length);
	    fillUint16ArrayWithUint16Array(/* tuple */[
	          currentTextureRecord[/* widths */9],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* widths */9],
	          0
	        ], targetTextureRecord[/* widths */9].length);
	    fillUint16ArrayWithUint16Array(/* tuple */[
	          currentTextureRecord[/* heights */10],
	          0
	        ], /* tuple */[
	          targetTextureRecord[/* heights */10],
	          0
	        ], targetTextureRecord[/* heights */10].length);
	    return /* tuple */[
	            currentTextureRecord,
	            targetTextureRecord
	          ];
	  }
	}

	function restore$19(currentState, targetState) {
	  var currentTextureRecord = getRecord$11(currentState);
	  var targetTextureRecord = getRecord$11(targetState);
	  var match = _restoreTypeArrays$8(currentTextureRecord, targetTextureRecord, getArrayBufferViewSourceTextureIndexOffset$1(currentState));
	  var targetTextureRecord$1 = match[1];
	  var currentTextureRecord$1 = match[0];
	  var newrecord = caml_array_dup(targetState);
	  newrecord[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */targetTextureRecord$1[/* index */0],
	    /* wrapSs */currentTextureRecord$1[/* wrapSs */1],
	    /* wrapTs */currentTextureRecord$1[/* wrapTs */2],
	    /* magFilters */currentTextureRecord$1[/* magFilters */3],
	    /* minFilters */currentTextureRecord$1[/* minFilters */4],
	    /* formats */currentTextureRecord$1[/* formats */5],
	    /* types */currentTextureRecord$1[/* types */6],
	    /* isNeedUpdates */currentTextureRecord$1[/* isNeedUpdates */7],
	    /* flipYs */currentTextureRecord$1[/* flipYs */8],
	    /* widths */currentTextureRecord$1[/* widths */9],
	    /* heights */currentTextureRecord$1[/* heights */10],
	    /* sourceMap */targetTextureRecord$1[/* sourceMap */11],
	    /* glTextureMap */targetTextureRecord$1[/* glTextureMap */12],
	    /* bindTextureUnitCacheMap */targetTextureRecord$1[/* bindTextureUnitCacheMap */13],
	    /* disposedIndexArray */targetTextureRecord$1[/* disposedIndexArray */14],
	    /* needAddedSourceArray */targetTextureRecord$1[/* needAddedSourceArray */15],
	    /* needInitedTextureIndexArray */targetTextureRecord$1[/* needInitedTextureIndexArray */16],
	    /* nameMap */targetTextureRecord$1[/* nameMap */17]
	  ];
	  return newrecord;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _getSharedData(currentState) {
	  var typeArrayPoolRecord = currentState[/* typeArrayPoolRecord */37];
	  return /* record */[
	          /* gl */unsafeGetGl$1(currentState[/* deviceManagerRecord */10]),
	          /* float32ArrayPoolMap */getFloat32ArrayPoolMap(typeArrayPoolRecord),
	          /* uint16ArrayPoolMap */getUint16ArrayPoolMap(typeArrayPoolRecord)
	        ];
	}

	function restore(stateData, currentState, targetState) {
	  var sharedData = _getSharedData(currentState);
	  var match = restore$17(currentState, sharedData, targetState);
	  var sharedData$1 = match[1];
	  var targetState$1 = restore$11(currentState, sharedData$1, match[0]);
	  var gl = unsafeGetGl$1(targetState$1[/* deviceManagerRecord */10]);
	  return setState$2(stateData, restore$19(currentState, restore$18(currentState, restore$13(currentState, restore$8(currentState, restore$16(currentState, restore$15(currentState, restore$4(currentState, restore$1(currentState, restore$12(gl, currentState, restore$10(gl, currentState, restore$6(currentState, restore$9(currentState, restore$3(currentState, restore$2(currentState, restore$5(currentState, restore$7(currentState, restore$14(currentState, sharedData$1, targetState$1))))))))))))))))));
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	function deepCopyForRestore$24(state) {
	  var state$1 = deepCopyForRestore$14(deepCopyForRestore$13(deepCopyForRestore$11(deepCopyForRestore$12(deepCopyForRestore$7(deepCopyForRestore$6(deepCopyForRestore$3(deepCopyForRestore$2(deepCopyForRestore$5(deepCopyForRestore$4(deepCopyForRestore$1(deepCopyForRestore$15(state))))))))))));
	  var newrecord = caml_array_dup(state$1);
	  newrecord[/* objectInstanceRecord */8] = deepCopyForRestore$20(state$1[/* objectInstanceRecord */8]);
	  newrecord[/* deviceManagerRecord */10] = deepCopyForRestore$18(state$1[/* deviceManagerRecord */10]);
	  newrecord[/* gameObjectRecord */11] = deepCopyForRestore$17(state$1[/* gameObjectRecord */11]);
	  newrecord[/* basicCameraViewRecord */14] = deepCopyForRestore$21(state$1[/* basicCameraViewRecord */14]);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = deepCopyForRestore$23(state$1[/* perspectiveCameraProjectionRecord */15]);
	  newrecord[/* arcballCameraControllerRecord */26] = deepCopyForRestore$22(state$1[/* arcballCameraControllerRecord */26]);
	  newrecord[/* shaderRecord */27] = deepCopyForRestore$10(state$1[/* shaderRecord */27]);
	  newrecord[/* glslRecord */28] = deepCopyForRestore$9(state$1[/* glslRecord */28]);
	  newrecord[/* vboBufferRecord */35] = deepCopyForRestore$16(state$1[/* vboBufferRecord */35]);
	  newrecord[/* typeArrayPoolRecord */37] = deepCopyForRestore$19(state$1[/* typeArrayPoolRecord */37]);
	  return newrecord;
	}


	/* RecordShaderService-Wonderjs Not a pure module */

	function restoreState$1(currentState, targetState) {
	  return restore(stateData, currentState, targetState);
	}

	function getStateData$1() {
	  return stateData;
	}

	function createStateData$2() {
	  return createStateData$1(/* () */0);
	}

	function unsafeGetState$1() {
	  return unsafeGetState$2(stateData);
	}

	var getStateFromData$1 = unsafeGetState$2;

	function createState$1() {
	  return createState$2(/* () */0);
	}

	function setState$1(state) {
	  return setState$2(stateData, state);
	}

	var setStateToData$1 = setState$2;

	function setIsDebug$2(isDebug) {
	  return setIsDebug$1(stateData, isDebug);
	}

	var setUnsafeGetStateFunc$1 = setUnsafeGetStateFunc$2;

	var setSetStateFunc$1 = setSetStateFunc$2;

	var deepCopyForRestore$8 = deepCopyForRestore$24;


	/* StateDataMain-Wonderjs Not a pure module */

	function queryFullScreenData() {
	  var root = window;
	  return /* tuple */[
	          0,
	          0,
	          root.innerWidth,
	          root.innerHeight,
	          "100%",
	          "100%"
	        ];
	}

	function _setAbsolutePosition(canvas) {
	  canvas.style.position = "absolute";
	  return canvas;
	}

	function setX(x, canvas) {
	  canvas.style.left = "" + (String(x) + "px");
	  return canvas;
	}

	function setY(y, canvas) {
	  canvas.style.top = "" + (String(y) + "px");
	  return canvas;
	}

	function setWidth$1(width, canvas) {
	  canvas.width = width;
	  return canvas;
	}

	function setHeight$1(height, canvas) {
	  canvas.height = height;
	  return canvas;
	}

	function setStyleWidth(width, canvas) {
	  canvas.style.width = width;
	  return canvas;
	}

	function setStyleHeight(height, canvas) {
	  canvas.style.height = height;
	  return canvas;
	}

	function _setBodyMargin($$document) {
	  var bodies = $$document.querySelectorAll("body");
	  if (bodies.length === 0) {
	    return /* () */0;
	  } else {
	    setBatchStyle(caml_array_get(bodies, 0), "margin:0");
	    return /* () */0;
	  }
	}

	function setToFullScreen(param, canvas) {
	  _setBodyMargin(document);
	  return setStyleHeight(param[5], setStyleWidth(param[4], setHeight$1(param[3], setWidth$1(param[2], setY(param[1], setX(param[0], _setAbsolutePosition(canvas)))))));
	}

	function setScreenSize$2(param, canvas) {
	  return setStyleHeight(param[3], setStyleWidth(param[2], setHeight$1(param[1], setWidth$1(param[0], canvas))));
	}


	/* No side effect */

	var setScreenSize$1 = setScreenSize$2;


	/* No side effect */

	var classCallCheck$1 = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var NONE = /*#__PURE__*/new (function () {
	  function DisposeNone() {
	    classCallCheck$1(this, DisposeNone);
	  }

	  DisposeNone.prototype.dispose = function dispose() {};

	  return DisposeNone;
	}())();

	/** @license MIT License (c) copyright 2010-2017 original author or authors */

	// Wrap an existing disposable (which may not already have been once()d)
	// so that it will only dispose its underlying resource at most once.
	var disposeOnce = function disposeOnce(disposable) {
	  return new DisposeOnce(disposable);
	};

	var DisposeOnce = /*#__PURE__*/function () {
	  function DisposeOnce(disposable) {
	    classCallCheck$1(this, DisposeOnce);

	    this.disposed = false;
	    this.disposable = disposable;
	  }

	  DisposeOnce.prototype.dispose = function dispose() {
	    if (!this.disposed) {
	      this.disposed = true;
	      this.disposable.dispose();
	      this.disposable = undefined;
	    }
	  };

	  return DisposeOnce;
	}();

	/** @license MIT License (c) copyright 2010-2017 original author or authors */
	// Create a Disposable that will use the provided
	// dispose function to dispose the resource
	var disposeWith = /*#__PURE__*/curry2(function (dispose, resource) {
	  return disposeOnce(new DisposeWith(dispose, resource));
	});

	// Disposable represents a resource that must be
	// disposed/released. It aggregates a function to dispose
	// the resource and a handle to a key/id/handle/reference
	// that identifies the resource

	var DisposeWith = /*#__PURE__*/function () {
	  function DisposeWith(dispose, resource) {
	    classCallCheck$1(this, DisposeWith);

	    this._dispose = dispose;
	    this._resource = resource;
	  }

	  DisposeWith.prototype.dispose = function dispose() {
	    this._dispose(this._resource);
	  };

	  return DisposeWith;
	}();

	var DisposeAllError = /*#__PURE__*/function (Error) {
	  function DisposeAllError(message, errors) {
	    Error.call(this, message);
	    this.message = message;
	    this.name = DisposeAllError.name;
	    this.errors = errors;

	    if (Error.captureStackTrace) {
	      Error.captureStackTrace(this, DisposeAllError);
	    }

	    this.stack = '' + this.stack + formatErrorStacks(this.errors);
	  }

	  DisposeAllError.prototype = /*#__PURE__*/Object.create(Error.prototype);

	  return DisposeAllError;
	}(Error);

	var formatErrorStacks = function formatErrorStacks(errors) {
	  return reduce(formatErrorStack, '', errors);
	};

	var formatErrorStack = function formatErrorStack(s, e, i) {
	  return s + ('\n[' + (i + 1) + '] ' + e.stack);
	};

	var classCallCheck = function (instance, Constructor) {
	    if (!(instance instanceof Constructor)) {
	        throw new TypeError("Cannot call a class as a function");
	    }
	};

	var createClass = function () {
	    function defineProperties(target, props) {
	        for (var i = 0; i < props.length; i++) {
	            var descriptor = props[i];
	            descriptor.enumerable = descriptor.enumerable || false;
	            descriptor.configurable = true;
	            if ("value" in descriptor) descriptor.writable = true;
	            Object.defineProperty(target, descriptor.key, descriptor);
	        }
	    }

	    return function (Constructor, protoProps, staticProps) {
	        if (protoProps) defineProperties(Constructor.prototype, protoProps);
	        if (staticProps) defineProperties(Constructor, staticProps);
	        return Constructor;
	    };
	}();

	var nextAnimationFrame = function nextAnimationFrame() {
	    return { source: new AnimationFrame() };
	};

	var AnimationFrame = function () {
	    function AnimationFrame() {
	        classCallCheck(this, AnimationFrame);

	        // this.afp = afp;
	    }

	    var _originTime = null;

	    function _getCurrentTime() {
	        if (_originTime === null) {
	            _originTime = window.performance.now();
	            return 0;
	        }

	        var currentTime = window.performance.now() - _originTime;

	        _originTime = window.performance.now();

	        return currentTime;
	    }


	    function _runRequest(sink, scheduler$$1) {
	        var propagate = function propagate(timestamp) {
	            // edit by wonder
	            // return eventThenEnd(currentTime(scheduler$$1), timestamp, sink);
	            // return eventThenEnd(currentTime(newDefaultScheduler() ), timestamp, sink);
	            eventThenEnd(_getCurrentTime, timestamp, sink);

	            // _runRequest(sink, null);
	        };
	        // var request = this.afp.requestAnimationFrame(propagate);
	        var request = window.requestAnimationFrame(propagate);


	        // edit by wonder
	        // return disposeWith(this.afp.cancelAnimationFrame, request);

	        return disposeWith(function (requestId) {
	            window.cancelAnimationFrame(requestId);
	        }, request)
	    }


	    createClass(AnimationFrame, [{
	        key: 'run',
	        value: _runRequest
	    }]);
	    return AnimationFrame;
	}();

	var eventThenEnd = function eventThenEnd(t, x, sink) {
	    sink.event(t, x);
	    sink.end(t);
	};

	function getGameTime$1(param) {
	  return param[/* gameTime */4];
	}

	function getFps$1(param) {
	  return param[/* fps */5];
	}

	function getElapsed(param) {
	  return param[/* elapsed */0];
	}

	function _computeFps(deltaTime, lastTime) {
	  if (lastTime !== undefined) {
	    return 1000 / deltaTime;
	  } else {
	    return 60;
	  }
	}

	function tick(elapsed, record) {
	  var lastTime = record[/* lastTime */3];
	  var deltaTime = lastTime !== undefined ? elapsed - lastTime : elapsed;
	  return /* record */[
	          /* elapsed */record[/* elapsed */0],
	          /* startTime */record[/* startTime */1],
	          /* deltaTime */deltaTime,
	          /* lastTime */elapsed,
	          /* gameTime */elapsed / 1000,
	          /* fps */_computeFps(deltaTime, lastTime)
	        ];
	}

	function start(record) {
	  return /* record */[
	          /* elapsed */0,
	          /* startTime */window.performance.now(),
	          /* deltaTime */record[/* deltaTime */2],
	          /* lastTime */record[/* lastTime */3],
	          /* gameTime */record[/* gameTime */4],
	          /* fps */record[/* fps */5]
	        ];
	}

	function computeElapseTime(time, record) {
	  return ensureCheck((function (param) {
	                var elapsed = param[/* elapsed */0];
	                return test(buildAssertMessage("elapsed >= 0", "is " + (String(elapsed) + "")), (function () {
	                              return Operators[/* >=. */8](elapsed, 0);
	                            }));
	              }), getIsDebug(stateData), /* record */[
	              /* elapsed */leastFloat(0, time - record[/* startTime */1]),
	              /* startTime */record[/* startTime */1],
	              /* deltaTime */record[/* deltaTime */2],
	              /* lastTime */record[/* lastTime */3],
	              /* gameTime */record[/* gameTime */4],
	              /* fps */record[/* fps */5]
	            ]);
	}


	/* Log-WonderLog Not a pure module */

	var createJobHandleMap = fromList;


	/* HashMapService-WonderCommonlib Not a pure module */

	function execJob$1(timeControllerRecord) {
	  return tick(getElapsed(timeControllerRecord), timeControllerRecord);
	}


	/* TimeControllerService-Wonderjs Not a pure module */

	function execJob(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                state[/* timeControllerRecord */34] = execJob$1(state[/* timeControllerRecord */34]);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* No side effect */

	/* OptionService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function getLastXY(param) {
	  var mouseEventData = param[/* mouseEventData */6];
	  return /* tuple */[
	          mouseEventData[/* lastX */0],
	          mouseEventData[/* lastY */1]
	        ];
	}

	function setLastXY$1(lastX, lastY, eventRecord) {
	  return /* record */[
	          /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	          /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	          /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	          /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	          /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	          /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	          /* mouseEventData : record */[
	            /* lastX */lastX,
	            /* lastY */lastY,
	            /* isDrag */eventRecord[/* mouseEventData */6][/* isDrag */2]
	          ],
	          /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	          /* touchEventData */eventRecord[/* touchEventData */8]
	        ];
	}


	/* No side effect */

	function _getLocation$1(mouseDomEvent, param) {
	  var browser = param[/* browserDetectRecord */41][/* browser */0];
	  if (browser >= 2) {
	    return fatalUnknownBrowser("_getLocation", browser);
	  } else {
	    return /* tuple */[
	            mouseDomEvent.pageX,
	            mouseDomEvent.pageY
	          ];
	  }
	}

	function _getLocationInView(mouseDomEvent, state) {
	  return getLocationInView(mouseDomEvent, _getLocation$1, state);
	}

	function _getButton(mouseDomEvent, state) {
	  var browser = state[/* browserDetectRecord */41][/* browser */0];
	  if (browser >= 2) {
	    return fatalUnknownBrowser("_getButton", browser);
	  } else {
	    var button = mouseDomEvent.button;
	    if (button > 2 || button < 0) {
	      return fatal(buildFatalMessage("_getButton", "not support multi mouse button", "", "", "button: " + (String(button) + "")));
	    } else {
	      return button;
	    }
	  }
	}

	function _getFromWheelDelta(mouseDomEvent) {
	  var match = mouseDomEvent.wheelDelta;
	  if (match == null) {
	    return 0;
	  } else {
	    return match / 120 | 0;
	  }
	}

	function _getWheel(mouseDomEvent) {
	  var match = mouseDomEvent.detail;
	  if (!(match == null) && match !== 0) {
	    return imul(-1, match);
	  } else {
	    return _getFromWheelDelta(mouseDomEvent);
	  }
	}

	var _isPointerLocked = function (){
	  return !!(
	    document.pointerLockElement
	    || document.mozPointerLockElement
	    || document.webkitPointerLockElement
	  );
	    };

	function _getMovementDeltaWhenPointerLocked(mouseDomEvent, _) {
	  var match = mouseDomEvent.movementX;
	  var tmp;
	  if (match == null) {
	    var match$1 = mouseDomEvent.webkitMovementX;
	    if (match$1 == null) {
	      var match$2 = mouseDomEvent.mozMovementX;
	      tmp = (match$2 == null) ? 0 : match$2;
	    } else {
	      tmp = match$1;
	    }
	  } else {
	    tmp = match;
	  }
	  var match$3 = mouseDomEvent.movementY;
	  var tmp$1;
	  if (match$3 == null) {
	    var match$4 = mouseDomEvent.webkitMovementY;
	    if (match$4 == null) {
	      var match$5 = mouseDomEvent.mozMovementY;
	      tmp$1 = (match$5 == null) ? 0 : match$5;
	    } else {
	      tmp$1 = match$4;
	    }
	  } else {
	    tmp$1 = match$3;
	  }
	  return /* tuple */[
	          tmp,
	          tmp$1
	        ];
	}

	function _getMovementDelta(mouseDomEvent, state) {
	  var match = _isPointerLocked();
	  if (match) {
	    return _getMovementDeltaWhenPointerLocked(mouseDomEvent, state);
	  } else {
	    return getMovementDelta(_getLocation$1(mouseDomEvent, state), getLastXY(state[/* eventRecord */42]), state);
	  }
	}

	function _convertMouseDomEventToMouseEvent(eventName, mouseDomEvent, state) {
	  return /* record */[
	          /* name */eventName,
	          /* location */_getLocation$1(mouseDomEvent, state),
	          /* locationInView */_getLocationInView(mouseDomEvent, state),
	          /* button */_getButton(mouseDomEvent, state),
	          /* wheel */_getWheel(mouseDomEvent),
	          /* movementDelta */_getMovementDelta(mouseDomEvent, state),
	          /* event */mouseDomEvent
	        ];
	}

	function execEventHandle(eventName, mouseDomEvent, state) {
	  var match = get$3(eventName, state[/* eventRecord */42][/* mouseDomEventDataArrMap */1]);
	  if (match !== undefined) {
	    return reduceOneParam((function (state, param) {
	                  return param[/* handleFunc */1](_convertMouseDomEventToMouseEvent(eventName, mouseDomEvent, state), state);
	                }), state, match);
	  } else {
	    return state;
	  }
	}

	function setLastXY(lastX, lastY, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = setLastXY$1(lastX, lastY, state[/* eventRecord */42]);
	  return newrecord;
	}

	function setLastXYByLocation(eventName, mouseDomEvent, state) {
	  var match = _convertMouseDomEventToMouseEvent(eventName, mouseDomEvent, state);
	  var $$location = match[/* location */1];
	  return setLastXY($$location[0], $$location[1], state);
	}

	function getIsDrag(state) {
	  return state[/* eventRecord */42][/* mouseEventData */6][/* isDrag */2];
	}

	function setIsDrag(isDrag, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  var init = eventRecord[/* mouseEventData */6];
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData : record */[
	      /* lastX */init[/* lastX */0],
	      /* lastY */init[/* lastY */1],
	      /* isDrag */isDrag
	    ],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData */eventRecord[/* touchEventData */8]
	  ];
	  return newrecord;
	}

	function setLastXYWhenMouseMove(eventName, mouseDomEvent, state) {
	  var match = getIsDrag(state);
	  if (match) {
	    return state;
	  } else {
	    return setLastXYByLocation(eventName, mouseDomEvent, state);
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getLastXY$1(param) {
	  var touchEventData = param[/* touchEventData */8];
	  return /* tuple */[
	          touchEventData[/* lastX */0],
	          touchEventData[/* lastY */1]
	        ];
	}

	function setLastXY$3(lastX, lastY, eventRecord) {
	  return /* record */[
	          /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	          /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	          /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	          /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	          /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	          /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	          /* mouseEventData */eventRecord[/* mouseEventData */6],
	          /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	          /* touchEventData : record */[
	            /* lastX */lastX,
	            /* lastY */lastY,
	            /* isDrag */eventRecord[/* touchEventData */8][/* isDrag */2]
	          ]
	        ];
	}


	/* No side effect */

	function _getTouchData(touchDomEvent) {
	  var changedTouches = touchDomEvent.changedTouches;
	  var touchDataJsObj = changedTouches[0];
	  return /* record */[
	          /* clientX */touchDataJsObj.clientX,
	          /* clientY */touchDataJsObj.clientY,
	          /* pageX */touchDataJsObj.pageX,
	          /* pageY */touchDataJsObj.pageY,
	          /* identifier */touchDataJsObj.identifier,
	          /* screenX */touchDataJsObj.screenX,
	          /* screenY */touchDataJsObj.screenY,
	          /* radiusX */touchDataJsObj.radiusX,
	          /* radiusY */touchDataJsObj.radiusY,
	          /* rotationAngle */touchDataJsObj.rotationAngle,
	          /* force */touchDataJsObj.force
	        ];
	}

	function _getLocation$2(touchDomEvent, _) {
	  var match = _getTouchData(touchDomEvent);
	  return /* tuple */[
	          match[/* pageX */2],
	          match[/* pageY */3]
	        ];
	}

	function _getMovementDelta$1(touchDomEvent, state) {
	  return getMovementDelta(_getLocation$2(touchDomEvent, state), getLastXY$1(state[/* eventRecord */42]), state);
	}

	function _convertTouchDomEventToTouchEvent(eventName, touchDomEvent, state) {
	  return /* record */[
	          /* name */eventName,
	          /* location */_getLocation$2(touchDomEvent, state),
	          /* locationInView */getLocationInView(touchDomEvent, _getLocation$2, state),
	          /* touchData */_getTouchData(touchDomEvent),
	          /* movementDelta */_getMovementDelta$1(touchDomEvent, state),
	          /* event */touchDomEvent
	        ];
	}

	function execEventHandle$1(eventName, touchDomEvent, state) {
	  preventDefault(touchDomEvent);
	  var match = get$3(eventName, state[/* eventRecord */42][/* touchDomEventDataArrMap */3]);
	  if (match !== undefined) {
	    return reduceOneParam((function (state, param) {
	                  return param[/* handleFunc */1](_convertTouchDomEventToTouchEvent(eventName, touchDomEvent, state), state);
	                }), state, match);
	  } else {
	    return state;
	  }
	}

	function setLastXY$2(lastX, lastY, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* eventRecord */42] = setLastXY$3(lastX, lastY, state[/* eventRecord */42]);
	  return newrecord;
	}

	function setLastXYByLocation$1(eventName, touchDomEvent, state) {
	  var match = _convertTouchDomEventToTouchEvent(eventName, touchDomEvent, state);
	  var $$location = match[/* location */1];
	  return setLastXY$2($$location[0], $$location[1], state);
	}

	function getIsDrag$1(state) {
	  return state[/* eventRecord */42][/* touchEventData */8][/* isDrag */2];
	}

	function setIsDrag$1(isDrag, state) {
	  var eventRecord = state[/* eventRecord */42];
	  var newrecord = caml_array_dup(state);
	  var init = eventRecord[/* touchEventData */8];
	  newrecord[/* eventRecord */42] = /* record */[
	    /* domEventStreamSubscription */eventRecord[/* domEventStreamSubscription */0],
	    /* mouseDomEventDataArrMap */eventRecord[/* mouseDomEventDataArrMap */1],
	    /* keyboardDomEventDataArrMap */eventRecord[/* keyboardDomEventDataArrMap */2],
	    /* touchDomEventDataArrMap */eventRecord[/* touchDomEventDataArrMap */3],
	    /* customGlobalEventArrMap */eventRecord[/* customGlobalEventArrMap */4],
	    /* customGameObjectEventArrMap */eventRecord[/* customGameObjectEventArrMap */5],
	    /* mouseEventData */eventRecord[/* mouseEventData */6],
	    /* keyboardEventData */eventRecord[/* keyboardEventData */7],
	    /* touchEventData : record */[
	      /* lastX */init[/* lastX */0],
	      /* lastY */init[/* lastY */1],
	      /* isDrag */isDrag
	    ]
	  ];
	  return newrecord;
	}

	function setLastXYWhenTouchMove(eventName, touchDomEvent, state) {
	  var match = getIsDrag$1(state);
	  if (match) {
	    return state;
	  } else {
	    return setLastXYByLocation$1(eventName, touchDomEvent, state);
	  }
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function create$58(eventName, userData) {
	  return /* record */[
	          /* name */eventName,
	          /* target */undefined,
	          /* isStopPropagation */false,
	          /* phase */undefined,
	          /* userData */userData
	        ];
	}


	/* No side effect */

	function _getKeyFromSpecialKeyMap(keyCode, $$char, specialKeyMap) {
	  var match = get$3(keyCode, specialKeyMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    return $$char;
	  }
	}

	function _handleShiftKey(keyCode, $$char, param) {
	  var match = get$3(keyCode, param[0]);
	  if (match !== undefined) {
	    return match;
	  } else {
	    var match$1 = get($$char, param[1]);
	    if (match$1 !== undefined) {
	      return match$1;
	    } else {
	      return _getKeyFromSpecialKeyMap(keyCode, $$char, param[2]);
	    }
	  }
	}

	function _getKey(keyboardDomEvent, param) {
	  var keyboardEventData = param[/* eventRecord */42][/* keyboardEventData */7];
	  var specialKeyMap = keyboardEventData[/* specialKeyMap */0];
	  var keyCode = keyboardDomEvent.keyCode;
	  var $$char = String.fromCharCode(keyCode).toLowerCase();
	  var match = keyboardDomEvent.shiftKey;
	  if (match) {
	    return _handleShiftKey(keyCode, $$char, /* tuple */[
	                keyboardEventData[/* shiftKeyByKeyCodeMap */1],
	                keyboardEventData[/* shiftKeyByCharCodeMap */2],
	                specialKeyMap
	              ]);
	  } else {
	    return _getKeyFromSpecialKeyMap(keyCode, $$char, specialKeyMap);
	  }
	}

	function _convertKeyboardDomEventToKeyboardEvent(eventName, keyboardDomEvent, state) {
	  return /* record */[
	          /* name */eventName,
	          /* keyCode */keyboardDomEvent.keyCode,
	          /* ctrlKey */keyboardDomEvent.ctrlKey,
	          /* altKey */keyboardDomEvent.altKey,
	          /* shiftKey */keyboardDomEvent.shiftKey,
	          /* metaKey */keyboardDomEvent.metaKey,
	          /* key */_getKey(keyboardDomEvent, state),
	          /* event */keyboardDomEvent
	        ];
	}

	function execEventHandle$2(eventName, keyboardDomEvent, state) {
	  var match = get$3(eventName, state[/* eventRecord */42][/* keyboardDomEventDataArrMap */2]);
	  if (match !== undefined) {
	    return reduceOneParam((function (state, param) {
	                  return param[/* handleFunc */1](_convertKeyboardDomEventToKeyboardEvent(eventName, keyboardDomEvent, state), state);
	                }), state, match);
	  } else {
	    return state;
	  }
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function _fromPointDomEvent(eventName, state) {
	  return fromEvent(eventName, unsafeGetCanvas(state[/* viewRecord */9]), false);
	}

	function _fromKeyboardDomEvent(eventName, _) {
	  return fromEvent(eventName, document.body, false);
	}

	function _convertMouseEventToPointEvent(eventName, param) {
	  return /* record */[
	          /* name */eventName,
	          /* location */param[/* location */1],
	          /* locationInView */param[/* locationInView */2],
	          /* button */param[/* button */3],
	          /* wheel */param[/* wheel */4],
	          /* movementDelta */param[/* movementDelta */5],
	          /* event */param[/* event */6]
	        ];
	}

	function _bindDomEventToTriggerPointEvent(param, param$1, state) {
	  var convertDomEventToPointEventFunc = param$1[1];
	  var pointEventName = param[2];
	  var customEventName = param[1];
	  return _4(param$1[0], param[0], (function (mouseEvent, state) {
	                return triggerCustomGlobalEvent$1(create$58(customEventName, some$1(_2(convertDomEventToPointEventFunc, pointEventName, mouseEvent))), state)[0];
	              }), state, /* () */0);
	}

	function _bindMouseEventToTriggerPointEvent(mouseEventName, customEventName, pointEventName, state) {
	  return _bindDomEventToTriggerPointEvent(/* tuple */[
	              mouseEventName,
	              customEventName,
	              pointEventName
	            ], /* tuple */[
	              (function (param) {
	                  var func = function (param$1, param$2, param$3, param$4) {
	                    return onMouseEvent$1(param, param$1, param$2, param$3, param$4);
	                  };
	                  return (function (param) {
	                      var func$1 = _1(func, param);
	                      return (function (param) {
	                          return _2(func$1, param, 0);
	                        });
	                    });
	                }),
	              _convertMouseEventToPointEvent
	            ], state);
	}

	function _convertTouchEventToPointEvent(eventName, param) {
	  return /* record */[
	          /* name */eventName,
	          /* location */param[/* location */1],
	          /* locationInView */param[/* locationInView */2],
	          /* button */undefined,
	          /* wheel */undefined,
	          /* movementDelta */param[/* movementDelta */4],
	          /* event */param[/* event */5]
	        ];
	}

	function _bindTouchEventToTriggerPointEvent(touchEventName, customEventName, pointEventName, state) {
	  return _bindDomEventToTriggerPointEvent(/* tuple */[
	              touchEventName,
	              customEventName,
	              pointEventName
	            ], /* tuple */[
	              (function (param) {
	                  var func = function (param$1, param$2, param$3, param$4) {
	                    return onTouchEvent$1(param, param$1, param$2, param$3, param$4);
	                  };
	                  return (function (param) {
	                      var func$1 = _1(func, param);
	                      return (function (param) {
	                          return _2(func$1, param, 0);
	                        });
	                    });
	                }),
	              _convertTouchEventToPointEvent
	            ], state);
	}

	function bindDomEventToTriggerPointEvent(state) {
	  var browser = state[/* browserDetectRecord */41][/* browser */0];
	  if (browser >= 2) {
	    if (browser >= 4) {
	      return fatal(buildFatalMessage("bindDomEventToTriggerPointEvent", "unknown browser", "", "", "browser:" + (String(browser) + "")));
	    } else {
	      return _bindTouchEventToTriggerPointEvent(/* TouchDrag */14, getPointDragEventName$1(/* () */0), /* PointDrag */5, _bindTouchEventToTriggerPointEvent(/* TouchMove */12, getPointMoveEventName$1(/* () */0), /* PointMove */3, _bindTouchEventToTriggerPointEvent(/* TouchStart */13, getPointDownEventName$1(/* () */0), /* PointDown */1, _bindTouchEventToTriggerPointEvent(/* TouchEnd */11, getPointUpEventName$1(/* () */0), /* PointUp */2, _bindTouchEventToTriggerPointEvent(/* TouchTap */10, getPointTapEventName$1(/* () */0), /* PointTap */0, state)))));
	    }
	  } else {
	    return _bindMouseEventToTriggerPointEvent(/* MouseDrag */6, getPointDragEventName$1(/* () */0), /* PointDrag */5, _bindMouseEventToTriggerPointEvent(/* MouseMove */4, getPointMoveEventName$1(/* () */0), /* PointMove */3, _bindMouseEventToTriggerPointEvent(/* MouseWheel */5, getPointScaleEventName$1(/* () */0), /* PointScale */4, _bindMouseEventToTriggerPointEvent(/* MouseDown */2, getPointDownEventName$1(/* () */0), /* PointDown */1, _bindMouseEventToTriggerPointEvent(/* MouseUp */3, getPointUpEventName$1(/* () */0), /* PointUp */2, _bindMouseEventToTriggerPointEvent(/* Click */1, getPointTapEventName$1(/* () */0), /* PointTap */0, state))))));
	  }
	}

	function _execMouseEventHandle(mouseEventName, $$event, state) {
	  setStateByFunc(execEventHandle(mouseEventName, $$event, unsafeGetStateByFunc(state)));
	  return /* () */0;
	}

	function _execMouseMoveEventHandle(mouseEventName, $$event, state) {
	  setStateByFunc(setLastXYWhenMouseMove(mouseEventName, $$event, execEventHandle(mouseEventName, $$event, unsafeGetStateByFunc(state))));
	  return /* () */0;
	}

	function _execMouseDragingEventHandle(mouseEventName, $$event, state) {
	  setStateByFunc(setLastXYByLocation(mouseEventName, $$event, execEventHandle(mouseEventName, $$event, unsafeGetStateByFunc(state))));
	  return /* () */0;
	}

	function _execMouseDragStartEventHandle(state) {
	  setStateByFunc(setLastXY(undefined, undefined, setIsDrag(true, unsafeGetStateByFunc(state))));
	  return /* () */0;
	}

	function _execMouseDragEndEventHandle(state) {
	  setStateByFunc(setIsDrag(false, unsafeGetStateByFunc(state)));
	  return /* () */0;
	}

	function _execTouchEventHandle(touchEventName, $$event, state) {
	  setStateByFunc(execEventHandle$1(touchEventName, $$event, unsafeGetStateByFunc(state)));
	  return /* () */0;
	}

	function _execTouchMoveEventHandle(touchEventName, $$event, state) {
	  setStateByFunc(setLastXYWhenTouchMove(touchEventName, $$event, execEventHandle$1(touchEventName, $$event, unsafeGetStateByFunc(state))));
	  return /* () */0;
	}

	function _execTouchDragingEventHandle(touchEventName, $$event, state) {
	  setStateByFunc(setLastXYByLocation$1(touchEventName, $$event, execEventHandle$1(touchEventName, $$event, unsafeGetStateByFunc(state))));
	  return /* () */0;
	}

	function _execTouchDragStartEventHandle(state) {
	  setStateByFunc(setLastXY$2(undefined, undefined, setIsDrag$1(true, unsafeGetStateByFunc(state))));
	  return /* () */0;
	}

	function _execTouchDragEndEventHandle(state) {
	  setStateByFunc(setIsDrag$1(false, unsafeGetStateByFunc(state)));
	  return /* () */0;
	}

	function _execKeyboardEventHandle(keyboardEventName, $$event, state) {
	  setStateByFunc(execEventHandle$2(keyboardEventName, $$event, unsafeGetStateByFunc(state)));
	  return /* () */0;
	}

	function _fromPCDomEventArr(state) {
	  return /* array */[
	          tap((function ($$event) {
	                  preventDefault$1($$event);
	                  return /* () */0;
	                }), fromEvent("contextmenu", document.body, false)),
	          tap((function ($$event) {
	                  return _execMouseEventHandle(/* Click */1, $$event, state);
	                }), _fromPointDomEvent("click", state)),
	          tap((function ($$event) {
	                  return _execMouseEventHandle(/* MouseDown */2, $$event, state);
	                }), _fromPointDomEvent("mousedown", state)),
	          tap((function ($$event) {
	                  return _execMouseEventHandle(/* MouseUp */3, $$event, state);
	                }), _fromPointDomEvent("mouseup", state)),
	          tap((function ($$event) {
	                  return _execMouseMoveEventHandle(/* MouseMove */4, $$event, state);
	                }), _fromPointDomEvent("mousemove", state)),
	          tap((function ($$event) {
	                  return _execMouseEventHandle(/* MouseWheel */5, $$event, state);
	                }), _fromPointDomEvent("mousewheel", state)),
	          tap((function ($$event) {
	                  return _execMouseDragingEventHandle(/* MouseDrag */6, $$event, state);
	                }), flatMap((function () {
	                      return takeUntil(tap((function () {
	                                        return _execMouseDragEndEventHandle(state);
	                                      }), _fromPointDomEvent("mouseup", state)), _fromPointDomEvent("mousemove", state));
	                    }), tap((function () {
	                          return _execMouseDragStartEventHandle(state);
	                        }), _fromPointDomEvent("mousedown", state)))),
	          tap((function ($$event) {
	                  return _execKeyboardEventHandle(/* KeyUp */7, $$event, state);
	                }), _fromKeyboardDomEvent("keyup", state)),
	          tap((function ($$event) {
	                  return _execKeyboardEventHandle(/* KeyDown */8, $$event, state);
	                }), _fromKeyboardDomEvent("keydown", state)),
	          tap((function ($$event) {
	                  return _execKeyboardEventHandle(/* KeyPress */9, $$event, state);
	                }), _fromKeyboardDomEvent("keypress", state))
	        ];
	}

	function _fromMobileDomEventArr(state) {
	  return /* array */[
	          tap((function ($$event) {
	                  return _execTouchEventHandle(/* TouchTap */10, $$event, state);
	                }), skipUntil(_fromPointDomEvent("touchstart", state), _fromPointDomEvent("touchend", state))),
	          tap((function ($$event) {
	                  return _execTouchEventHandle(/* TouchEnd */11, $$event, state);
	                }), _fromPointDomEvent("touchend", state)),
	          tap((function ($$event) {
	                  return _execTouchEventHandle(/* TouchStart */13, $$event, state);
	                }), _fromPointDomEvent("touchstart", state)),
	          tap((function ($$event) {
	                  return _execTouchMoveEventHandle(/* TouchMove */12, $$event, state);
	                }), _fromPointDomEvent("touchmove", state)),
	          tap((function ($$event) {
	                  return _execTouchDragingEventHandle(/* TouchDrag */14, $$event, state);
	                }), flatMap((function () {
	                      return takeUntil(tap((function () {
	                                        return _execTouchDragEndEventHandle(state);
	                                      }), _fromPointDomEvent("touchend", state)), _fromPointDomEvent("touchmove", state));
	                    }), tap((function () {
	                          return _execTouchDragStartEventHandle(state);
	                        }), _fromPointDomEvent("touchstart", state))))
	        ];
	}

	function fromDomEvent(state) {
	  var browser = state[/* browserDetectRecord */41][/* browser */0];
	  return mergeArray(browser >= 2 ? (
	                browser >= 4 ? fatal(buildFatalMessage("fromDomEvent", "unknown browser", "", "", "browser:" + (String(browser) + ""))) : _fromMobileDomEventArr(state)
	              ) : _fromPCDomEventArr(state));
	}

	function handleDomEventStreamError(e) {
	  var message = e.message;
	  var stack = e.stack;
	  var partial_arg = "message:" + (String(message) + ("\nstack:" + (String(stack) + "")));
	  var partial_arg$1 = "from dom event stream error";
	  return debug((function (param) {
	                return buildDebugMessage(partial_arg$1, partial_arg, param);
	              }), getIsDebug(stateData));
	}

	function initEvent(state) {
	  var domEventStreamSubscription = fromDomEvent(state).subscribe({
	        next: (function () {
	            return /* () */0;
	          }),
	        error: handleDomEventStreamError,
	        complete: (function () {
	            return /* () */0;
	          })
	      });
	  return bindDomEventToTriggerPointEvent(setDomEventStreamSubscription(domEventStreamSubscription, state));
	}


	/* most Not a pure module */

	function execJob$3(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                setState$2(stateData, initEvent(state));
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function bindEvent$1(state) {
	  var state$1 = onCustomGlobalEvent$1(getPointDownEventName$1(/* () */0), (function ($$event, state) {
	          var imguiRecord = state[/* imguiRecord */43];
	          var newrecord = caml_array_dup(state);
	          var init = imguiRecord[/* ioData */0];
	          newrecord[/* imguiRecord */43] = /* record */[
	            /* ioData : record */[
	              /* pointUp */init[/* pointUp */0],
	              /* pointDown */true,
	              /* pointPosition */init[/* pointPosition */2],
	              /* pointMovementDelta */init[/* pointMovementDelta */3]
	            ],
	            /* wonderImguiIMGUIRecord */imguiRecord[/* wonderImguiIMGUIRecord */1]
	          ];
	          return /* tuple */[
	                  newrecord,
	                  $$event
	                ];
	        }), state, undefined, /* () */0);
	  var state$2 = onCustomGlobalEvent$1(getPointUpEventName$1(/* () */0), (function ($$event, state) {
	          var imguiRecord = state[/* imguiRecord */43];
	          var newrecord = caml_array_dup(state);
	          var init = imguiRecord[/* ioData */0];
	          newrecord[/* imguiRecord */43] = /* record */[
	            /* ioData : record */[
	              /* pointUp */true,
	              /* pointDown */init[/* pointDown */1],
	              /* pointPosition */init[/* pointPosition */2],
	              /* pointMovementDelta */init[/* pointMovementDelta */3]
	            ],
	            /* wonderImguiIMGUIRecord */imguiRecord[/* wonderImguiIMGUIRecord */1]
	          ];
	          return /* tuple */[
	                  newrecord,
	                  $$event
	                ];
	        }), state$1, undefined, /* () */0);
	  return onCustomGlobalEvent$1(getPointMoveEventName$1(/* () */0), (function ($$event, state) {
	                var imguiRecord = state[/* imguiRecord */43];
	                var pointEvent = unsafeGet$1($$event[/* userData */4]);
	                var newrecord = caml_array_dup(state);
	                var init = imguiRecord[/* ioData */0];
	                newrecord[/* imguiRecord */43] = /* record */[
	                  /* ioData : record */[
	                    /* pointUp */init[/* pointUp */0],
	                    /* pointDown */init[/* pointDown */1],
	                    /* pointPosition */pointEvent[/* locationInView */2],
	                    /* pointMovementDelta */pointEvent[/* movementDelta */5]
	                  ],
	                  /* wonderImguiIMGUIRecord */imguiRecord[/* wonderImguiIMGUIRecord */1]
	                ];
	                return /* tuple */[
	                        newrecord,
	                        $$event
	                      ];
	              }), state$2, undefined, /* () */0);
	}

	function resetPointEventStateWhenPointUp(state) {
	  var imguiRecord = state[/* imguiRecord */43];
	  var match = getIOData$1(state);
	  if (match[/* pointUp */0]) {
	    var newrecord = caml_array_dup(state);
	    var init = imguiRecord[/* ioData */0];
	    newrecord[/* imguiRecord */43] = /* record */[
	      /* ioData : record */[
	        /* pointUp */false,
	        /* pointDown */false,
	        /* pointPosition */init[/* pointPosition */2],
	        /* pointMovementDelta */init[/* pointMovementDelta */3]
	      ],
	      /* wonderImguiIMGUIRecord */imguiRecord[/* wonderImguiIMGUIRecord */1]
	    ];
	    return newrecord;
	  } else {
	    return state;
	  }
	}


	/* OptionService-Wonderjs Not a pure module */

	function execJob$4(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                setState$2(stateData, bindEvent$1(state));
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function createGl(contextConfig, canvas) {
	  return canvas.getContext("webgl", contextConfig);
	}


	/* No side effect */

	/* OptionService-Wonderjs Not a pure module */

	function convertContextConfigDataToJsObj(param) {
	  return {
	          alpha: param[/* alpha */0],
	          depth: param[/* depth */1],
	          stencil: param[/* stencil */2],
	          antialias: param[/* antialias */3],
	          premultipliedAlpha: param[/* premultipliedAlpha */4],
	          preserveDrawingBuffer: param[/* preserveDrawingBuffer */5]
	        };
	}


	/* No side effect */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function execJob$7(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var state$1 = init$4(init$5(state));
	                setState$2(stateData, state$1);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	var getFntData$1 = getFntData;

	var getCustomImageArr$1 = getCustomImageArr;


	/* AssetIMGUIService-WonderImgui Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* RecordBrowserDetectAllService-Wonderjs Not a pure module */

	function getRecord$18(state) {
	  return state[/* imguiRecord */28];
	}


	/* No side effect */

	/* most Not a pure module */

	function execJob$10(deviceManagerRecord) {
	  return setDepthTest(unsafeGetGl$1(deviceManagerRecord), true, setSide(unsafeGetGl$1(deviceManagerRecord), /* FRONT */2, deviceManagerRecord));
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function postMessage(data, worker) {
	  worker.postMessage(data);
	  return /* () */0;
	}

	function postMessageWithTransferData(data, transferData, worker) {
	  worker.postMessage(data, transferData);
	  return /* () */0;
	}


	/* getSelf Not a pure module */

	function getOperateType(flags) {
	  return caml_array_get(unsafeGetFlags(flags), 0);
	}


	/* JobConfigService-Wonderjs Not a pure module */

	function unsafeGetRenderWorker(param) {
	  var renderWorker = param[/* renderWorker */0];
	  requireCheck((function () {
	          return test(buildAssertMessage("render worker exist", "not"), (function () {
	                        return assertExist(renderWorker);
	                      }));
	        }), getIsDebug(stateData));
	  return unsafeGet$1(renderWorker);
	}

	function _getValidFileDir(dir) {
	  var lastChar = dir.slice(-1);
	  if (lastChar !== "/") {
	    return "" + (String(dir) + "/");
	  } else {
	    return dir;
	  }
	}

	function _getRenderWorkerFilePath(workerFileDir) {
	  requireCheck((function () {
	          return test(buildAssertMessage("workerFileDir be defined", "is empty string|"), (function () {
	                        return assertGt(/* Int */0, workerFileDir.length, 0);
	                      }));
	        }), getIsDebug(stateData));
	  return _getValidFileDir(workerFileDir) + "wd.render.worker.js";
	}

	function initWorkInstances(workerFileDir, _) {
	  var worker = new Worker(_getRenderWorkerFilePath(workerFileDir));
	  return /* record */[/* renderWorker */some$1(worker)];
	}


	/* Log-WonderLog Not a pure module */

	function execJob$11(flags, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var operateType = getOperateType(flags);
	                postMessage({
	                      operateType: operateType,
	                      pipelineJobs: JSON.stringify(getRenderWorkerPipelineJobs(state[/* workerJobRecord */4])),
	                      jobs: JSON.stringify(getWorkerJobs(state[/* workerJobRecord */4]))
	                    }, unsafeGetRenderWorker(state[/* workerInstanceRecord */38]));
	                return some$1(operateType);
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	var max$1 = 2147483647;

	var min$1 = -2147483648;


	/* No side effect */

	function floor_int(f) {
	  if (f > max$1) {
	    return max$1;
	  } else if (f < min$1) {
	    return min$1;
	  } else {
	    return Math.floor(f);
	  }
	}

	var floor = floor_int;


	/* No side effect */

	var regex_num = (/^\#([0-9a-f]{6})$/i);

	function _handleInValidHexStr(hexStr) {
	  return fatal(buildFatalMessage("convert16HexToRGBA", "color should be #xxxxxx, but actual is " + (String(hexStr) + ""), "", "", ""));
	}

	function convert16HexToRGBA(hexStr) {
	  var match = regex_num.exec(hexStr);
	  if (match !== null) {
	    var match$1 = caml_array_get(match, 1);
	    if (match$1 == null) {
	      return _handleInValidHexStr(hexStr);
	    } else {
	      var hex = floor(_1(hexFloat_of_string, match$1));
	      return /* tuple */[
	              ((hex >>> 16) & 255) / 255,
	              ((hex >>> 8) & 255) / 255,
	              (hex & 255) / 255,
	              1
	            ];
	    }
	  } else {
	    return _handleInValidHexStr(hexStr);
	  }
	}


	/* regex_num Not a pure module */

	function execJob$13(flags, deviceManagerRecord) {
	  return clearColor(unsafeGetGl$1(deviceManagerRecord), convert16HexToRGBA(getOperateType(flags)), deviceManagerRecord);
	}


	/* ColorService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* No side effect */

	function index_rec(s, lim, _i, c) {
	  while(true) {
	    var i = _i;
	    if (i >= lim) {
	      throw not_found;
	    } else if (s[i] === c) {
	      return i;
	    } else {
	      _i = i + 1 | 0;
	      continue ;
	    }
	  }
	}

	function contains_from$1(s, i, c) {
	  var l = s.length;
	  if (i < 0 || i > l) {
	    throw [
	          invalid_argument,
	          "String.contains_from / Bytes.contains_from"
	        ];
	  } else {
	    try {
	      index_rec(s, l, i, c);
	      return true;
	    }
	    catch (exn){
	      if (exn === not_found) {
	        return false;
	      } else {
	        throw exn;
	      }
	    }
	  }
	}

	function contains$1(s, c) {
	  return contains_from$1(s, 0, c);
	}


	/* No side effect */

	function contains(s, c) {
	  return contains$1(bytes_of_string(s), c);
	}


	/* No side effect */

	function _getCanvasId(domId) {
	  var match = contains(domId, /* "#" */35);
	  if (match) {
	    return domId;
	  } else {
	    return ensureCheck((function (id) {
	                  return test(buildAssertMessage("dom id start with \'#\'", "is " + (String(domId) + "")), (function () {
	                                return assertTrue((/#[^#]+/).test(id));
	                              }));
	                }), getIsDebug(stateData), "#" + (String(domId) + ""));
	  }
	}

	function createCanvas(canvasId) {
	  if (canvasId !== undefined) {
	    var canvasId$1 = canvasId;
	    var match = findFirstHtmlElement(document, _getCanvasId(canvasId$1));
	    if (match !== undefined) {
	      return valFromOption(match);
	    } else {
	      return failwith("canvas whose id is " + (String(canvasId$1) + " should exist"));
	    }
	  } else {
	    var arg = findFirstHtmlElement(document, "body");
	    return (function (param) {
	                return prependTo(param, arg);
	              })(buildCanvas(/* () */0));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function execJob$14(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                state[/* viewRecord */9] = setCanvas(createCanvas(getCanvasId(state[/* settingRecord */1])), state[/* viewRecord */9]);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function disposeBoxGeometryBufferData(geometry, record) {
	  return /* record */[
	          /* boxGeometryVertexBufferMap */disposeSparseMapData(geometry, record[/* boxGeometryVertexBufferMap */0]),
	          /* boxGeometryTexCoordBufferMap */disposeSparseMapData(geometry, record[/* boxGeometryTexCoordBufferMap */1]),
	          /* boxGeometryNormalBufferMap */disposeSparseMapData(geometry, record[/* boxGeometryNormalBufferMap */2]),
	          /* boxGeometryElementArrayBufferMap */disposeSparseMapData(geometry, record[/* boxGeometryElementArrayBufferMap */3]),
	          /* customGeometryVertexBufferMap */record[/* customGeometryVertexBufferMap */4],
	          /* customGeometryTexCoordBufferMap */record[/* customGeometryTexCoordBufferMap */5],
	          /* customGeometryNormalBufferMap */record[/* customGeometryNormalBufferMap */6],
	          /* customGeometryElementArrayBufferMap */record[/* customGeometryElementArrayBufferMap */7],
	          /* matrixInstanceBufferMap */record[/* matrixInstanceBufferMap */8],
	          /* vertexArrayBufferPool */record[/* vertexArrayBufferPool */9],
	          /* elementArrayBufferPool */record[/* elementArrayBufferPool */10],
	          /* matrixInstanceBufferPool */record[/* matrixInstanceBufferPool */11]
	        ];
	}

	function disposeCustomGeometryBufferData(geometry, record) {
	  return /* record */[
	          /* boxGeometryVertexBufferMap */record[/* boxGeometryVertexBufferMap */0],
	          /* boxGeometryTexCoordBufferMap */record[/* boxGeometryTexCoordBufferMap */1],
	          /* boxGeometryNormalBufferMap */record[/* boxGeometryNormalBufferMap */2],
	          /* boxGeometryElementArrayBufferMap */record[/* boxGeometryElementArrayBufferMap */3],
	          /* customGeometryVertexBufferMap */disposeSparseMapData(geometry, record[/* customGeometryVertexBufferMap */4]),
	          /* customGeometryTexCoordBufferMap */disposeSparseMapData(geometry, record[/* customGeometryTexCoordBufferMap */5]),
	          /* customGeometryNormalBufferMap */disposeSparseMapData(geometry, record[/* customGeometryNormalBufferMap */6]),
	          /* customGeometryElementArrayBufferMap */disposeSparseMapData(geometry, record[/* customGeometryElementArrayBufferMap */7]),
	          /* matrixInstanceBufferMap */record[/* matrixInstanceBufferMap */8],
	          /* vertexArrayBufferPool */record[/* vertexArrayBufferPool */9],
	          /* elementArrayBufferPool */record[/* elementArrayBufferPool */10],
	          /* matrixInstanceBufferPool */record[/* matrixInstanceBufferPool */11]
	        ];
	}

	function disposeInstanceBufferData(sourceInstance, record) {
	  return /* record */[
	          /* boxGeometryVertexBufferMap */record[/* boxGeometryVertexBufferMap */0],
	          /* boxGeometryTexCoordBufferMap */record[/* boxGeometryTexCoordBufferMap */1],
	          /* boxGeometryNormalBufferMap */record[/* boxGeometryNormalBufferMap */2],
	          /* boxGeometryElementArrayBufferMap */record[/* boxGeometryElementArrayBufferMap */3],
	          /* customGeometryVertexBufferMap */record[/* customGeometryVertexBufferMap */4],
	          /* customGeometryTexCoordBufferMap */record[/* customGeometryTexCoordBufferMap */5],
	          /* customGeometryNormalBufferMap */record[/* customGeometryNormalBufferMap */6],
	          /* customGeometryElementArrayBufferMap */record[/* customGeometryElementArrayBufferMap */7],
	          /* matrixInstanceBufferMap */disposeSparseMapData(sourceInstance, record[/* matrixInstanceBufferMap */8]),
	          /* vertexArrayBufferPool */record[/* vertexArrayBufferPool */9],
	          /* elementArrayBufferPool */record[/* elementArrayBufferPool */10],
	          /* matrixInstanceBufferPool */record[/* matrixInstanceBufferPool */11]
	        ];
	}

	function _disposeVboBuffer(needDisposeVboBufferArr, param, vboBufferRecord) {
	  var disposeBufferDataFunc = param[1];
	  var addBufferToPoolFunc = param[0];
	  return reduceOneParam((function (vboBufferRecord, component) {
	                return disposeBufferDataFunc(component, addBufferToPoolFunc(component, vboBufferRecord));
	              }), vboBufferRecord, needDisposeVboBufferArr);
	}

	function disposeBoxGeometryVboBuffer(boxGeometryNeedDisposeVboBufferArr, vboBufferRecord) {
	  return _disposeVboBuffer(boxGeometryNeedDisposeVboBufferArr, /* tuple */[
	              addBoxGeometryBufferToPool,
	              disposeBoxGeometryBufferData
	            ], vboBufferRecord);
	}

	function disposeCustomGeometryVboBuffer(customGeometryNeedDisposeVboBufferArr, vboBufferRecord) {
	  return _disposeVboBuffer(customGeometryNeedDisposeVboBufferArr, /* tuple */[
	              addCustomGeometryBufferToPool,
	              disposeCustomGeometryBufferData
	            ], vboBufferRecord);
	}

	function disposeSourceInstanceVboBuffer(sourceInstanceNeedDisposeVboBufferArr, vboBufferRecord) {
	  return _disposeVboBuffer(sourceInstanceNeedDisposeVboBufferArr, /* tuple */[
	              addInstanceBufferToPool,
	              disposeInstanceBufferData
	            ], vboBufferRecord);
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function _updateTransform(cameraController, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var transformRecord = getRecord$1(state);
	  var transform = unsafeGetTransformComponent(unsafeGetGameObject$7(cameraController, arcballCameraControllerRecord), gameObjectRecord);
	  var distance = unsafeGetDistance(cameraController, arcballCameraControllerRecord);
	  var phi = unsafeGetPhi(cameraController, arcballCameraControllerRecord);
	  var theta = unsafeGetTheta(cameraController, arcballCameraControllerRecord);
	  var target = unsafeGetTarget(cameraController, arcballCameraControllerRecord);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* transformRecord */12] = setLocalPositionByTuple$1(transform, /* tuple */[
	        distance * Math.cos(phi) * Math.sin(theta) + target[0],
	        distance * Math.cos(theta) + target[1],
	        distance * Math.sin(phi) * Math.sin(theta) + target[2]
	      ], transformRecord);
	  return lookAt$2(transform, target, newrecord, undefined, /* () */0);
	}

	function _clearDirtyArray$1(state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = /* record */[
	    /* index */arcballCameraControllerRecord[/* index */0],
	    /* pointDownEventHandleFuncMap */arcballCameraControllerRecord[/* pointDownEventHandleFuncMap */1],
	    /* pointUpEventHandleFuncMap */arcballCameraControllerRecord[/* pointUpEventHandleFuncMap */2],
	    /* pointDragEventHandleFuncMap */arcballCameraControllerRecord[/* pointDragEventHandleFuncMap */3],
	    /* pointScaleEventHandleFuncMap */arcballCameraControllerRecord[/* pointScaleEventHandleFuncMap */4],
	    /* keydownEventHandleFuncMap */arcballCameraControllerRecord[/* keydownEventHandleFuncMap */5],
	    /* dirtyArray */create$25(/* () */0),
	    /* distanceMap */arcballCameraControllerRecord[/* distanceMap */7],
	    /* minDistanceMap */arcballCameraControllerRecord[/* minDistanceMap */8],
	    /* phiMap */arcballCameraControllerRecord[/* phiMap */9],
	    /* thetaMap */arcballCameraControllerRecord[/* thetaMap */10],
	    /* thetaMarginMap */arcballCameraControllerRecord[/* thetaMarginMap */11],
	    /* targetMap */arcballCameraControllerRecord[/* targetMap */12],
	    /* moveSpeedXMap */arcballCameraControllerRecord[/* moveSpeedXMap */13],
	    /* moveSpeedYMap */arcballCameraControllerRecord[/* moveSpeedYMap */14],
	    /* rotateSpeedMap */arcballCameraControllerRecord[/* rotateSpeedMap */15],
	    /* wheelSpeedMap */arcballCameraControllerRecord[/* wheelSpeedMap */16],
	    /* gameObjectMap */arcballCameraControllerRecord[/* gameObjectMap */17],
	    /* disposedIndexArray */arcballCameraControllerRecord[/* disposedIndexArray */18]
	  ];
	  return newrecord;
	}

	function update$2(state) {
	  return _clearDirtyArray$1(reduceOneParam((function (state, dirtyIndex) {
	                    return _updateTransform(dirtyIndex, state);
	                  }), state, removeDuplicateItems(state[/* arcballCameraControllerRecord */26][/* dirtyArray */6])));
	}


	/* DirtyArrayService-Wonderjs Not a pure module */

	function execJob$16(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var state$1 = update$2(update$1(state));
	                setState$2(stateData, state$1);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function _getBitFromFlags(gl, param, getBufferBitFunc, bit) {
	  var match = param[1].includes(param[0]);
	  if (match) {
	    if (bit !== undefined) {
	      return bit | _1(getBufferBitFunc, gl);
	    } else {
	      return _1(getBufferBitFunc, gl);
	    }
	  } else {
	    return bit;
	  }
	}

	function getBit(gl, flags) {
	  var match = _getBitFromFlags(gl, /* tuple */[
	        "STENCIL_BUFFER",
	        flags
	      ], (function (prim) {
	          return prim.STENCIL_BUFFER_BIT;
	        }), _getBitFromFlags(gl, /* tuple */[
	            "DEPTH_BUFFER",
	            flags
	          ], (function (prim) {
	              return prim.DEPTH_BUFFER_BIT;
	            }), _getBitFromFlags(gl, /* tuple */[
	                "COLOR_BUFFER",
	                flags
	              ], (function (prim) {
	                  return prim.COLOR_BUFFER_BIT;
	                }), undefined)));
	  if (match !== undefined) {
	    return match;
	  } else {
	    return fatal(buildFatalMessage("_getBit", "should find bit", "", "", "flags:" + (String(flags) + "")));
	  }
	}


	/* Log-WonderLog Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function unsafeGetCopiedBuffer(param) {
	  return unsafeGet$1(param[/* copiedBuffer */6]);
	}

	function unsafeGetCopiedLocalToWorldMatrices(param) {
	  return unsafeGet$1(param[/* copiedLocalToWorldMatrices */7]);
	}


	/* OptionService-Wonderjs Not a pure module */

	function copyArrayBufferSpecificData(sourceBuffer, targetBuffer, totalByteLength) {
	  var length = totalByteLength / 1 | 0;
	  var targetView = new Uint8Array(targetBuffer, 0, length);
	  return setUint8Array(new Uint8Array(sourceBuffer, 0, length), targetView).buffer;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function execJob$18(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var transformRecord = getRecord$1(state);
	                var index = transformRecord[/* index */0];
	                var newrecord = caml_array_dup(transformRecord);
	                state[/* transformRecord */12] = (newrecord[/* copiedBuffer */6] = some$1(copyArrayBufferSpecificData(transformRecord[/* buffer */1], unsafeGetCopiedBuffer(transformRecord), getTotalByteLength(index))), newrecord);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function execJob$19(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                detectMobileNotSupportWorker(state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function getCameraData(state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var basicCameraViewRecord = state[/* basicCameraViewRecord */14];
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  var globalTempRecord = state[/* globalTempRecord */36];
	  var match = getCurrentCameraGameObject$2(basicCameraViewRecord, getRecord(state));
	  if (match !== undefined) {
	    var currentCameraGameObject = match;
	    var transformRecord = getRecord$1(state);
	    var transform = unsafeGetTransformComponent(currentCameraGameObject, gameObjectRecord);
	    return /* record */[
	            /* vMatrix */getWorldToCameraMatrix(updateAndGetLocalToWorldMatrixTypeArray(transform, globalTempRecord, transformRecord)),
	            /* pMatrix */unsafeGetPMatrix(unsafeGetPerspectiveCameraProjectionComponent(currentCameraGameObject, gameObjectRecord), perspectiveCameraProjectionRecord[/* pMatrixMap */2]),
	            /* position */updateAndGetPositionTuple(transform, globalTempRecord, transformRecord)
	          ];
	  }
	  
	}


	/* PMatrixService-Wonderjs Not a pure module */

	function getCameraRecord(state) {
	  return getRecord$13(state)[/* cameraRecord */2];
	}

	function setCameraRecord(cameraRecord, state) {
	  getRecord$13(state)[/* cameraRecord */2] = cameraRecord;
	  return state;
	}

	function getBasicRenderObjectRecord(state) {
	  return getRecord$13(state)[/* basicRenderObjectRecord */0];
	}

	function unsafeGetBasicRenderObjectRecord(state) {
	  return unsafeGet$1(getRecord$13(state)[/* basicRenderObjectRecord */0]);
	}

	function getLightRenderObjectRecord(state) {
	  return getRecord$13(state)[/* lightRenderObjectRecord */1];
	}

	function unsafeGetLightRenderObjectRecord(state) {
	  return unsafeGet$1(getRecord$13(state)[/* lightRenderObjectRecord */1]);
	}


	/* OptionService-Wonderjs Not a pure module */

	function execJob$20(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                setCameraRecord(getCameraData(state), state);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	var getSource$3 = get$3;

	var unsafeGetSource = unsafeGet$2;

	var setSource = set$1;


	/* Log-WonderLog Not a pure module */

	/* most Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* most Not a pure module */

	/* Log-WonderLog Not a pure module */

	function drawElement(param, gl) {
	  gl.drawElements(param[0], param[3], param[1], 0);
	  return /* () */0;
	}

	function drawElementsInstancedANGLE(param, extension) {
	  extension.drawElementsInstancedANGLE(param[0], param[3], param[1], 0, param[4]);
	  return /* () */0;
	}


	/* No side effect */

	function getIndexType(gl) {
	  return gl.UNSIGNED_SHORT;
	}

	function getIndexTypeSize() {
	  return Uint16Array.BYTES_PER_ELEMENT;
	}


	/* No side effect */

	function use(gl, program, state) {
	  var programRecord = state[/* programRecord */4];
	  var match = programRecord[/* lastUsedProgram */1];
	  var exit = 0;
	  if (match !== undefined && program === valFromOption(match)) {
	    return state;
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    programRecord[/* lastUsedProgram */1] = some$1(program);
	    gl.useProgram(program);
	    return state;
	  }
	  
	}


	/* No side effect */

	function getOrCreateBuffer$1(gl, param, param$1, state) {
	  var bufferMap = param[1];
	  var geometryIndex = param[0];
	  var match = get$3(geometryIndex, bufferMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    var buffer = param$1[0](gl, param$1[1](geometryIndex, state), state);
	    set$1(geometryIndex, buffer, bufferMap);
	    return buffer;
	  }
	}


	/* No side effect */

	function createBuffer$9(gl, record, state) {
	  var buffer = getArrayBuffer(gl, state[/* vboBufferRecord */1]);
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, record, gl.STATIC_DRAW);
	  gl.bindBuffer(gl.ARRAY_BUFFER, null);
	  return buffer;
	}

	function getOrCreateBuffer(gl, param, getDataFunc, state) {
	  return getOrCreateBuffer$1(gl, /* tuple */[
	              param[0],
	              param[1]
	            ], /* tuple */[
	              createBuffer$9,
	              getDataFunc
	            ], state);
	}


	/* PoolVboBufferService-Wonderjs Not a pure module */

	function getGlDrawMode(gl, meshRenderer, state) {
	  var match = getDrawMode(meshRenderer, state[/* meshRendererRecord */10][/* drawModes */0]);
	  switch (match) {
	    case 0 : 
	        return gl.POINTS;
	    case 1 : 
	        return gl.LINES;
	    case 2 : 
	        return gl.LINE_LOOP;
	    case 3 : 
	        return gl.LINE_STRIP;
	    case 4 : 
	        return gl.TRIANGLES;
	    case 5 : 
	        return gl.TRIANGLE_STRIP;
	    case 6 : 
	        return gl.TRIANGLE_FAN;
	    
	  }
	}


	/* OperateTypeArrayMeshRendererService-Wonderjs Not a pure module */

	function createBuffer$10(gl, record, state) {
	  var buffer = getElementArrayBuffer(gl, state[/* vboBufferRecord */1]);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, record, gl.STATIC_DRAW);
	  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
	  return buffer;
	}

	function getOrCreateBuffer$2(gl, param, getDataFunc, state) {
	  return getOrCreateBuffer$1(gl, /* tuple */[
	              param[0],
	              param[1]
	            ], /* tuple */[
	              createBuffer$10,
	              getDataFunc
	            ], state);
	}


	/* PoolVboBufferService-Wonderjs Not a pure module */

	function unsafeGetAttributeSendData(shaderIndex, glslSenderRecord) {
	  return ensureCheck((function (sendData) {
	                return test(buildAssertMessage("attribute send record exist", "not"), (function () {
	                              return assertNullableExist(sendData);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(shaderIndex, glslSenderRecord[/* attributeSendDataMap */0]));
	}

	function unsafeGetInstanceAttributeSendData(shaderIndex, param) {
	  return ensureCheck((function (sendData) {
	                return test(buildAssertMessage("instance attribute send record exist", "not"), (function () {
	                              return assertNullableExist(sendData);
	                            }));
	              }), getIsDebug(stateData), unsafeGet$2(shaderIndex, param[/* instanceAttributeSendDataMap */1]));
	}


	/* Log-WonderLog Not a pure module */

	function _getOrCreateBuffer(buffer, param, param$1, state) {
	  var match = param$1[1];
	  var match$1 = param$1[0];
	  var geometryIndex = param[1];
	  var gl = param[0];
	  var exit = 0;
	  switch (buffer) {
	    case 0 : 
	        return getOrCreateBuffer(gl, /* tuple */[
	                    geometryIndex,
	                    match$1[0]
	                  ], match[0], state);
	    case 1 : 
	        return getOrCreateBuffer(gl, /* tuple */[
	                    geometryIndex,
	                    match$1[2]
	                  ], match[2], state);
	    case 2 : 
	        return getOrCreateBuffer(gl, /* tuple */[
	                    geometryIndex,
	                    match$1[1]
	                  ], match[1], state);
	    case 3 : 
	        return getOrCreateBuffer$2(gl, /* tuple */[
	                    geometryIndex,
	                    match$1[3]
	                  ], match[3], state);
	    case 4 : 
	    case 5 : 
	        exit = 1;
	        break;
	    
	  }
	  if (exit === 1) {
	    return fatal(buildFatalMessage("_sendAttributeData", "unknown buffer: " + (String(buffer) + ""), "", "", ""));
	  }
	  
	}

	function _directlySendAttributeData(gl, param, state) {
	  var currentGeometryBufferMapAndGetPointsFuncsTuple = getCurrentGeometryBufferMapAndGetPointsFuncs(param[2], state[/* vboBufferRecord */1]);
	  var dataTuple_001 = param[1];
	  var dataTuple = /* tuple */[
	    gl,
	    dataTuple_001
	  ];
	  return reduceOneParam((function (state, param) {
	                var arrayBuffer = _getOrCreateBuffer(param[/* buffer */2], dataTuple, currentGeometryBufferMapAndGetPointsFuncsTuple, state);
	                return param[/* sendFunc */3](gl, /* tuple */[
	                            param[/* size */1],
	                            param[/* pos */0]
	                          ], arrayBuffer, state);
	              }), state, unsafeGetAttributeSendData(param[0], state[/* glslSenderRecord */3]));
	}

	function _sendAttributeData(gl, indexTuple, state) {
	  var geometryType = indexTuple[2];
	  var geometryIndex = indexTuple[1];
	  var record = state[/* glslSenderRecord */3];
	  var lastSendGeometryData = record[/* lastSendGeometryData */11];
	  var exit = 0;
	  if (lastSendGeometryData !== undefined) {
	    var match = lastSendGeometryData;
	    if (match[0] === geometryIndex && match[1] === geometryType) {
	      return state;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    record[/* lastSendGeometryData */11] = /* tuple */[
	      geometryIndex,
	      geometryType
	    ];
	    return _directlySendAttributeData(gl, indexTuple, state);
	  }
	  
	}

	function _sendUniformRenderObjectModelData(gl, shaderIndex, transformIndex, state) {
	  return reduceOneParam((function (state, param) {
	                var pos = param[/* pos */0];
	                var match = isUniformLocationExist(pos);
	                if (match) {
	                  param[/* sendDataFunc */2](gl, pos, param[/* getDataFunc */1](transformIndex, state));
	                }
	                return state;
	              }), state, unsafeGetUniformSendData(shaderIndex, state[/* glslSenderRecord */3]));
	}

	function _sendUniformRenderObjectMaterialData(gl, shaderIndex, materialIndex, state) {
	  return reduceOneParam((function (state, param) {
	                param[/* sendDataFunc */4](gl, param[/* shaderCacheMap */0], /* tuple */[
	                      param[/* name */1],
	                      param[/* pos */2]
	                    ], param[/* getDataFunc */3](materialIndex, state));
	                return state;
	              }), state, unsafeGetUniformSendData$5(shaderIndex, state[/* glslSenderRecord */3]));
	}

	function render$3(gl, param, bindAndUpdateFunc, state) {
	  var shaderIndex = param[2];
	  var materialIndex = param[1];
	  var program = unsafeGetProgram(shaderIndex, state[/* programRecord */4]);
	  var state$1 = _sendUniformRenderObjectModelData(gl, shaderIndex, param[0], _sendAttributeData(gl, /* tuple */[
	            shaderIndex,
	            param[4],
	            param[5]
	          ], use(gl, program, state)));
	  var record = state$1[/* glslSenderRecord */3];
	  var lastSendMaterialData = record[/* lastSendMaterialData */10];
	  var exit = 0;
	  if (lastSendMaterialData !== undefined) {
	    var match = lastSendMaterialData;
	    if (match[0] === materialIndex && match[1] === shaderIndex) {
	      return state$1;
	    } else {
	      exit = 1;
	    }
	  } else {
	    exit = 1;
	  }
	  if (exit === 1) {
	    record[/* lastSendMaterialData */10] = /* tuple */[
	      materialIndex,
	      shaderIndex
	    ];
	    var state$2 = _sendUniformRenderObjectMaterialData(gl, shaderIndex, materialIndex, state$1);
	    return bindAndUpdateFunc(gl, materialIndex, state$2);
	  }
	  
	}

	function draw$4(gl, meshRendererIndex, geometryIndex, geometryType, state) {
	  var getIndicesCountFunc = getGetIndicesCountFunc(geometryType);
	  return drawElement(/* tuple */[
	              getGlDrawMode(gl, meshRendererIndex, state),
	              getIndexType(gl),
	              getIndexTypeSize(gl),
	              getIndicesCountFunc(geometryIndex, state)
	            ], gl);
	}


	/* Log-WonderLog Not a pure module */

	function isCached(unit, texture, bindTextureUnitCacheMap) {
	  var match = get$3(unit, bindTextureUnitCacheMap);
	  if (match !== undefined) {
	    return valFromOption(match) === texture;
	  } else {
	    return false;
	  }
	}

	function addActiveTexture(unit, texture, bindTextureUnitCacheMap) {
	  requireCheck((function () {
	          return test(buildAssertMessage("not cached", ""), (function () {
	                        return assertFalse(isCached(unit, texture, bindTextureUnitCacheMap));
	                      }));
	        }), getIsDebug(stateData));
	  return set$1(unit, texture, bindTextureUnitCacheMap);
	}


	/* Log-WonderLog Not a pure module */

	function _bind(gl, unit, texture, dataTuple) {
	  var glTextureMap = dataTuple[1];
	  var bindTextureUnitCacheMap = dataTuple[0];
	  requireCheck((function () {
	          return test(buildAssertMessage("unit should >= 0", "is " + (String(unit) + "")), (function () {
	                        return Operators[/* >= */7](unit, 0);
	                      }));
	        }), getIsDebug(stateData));
	  var match = getTexture(texture, glTextureMap);
	  if (match !== undefined) {
	    var match$1 = isCached(unit, texture, bindTextureUnitCacheMap);
	    if (match$1) {
	      return dataTuple;
	    } else {
	      var bindTextureUnitCacheMap$1 = addActiveTexture(unit, texture, bindTextureUnitCacheMap);
	      var target = gl.TEXTURE_2D;
	      gl.activeTexture(gl.TEXTURE0 + unit | 0);
	      gl.bindTexture(target, valFromOption(match));
	      return /* tuple */[
	              bindTextureUnitCacheMap$1,
	              glTextureMap
	            ];
	    }
	  } else {
	    return dataTuple;
	  }
	}

	function _bindBasicSourceTexture(basicSourceTextureInTypeArray, param) {
	  var state = param[2];
	  var basicSourceTextureRecord = state[/* basicSourceTextureRecord */11];
	  _bind(param[0], param[1], basicSourceTextureInTypeArray, /* tuple */[
	        basicSourceTextureRecord[/* bindTextureUnitCacheMap */10],
	        basicSourceTextureRecord[/* glTextureMap */9]
	      ]);
	  return state;
	}

	function _bindArrayBufferViewSourceTexture(arrayBufferViewTextureInTypeArray, param) {
	  var state = param[2];
	  var arrayBufferViewSourceTextureRecord = state[/* arrayBufferViewSourceTextureRecord */12];
	  _bind(param[0], param[1], arrayBufferViewTextureInTypeArray, /* tuple */[
	        arrayBufferViewSourceTextureRecord[/* bindTextureUnitCacheMap */12],
	        arrayBufferViewSourceTextureRecord[/* glTextureMap */11]
	      ]);
	  return state;
	}

	function bind$4(gl, unit, texture, state) {
	  requireCheck((function () {
	          return test(buildAssertMessage("unit should >= 0", "is " + (String(unit) + "")), (function () {
	                        return Operators[/* >= */7](unit, 0);
	                      }));
	        }), getIsDebug(stateData));
	  return handleByJudgeSourceTextureIndex(texture, state[/* arrayBufferViewSourceTextureRecord */12][/* textureIndexOffset */14], /* tuple */[
	              gl,
	              unit,
	              state
	            ], /* tuple */[
	              _bindBasicSourceTexture,
	              _bindArrayBufferViewSourceTexture
	            ]);
	}


	/* Log-WonderLog Not a pure module */

	function getWidth$1(source) {
	  return source.width;
	}

	function getHeight$1(source) {
	  return source.height;
	}


	/* No side effect */

	function getGlWrap(gl, wrap) {
	  switch (wrap) {
	    case 0 : 
	        return gl.CLAMP_TO_EDGE;
	    case 1 : 
	        return gl.MIRRORED_REPEAT;
	    case 2 : 
	        return gl.REPEAT;
	    
	  }
	}


	/* No side effect */

	function getGlFormat(gl, format) {
	  switch (format) {
	    case 0 : 
	        return gl.RGB;
	    case 1 : 
	        return gl.RGBA;
	    case 2 : 
	        return gl.ALPHA;
	    case 3 : 
	        return gl.LUMINANCE;
	    case 4 : 
	        return gl.LUMINANCE_ALPHA;
	    case 5 : 
	        return gl.RGB_S3TC_DXT1;
	    case 6 : 
	        return gl.RGBA_S3TC_DXT1;
	    case 7 : 
	        return gl.RGBA_S3TC_DXT3;
	    case 8 : 
	        return gl.RGBA_S3TC_DXT5;
	    
	  }
	}


	/* No side effect */

	function getGlFilter(gl, filter) {
	  switch (filter) {
	    case 0 : 
	        return gl.NEAREST;
	    case 1 : 
	        return gl.LINEAR;
	    case 2 : 
	        return gl.NEAREST_MIPMAP_NEAREST;
	    case 3 : 
	        return gl.LINEAR_MIPMAP_NEAREST;
	    case 4 : 
	        return gl.NEAREST_MIPMAP_LINEAR;
	    case 5 : 
	        return gl.LINEAR_MIPMAP_LINEAR;
	    
	  }
	}


	/* No side effect */

	function setIsNeedUpdate$2(index, data, typeArr) {
	  return setUint8_1(getIsNeedUpdateIndex(index), data, typeArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _isPowerOfTwo(value) {
	  if ((value & (value - 1 | 0)) === 0 && value !== 0) {
	    return value !== 1;
	  } else {
	    return false;
	  }
	}

	function _isSourcePowerOfTwo(width, height) {
	  if (_isPowerOfTwo(width)) {
	    return _isPowerOfTwo(height);
	  } else {
	    return false;
	  }
	}

	function _filterFallback(filter, gl) {
	  switch (filter) {
	    case 0 : 
	    case 2 : 
	    case 4 : 
	        return gl.NEAREST;
	    case 1 : 
	    case 3 : 
	    case 5 : 
	        return gl.LINEAR;
	    
	  }
	}

	function _setTextureParameters(gl, target, isSourcePowerOfTwo, param) {
	  var minFilter = param[3];
	  var magFilter = param[2];
	  if (isSourcePowerOfTwo) {
	    gl.texParameteri(target, gl.TEXTURE_WRAP_S, param[0]);
	    gl.texParameteri(target, gl.TEXTURE_WRAP_T, param[1]);
	    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, getGlFilter(gl, magFilter));
	    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, getGlFilter(gl, minFilter));
	    return /* () */0;
	  } else {
	    gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, _filterFallback(magFilter, gl));
	    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, _filterFallback(minFilter, gl));
	    return /* () */0;
	  }
	}

	function _isFilterMipmaps(filter) {
	  return filter >= 2;
	}

	function update$4(param, param$1, param$2, param$3) {
	  var target = param$1[9];
	  var minFilter = param$1[5];
	  var magFilter = param$1[4];
	  var gl = param[0];
	  var isSourcePowerOfTwo = _isSourcePowerOfTwo(param$1[0], param$1[1]);
	  _3(param$3[1], gl, param$1[8], param$2[1]);
	  gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
	  _setTextureParameters(gl, target, isSourcePowerOfTwo, /* tuple */[
	        param$1[2],
	        param$1[3],
	        magFilter,
	        minFilter
	      ]);
	  _3(param$3[0], gl, /* tuple */[
	        target,
	        param$1[6],
	        param$1[7]
	      ], param[2]);
	  var match = isSourcePowerOfTwo && (_isFilterMipmaps(magFilter) || _isFilterMipmaps(minFilter));
	  if (match) {
	    gl.generateMipmap(target);
	  }
	  setIsNeedUpdate$2(param[1], getNotNeedUpdate(/* () */0), param$2[0]);
	  return /* () */0;
	}

	function isNeedUpdate$1(textureInTypeArray, _, isNeedUpdates, getIsNeedUpdateFunc) {
	  return getIsNeedUpdateFunc(textureInTypeArray, isNeedUpdates) === getDefaultIsNeedUpdate(/* () */0);
	}


	/* BufferSourceTextureService-Wonderjs Not a pure module */

	function _drawTexture(gl, param) {
	  var glFormat = param[3];
	  gl.texImage2D(param[0], param[1], glFormat, glFormat, param[4], param[2]);
	  return /* () */0;
	}

	function _drawNoMipmapTwoDTexture(gl, param, source) {
	  return _drawTexture(gl, /* tuple */[
	              param[0],
	              0,
	              source,
	              param[1],
	              param[2]
	            ]);
	}

	var _allocateSourceToTexture = _drawNoMipmapTwoDTexture;

	function update$3(gl, textureInTypeArray, param) {
	  var basicSourceTextureRecord = param[0];
	  var browserDetectRecord = param[1];
	  var match = getSource$3(textureInTypeArray, basicSourceTextureRecord[/* sourceMap */8]);
	  if (match !== undefined) {
	    var source = valFromOption(match);
	    var width = getWidth$1(source);
	    var height = getHeight$1(source);
	    var glWrapS = getGlWrap(gl, getWrapS(textureInTypeArray, basicSourceTextureRecord[/* wrapSs */0]));
	    var glWrapT = getGlWrap(gl, getWrapT(textureInTypeArray, basicSourceTextureRecord[/* wrapTs */1]));
	    var magFilter = getMagFilter(textureInTypeArray, basicSourceTextureRecord[/* magFilters */2]);
	    var minFilter = getMinFilter(textureInTypeArray, basicSourceTextureRecord[/* minFilters */3]);
	    var glFormat = getGlFormat(gl, getFormat(textureInTypeArray, basicSourceTextureRecord[/* formats */4]));
	    var glType = getGlType(gl, getType(textureInTypeArray, basicSourceTextureRecord[/* types */5]));
	    var flipY = isFlipY(textureInTypeArray, basicSourceTextureRecord[/* flipYs */7]);
	    var target = gl.TEXTURE_2D;
	    update$4(/* tuple */[
	          gl,
	          textureInTypeArray,
	          source
	        ], /* tuple */[
	          width,
	          height,
	          glWrapS,
	          glWrapT,
	          magFilter,
	          minFilter,
	          glFormat,
	          glType,
	          flipY,
	          target
	        ], /* tuple */[
	          basicSourceTextureRecord[/* isNeedUpdates */6],
	          browserDetectRecord
	        ], /* tuple */[
	          _allocateSourceToTexture,
	          basicSourceTextureRecord[/* setFlipYFunc */11]
	        ]);
	    return /* tuple */[
	            basicSourceTextureRecord,
	            browserDetectRecord
	          ];
	  } else {
	    return /* tuple */[
	            basicSourceTextureRecord,
	            browserDetectRecord
	          ];
	  }
	}

	function isNeedUpdate(textureInTypeArray, basicSourceTextureRecord) {
	  return isNeedUpdate$1(textureInTypeArray, getDefaultIsNeedUpdate$1(/* () */0), basicSourceTextureRecord[/* isNeedUpdates */6], getIsNeedUpdate);
	}


	/* TextureSourceMapService-Wonderjs Not a pure module */

	function _drawTexture$1(gl, param, param$1) {
	  var height = param$1[1];
	  var width = param$1[0];
	  var glFormat = param[3];
	  requireCheck((function () {
	          return test(buildAssertMessage("width/height shouldn\'t be 0", "width is " + (String(width) + ("; height is " + (String(height) + "")))), (function () {
	                        Operators[/* <>= */3](width, 0);
	                        return Operators[/* <>= */3](height, 0);
	                      }));
	        }), getIsDebug(stateData));
	  gl.texImage2D(param[0], param[1], glFormat, width, height, 0, glFormat, param[4], param[2]);
	  return /* () */0;
	}

	function _drawNoMipmapTwoDTexture$1(gl, param, sizeTuple, source) {
	  return _drawTexture$1(gl, /* tuple */[
	              param[0],
	              0,
	              source,
	              param[1],
	              param[2]
	            ], sizeTuple);
	}

	function _allocateSourceToTexture$1(sizeTuple, gl, paramTuple, source) {
	  return _drawNoMipmapTwoDTexture$1(gl, paramTuple, sizeTuple, source);
	}

	function update$5(gl, textureInTypeArray, param) {
	  var arrayBufferViewSourceTextureRecord = param[0];
	  var browserDetectRecord = param[1];
	  var match = getSource$3(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* sourceMap */10]);
	  if (match !== undefined) {
	    var width = getWidth(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* widths */8]);
	    var height = getHeight(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* heights */9]);
	    var glWrapS = getGlWrap(gl, getWrapS$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* wrapSs */0]));
	    var glWrapT = getGlWrap(gl, getWrapT$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* wrapTs */1]));
	    var magFilter = getMagFilter$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* magFilters */2]);
	    var minFilter = getMinFilter$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* minFilters */3]);
	    var glFormat = getGlFormat(gl, getFormat$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* formats */4]));
	    var glType = getGlType(gl, getType$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* types */5]));
	    var flipY = isFlipY$1(textureInTypeArray, arrayBufferViewSourceTextureRecord[/* flipYs */7]);
	    var target = gl.TEXTURE_2D;
	    var partial_arg = /* tuple */[
	      width,
	      height
	    ];
	    update$4(/* tuple */[
	          gl,
	          textureInTypeArray,
	          valFromOption(match)
	        ], /* tuple */[
	          width,
	          height,
	          glWrapS,
	          glWrapT,
	          magFilter,
	          minFilter,
	          glFormat,
	          glType,
	          flipY,
	          target
	        ], /* tuple */[
	          arrayBufferViewSourceTextureRecord[/* isNeedUpdates */6],
	          browserDetectRecord
	        ], /* tuple */[
	          (function (param, param$1, param$2) {
	              return _allocateSourceToTexture$1(partial_arg, param, param$1, param$2);
	            }),
	          arrayBufferViewSourceTextureRecord[/* setFlipYFunc */13]
	        ]);
	    return /* tuple */[
	            arrayBufferViewSourceTextureRecord,
	            browserDetectRecord
	          ];
	  } else {
	    return /* tuple */[
	            arrayBufferViewSourceTextureRecord,
	            browserDetectRecord
	          ];
	  }
	}

	function isNeedUpdate$2(textureInTypeArray, arrayBufferViewSourceTextureRecord) {
	  return isNeedUpdate$1(textureInTypeArray, getDefaultIsNeedUpdate$2(/* () */0), arrayBufferViewSourceTextureRecord[/* isNeedUpdates */6], getIsNeedUpdate$1);
	}


	/* Log-WonderLog Not a pure module */

	function _handleUpdateBasicSourceTexture(basicSourceTextureInTypeArray, param) {
	  var state = param[1];
	  var browserDetectRecord = state[/* browserDetectRecord */23];
	  var basicSourceTextureRecord = state[/* basicSourceTextureRecord */11];
	  var match = isNeedUpdate(basicSourceTextureInTypeArray, basicSourceTextureRecord);
	  if (match) {
	    update$3(param[0], basicSourceTextureInTypeArray, /* tuple */[
	          basicSourceTextureRecord,
	          browserDetectRecord
	        ]);
	  } else {
	    /* tuple */
	  }
	  return state;
	}

	function _handleUpdateArrayBufferViewSourceTexture(arrayBufferViewTextureInTypeArray, param) {
	  var state = param[1];
	  var browserDetectRecord = state[/* browserDetectRecord */23];
	  var arrayBufferViewSourceTextureRecord = state[/* arrayBufferViewSourceTextureRecord */12];
	  var match = isNeedUpdate$2(arrayBufferViewTextureInTypeArray, arrayBufferViewSourceTextureRecord);
	  if (match) {
	    update$5(param[0], arrayBufferViewTextureInTypeArray, /* tuple */[
	          arrayBufferViewSourceTextureRecord,
	          browserDetectRecord
	        ]);
	  } else {
	    /* tuple */
	  }
	  return state;
	}

	function handleUpdate(gl, texture, state) {
	  return handleByJudgeSourceTextureIndex(texture, state[/* arrayBufferViewSourceTextureRecord */12][/* textureIndexOffset */14], /* tuple */[
	              gl,
	              state
	            ], /* tuple */[
	              _handleUpdateBasicSourceTexture,
	              _handleUpdateArrayBufferViewSourceTexture
	            ]);
	}


	/* IndexSourceTextureService-Wonderjs Not a pure module */

	function unsafeGetGPU$1(param) {
	  return unsafeGet$1(param[/* gpu */0]);
	}

	function unsafeGetObjectInstanceCountPerSourceInstance(param) {
	  return unsafeGet$1(param[/* instanceBuffer */1])[/* objectInstanceCountPerSourceInstance */0];
	}

	function getTextureCountPerMaterial$2(param) {
	  return unsafeGet$1(param[/* textureCountPerMaterial */2]);
	}


	/* OptionService-Wonderjs Not a pure module */

	function getTextureIndex$3(material, mapUnit, getTextureIndexFunc, param) {
	  return getTextureIndexFunc(/* tuple */[
	              material,
	              mapUnit,
	              getTextureCountPerMaterial$2(param[1])
	            ], param[0]);
	}

	function bindAndUpdate$1(param, getTextureIndexFunc, stateDataTuple) {
	  var settingRecord = stateDataTuple[1];
	  var textureIndices = stateDataTuple[0];
	  var mapUnit = param[2];
	  var gl = param[0];
	  var match = hasMap(mapUnit);
	  if (match) {
	    var texture = getTextureIndex$3(param[1], mapUnit, getTextureIndexFunc, /* tuple */[
	          textureIndices,
	          settingRecord
	        ]);
	    var state = bind$4(gl, mapUnit, texture, stateDataTuple[2]);
	    return /* tuple */[
	            textureIndices,
	            settingRecord,
	            handleUpdate(gl, texture, state)
	          ];
	  } else {
	    return stateDataTuple;
	  }
	}


	/* BindTextureRenderService-Wonderjs Not a pure module */

	function bindAndUpdate(gl, material, state) {
	  var basicMaterialRecord = state[/* basicMaterialRecord */8];
	  var mapUnit = getMapUnit(material, basicMaterialRecord[/* mapUnits */3]);
	  return bindAndUpdate$1(/* tuple */[
	                gl,
	                material,
	                mapUnit
	              ], getTextureIndex, /* tuple */[
	                basicMaterialRecord[/* textureIndices */2],
	                state[/* settingRecord */21],
	                state
	              ])[2];
	}


	/* OperateTypeArrayBasicMaterialService-Wonderjs Not a pure module */

	function render$4(gl, indexTuple, state) {
	  return render$3(gl, indexTuple, bindAndUpdate, state);
	}


	/* RenderJobUtils-Wonderjs Not a pure module */

	function getShaderIndex$2(materialIndex, getShaderIndexFunc, renderState) {
	  return ensureCheck((function (shaderIndex) {
	                return test(buildAssertMessage("shaderIndex should exist", "not"), (function () {
	                              return Operators[/* <>= */3](shaderIndex, getDefaultShaderIndex(/* () */0));
	                            }));
	              }), getIsDebug(stateData), getShaderIndexFunc(materialIndex, renderState));
	}


	/* Log-WonderLog Not a pure module */

	function isSupportInstance$2(state) {
	  return isSupportInstance$1(unsafeGetGPU$1(state[/* settingRecord */21])[/* useHardwareInstance */0], state[/* gpuDetectRecord */17]);
	}


	/* JudgeInstanceService-Wonderjs Not a pure module */

	function build(sourceInstance, state) {
	  var match = state[/* sourceInstanceRecord */16];
	  var objectInstanceTransformIndex = getObjectInstanceTransformIndex$1(sourceInstance, match[/* objectInstanceTransformIndexMap */0]);
	  return /* tuple */[
	          objectInstanceTransformIndex,
	          /* tuple */[
	            sourceInstance,
	            unsafeGetObjectInstanceCountPerSourceInstance(state[/* settingRecord */21]),
	            objectInstanceTransformIndex,
	            match[/* objectInstanceTransformCollections */1]
	          ]
	        ];
	}


	/* OperateRenderSettingService-Wonderjs Not a pure module */

	function render$7(gl, indexTuple, renderFunc, state) {
	  var geometryType = indexTuple[5];
	  var geometryIndex = indexTuple[4];
	  var meshRendererIndex = indexTuple[3];
	  var shaderIndex = indexTuple[2];
	  var state$1 = renderFunc(gl, /* tuple */[
	        indexTuple[0],
	        indexTuple[1],
	        shaderIndex,
	        meshRendererIndex,
	        geometryIndex,
	        geometryType
	      ], state);
	  draw$4(gl, meshRendererIndex, geometryIndex, geometryType, state$1);
	  var uniformRenderObjectSendModelData = unsafeGetUniformSendData(shaderIndex, state$1[/* glslSenderRecord */3]);
	  var drawMode = getGlDrawMode(gl, meshRendererIndex, state$1);
	  var indexType = getIndexType(gl);
	  var indexTypeSize = getIndexTypeSize(gl);
	  var getIndicesCountFunc = getGetIndicesCountFunc(geometryType);
	  var indicesCount = getIndicesCountFunc(geometryIndex, state$1);
	  var match = build(indexTuple[6], state$1);
	  return reduceObjectInstanceTransformCollection(match[1], state$1, (function (state, objectInstanceTransform) {
	                var state$1 = reduceOneParam((function (state, param) {
	                        var pos = param[/* pos */0];
	                        var match = isUniformLocationExist(pos);
	                        if (match) {
	                          param[/* sendDataFunc */2](gl, pos, param[/* getDataFunc */1](objectInstanceTransform, state));
	                        }
	                        return state;
	                      }), state, uniformRenderObjectSendModelData);
	                drawElement(/* tuple */[
	                      drawMode,
	                      indexType,
	                      indexTypeSize,
	                      indicesCount
	                    ], gl);
	                return state$1;
	              }));
	}


	/* RenderJobUtils-Wonderjs Not a pure module */

	function render$6(gl, indexTuple, state) {
	  return render$7(gl, indexTuple, render$4, state);
	}


	/* RenderBasicJobCommon-Wonderjs Not a pure module */

	function createBuffer$11(gl, capacity, state) {
	  var buffer = getInstanceBuffer(gl, state[/* vboBufferRecord */1]);
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferData(gl.ARRAY_BUFFER, capacity, gl.DYNAMIC_DRAW);
	  return buffer;
	}

	function _getFloat32InstanceArraySize(capacity) {
	  requireCheck((function () {
	          return test(buildAssertMessage("capacity should be a multiplier of 4", "is " + (String(capacity) + "")), (function () {
	                        return Operators[/* = */0](capacity % 4, 0);
	                      }));
	        }), getIsDebug(stateData));
	  return capacity / 4 | 0;
	}

	function _getCapacity(sourceInstance, defaultCapacity, capacityMap) {
	  var match = get$3(sourceInstance, capacityMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    return defaultCapacity;
	  }
	}

	function _setCapacity(sourceInstance, capacity, capacityMap) {
	  set$1(sourceInstance, capacity, capacityMap);
	  return capacityMap;
	}

	function getOrCreateBuffer$3(param, param$1, state) {
	  var bufferMap = param$1[1];
	  var sourceInstance = param[1];
	  var match = get$3(sourceInstance, bufferMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    var buffer = createBuffer$11(param[0], _getCapacity(sourceInstance, param[2], param$1[0]), state);
	    set$1(sourceInstance, buffer, bufferMap);
	    return buffer;
	  }
	}

	function getOrCreateMatrixFloat32Array(sourceInstance, defaultCapacity, param, state) {
	  var matrixFloat32ArrayMap = param[1];
	  var capacity = _getCapacity(sourceInstance, defaultCapacity, param[0]);
	  var match = get$3(sourceInstance, matrixFloat32ArrayMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    var match$1 = getFloat32TypeArrayFromPool(_getFloat32InstanceArraySize(capacity), state[/* typeArrayPoolRecord */2]);
	    if (match$1 !== undefined) {
	      return valFromOption(match$1);
	    } else {
	      var typeArr = new Float32Array(_getFloat32InstanceArraySize(capacity));
	      set$1(sourceInstance, typeArr, matrixFloat32ArrayMap);
	      return typeArr;
	    }
	  }
	}

	function setCapacityAndUpdateBufferTypeArray(param, param$1, param$2, state) {
	  var capacityMap = param$2[2];
	  var buffer = param$1[0];
	  var capacity = param[2];
	  var sourceInstance = param[1];
	  var gl = param[0];
	  var currentCapacity = _getCapacity(sourceInstance, param[3], capacityMap);
	  var needIncreaseCapacity = false;
	  while(currentCapacity < capacity) {
	    currentCapacity = (currentCapacity << 1);
	    needIncreaseCapacity = true;
	  }
	  if (needIncreaseCapacity) {
	    _setCapacity(sourceInstance, currentCapacity, capacityMap);
	    gl.deleteBuffer(buffer);
	    var buffer$1 = createBuffer$11(gl, currentCapacity, state);
	    set$1(sourceInstance, buffer$1, param$2[0]);
	    var matrixFloat32Array = new Float32Array(_getFloat32InstanceArraySize(currentCapacity));
	    set$1(sourceInstance, matrixFloat32Array, param$2[1]);
	    return /* tuple */[
	            buffer$1,
	            matrixFloat32Array
	          ];
	  } else {
	    return /* tuple */[
	            buffer,
	            param$1[1]
	          ];
	  }
	}

	function updateData(gl, data, buffer) {
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  gl.bufferSubData(gl.ARRAY_BUFFER, 0, data);
	  return buffer;
	}

	function bind$5(gl, buffer) {
	  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	  return buffer;
	}


	/* Log-WonderLog Not a pure module */

	var markIsSendTransformMatrixData$1 = set$1;

	function isSendTransformMatrixData(sourceInstance, isSendTransformMatrixDataMap) {
	  var match = get$3(sourceInstance, isSendTransformMatrixDataMap);
	  if (match !== undefined) {
	    return match;
	  } else {
	    return false;
	  }
	}


	/* No side effect */

	function isTransformStatic$1(sourceInstance, param) {
	  return isTransformStatic(sourceInstance, param[/* isTransformStatics */2]);
	}

	function markIsSendTransformMatrixData(sourceInstance, isSend, record) {
	  return /* record */[
	          /* objectInstanceTransformIndexMap */record[/* objectInstanceTransformIndexMap */0],
	          /* objectInstanceTransformCollections */record[/* objectInstanceTransformCollections */1],
	          /* isTransformStatics */record[/* isTransformStatics */2],
	          /* matrixInstanceBufferCapacityMap */record[/* matrixInstanceBufferCapacityMap */3],
	          /* matrixFloat32ArrayMap */record[/* matrixFloat32ArrayMap */4],
	          /* isSendTransformMatrixDataMap */markIsSendTransformMatrixData$1(sourceInstance, isSend, record[/* isSendTransformMatrixDataMap */5])
	        ];
	}


	/* StaticTransformService-Wonderjs Not a pure module */

	function _fillObjectInstanceData(objectInstanceTransformDataTuple, matricesArrayForInstance, fillMatrixTypeArrFunc, stateOffsetTuple) {
	  return reduceObjectInstanceTransformCollection(objectInstanceTransformDataTuple, stateOffsetTuple, (function (stateOffsetTuple, objectInstanceTransform) {
	                  return fillMatrixTypeArrFunc(objectInstanceTransform, matricesArrayForInstance, stateOffsetTuple);
	                }))[0];
	}

	function _sendTransformMatrixDataBuffer(param, param$1, state) {
	  var match = param$1[0];
	  var pos = match[/* pos */0];
	  var gl = param[0];
	  gl.vertexAttribPointer(pos, match[/* size */1], gl.FLOAT, false, param$1[1], match[/* getOffsetFunc */2](param$1[2]));
	  param[1].vertexAttribDivisorANGLE(pos, 1);
	  enableVertexAttribArray(gl, pos, state[/* glslSenderRecord */3][/* vertexAttribHistoryArray */9]);
	  return state;
	}

	function _sendTransformMatrixDataBufferData(glDataTuple, shaderIndex, stride, state) {
	  return reduceOneParami((function (state, sendData, index) {
	                return _sendTransformMatrixDataBuffer(glDataTuple, /* tuple */[
	                            sendData,
	                            stride,
	                            index
	                          ], state);
	              }), state, unsafeGetInstanceAttributeSendData(shaderIndex, state[/* glslSenderRecord */3]));
	}

	function _updateAndSendTransformMatrixDataBufferData(glDataTuple, shaderIndex, param, state) {
	  updateData(glDataTuple[0], param[1], param[2]);
	  return _sendTransformMatrixDataBufferData(glDataTuple, shaderIndex, param[0], state);
	}

	function _sendTransformMatrixData(param, param$1, fillMatrixTypeArrFunc, state) {
	  var match = param$1[2];
	  var matrixFloat32ArrayMap = match[2];
	  var matrixInstanceBufferMap = match[1];
	  var matrixInstanceBufferCapacityMap = match[0];
	  var match$1 = param$1[1];
	  var defaultCapacity = match$1[0];
	  var match$2 = param$1[0];
	  var gl = match$2[0];
	  var sourceInstance = param[1];
	  var matrixInstanceBuffer = getOrCreateBuffer$3(/* tuple */[
	        gl,
	        sourceInstance,
	        defaultCapacity
	      ], /* tuple */[
	        matrixInstanceBufferCapacityMap,
	        matrixInstanceBufferMap
	      ], state);
	  var matricesArrayForInstance = getOrCreateMatrixFloat32Array(sourceInstance, defaultCapacity, /* tuple */[
	        matrixInstanceBufferCapacityMap,
	        matrixFloat32ArrayMap
	      ], state);
	  var match$3 = setCapacityAndUpdateBufferTypeArray(/* tuple */[
	        gl,
	        sourceInstance,
	        imul(match$1[4], match$1[1]),
	        defaultCapacity
	      ], /* tuple */[
	        matrixInstanceBuffer,
	        matricesArrayForInstance
	      ], /* tuple */[
	        matrixInstanceBufferMap,
	        matrixFloat32ArrayMap,
	        matrixInstanceBufferCapacityMap
	      ], state);
	  var matricesArrayForInstance$1 = match$3[1];
	  return _updateAndSendTransformMatrixDataBufferData(/* tuple */[
	              gl,
	              match$2[1]
	            ], match$2[2], /* tuple */[
	              match$1[2],
	              matricesArrayForInstance$1,
	              match$3[0]
	            ], _fillObjectInstanceData(match$1[3], matricesArrayForInstance$1, fillMatrixTypeArrFunc, fillMatrixTypeArrFunc(param[0], matricesArrayForInstance$1, /* tuple */[
	                      state,
	                      0
	                    ])));
	}

	function _sendStaticTransformMatrixData(componentTuple, dataTuple, fillMatrixTypeArrFunc, state) {
	  var match = dataTuple[2];
	  var match$1 = dataTuple[1];
	  var match$2 = dataTuple[0];
	  var gl = match$2[0];
	  var sourceInstance = componentTuple[1];
	  var match$3 = isSendTransformMatrixData(sourceInstance, state[/* sourceInstanceRecord */16][/* isSendTransformMatrixDataMap */5]);
	  if (match$3) {
	    bind$5(gl, getOrCreateBuffer$3(/* tuple */[
	              gl,
	              sourceInstance,
	              match$1[0]
	            ], /* tuple */[
	              match[0],
	              match[1]
	            ], state));
	    return _sendTransformMatrixDataBufferData(/* tuple */[
	                gl,
	                match$2[1]
	              ], match$2[2], match$1[2], state);
	  } else {
	    var state$1 = _sendTransformMatrixData(componentTuple, dataTuple, fillMatrixTypeArrFunc, state);
	    var newrecord = caml_array_dup(state$1);
	    newrecord[/* sourceInstanceRecord */16] = markIsSendTransformMatrixData(sourceInstance, true, state$1[/* sourceInstanceRecord */16]);
	    return newrecord;
	  }
	}

	function _sendDynamicTransformMatrixData(componentTuple, dataTuple, fillMatrixTypeArrFunc, state) {
	  var newrecord = caml_array_dup(state);
	  return _sendTransformMatrixData(componentTuple, dataTuple, fillMatrixTypeArrFunc, (newrecord[/* sourceInstanceRecord */16] = markIsSendTransformMatrixData(componentTuple[1], false, state[/* sourceInstanceRecord */16]), newrecord));
	}

	function _geMatrixMapTuple(state) {
	  var match = state[/* vboBufferRecord */1];
	  var match$1 = state[/* sourceInstanceRecord */16];
	  return /* tuple */[
	          match$1[/* matrixInstanceBufferCapacityMap */3],
	          match[/* matrixInstanceBufferMap */8],
	          match$1[/* matrixFloat32ArrayMap */4]
	        ];
	}

	function _renderSourceInstanceGameObject(gl, indexTuple, renderFunc, state) {
	  return renderFunc(gl, indexTuple, state);
	}

	function _prepareData(gl, shaderIndex, param, state) {
	  var extension = unsafeGetInstanceExtension(state[/* gpuDetectRecord */17]);
	  var match = build(param[0], state);
	  var instanceRenderListCount = getObjectInstanceTransformCount(match[0]) + 1 | 0;
	  return /* tuple */[
	          /* tuple */[
	            gl,
	            extension,
	            shaderIndex
	          ],
	          /* tuple */[
	            param[1],
	            param[2],
	            param[3],
	            match[1],
	            instanceRenderListCount
	          ],
	          _geMatrixMapTuple(state)
	        ];
	}

	function _unbind(shaderIndex, extension, state) {
	  forEach((function (param) {
	          extension.vertexAttribDivisorANGLE(param[/* pos */0], 0);
	          return /* () */0;
	        }), unsafeGetInstanceAttributeSendData(shaderIndex, state[/* glslSenderRecord */3]));
	  return state;
	}

	function render$9(gl, param, param$1, state) {
	  var fillMatrixTypeArrFunc = param$1[1];
	  var indexTuple = param[0];
	  var sourceInstance = indexTuple[6];
	  var geometryType = indexTuple[5];
	  var geometryIndex = indexTuple[4];
	  var meshRendererIndex = indexTuple[3];
	  var shaderIndex = indexTuple[2];
	  var transformIndex = indexTuple[0];
	  var state$1 = _renderSourceInstanceGameObject(gl, /* tuple */[
	        transformIndex,
	        indexTuple[1],
	        shaderIndex,
	        meshRendererIndex,
	        geometryIndex,
	        geometryType
	      ], param$1[0], state);
	  var dataTuple = _prepareData(gl, shaderIndex, /* tuple */[
	        sourceInstance,
	        param[1],
	        param[2],
	        param[3]
	      ], state$1);
	  var match = dataTuple[0];
	  var extension = match[1];
	  var gl$1 = match[0];
	  var match$1 = isTransformStatic$1(sourceInstance, state$1[/* sourceInstanceRecord */16]);
	  var state$2 = match$1 ? _sendStaticTransformMatrixData(/* tuple */[
	          transformIndex,
	          sourceInstance
	        ], dataTuple, fillMatrixTypeArrFunc, state$1) : _sendDynamicTransformMatrixData(/* tuple */[
	          transformIndex,
	          sourceInstance
	        ], dataTuple, fillMatrixTypeArrFunc, state$1);
	  var getIndicesCountFunc = getGetIndicesCountFunc(geometryType);
	  drawElementsInstancedANGLE(/* tuple */[
	        getGlDrawMode(gl$1, meshRendererIndex, state$2),
	        getIndexType(gl$1),
	        getIndexTypeSize(gl$1),
	        getIndicesCountFunc(geometryIndex, state$2),
	        dataTuple[1][4]
	      ], extension);
	  return _unbind(shaderIndex, extension, state$2);
	}

	function fillMatrixTypeArr(transformIndex, matricesArrayForInstance, param) {
	  return fillFloat32ArrayWithFloat32Array(/* tuple */[
	              matricesArrayForInstance,
	              param[1]
	            ], /* tuple */[
	              getLocalToWorldMatrixTypeArray$2(transformIndex, param[0]),
	              0
	            ], 16);
	}


	/* GPUDetectService-Wonderjs Not a pure module */

	function _fillMatrixTypeArr(transform, matricesArrayForInstance, tuple) {
	  fillMatrixTypeArr(transform, matricesArrayForInstance, tuple);
	  return /* tuple */[
	          tuple[0],
	          tuple[1] + 16 | 0
	        ];
	}

	function render$8(gl, indexTuple, state) {
	  return render$9(gl, /* tuple */[
	              indexTuple,
	              4096,
	              64,
	              64
	            ], /* tuple */[
	              render$4,
	              _fillMatrixTypeArr
	            ], state);
	}


	/* RenderBasicJobCommon-Wonderjs Not a pure module */

	function render$5(gl, indexTuple, state) {
	  if (isSupportInstance$2(state)) {
	    return render$8(gl, indexTuple, state);
	  } else {
	    return render$6(gl, indexTuple, state);
	  }
	}


	/* JudgeInstanceRenderService-Wonderjs Not a pure module */

	function getShaderIndex$3(materialIndex, param) {
	  return getShaderIndex(materialIndex, param[/* basicMaterialRecord */8][/* shaderIndices */0]);
	}


	/* ShaderIndicesService-Wonderjs Not a pure module */

	function render$2(gl, param, state) {
	  var sourceInstanceIndices = param[6];
	  var geometryTypes = param[5];
	  var geometryIndices = param[4];
	  var meshRendererIndices = param[3];
	  var materialIndices = param[2];
	  var transformIndices = param[1];
	  return reduceOneParam((function (state, index) {
	                var transformIndex = getComponent$1(index, transformIndices);
	                var materialIndex = getComponent$1(index, materialIndices);
	                var shaderIndex = getShaderIndex$2(materialIndex, getShaderIndex$3, state);
	                var meshRendererIndex = getComponent$1(index, meshRendererIndices);
	                var geometryIndex = getComponent$1(index, geometryIndices);
	                var geometryType = getGeometryType(index, geometryTypes);
	                var sourceInstance = getComponent$1(index, sourceInstanceIndices);
	                if (hasSourceInstance(sourceInstance)) {
	                  return render$5(gl, /* tuple */[
	                              transformIndex,
	                              materialIndex,
	                              shaderIndex,
	                              meshRendererIndex,
	                              geometryIndex,
	                              geometryType,
	                              sourceInstance
	                            ], state);
	                } else {
	                  var state$1 = render$4(gl, /* tuple */[
	                        transformIndex,
	                        materialIndex,
	                        shaderIndex,
	                        meshRendererIndex,
	                        geometryIndex,
	                        geometryType
	                      ], state);
	                  draw$4(gl, meshRendererIndex, geometryIndex, geometryType, state$1);
	                  return state$1;
	                }
	              }), state, range$1(0, param[0] - 1 | 0));
	}


	/* ArrayService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* No side effect */

	/* ComputePointsBoxGeometryService-Wonderjs Not a pure module */

	/* IndexSourceTextureService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* Log-WonderLog Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	var serializeFunction = function (func){
	    return func.toString();
	    };

	var deserializeFunction = function (funcStr){
	    return eval('(' + funcStr + ')');
	    };


	/* No side effect */

	function getCustomDataFromRenderWorkerToMainWorker(state) {
	  return state[/* customRecord */30][/* customDataFromRenderWorkerToMainWorker */0];
	}

	function setCustomDataFromRenderWorkerToMainWorker(customData, state) {
	  var init = state[/* customRecord */30];
	  state[/* customRecord */30] = /* record */[
	    /* customDataFromRenderWorkerToMainWorker */customData,
	    /* customDataFromMainWorkerToRenderWorker */init[/* customDataFromMainWorkerToRenderWorker */1]
	  ];
	  return state;
	}

	function getCustomDataFromMainWorkerToRenderWorker(state) {
	  return state[/* customRecord */30][/* customDataFromMainWorkerToRenderWorker */1];
	}


	/* No side effect */

	var getRecord$30 = getRecord$18;

	function setRecord$1(record, state) {
	  state[/* imguiRecord */28] = record;
	  return state;
	}


	/* No side effect */

	function label$3(rect, str, align, state) {
	  var __x = label$2(rect, str, align, getRecord$30(state));
	  return setRecord$1(__x, state);
	}

	function image$3(rect, uv, id, state) {
	  var __x = image$2(rect, uv, id, getRecord$30(state));
	  return setRecord$1(__x, state);
	}

	function button$3(rect, str, state) {
	  var match = button$1(rect, str, getRecord$30(state));
	  return /* tuple */[
	          setRecord$1(match[0], state),
	          match[1]
	        ];
	}

	function box$2(rect, color, state) {
	  var __x = box$1(rect, color, getRecord$30(state));
	  return setRecord$1(__x, state);
	}

	function radioButton$3(groupDataArr, defaultSelectIndex, group, state) {
	  var match = radioButton$1(groupDataArr, defaultSelectIndex, group, getRecord$30(state));
	  return /* tuple */[
	          setRecord$1(match[0], state),
	          match[1]
	        ];
	}

	function checkbox$3(rect, defaultIsSelected, str, state) {
	  var match = checkbox$1(rect, defaultIsSelected, str, getRecord$30(state));
	  return /* tuple */[
	          setRecord$1(match[0], state),
	          match[1]
	        ];
	}

	function sliderInt$3(param, param$1, param$2, state) {
	  var match = sliderInt$1(/* tuple */[
	        param[0],
	        param[1]
	      ], /* tuple */[
	        param$1[0],
	        param$1[1]
	      ], /* tuple */[
	        param$2[0],
	        param$2[1]
	      ], getRecord$30(state));
	  return /* tuple */[
	          setRecord$1(match[0], state),
	          match[1],
	          match[2]
	        ];
	}

	function sliderFloat$3(param, param$1, param$2, state) {
	  var match = sliderFloat$1(/* tuple */[
	        param[0],
	        param[1]
	      ], /* tuple */[
	        param$1[0],
	        param$1[1],
	        param$1[2]
	      ], /* tuple */[
	        param$2[0],
	        param$2[1]
	      ], getRecord$30(state));
	  return /* tuple */[
	          setRecord$1(match[0], state),
	          match[1],
	          match[2]
	        ];
	}

	function beginGroup$3(position, state) {
	  var __x = beginGroup$1(position, getRecord$30(state));
	  return setRecord$1(__x, state);
	}

	function endGroup$3(state) {
	  var __x = endGroup$1(getRecord$30(state));
	  return setRecord$1(__x, state);
	}


	/* GroupLayoutIMGUIAPI-WonderImgui Not a pure module */

	function getAPIJsObj$3(state) {
	  return state[/* apiRecord */29][/* apiJsObj */0];
	}

	function setAPIJsObj$2(apiJsObj, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* apiRecord */29] = apiJsObj;
	  return newrecord;
	}

	function create$61() {
	  return /* record */[/* apiJsObj */{
	            label: label$3,
	            image: image$3,
	            button: button$3,
	            box: box$2,
	            radioButton: radioButton$3,
	            checkbox: checkbox$3,
	            sliderInt: sliderInt$3,
	            sliderFloat: sliderFloat$3,
	            beginGroup: beginGroup$3,
	            endGroup: endGroup$3,
	            getCustomDataFromMainWorkerToRenderWorker: getCustomDataFromMainWorkerToRenderWorker,
	            getCustomDataFromRenderWorkerToMainWorker: getCustomDataFromRenderWorkerToMainWorker,
	            setCustomDataFromRenderWorkerToMainWorker: setCustomDataFromRenderWorkerToMainWorker
	          }];
	}


	/* FixedLayoutControlIMGUIRenderWorkerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function execJob$24(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var viewRecord = state[/* viewRecord */9];
	                state[/* viewRecord */9] = setCanvas(setToFullScreen(queryFullScreenData(/* () */0), unsafeGetCanvas(viewRecord)), state[/* viewRecord */9]);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function clearDataForWorkerInit(record) {
	  record[/* materialArrayForWorkerInit */12] = /* array */[];
	  return record;
	}


	/* No side effect */

	function clearDataForWorkerInit$1(record) {
	  record[/* materialArrayForWorkerInit */17] = /* array */[];
	  return record;
	}


	/* No side effect */

	function getPosition$1(gameObject, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  return updateAndGetPositionTuple(unsafeGetTransformComponent(gameObject, gameObjectRecord), state[/* globalTempRecord */36], getRecord$1(state));
	}

	function buildPositionMap(index, getPositionFunc, state) {
	  return reduceOneParam((function (map, i) {
	                return set$1(i, _2(getPositionFunc, i, state), map);
	              }), createEmpty$2(/* () */0), range$1(0, index - 1 | 0));
	}


	/* ArrayService-Wonderjs Not a pure module */

	function unsafeGetGameObject$9(light, param) {
	  return unsafeGetGameObject$1(light, param[/* gameObjectMap */9]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getPosition$2(index, state) {
	  return getPosition$1(unsafeGetGameObject$9(index, state[/* pointLightRecord */22]), state);
	}


	/* PositionLightMainService-Wonderjs Not a pure module */

	function setFlipY$3(gl, flipY, _) {
	  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
	  return /* () */0;
	}

	function clearNeedAddedSourceArr(state) {
	  var newrecord = caml_array_dup(state);
	  var init = getRecord$9(state);
	  newrecord[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */init[/* index */0],
	    /* wrapSs */init[/* wrapSs */1],
	    /* wrapTs */init[/* wrapTs */2],
	    /* magFilters */init[/* magFilters */3],
	    /* minFilters */init[/* minFilters */4],
	    /* formats */init[/* formats */5],
	    /* types */init[/* types */6],
	    /* isNeedUpdates */init[/* isNeedUpdates */7],
	    /* flipYs */init[/* flipYs */8],
	    /* sourceMap */init[/* sourceMap */9],
	    /* glTextureMap */init[/* glTextureMap */10],
	    /* bindTextureUnitCacheMap */init[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */init[/* disposedIndexArray */12],
	    /* needAddedSourceArray : array */[],
	    /* needInitedTextureIndexArray */init[/* needInitedTextureIndexArray */14],
	    /* nameMap */init[/* nameMap */15]
	  ];
	  var init$1 = getRecord$11(state);
	  newrecord[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */init$1[/* index */0],
	    /* wrapSs */init$1[/* wrapSs */1],
	    /* wrapTs */init$1[/* wrapTs */2],
	    /* magFilters */init$1[/* magFilters */3],
	    /* minFilters */init$1[/* minFilters */4],
	    /* formats */init$1[/* formats */5],
	    /* types */init$1[/* types */6],
	    /* isNeedUpdates */init$1[/* isNeedUpdates */7],
	    /* flipYs */init$1[/* flipYs */8],
	    /* widths */init$1[/* widths */9],
	    /* heights */init$1[/* heights */10],
	    /* sourceMap */init$1[/* sourceMap */11],
	    /* glTextureMap */init$1[/* glTextureMap */12],
	    /* bindTextureUnitCacheMap */init$1[/* bindTextureUnitCacheMap */13],
	    /* disposedIndexArray */init$1[/* disposedIndexArray */14],
	    /* needAddedSourceArray : array */[],
	    /* needInitedTextureIndexArray */init$1[/* needInitedTextureIndexArray */16],
	    /* nameMap */init$1[/* nameMap */17]
	  ];
	  return newrecord;
	}


	/* RecordBasicSourceTextureMainService-Wonderjs Not a pure module */

	function unsafeGetGameObject$10(light, param) {
	  return unsafeGetGameObject$1(light, param[/* gameObjectMap */5]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function getDirection$1(index, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var directionLightRecord = state[/* directionLightRecord */21];
	  return transformQuat(/* tuple */[
	              0,
	              0,
	              1
	            ], updateAndGetRotationTuple(unsafeGetTransformComponent(unsafeGetGameObject$10(index, directionLightRecord), gameObjectRecord), state[/* globalTempRecord */36], getRecord$1(state)));
	}

	function buildDirectionMap(index, getDirectionFunc, state) {
	  return reduceOneParam((function (map, i) {
	                return set$1(i, _2(getDirectionFunc, i, state), map);
	              }), createEmpty$2(/* () */0), range$1(0, index - 1 | 0));
	}


	/* ArrayService-Wonderjs Not a pure module */

	var drawImage = (
	    function(source, x, y, context){
	      context.drawImage(source, x, y);
	      return context
	    }
	    );

	var getImageData$1 = (
	    function(x, y, width, height, context){
	      return context.getImageData(x, y, width, height);
	    }
	    );


	/* drawImage Not a pure module */

	function getImageData(source, width, height) {
	  var canvas = buildCanvas(/* () */0);
	  var ctx = canvas.getContext("2d");
	  canvas.width = width;
	  canvas.height = height;
	  return _5(getImageData$1, 0, 0, width, height, _4(drawImage, source, 0, 0, ctx));
	}

	function convertImageToImageData(image) {
	  var width = image.width;
	  var height = image.height;
	  var imageData = getImageData(image, width, height);
	  return /* tuple */[
	          imageData.data.buffer,
	          width,
	          height
	        ];
	}


	/* Canvas-Wonderjs Not a pure module */

	function unsafeGetSource$1(texture, state) {
	  var match = getRecord$9(state);
	  return unsafeGetSource(texture, match[/* sourceMap */9]);
	}

	function setSource$1(texture, source, state) {
	  var match = isUseWorker(state);
	  if (match) {
	    var match$1 = getRecord$9(state);
	    setSource(texture, source, match$1[/* sourceMap */9]);
	    push(/* tuple */[
	          texture,
	          source
	        ], match$1[/* needAddedSourceArray */13]);
	    return state;
	  } else {
	    var match$2 = getRecord$9(state);
	    setSource(texture, source, match$2[/* sourceMap */9]);
	    return state;
	  }
	}

	function convertNeedAddedSourceArrayToImageDataArr(needAddedSourceArray) {
	  return reduceOneParam((function (imageDataArr, param) {
	                var match = convertImageToImageData(param[1]);
	                return push(/* tuple */[
	                            match[0],
	                            match[1],
	                            match[2],
	                            param[0]
	                          ], imageDataArr);
	              }), /* array */[], needAddedSourceArray);
	}

	function getWrapS$2(texture, state) {
	  var match = getRecord$9(state);
	  return getWrapS(texture, match[/* wrapSs */1]);
	}

	function setWrapS$2(texture, wrapS, state) {
	  var match = getRecord$9(state);
	  setWrapS(texture, wrapS, match[/* wrapSs */1]);
	  return state;
	}

	function getWrapT$2(texture, state) {
	  var match = getRecord$9(state);
	  return getWrapT(texture, match[/* wrapTs */2]);
	}

	function setWrapT$2(texture, wrapT, state) {
	  var match = getRecord$9(state);
	  setWrapT(texture, wrapT, match[/* wrapTs */2]);
	  return state;
	}

	function getMagFilter$2(texture, state) {
	  var match = getRecord$9(state);
	  return getMagFilter(texture, match[/* magFilters */3]);
	}

	function setMagFilter$2(texture, filter, state) {
	  var match = getRecord$9(state);
	  setMagFilter(texture, filter, match[/* magFilters */3]);
	  return state;
	}

	function getMinFilter$2(texture, state) {
	  var match = getRecord$9(state);
	  return getMinFilter(texture, match[/* minFilters */4]);
	}

	function setMinFilter$2(texture, filter, state) {
	  var match = getRecord$9(state);
	  setMinFilter(texture, filter, match[/* minFilters */4]);
	  return state;
	}

	function getFormat$2(texture, state) {
	  var match = getRecord$9(state);
	  return getFormat(texture, match[/* formats */5]);
	}

	function setFormat$2(texture, format, state) {
	  var match = getRecord$9(state);
	  setFormat(texture, format, match[/* formats */5]);
	  return state;
	}

	function getType$3(texture, state) {
	  var match = getRecord$9(state);
	  return getType(texture, match[/* types */6]);
	}

	function setType$2(texture, filter, state) {
	  var match = getRecord$9(state);
	  setType(texture, filter, match[/* types */6]);
	  return state;
	}

	function getFlipY$3(texture, state) {
	  var match = getRecord$9(state);
	  return getFlipYFromTypeArrayValue(getFlipY$1(texture, match[/* flipYs */8]));
	}

	function setFlipY$4(texture, flipY, state) {
	  var match = getRecord$9(state);
	  setFlipY(texture, getFlipYTypeArrayValue(flipY), match[/* flipYs */8]);
	  return state;
	}

	function getWidth$2(texture, state) {
	  var match = getRecord$9(state);
	  var match$1 = getSource$3(texture, match[/* sourceMap */9]);
	  if (match$1 !== undefined) {
	    return getWidth$1(valFromOption(match$1));
	  } else {
	    return fatal(buildFatalMessage("getWidth", "source should exist", "", "", ""));
	  }
	}

	function getHeight$2(texture, state) {
	  var match = getRecord$9(state);
	  var match$1 = getSource$3(texture, match[/* sourceMap */9]);
	  if (match$1 !== undefined) {
	    return getHeight$1(valFromOption(match$1));
	  } else {
	    return fatal(buildFatalMessage("getHeight", "source should exist", "", "", ""));
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _buildMaterialData(materialArrayForWorkerInit, gameObjectMap, gameObjectRecord) {
	  return removeDuplicateItems(materialArrayForWorkerInit).reduce((function (arr, materialIndex) {
	                return push(/* tuple */[
	                            materialIndex,
	                            isSourceInstance(materialIndex, gameObjectMap, gameObjectRecord)
	                          ], arr);
	              }), /* array */[]);
	}

	function _removeAddedSourceDataDuplicateItems(needAddedSourceDataArray) {
	  return removeDuplicateItems$1((function (param) {
	                return param[0].toString();
	              }), needAddedSourceDataArray);
	}

	function _buildIMGUIData(state) {
	  var wonderImguiIMGUIRecord = getWonderIMGUIRecord(state);
	  var ioData = getIOData$1(state);
	  var match = getCustomData$1(wonderImguiIMGUIRecord);
	  var match$1 = getIMGUIFunc$1(wonderImguiIMGUIRecord);
	  return {
	          ioData: ioData,
	          customData: match !== undefined ? some$1(valFromOption(match)) : undefined,
	          imguiFunc: match$1 !== undefined ? some$1(serializeFunction(valFromOption(match$1))) : undefined,
	          controlData: getControlData(wonderImguiIMGUIRecord)
	        };
	}

	function _buildData(operateType, stateData) {
	  var state = unsafeGetState$2(stateData);
	  var settingRecord = state[/* settingRecord */1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var basicMaterialRecord = getRecord$4(state);
	  var lightMaterialRecord = getRecord$5(state);
	  var basicRenderObjectRecord = unsafeGetBasicRenderObjectRecord(state);
	  var lightRenderObjectRecord = unsafeGetLightRenderObjectRecord(state);
	  var sourceInstanceRecord = getRecord$7(state);
	  var basicSourceTextureRecord = getRecord$9(state);
	  var arrayBufferViewSourceTextureRecord = getRecord$11(state);
	  var cameraData = getCameraRecord(state);
	  var match = getCameraRecord(state);
	  var match$1;
	  if (match !== undefined) {
	    var match$2 = match;
	    match$1 = /* tuple */[
	      true,
	      {
	        vMatrix: match$2[/* vMatrix */0],
	        pMatrix: match$2[/* pMatrix */1],
	        position: match$2[/* position */2]
	      }
	    ];
	  } else {
	    match$1 = /* tuple */[
	      false,
	      null
	    ];
	  }
	  return {
	          operateType: operateType,
	          ambientLightData: {
	            color: getAmbientLightColor$2(state)
	          },
	          directionLightData: {
	            index: directionLightRecord[/* index */0],
	            directionMap: buildDirectionMap(directionLightRecord[/* index */0], getDirection$1, state)
	          },
	          pointLightData: {
	            index: pointLightRecord[/* index */0],
	            positionMap: buildPositionMap(pointLightRecord[/* index */0], getPosition$2, state)
	          },
	          initData: {
	            materialData: {
	              basicMaterialData: {
	                materialDataForWorkerInit: _buildMaterialData(basicMaterialRecord[/* materialArrayForWorkerInit */12], basicMaterialRecord[/* gameObjectMap */8], gameObjectRecord)
	              },
	              lightMaterialData: {
	                materialDataForWorkerInit: _buildMaterialData(lightMaterialRecord[/* materialArrayForWorkerInit */17], lightMaterialRecord[/* gameObjectMap */13], gameObjectRecord)
	              }
	            },
	            textureData: {
	              basicSourceTextureData: {
	                needAddedImageDataArray: convertNeedAddedSourceArrayToImageDataArr(_removeAddedSourceDataDuplicateItems(basicSourceTextureRecord[/* needAddedSourceArray */13])),
	                needInitedTextureIndexArray: removeDuplicateItems(basicSourceTextureRecord[/* needInitedTextureIndexArray */14])
	              },
	              arrayBufferViewSourceTextureData: {
	                needAddedSourceArray: _removeAddedSourceDataDuplicateItems(arrayBufferViewSourceTextureRecord[/* needAddedSourceArray */15]),
	                needInitedTextureIndexArray: removeDuplicateItems(arrayBufferViewSourceTextureRecord[/* needInitedTextureIndexArray */16])
	              }
	            }
	          },
	          renderData: {
	            isRender: match$1[0],
	            camera: match$1[1],
	            basic: {
	              buffer: basicRenderObjectRecord[/* buffer */0],
	              count: basicRenderObjectRecord[/* count */1],
	              bufferCount: getBasicMaterialCount(settingRecord)
	            },
	            light: {
	              buffer: lightRenderObjectRecord[/* buffer */0],
	              count: lightRenderObjectRecord[/* count */1],
	              bufferCount: getLightMaterialCount(settingRecord)
	            },
	            sourceInstance: {
	              objectInstanceTransformIndexMap: sourceInstanceRecord[/* objectInstanceTransformIndexMap */1]
	            }
	          },
	          imguiData: _buildIMGUIData(state),
	          customData: getMainWorkerCustomData$1(state)
	        };
	}

	function _clearData$1(state) {
	  clearDataForWorkerInit(getRecord$4(state));
	  clearDataForWorkerInit$1(getRecord$5(state));
	  return resetPointEventStateWhenPointUp(clearNeedInitedTextureIndexArray(clearNeedAddedSourceArr(state)));
	}

	function execJob$27(flags, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var workerInstanceRecord = state[/* workerInstanceRecord */38];
	                var operateType = getOperateType(flags);
	                postMessage(_buildData(operateType, stateData), unsafeGetRenderWorker(workerInstanceRecord));
	                var state$1 = _clearData$1(state);
	                setState$2(stateData, state$1);
	                return some$1(operateType);
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function _createGetWorkerDataStream(flags, target) {
	  return filter$1((function (e) {
	                return e.data.operateType === getOperateType(flags);
	              }), fromEvent("message", target));
	}

	function createGetOtherWorkerDataStream(flags, target) {
	  return take(1, _createGetWorkerDataStream(flags, target));
	}

	function createGetOtherWorkerNoDataStream(flags, target) {
	  return map$4((function () {
	                return undefined;
	              }), take(1, _createGetWorkerDataStream(flags, target)));
	}


	/* most Not a pure module */

	/* WorkerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function execJob$33(index, globalTempRecord, transformRecord) {
	  for(var i = 0 ,i_finish = index - 1 | 0; i <= i_finish; ++i){
	    update(i, globalTempRecord, transformRecord);
	  }
	  return transformRecord;
	}


	/* UpdateTransformMainService-Wonderjs Not a pure module */

	function execJob$32(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var transformRecord = getRecord$1(state);
	                var index = transformRecord[/* index */0];
	                state[/* transformRecord */12] = execJob$33(index, state[/* globalTempRecord */36], transformRecord);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* WorkerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function getPrecisionSource(gpuDetectRecord, glslChunkRecord) {
	  var $$default = getChunk("highp_fragment", glslChunkRecord)[/* top */0];
	  var match = gpuDetectRecord[/* precision */1];
	  if (match !== undefined) {
	    switch (match) {
	      case 0 : 
	          return getChunk("highp_fragment", glslChunkRecord)[/* top */0];
	      case 1 : 
	          return getChunk("mediump_fragment", glslChunkRecord)[/* top */0];
	      case 2 : 
	          return getChunk("lowp_fragment", glslChunkRecord)[/* top */0];
	      
	    }
	  } else {
	    return $$default;
	  }
	}


	/* ShaderChunkSystem-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function bindAndUpdate$2(gl, material, state) {
	  var lightMaterialRecord = state[/* lightMaterialRecord */9];
	  var diffuseMapUnit = getDiffuseMapUnit(material, lightMaterialRecord[/* diffuseMapUnits */5]);
	  var specularMapUnit = getSpecularMapUnit(material, lightMaterialRecord[/* specularMapUnits */6]);
	  return bindAndUpdate$1(/* tuple */[
	                gl,
	                material,
	                specularMapUnit
	              ], getTextureIndex$2, bindAndUpdate$1(/* tuple */[
	                    gl,
	                    material,
	                    diffuseMapUnit
	                  ], getTextureIndex$2, /* tuple */[
	                    lightMaterialRecord[/* textureIndices */4],
	                    state[/* settingRecord */21],
	                    state
	                  ]))[2];
	}


	/* OperateTypeArrayLightMaterialService-Wonderjs Not a pure module */

	function render$11(gl, indexTuple, state) {
	  return render$3(gl, indexTuple, bindAndUpdate$2, state);
	}


	/* RenderJobUtils-Wonderjs Not a pure module */

	function render$13(gl, indexTuple, state) {
	  return render$7(gl, indexTuple, render$11, state);
	}


	/* FrontRenderLightJobCommon-Wonderjs Not a pure module */

	function _fillMatrixTypeArr$1(transform, matricesArrayForInstance, tuple) {
	  var offset = tuple[1];
	  var state = tuple[0];
	  fillMatrixTypeArr(transform, matricesArrayForInstance, tuple);
	  var normalMatrix = getNormalMatrixTypeArray$1(transform, state);
	  fillFloat32ArrayWithFloat32Array(/* tuple */[
	        matricesArrayForInstance,
	        offset + 16 | 0
	      ], /* tuple */[
	        normalMatrix,
	        0
	      ], 9);
	  return /* tuple */[
	          state,
	          (offset + 16 | 0) + 9 | 0
	        ];
	}

	function render$14(gl, indexTuple, state) {
	  return render$9(gl, /* tuple */[
	              indexTuple,
	              6400,
	              112,
	              100
	            ], /* tuple */[
	              render$11,
	              _fillMatrixTypeArr$1
	            ], state);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function render$12(gl, indexTuple, state) {
	  if (isSupportInstance$2(state)) {
	    return render$14(gl, indexTuple, state);
	  } else {
	    return render$13(gl, indexTuple, state);
	  }
	}


	/* JudgeInstanceRenderService-Wonderjs Not a pure module */

	function getShaderIndex$4(materialIndex, param) {
	  return getShaderIndex(materialIndex, param[/* lightMaterialRecord */9][/* shaderIndices */0]);
	}


	/* ShaderIndicesService-Wonderjs Not a pure module */

	function render$10(gl, param, state) {
	  var sourceInstanceIndices = param[6];
	  var geometryTypes = param[5];
	  var geometryIndices = param[4];
	  var meshRendererIndices = param[3];
	  var materialIndices = param[2];
	  var transformIndices = param[1];
	  return reduceOneParam((function (state, index) {
	                var transformIndex = getComponent$1(index, transformIndices);
	                var materialIndex = getComponent$1(index, materialIndices);
	                var shaderIndex = getShaderIndex$2(materialIndex, getShaderIndex$4, state);
	                var meshRendererIndex = getComponent$1(index, meshRendererIndices);
	                var geometryIndex = getComponent$1(index, geometryIndices);
	                var geometryType = getGeometryType(index, geometryTypes);
	                var sourceInstance = getComponent$1(index, sourceInstanceIndices);
	                if (hasSourceInstance(sourceInstance)) {
	                  return render$12(gl, /* tuple */[
	                              transformIndex,
	                              materialIndex,
	                              shaderIndex,
	                              meshRendererIndex,
	                              geometryIndex,
	                              geometryType,
	                              sourceInstance
	                            ], state);
	                } else {
	                  var state$1 = render$11(gl, /* tuple */[
	                        transformIndex,
	                        materialIndex,
	                        shaderIndex,
	                        meshRendererIndex,
	                        geometryIndex,
	                        geometryType
	                      ], state);
	                  draw$4(gl, meshRendererIndex, geometryIndex, geometryType, state$1);
	                  return state$1;
	                }
	              }), state, range$1(0, param[0] - 1 | 0));
	}


	/* ArrayService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function convertBitmapToImageData(state) {
	  var match = getBitmap(getWonderIMGUIRecord(state));
	  if (match !== undefined) {
	    return convertImageToImageData(valFromOption(match));
	  }
	  
	}

	function convertCustomTextureSourcesToImageDataArr(state) {
	  return reduceOneParam((function (imageDataArr, param) {
	                return push(/* tuple */[
	                            convertImageToImageData(param[0]),
	                            param[1],
	                            param[2]
	                          ], imageDataArr);
	              }), /* array */[], getCustomImageArr$1(getWonderIMGUIRecord(state)));
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _buildMaterialData$1(buffer, index, disposedIndexArray, isSourceInstanceMap) {
	  return {
	          buffer: buffer,
	          index: index,
	          disposedIndexArray: disposedIndexArray,
	          isSourceInstanceMap: isSourceInstanceMap
	        };
	}

	function _buildTextureData(state) {
	  requireCheck((function () {
	          var basicSourceTextureRecord = getRecord$9(state);
	          var needInitedTextureIndexArray = basicSourceTextureRecord[/* needInitedTextureIndexArray */14];
	          test(buildAssertMessage("basicSourceTextureRecord->needInitedTextureIndexArray should be empty", "is " + (String(needInitedTextureIndexArray) + "")), (function () {
	                  return Operators[/* = */0](needInitedTextureIndexArray.length, 0);
	                }));
	          var arrayBufferViewSourceTextureRecord = getRecord$11(state);
	          var needInitedTextureIndexArray$1 = arrayBufferViewSourceTextureRecord[/* needInitedTextureIndexArray */16];
	          return test(buildAssertMessage("arrayBufferViewSourceTextureRecord->needInitedTextureIndexArray should be empty", "is " + (String(needInitedTextureIndexArray$1) + "")), (function () {
	                        return Operators[/* = */0](needInitedTextureIndexArray$1.length, 0);
	                      }));
	        }), getIsDebug(stateData));
	  var sourceTextureRecord = getRecord$10(state);
	  var basicSourceTextureRecord = getRecord$9(state);
	  var arrayBufferViewSourceTextureRecord = getRecord$11(state);
	  return {
	          buffer: sourceTextureRecord[/* buffer */0],
	          basicSourceTextureData: {
	            index: basicSourceTextureRecord[/* index */0],
	            needAddedImageDataArray: convertNeedAddedSourceArrayToImageDataArr(basicSourceTextureRecord[/* needAddedSourceArray */13])
	          },
	          arrayBufferViewSourceTextureData: {
	            index: arrayBufferViewSourceTextureRecord[/* index */0],
	            sourceMap: arrayBufferViewSourceTextureRecord[/* sourceMap */11]
	          }
	        };
	}

	function _getFntData(imguiRecord) {
	  var match = getFntData$1(imguiRecord);
	  if (match !== undefined) {
	    return JSON.stringify(match);
	  }
	  
	}

	function _buildIMGUIData$1(state) {
	  var match = getCanvasSize(state);
	  var wonderImguiIMGUIRecord = getWonderIMGUIRecord(state);
	  return {
	          canvasWidth: match[0],
	          canvasHeight: match[1],
	          setting: JSON.stringify(getSetting$3(wonderImguiIMGUIRecord)),
	          fntData: _getFntData(wonderImguiIMGUIRecord),
	          bitmapImageData: convertBitmapToImageData(state),
	          customTextureSourceDataArr: convertCustomTextureSourcesToImageDataArr(state)
	        };
	}

	function _buildData$1(operateType, canvas, stateData$$1) {
	  var state = unsafeGetState$2(stateData$$1);
	  var settingRecord = state[/* settingRecord */1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var match = unsafeGetGPU(settingRecord);
	  var match$1 = unsafeGetMemory(settingRecord);
	  var buffer = unsafeGetBuffer(settingRecord);
	  var renderConfigRecord = getRecord$8(state);
	  var transformRecord = getRecord$1(state);
	  var basicMaterialRecord = getRecord$4(state);
	  var lightMaterialRecord = getRecord$5(state);
	  getRecord$3(state);
	  var customGeometryRecord = getRecord$6(state);
	  var meshRendererRecord = getRecord$2(state);
	  var sourceInstanceRecord = getRecord$7(state);
	  var match$2 = queryFullScreenData(/* () */0);
	  return {
	          operateType: operateType,
	          canvas: canvas,
	          contextConfig: unsafeGetContext(settingRecord),
	          isDebug: getIsDebug(stateData$$1),
	          viewportData: /* array */[
	            match$2[0],
	            match$2[1],
	            match$2[2],
	            match$2[3]
	          ],
	          bufferData: {
	            customGeometryPointCount: buffer[/* customGeometryPointCount */0],
	            customGeometryCount: buffer[/* customGeometryCount */1],
	            transformCount: buffer[/* transformCount */2],
	            basicMaterialCount: buffer[/* basicMaterialCount */3],
	            lightMaterialCount: buffer[/* lightMaterialCount */4],
	            meshRendererCount: buffer[/* meshRendererCount */8],
	            textureCountPerMaterial: buffer[/* textureCountPerMaterial */5],
	            basicSourceTextureCount: buffer[/* basicSourceTextureCount */6],
	            arrayBufferViewSourceTextureCount: buffer[/* arrayBufferViewSourceTextureCount */7]
	          },
	          gpuData: {
	            useHardwareInstance: match[/* useHardwareInstance */0]
	          },
	          memoryData: {
	            maxBigTypeArrayPoolSize: match$1[/* maxBigTypeArrayPoolSize */2]
	          },
	          instanceBufferData: {
	            sourceInstanceCount: getSourceInstanceCount(settingRecord),
	            objectInstanceCountPerSourceInstance: getObjectInstanceCountPerSourceInstance(settingRecord)
	          },
	          workerDetectData: {
	            isUseWorker: isUseWorker(state)
	          },
	          browserDetectData: {
	            browser: state[/* browserDetectRecord */41][/* browser */0]
	          },
	          renderConfigData: {
	            shaders: JSON.stringify(getShaders(renderConfigRecord)),
	            shaderLibs: JSON.stringify(getShaderLibs(renderConfigRecord))
	          },
	          transformData: {
	            buffer: unsafeGetCopiedBuffer(transformRecord)
	          },
	          basicMaterialData: _buildMaterialData$1(basicMaterialRecord[/* buffer */1], basicMaterialRecord[/* index */0], basicMaterialRecord[/* disposedIndexArray */10], buildMap(basicMaterialRecord[/* index */0], getRecord$4(state)[/* gameObjectMap */8], gameObjectRecord)),
	          lightMaterialData: _buildMaterialData$1(lightMaterialRecord[/* buffer */1], lightMaterialRecord[/* index */0], lightMaterialRecord[/* disposedIndexArray */15], buildMap(lightMaterialRecord[/* index */0], getRecord$5(state)[/* gameObjectMap */13], gameObjectRecord)),
	          customGeometryData: {
	            buffer: customGeometryRecord[/* buffer */1]
	          },
	          meshRendererData: {
	            buffer: meshRendererRecord[/* buffer */1]
	          },
	          directionLightData: {
	            buffer: directionLightRecord[/* buffer */1],
	            index: directionLightRecord[/* index */0]
	          },
	          pointLightData: {
	            buffer: pointLightRecord[/* buffer */1],
	            index: pointLightRecord[/* index */0]
	          },
	          sourceInstanceData: {
	            buffer: sourceInstanceRecord[/* buffer */2],
	            objectInstanceTransformIndexMap: sourceInstanceRecord[/* objectInstanceTransformIndexMap */1]
	          },
	          textureData: _buildTextureData(state),
	          imguiData: _buildIMGUIData$1(state)
	        };
	}

	function execJob$43(flags, stateData$$1) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData$$1);
	                var viewRecord = state[/* viewRecord */9];
	                var workerInstanceRecord = state[/* workerInstanceRecord */38];
	                var operateType = getOperateType(flags);
	                var offscreen = unsafeGetCanvas(viewRecord).transferControlToOffscreen();
	                postMessageWithTransferData(_buildData$1(operateType, offscreen, stateData$$1), /* array */[offscreen], unsafeGetRenderWorker(workerInstanceRecord));
	                var state$1 = clearNeedInitedTextureIndexArray(clearNeedAddedSourceArr(state));
	                setState$2(stateData$$1, state$1);
	                return some$1(operateType);
	              }));
	}


	/* Log-WonderLog Not a pure module */

	function execNoDataJob(flags, stateData) {
	  return createGetOtherWorkerNoDataStream(flags, unsafeGetRenderWorker(unsafeGetState$2(stateData)[/* workerInstanceRecord */38]));
	}

	function createGetOtherWorkerDataStream$1(flags, stateData) {
	  return createGetOtherWorkerDataStream(flags, unsafeGetRenderWorker(unsafeGetState$2(stateData)[/* workerInstanceRecord */38]));
	}


	/* GetWorkerDataUtils-Wonderjs Not a pure module */

	function _exec$1(data, state) {
	  return setControlDataFromRenderWorker(data.imguiData, setRenderWorkerCustomData(data.customData, state));
	}

	function execJob$44(flags, stateData) {
	  return map$4((function () {
	                return undefined;
	              }), tap((function (e) {
	                    var state = unsafeGetState$2(stateData);
	                    var data = e.data;
	                    var state$1 = _exec$1(data, state);
	                    setState$2(stateData, state$1);
	                    return /* () */0;
	                  }), createGetOtherWorkerDataStream$1(flags, stateData)));
	}


	/* most Not a pure module */

	/* WorkerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* JudgeInstanceService-Wonderjs Not a pure module */

	/* DeviceManagerService-Wonderjs Not a pure module */

	/* OptionService-Wonderjs Not a pure module */

	/* RecordRenderConfigRenderWorkerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* RecordPointLightRenderWorkerService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function isDisposeTooMany(disposeCount, settingRecord) {
	  return disposeCount >= getMaxDisposeCount(settingRecord);
	}


	/* MemorySettingService-Wonderjs Not a pure module */

	var isDisposed$1 = has$1;


	/* No side effect */

	function _setNewDataToState(newAliveUidArray, record, param) {
	  return /* record */[
	          /* uid */record[/* uid */0],
	          /* nameMap */param[0],
	          /* disposeCount */record[/* disposeCount */2],
	          /* disposedUidMap */createEmpty$2(/* () */0),
	          /* disposedUidArray */record[/* disposedUidArray */4],
	          /* disposedUidArrayForKeepOrder */record[/* disposedUidArrayForKeepOrder */5],
	          /* disposedBasicCameraViewArray */record[/* disposedBasicCameraViewArray */6],
	          /* disposedTransformArray */record[/* disposedTransformArray */7],
	          /* disposedTransformArrayForKeepOrder */record[/* disposedTransformArrayForKeepOrder */8],
	          /* disposedPerspectiveCameraProjectionArray */record[/* disposedPerspectiveCameraProjectionArray */9],
	          /* disposedArcballCameraControllerArray */record[/* disposedArcballCameraControllerArray */10],
	          /* disposedBasicMaterialArray */record[/* disposedBasicMaterialArray */11],
	          /* disposedLightMaterialArray */record[/* disposedLightMaterialArray */12],
	          /* disposedBoxGeometryArray */record[/* disposedBoxGeometryArray */13],
	          /* disposedCustomGeometryArray */record[/* disposedCustomGeometryArray */14],
	          /* disposedSourceInstanceArray */record[/* disposedSourceInstanceArray */15],
	          /* disposedObjectInstanceArray */record[/* disposedObjectInstanceArray */16],
	          /* disposedDirectionLightArray */record[/* disposedDirectionLightArray */17],
	          /* disposedPointLightArray */record[/* disposedPointLightArray */18],
	          /* disposedMeshRendererComponentArray */record[/* disposedMeshRendererComponentArray */19],
	          /* aliveUidArray */newAliveUidArray,
	          /* geometryDataMap */param[1],
	          /* transformMap */param[2],
	          /* basicCameraViewMap */param[4],
	          /* perspectiveCameraProjectionMap */param[5],
	          /* arcballCameraControllerMap */param[6],
	          /* meshRendererMap */param[3],
	          /* basicMaterialMap */param[7],
	          /* lightMaterialMap */param[8],
	          /* sourceInstanceMap */param[11],
	          /* objectInstanceMap */param[12],
	          /* directionLightMap */param[9],
	          /* pointLightMap */param[10]
	        ];
	}

	function _setNewMap(uid, oldMap, newMap) {
	  var match = get$3(uid, oldMap);
	  if (match !== undefined) {
	    return set$1(uid, valFromOption(match), newMap);
	  } else {
	    return newMap;
	  }
	}

	function _allocateNewMaps(newAliveUidArray, record) {
	  var nameMap = record[/* nameMap */1];
	  var geometryDataMap = record[/* geometryDataMap */21];
	  var transformMap = record[/* transformMap */22];
	  var basicCameraViewMap = record[/* basicCameraViewMap */23];
	  var perspectiveCameraProjectionMap = record[/* perspectiveCameraProjectionMap */24];
	  var arcballCameraControllerMap = record[/* arcballCameraControllerMap */25];
	  var meshRendererMap = record[/* meshRendererMap */26];
	  var basicMaterialMap = record[/* basicMaterialMap */27];
	  var lightMaterialMap = record[/* lightMaterialMap */28];
	  var sourceInstanceMap = record[/* sourceInstanceMap */29];
	  var objectInstanceMap = record[/* objectInstanceMap */30];
	  var directionLightMap = record[/* directionLightMap */31];
	  var pointLightMap = record[/* pointLightMap */32];
	  return reduceOneParam((function (param, uid) {
	                return /* tuple */[
	                        _setNewMap(uid, nameMap, param[0]),
	                        _setNewMap(uid, geometryDataMap, param[1]),
	                        set$1(uid, unsafeGet$2(uid, transformMap), param[2]),
	                        _setNewMap(uid, meshRendererMap, param[3]),
	                        _setNewMap(uid, basicCameraViewMap, param[4]),
	                        _setNewMap(uid, perspectiveCameraProjectionMap, param[5]),
	                        _setNewMap(uid, arcballCameraControllerMap, param[6]),
	                        _setNewMap(uid, basicMaterialMap, param[7]),
	                        _setNewMap(uid, lightMaterialMap, param[8]),
	                        _setNewMap(uid, directionLightMap, param[9]),
	                        _setNewMap(uid, pointLightMap, param[10]),
	                        _setNewMap(uid, sourceInstanceMap, param[11]),
	                        _setNewMap(uid, objectInstanceMap, param[12])
	                      ];
	              }), /* tuple */[
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0),
	              createEmpty$2(/* () */0)
	            ], newAliveUidArray);
	}

	function reAllocate(record) {
	  var disposedUidMap = record[/* disposedUidMap */3];
	  var aliveUidArray = record[/* aliveUidArray */20];
	  var newAliveUidArray = aliveUidArray.filter((function (aliveUid) {
	          return !isDisposed$1(aliveUid, disposedUidMap);
	        }));
	  return _setNewDataToState(newAliveUidArray, record, _allocateNewMaps(newAliveUidArray, record));
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function _updateInfos(infos, infoIndex, param, offset) {
	  var increment = param[1] - param[0] | 0;
	  return setInfo(infoIndex, offset, offset + increment | 0, infos);
	}

	function _allocateNewData(newAliveIndexArray, param) {
	  var indicesInfos = param[/* indicesInfos */9];
	  var normalsInfos = param[/* normalsInfos */8];
	  var texCoordsInfos = param[/* texCoordsInfos */7];
	  var verticesInfos = param[/* verticesInfos */6];
	  var indices = param[/* indices */5];
	  var normals = param[/* normals */4];
	  var texCoords = param[/* texCoords */3];
	  var vertices = param[/* vertices */2];
	  return reduceOneParam((function (param, index) {
	                var newIndicesOffset = param[8];
	                var newNormalsOffset = param[7];
	                var newTexCoordsOffset = param[6];
	                var newVerticesOffset = param[5];
	                var infoIndex = getInfoIndex(index);
	                var verticesInfo = getInfo(infoIndex, verticesInfos);
	                var texCoordsInfo = getInfo(infoIndex, texCoordsInfos);
	                var normalsInfo = getInfo(infoIndex, normalsInfos);
	                var indicesInfo = getInfo(infoIndex, indicesInfos);
	                return /* tuple */[
	                        param[0] + 1 | 0,
	                        _updateInfos(verticesInfos, infoIndex, verticesInfo, newVerticesOffset),
	                        _updateInfos(texCoordsInfos, infoIndex, texCoordsInfo, newTexCoordsOffset),
	                        _updateInfos(normalsInfos, infoIndex, normalsInfo, newNormalsOffset),
	                        _updateInfos(indicesInfos, infoIndex, indicesInfo, newIndicesOffset),
	                        fillFloat32ArrayWithFloat32Array(/* tuple */[
	                              vertices,
	                              newVerticesOffset
	                            ], /* tuple */[
	                              vertices,
	                              verticesInfo[0]
	                            ], verticesInfo[1]),
	                        fillFloat32ArrayWithFloat32Array(/* tuple */[
	                              texCoords,
	                              newTexCoordsOffset
	                            ], /* tuple */[
	                              texCoords,
	                              texCoordsInfo[0]
	                            ], texCoordsInfo[1]),
	                        fillFloat32ArrayWithFloat32Array(/* tuple */[
	                              normals,
	                              newNormalsOffset
	                            ], /* tuple */[
	                              normals,
	                              normalsInfo[0]
	                            ], normalsInfo[1]),
	                        fillUint16ArrayWithUint16Array(/* tuple */[
	                              indices,
	                              newIndicesOffset
	                            ], /* tuple */[
	                              indices,
	                              indicesInfo[0]
	                            ], indicesInfo[1]),
	                        vertices,
	                        texCoords,
	                        normals,
	                        indices
	                      ];
	              }), /* tuple */[
	              0,
	              verticesInfos,
	              texCoordsInfos,
	              normalsInfos,
	              indicesInfos,
	              0,
	              0,
	              0,
	              0,
	              vertices,
	              texCoords,
	              normals,
	              indices
	            ], newAliveIndexArray);
	}

	function _setNewDataToState$1(newAliveIndexArray, customGeometryRecord, param) {
	  return /* record */[
	          /* index */customGeometryRecord[/* index */0],
	          /* buffer */customGeometryRecord[/* buffer */1],
	          /* vertices */param[9],
	          /* texCoords */param[10],
	          /* normals */param[11],
	          /* indices */param[12],
	          /* verticesInfos */param[1],
	          /* texCoordsInfos */param[2],
	          /* normalsInfos */param[3],
	          /* indicesInfos */param[4],
	          /* verticesOffset */param[5],
	          /* texCoordsOffset */param[6],
	          /* normalsOffset */param[7],
	          /* indicesOffset */param[8],
	          /* disposeCount */customGeometryRecord[/* disposeCount */14],
	          /* gameObjectMap */customGeometryRecord[/* gameObjectMap */15],
	          /* groupCountMap */customGeometryRecord[/* groupCountMap */16],
	          /* disposedIndexArray */customGeometryRecord[/* disposedIndexArray */17],
	          /* disposedIndexMap */createEmpty$2(/* () */0),
	          /* aliveIndexArray */newAliveIndexArray
	        ];
	}

	function reAllocate$1(customGeometryRecord) {
	  var disposedIndexMap = customGeometryRecord[/* disposedIndexMap */18];
	  var newAliveIndexArray = customGeometryRecord[/* aliveIndexArray */19].filter((function (aliveIndex) {
	          return !isDisposed$1(aliveIndex, disposedIndexMap);
	        }));
	  return _setNewDataToState$1(newAliveIndexArray, customGeometryRecord, _allocateNewData(newAliveIndexArray, customGeometryRecord));
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _reallocateGameObjectByDisposeCount(state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  if (isDisposeTooMany(gameObjectRecord[/* disposeCount */2], state[/* settingRecord */1])) {
	    gameObjectRecord[/* disposeCount */2] = 0;
	    var newrecord = caml_array_dup(state);
	    newrecord[/* gameObjectRecord */11] = reAllocate(state[/* gameObjectRecord */11]);
	    return newrecord;
	  } else {
	    return state;
	  }
	}

	function _reallocateCustomGeometryByDisposeCount(state) {
	  var newrecord = caml_array_dup(state);
	  var customGeometryRecord = getRecord$6(state);
	  newrecord[/* customGeometryRecord */24] = isDisposeTooMany(customGeometryRecord[/* disposeCount */14], state[/* settingRecord */1]) ? (customGeometryRecord[/* disposeCount */14] = 0, reAllocate$1(customGeometryRecord)) : customGeometryRecord;
	  return newrecord;
	}

	function execJob$50(state) {
	  return _reallocateCustomGeometryByDisposeCount(_reallocateGameObjectByDisposeCount(state));
	}


	/* QueryCPUMemoryService-Wonderjs Not a pure module */

	function execJob$49(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var state$1 = execJob$50(state);
	                setState$2(stateData, state$1);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function execJob$51(_, stateData) {
	  var state = unsafeGetState$2(stateData);
	  state[/* workerInstanceRecord */38] = initWorkInstances(getSetting$1(state[/* workerJobRecord */4])[/* workerFileDir */0], state[/* workerInstanceRecord */38]);
	  setState$2(stateData, state);
	  return of(undefined);
	}


	/* most Not a pure module */

	var execJob$52 = execNoDataJob;


	/* GetWorkerDataJobUtils-Wonderjs Not a pure module */

	var execJob$53 = execNoDataJob;


	/* GetWorkerDataJobUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function create$62(param) {
	  return /* record */[
	          /* shaders */param[0],
	          /* shaderLibs */param[1]
	        ];
	}


	/* No side effect */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* most Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* OperateRenderWorkerSettingService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	var execJob$64 = execNoDataJob;


	/* GetWorkerDataJobUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* SendWorkerDataJobUtils-Wonderjs Not a pure module */

	/* SendWorkerDataJobUtils-Wonderjs Not a pure module */

	function getAllShaderIndexArray(param) {
	  return param[/* usedShaderIndexArray */0];
	}


	/* No side effect */

	function execJob$70(renderState) {
	  var gl = unsafeGetGl$1(renderState[/* deviceManagerRecord */19]);
	  return reduceOneParam((function (renderState, shaderIndex) {
	                var program = unsafeGetProgram(shaderIndex, renderState[/* programRecord */4]);
	                var renderState$1 = use(gl, program, renderState);
	                var renderState$2 = reduceOneParam((function (renderState, param) {
	                        var pos = param[/* pos */0];
	                        var match = isUniformLocationExist(pos);
	                        if (match) {
	                          param[/* sendDataFunc */2](gl, pos, param[/* getDataFunc */1](renderState));
	                        }
	                        return renderState;
	                      }), renderState$1, unsafeGetUniformSendData$4(shaderIndex, renderState$1[/* glslSenderRecord */3]));
	                var renderState$3 = reduceOneParam((function (renderState, param) {
	                        param[/* sendDataFunc */4](gl, param[/* shaderCacheMap */0], /* tuple */[
	                              param[/* name */1],
	                              param[/* pos */2]
	                            ], param[/* getDataFunc */3](renderState));
	                        return renderState;
	                      }), renderState$2, unsafeGetUniformSendData$3(shaderIndex, renderState$2[/* glslSenderRecord */3]));
	                return reduceOneParam((function (renderState, param) {
	                              param[/* sendCachableFunctionDataFunc */3](gl, /* tuple */[
	                                    param[/* program */0],
	                                    param[/* shaderCacheMap */1],
	                                    param[/* locationMap */2]
	                                  ], renderState);
	                              return renderState;
	                            }), renderState$3, unsafeGetUniformSendData$6(shaderIndex, renderState$3[/* glslSenderRecord */3]));
	              }), renderState, getAllShaderIndexArray(renderState[/* shaderRecord */20]));
	}


	/* ProgramService-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function execJob$72(glslSenderRecord) {
	  return /* record */[
	          /* attributeSendDataMap */glslSenderRecord[/* attributeSendDataMap */0],
	          /* instanceAttributeSendDataMap */glslSenderRecord[/* instanceAttributeSendDataMap */1],
	          /* uniformCacheMap */glslSenderRecord[/* uniformCacheMap */2],
	          /* uniformRenderObjectSendModelDataMap */glslSenderRecord[/* uniformRenderObjectSendModelDataMap */3],
	          /* uniformRenderObjectSendMaterialDataMap */glslSenderRecord[/* uniformRenderObjectSendMaterialDataMap */4],
	          /* uniformShaderSendNoCachableDataMap */glslSenderRecord[/* uniformShaderSendNoCachableDataMap */5],
	          /* uniformShaderSendCachableDataMap */glslSenderRecord[/* uniformShaderSendCachableDataMap */6],
	          /* uniformShaderSendCachableFunctionDataMap */glslSenderRecord[/* uniformShaderSendCachableFunctionDataMap */7],
	          /* uniformInstanceSendNoCachableDataMap */glslSenderRecord[/* uniformInstanceSendNoCachableDataMap */8],
	          /* vertexAttribHistoryArray */glslSenderRecord[/* vertexAttribHistoryArray */9],
	          /* lastSendMaterialData */undefined,
	          /* lastSendGeometryData */undefined
	        ];
	}


	/* No side effect */

	/* MostUtils-Wonderjs Not a pure module */

	function _disposeComponents(batchDisposeBasicMaterialComponentFunc, batchDisposeLightMaterialComponentFunc, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var disposedBasicCameraViewArray = gameObjectRecord[/* disposedBasicCameraViewArray */6];
	  var disposedTransformArray = gameObjectRecord[/* disposedTransformArray */7];
	  var disposedTransformArrayForKeepOrder = gameObjectRecord[/* disposedTransformArrayForKeepOrder */8];
	  var disposedPerspectiveCameraProjectionArray = gameObjectRecord[/* disposedPerspectiveCameraProjectionArray */9];
	  var disposedArcballCameraControllerArray = gameObjectRecord[/* disposedArcballCameraControllerArray */10];
	  var disposedBasicMaterialArray = gameObjectRecord[/* disposedBasicMaterialArray */11];
	  var disposedLightMaterialArray = gameObjectRecord[/* disposedLightMaterialArray */12];
	  var disposedBoxGeometryArray = gameObjectRecord[/* disposedBoxGeometryArray */13];
	  var disposedCustomGeometryArray = gameObjectRecord[/* disposedCustomGeometryArray */14];
	  var disposedSourceInstanceArray = gameObjectRecord[/* disposedSourceInstanceArray */15];
	  var disposedObjectInstanceArray = gameObjectRecord[/* disposedObjectInstanceArray */16];
	  var disposedDirectionLightArray = gameObjectRecord[/* disposedDirectionLightArray */17];
	  var disposedPointLightArray = gameObjectRecord[/* disposedPointLightArray */18];
	  var disposedMeshRendererComponentArray = gameObjectRecord[/* disposedMeshRendererComponentArray */19];
	  var state$1 = batchDisposeBasicCameraViewComponent(state, disposedBasicCameraViewArray);
	  var state$2 = batchDisposePerspectiveCameraProjectionComponent(state$1, disposedPerspectiveCameraProjectionArray);
	  var state$3 = batchDisposeArcballCameraControllerComponent(state$2, disposedArcballCameraControllerArray);
	  var state$4 = batchDisposeTransformComponent(state$3, false, disposedTransformArray);
	  var state$5 = batchDisposeTransformComponent(state$4, true, disposedTransformArrayForKeepOrder);
	  var state$6 = _2(batchDisposeBasicMaterialComponentFunc, state$5, disposedBasicMaterialArray);
	  var state$7 = _2(batchDisposeLightMaterialComponentFunc, state$6, disposedLightMaterialArray);
	  var match = batchDisposeBoxGeometryComponent(state$7, disposedBoxGeometryArray);
	  var match$1 = batchDisposeCustomGeometryComponent(match[0], disposedCustomGeometryArray);
	  var partial_arg = /* tuple */[
	    batchDisposeLightMaterialComponentFunc,
	    batchDisposeLightMaterialComponentFunc
	  ];
	  var match$2 = batchDisposeSourceInstanceComponent(match$1[0], false, (function (param, param$1, param$2) {
	          return batchDispose(partial_arg, param, param$1, param$2);
	        }), disposedSourceInstanceArray);
	  var state$8 = batchDisposeObjectInstanceComponent(match$2[0], disposedObjectInstanceArray);
	  var state$9 = batchDisposeDirectionLightComponent(state$8, disposedDirectionLightArray);
	  var state$10 = batchDisposePointLightComponent(state$9, disposedPointLightArray);
	  var state$11 = batchDisposeMeshRendererComponent(state$10, disposedMeshRendererComponentArray);
	  return /* tuple */[
	          state$11,
	          match[1],
	          match$1[1],
	          match$2[1]
	        ];
	}

	function _disposeGameObjects(batchDisposeBasicMaterialComponentFunc, batchDisposeLightMaterialComponentFunc, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var disposedUidArray = gameObjectRecord[/* disposedUidArray */4];
	  var disposedUidArrayForKeepOrder = gameObjectRecord[/* disposedUidArrayForKeepOrder */5];
	  var match = batchDispose(/* tuple */[
	        batchDisposeBasicMaterialComponentFunc,
	        batchDisposeLightMaterialComponentFunc
	      ], disposedUidArray, false, state);
	  var match$1 = batchDispose(/* tuple */[
	        batchDisposeBasicMaterialComponentFunc,
	        batchDisposeLightMaterialComponentFunc
	      ], disposedUidArrayForKeepOrder, true, match[0]);
	  var state$1 = clearDeferDisposeData(match$1[0]);
	  return /* tuple */[
	          state$1,
	          match[1].concat(match$1[1]),
	          match[2].concat(match$1[2]),
	          match[3].concat(match$1[3])
	        ];
	}

	function execJob$74(batchDisposeBasicMaterialComponentFunc, batchDisposeLightMaterialComponentFunc, state) {
	  var match = _disposeComponents(batchDisposeBasicMaterialComponentFunc, batchDisposeLightMaterialComponentFunc, state);
	  var match$1 = _disposeGameObjects(batchDisposeBasicMaterialComponentFunc, batchDisposeLightMaterialComponentFunc, match[0]);
	  return /* tuple */[
	          match$1[0],
	          match[1].concat(match$1[1]),
	          match[2].concat(match$1[2]),
	          match[3].concat(match$1[3])
	        ];
	}


	/* DisposeGameObjectMainService-Wonderjs Not a pure module */

	function _buildData$2(operateType, param) {
	  return {
	          operateType: operateType,
	          boxGeometryNeedDisposeVboBufferArr: param[0],
	          customGeometryNeedDisposeVboBufferArr: param[1],
	          sourceInstanceNeedDisposeVboBufferArr: param[2]
	        };
	}

	function _sendDisposeData(operateType, needDisposeVboBufferArrTuple, state) {
	  return postMessage(_buildData$2(operateType, needDisposeVboBufferArrTuple), unsafeGetRenderWorker(state[/* workerInstanceRecord */38]));
	}

	function execJob$73(flags, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                var operateType = getOperateType(flags);
	                var match = execJob$74(batchDisposeBasicMaterialComponentForWorker, batchDisposeLightMaterialComponentForWorker, state);
	                var state$1 = match[0];
	                _sendDisposeData(operateType, /* tuple */[
	                      match[1],
	                      match[2],
	                      match[3]
	                    ], state$1);
	                setState$2(stateData, state$1);
	                return some$1(operateType);
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* SendWorkerDataJobUtils-Wonderjs Not a pure module */

	function getBasicMaterialRenderArray(param) {
	  return getValidValues(param[/* basicMaterialRenderGameObjectMap */3]);
	}

	function getLightMaterialRenderArray(param) {
	  return getValidValues(param[/* lightMaterialRenderGameObjectMap */4]);
	}


	/* SparseMapService-Wonderjs Not a pure module */

	function setData(renderArray, unsafeGetMaterialComponentFunc, renderObjectRecord, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var count = renderArray.length;
	  var match = reduceOneParami((function (param, uid, index) {
	          var sourceInstanceIndices = param[4];
	          var materialIndex = unsafeGetMaterialComponentFunc(uid, gameObjectRecord);
	          var match = unsafeGetGeometryComponentData(uid, gameObjectRecord);
	          var match$1 = getSourceInstanceComponent(uid, gameObjectRecord);
	          return /* tuple */[
	                  setComponent(index, unsafeGetTransformComponent(uid, gameObjectRecord), param[0]),
	                  setComponent(index, materialIndex, param[1]),
	                  setComponent(index, unsafeGetMeshRendererComponent(uid, gameObjectRecord), param[2]),
	                  setComponent(index, match[0], param[3]),
	                  match$1 !== undefined ? setComponent(index, match$1, sourceInstanceIndices) : sourceInstanceIndices,
	                  setUint8_1(index, match[1], param[5])
	                ];
	        }), /* tuple */[
	        renderObjectRecord[/* transformIndices */2],
	        renderObjectRecord[/* materialIndices */3],
	        renderObjectRecord[/* meshRendererIndices */4],
	        renderObjectRecord[/* geometryIndices */5],
	        renderObjectRecord[/* sourceInstanceIndices */7],
	        renderObjectRecord[/* geometryTypes */6]
	      ], renderArray);
	  return /* record */[
	          /* buffer */renderObjectRecord[/* buffer */0],
	          /* count */count,
	          /* transformIndices */match[0],
	          /* materialIndices */match[1],
	          /* meshRendererIndices */match[2],
	          /* geometryIndices */match[3],
	          /* geometryTypes */match[5],
	          /* sourceInstanceIndices */match[4]
	        ];
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function execJob$77(state) {
	  return setData(getBasicMaterialRenderArray(getRecord$2(state)), unsafeGetBasicMaterialComponent, getRecord$14(getRecord$13(state)), state);
	}


	/* RecordRenderMainService-Wonderjs Not a pure module */

	function execJob$76(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                getRecord$13(state)[/* basicRenderObjectRecord */0] = execJob$77(state);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	function execJob$79(state) {
	  return setData(getLightMaterialRenderArray(getRecord$2(state)), unsafeGetLightMaterialComponent, getRecord$15(getRecord$13(state)), state);
	}


	/* RecordRenderMainService-Wonderjs Not a pure module */

	function execJob$78(_, stateData) {
	  return callFunc((function () {
	                var state = unsafeGetState$2(stateData);
	                getRecord$13(state)[/* lightRenderObjectRecord */1] = execJob$79(state);
	                setState$2(stateData, state);
	                return undefined;
	              }));
	}


	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	/* MostUtils-Wonderjs Not a pure module */

	function _getMainInitJobHandles() {
	  return /* :: */[
	          /* tuple */[
	            "detect_environment",
	            execJob$19
	          ],
	          /* :: */[
	            /* tuple */[
	              "init_imgui",
	              execJob$4
	            ],
	            /* :: */[
	              /* tuple */[
	                "init_event",
	                execJob$3
	              ],
	              /* :: */[
	                /* tuple */[
	                  "init_camera",
	                  execJob$7
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "create_worker_instance",
	                    execJob$51
	                  ],
	                  /* :: */[
	                    /* tuple */[
	                      "send_job_data",
	                      execJob$11
	                    ],
	                    /* :: */[
	                      /* tuple */[
	                        "create_canvas",
	                        execJob$14
	                      ],
	                      /* :: */[
	                        /* tuple */[
	                          "set_full_screen",
	                          execJob$24
	                        ],
	                        /* :: */[
	                          /* tuple */[
	                            "get_finish_send_job_data",
	                            execJob$53
	                          ],
	                          /* :: */[
	                            /* tuple */[
	                              "send_init_render_data",
	                              execJob$43
	                            ],
	                            /* :: */[
	                              /* tuple */[
	                                "get_finish_init_render_data",
	                                execJob$64
	                              ],
	                              /* [] */0
	                            ]
	                          ]
	                        ]
	                      ]
	                    ]
	                  ]
	                ]
	              ]
	            ]
	          ]
	        ];
	}

	function _getMainLoopJobHandles() {
	  return /* :: */[
	          /* tuple */[
	            "tick",
	            execJob
	          ],
	          /* :: */[
	            /* tuple */[
	              "update_transform",
	              execJob$32
	            ],
	            /* :: */[
	              /* tuple */[
	                "update_camera",
	                execJob$16
	              ],
	              /* :: */[
	                /* tuple */[
	                  "get_camera_data",
	                  execJob$20
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "dispose_and_send_dispose_data",
	                    execJob$73
	                  ],
	                  /* :: */[
	                    /* tuple */[
	                      "reallocate_cpu_memory",
	                      execJob$49
	                    ],
	                    /* :: */[
	                      /* tuple */[
	                        "create_basic_render_object_buffer",
	                        execJob$76
	                      ],
	                      /* :: */[
	                        /* tuple */[
	                          "create_light_render_object_buffer",
	                          execJob$78
	                        ],
	                        /* :: */[
	                          /* tuple */[
	                            "send_render_data",
	                            execJob$27
	                          ],
	                          /* :: */[
	                            /* tuple */[
	                              "copy_transform",
	                              execJob$18
	                            ],
	                            /* :: */[
	                              /* tuple */[
	                                "get_finish_render_data",
	                                execJob$44
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "get_finish_dispose_data",
	                                  execJob$52
	                                ],
	                                /* [] */0
	                              ]
	                            ]
	                          ]
	                        ]
	                      ]
	                    ]
	                  ]
	                ]
	              ]
	            ]
	          ]
	        ];
	}

	function createMainInitJobHandleMap() {
	  return createJobHandleMap(_getMainInitJobHandles(/* () */0));
	}

	function createMainLoopJobHandleMap() {
	  return createJobHandleMap(_getMainLoopJobHandles(/* () */0));
	}

	function _getJobHandle(name, jobHandleMap) {
	  var match = get(name, jobHandleMap);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    return handleGetNoneJob(name, jobHandleMap);
	  }
	}

	var getMainInitJobHandle = _getJobHandle;

	var getMainLoopJobHandle = _getJobHandle;


	/* JobService-Wonderjs Not a pure module */

	function _workerInit(stateData$$1, state) {
	  return getMainInitJobStream(stateData$$1, /* tuple */[
	              createMainInitJobHandleMap,
	              getMainInitJobHandle
	            ], state);
	}

	var _noWorkerInit = execNoWorkerInitJobs;

	function _computeElapseTime(time, state) {
	  state[/* timeControllerRecord */34] = computeElapseTime(time, state[/* timeControllerRecord */34]);
	  return state;
	}

	function _createWorkerLoopStream() {
	  return continueWith((function () {
	                return _createWorkerLoopStream(/* () */0);
	              }), flatMap((function (time) {
	                    var state = _computeElapseTime(time, unsafeGetState$2(stateData));
	                    return map$4((function () {
	                                  return /* () */0;
	                                }), getMainLoopJobStream(stateData, /* tuple */[
	                                    createMainLoopJobHandleMap,
	                                    getMainLoopJobHandle
	                                  ], state));
	                  }), nextAnimationFrame()));
	}

	function loopBody$1(time, state) {
	  return execNoWorkerLoopJobs(_computeElapseTime(time, state));
	}

	function _noWorkerLoop(_, state) {
	  setState$2(stateData, state);
	  return requestAnimationFrame((function (time) {
	                var state = unsafeGetState$2(stateData);
	                _noWorkerLoop(time, setState$2(stateData, execNoWorkerLoopJobs(_computeElapseTime(time, state))));
	                return /* () */0;
	              }));
	}

	function startDirector$1(state) {
	  var match = isUseWorker(state);
	  if (match) {
	    drain(_workerInit(stateData, setState$2(stateData, state)).concat(_createWorkerLoopStream(/* () */0)));
	    return /* () */0;
	  } else {
	    _noWorkerLoop(0, execNoWorkerInitJobs(state));
	    return /* () */0;
	  }
	}

	var initDirector$1 = _noWorkerInit;


	/* most Not a pure module */

	function replaceMaterial$2(param, gameObject, param$1, state) {
	  var state$1 = _3(param$1[0], gameObject, param[0], state);
	  var state$2 = _3(param$1[1], gameObject, param[1], state$1);
	  var match = getMeshRendererComponent(gameObject, state$2[/* gameObjectRecord */11]);
	  var state$3;
	  if (match !== undefined) {
	    var state$4 = deferDisposeMeshRendererComponent(gameObject, match, state$2);
	    var match$1 = create$29(state$4);
	    state$3 = addMeshRendererComponent(gameObject, match$1[1], match$1[0]);
	  } else {
	    state$3 = state$2;
	  }
	  return initGameObject$1(gameObject, state$3);
	}


	/* GameObjectAPI-Wonderjs Not a pure module */

	function replaceMaterial$1(param, gameObject, param$1, state) {
	  return replaceMaterial$2(/* tuple */[
	              param[0],
	              param[1]
	            ], gameObject, /* tuple */[
	              param$1[0],
	              param$1[1]
	            ], state);
	}


	/* ReplaceMaterialMainService-Wonderjs Not a pure module */

	function getGenerator() {
	  return "GLTF2WD";
	}


	/* No side effect */

	function create$63(arrayBuffer) {
	  return new DataView(arrayBuffer);
	}

	function getUint32_1$1(offset, dataView) {
	  return /* tuple */[
	          dataView.getUint32(offset, 1),
	          offset + 4 | 0
	        ];
	}

	function writeUint8_1(value, offset, dataView) {
	  dataView.setUint8(offset, value);
	  return offset + 1 | 0;
	}

	function writeUint32_1(value, offset, dataView) {
	  dataView.setUint32(offset, value, 1);
	  return offset + 4 | 0;
	}


	/* No side effect */

	function alignedLength(value) {
	  if (value !== 0) {
	    var multiple = value % 4;
	    if (multiple !== 0) {
	      return value + (4 - multiple | 0) | 0;
	    } else {
	      return value;
	    }
	  } else {
	    return value;
	  }
	}

	function decode(binary, checkFunc) {
	  var dataView = create$63(binary);
	  var dataView$1 = _1(checkFunc, dataView);
	  var match = getUint32_1$1(12, dataView$1);
	  var jsonBufSize = match[0];
	  var decoder = new TextDecoder("utf-8");
	  return /* tuple */[
	          decoder.decode(new Uint8Array(binary, 20, jsonBufSize)).trim(),
	          binary.slice(jsonBufSize + 28 | 0)
	        ];
	}

	var convertBase64ToBinary = function (dataURI){
	    var BASE64_MARKER = ';base64,';

	    var base64Index = dataURI.indexOf(BASE64_MARKER) + BASE64_MARKER.length;
	    var base64 = dataURI.substring(base64Index);
	    var raw = window.atob(base64);
	    var rawLength = raw.length;
	    var array = new Uint8Array(new ArrayBuffer(rawLength));

	    for(var i = 0; i < rawLength; i++) {
	      array[i] = raw.charCodeAt(i);
	    }
	    return array;
	    };

	function _fatalBase64MimeType(base64Str) {
	  return fatal(buildFatalMessage("getBase64MimeType", "should has mimeType data", "", "", "base64Str: " + (String(base64Str) + "")));
	}

	function getBase64MimeType(base64Str) {
	  var match = (/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/g).exec(base64Str);
	  if (match !== null) {
	    var match$1 = caml_array_get(match, 1);
	    if (match$1 == null) {
	      return _fatalBase64MimeType(base64Str);
	    } else {
	      return match$1;
	    }
	  } else {
	    return _fatalBase64MimeType(base64Str);
	  }
	}


	/* Log-WonderLog Not a pure module */

	function getCount$1(arrs) {
	  return arrs.length;
	}

	function getPrimitiveData(primitives) {
	  return ensureCheck((function (param) {
	                var indices = param[/* indices */1];
	                var attributes = param[/* attributes */0];
	                test(buildAssertMessage("only has TEXCOORD_0", "not"), (function () {
	                        return assertTrue(isNone(attributes[/* texCoord_1 */3]));
	                      }));
	                return test(buildAssertMessage("indices exist", "not"), (function () {
	                              return assertTrue(isSome(indices));
	                            }));
	              }), getIsDebug(stateData), caml_array_get(primitives, 0));
	}

	function buildDefaultName(type_, index) {
	  return "" + (String(type_) + ("_" + (String(index) + "")));
	}

	function getScene(scenes, scene) {
	  return scenes[scene];
	}


	/* Log-WonderLog Not a pure module */

	function convertToImages(gltf) {
	  var images = gltf[/* images */3];
	  if (images !== undefined) {
	    return reduceOneParam((function (arr, param) {
	                  return push(/* record */[
	                              /* bufferView */unsafeGet$1(param[/* bufferView */2]),
	                              /* mimeType */unsafeGet$1(param[/* mimeType */3])
	                            ], arr);
	                }), /* array */[], images);
	  }
	  
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _getColor(color) {
	  if (color !== undefined) {
	    return color;
	  } else {
	    return /* array */[
	            0,
	            0,
	            0
	          ];
	  }
	}

	function _getIntensity(intensity) {
	  if (intensity !== undefined) {
	    return intensity;
	  } else {
	    return 1;
	  }
	}

	function _convertPointLights(param, param$1) {
	  var range$$1 = param$1[/* range */6];
	  var quadraticAttenuation = param$1[/* quadraticAttenuation */5];
	  var linearAttenuation = param$1[/* linearAttenuation */4];
	  var constantAttenuation = param$1[/* constantAttenuation */3];
	  return /* tuple */[
	          param[0],
	          param[1],
	          push(/* record */[
	                /* color */_getColor(param$1[/* color */1]),
	                /* intensity */_getIntensity(param$1[/* intensity */2]),
	                /* constantAttenuation */constantAttenuation !== undefined ? constantAttenuation : 1,
	                /* linearAttenuation */linearAttenuation !== undefined ? linearAttenuation : 0,
	                /* quadraticAttenuation */quadraticAttenuation !== undefined ? quadraticAttenuation : 0,
	                /* range */range$$1 !== undefined ? range$$1 : getDefaultRange(/* () */0)
	              ], param[2])
	        ];
	}

	function convertToLights(param) {
	  var extensions = param[/* extensions */14];
	  if (extensions !== undefined) {
	    var khr_lights = extensions[/* khr_lights */0];
	    if (khr_lights !== undefined) {
	      return reduceOneParam((function (param, lightData) {
	                    var color = lightData[/* color */1];
	                    var pointLightArr = param[2];
	                    var directionLightArr = param[1];
	                    var ambientLightArr = param[0];
	                    switch (lightData[/* type_ */0]) {
	                      case "ambient" : 
	                          return /* tuple */[
	                                  push(/* record */[/* color */_getColor(color)], ambientLightArr),
	                                  directionLightArr,
	                                  pointLightArr
	                                ];
	                      case "directional" : 
	                          return /* tuple */[
	                                  ambientLightArr,
	                                  push(/* record */[
	                                        /* color */_getColor(color),
	                                        /* intensity */_getIntensity(lightData[/* intensity */2])
	                                      ], directionLightArr),
	                                  pointLightArr
	                                ];
	                      case "point" : 
	                          return _convertPointLights(/* tuple */[
	                                      ambientLightArr,
	                                      directionLightArr,
	                                      pointLightArr
	                                    ], lightData);
	                      default:
	                        return /* tuple */[
	                                ambientLightArr,
	                                directionLightArr,
	                                pointLightArr
	                              ];
	                    }
	                  }), /* tuple */[
	                  /* array */[],
	                  /* array */[],
	                  /* array */[]
	                ], khr_lights[/* lights */0]);
	    } else {
	      return /* tuple */[
	              /* array */[],
	              /* array */[],
	              /* array */[]
	            ];
	    }
	  } else {
	    return /* tuple */[
	            /* array */[],
	            /* array */[],
	            /* array */[]
	          ];
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function convertToBuffers(param) {
	  return reduceOneParam((function (arr, param) {
	                return push(param[/* byteLength */1], arr);
	              }), /* array */[], param[/* buffers */6]);
	}

	function _convertComponentType(componentType) {
	  var exit = 0;
	  var switcher = componentType - 5120 | 0;
	  if (switcher > 6 || switcher < 0) {
	    exit = 1;
	  } else {
	    switch (switcher) {
	      case 0 : 
	          return /* BYTE */0;
	      case 1 : 
	          return /* UNSIGNED_BYTE */1;
	      case 2 : 
	          return /* SHORT */2;
	      case 3 : 
	          return /* UNSIGNED_SHORT */3;
	      case 4 : 
	          exit = 1;
	          break;
	      case 5 : 
	          return /* UNSIGNED_INT */4;
	      case 6 : 
	          return /* FLOAT */5;
	      
	    }
	  }
	  if (exit === 1) {
	    return fatal(buildFatalMessage("_convertToAccessors", "unknown componentType: " + (String(componentType) + ""), "", "", ""));
	  }
	  
	}

	function _convertType(type_) {
	  switch (type_) {
	    case "MAT2" : 
	        return /* MAT2 */4;
	    case "MAT3" : 
	        return /* MAT3 */5;
	    case "MAT4" : 
	        return /* MAT4 */6;
	    case "SCALAR" : 
	        return /* SCALAR */0;
	    case "VEC2" : 
	        return /* VEC2 */1;
	    case "VEC3" : 
	        return /* VEC3 */2;
	    case "VEC4" : 
	        return /* VEC4 */3;
	    default:
	      return fatal(buildFatalMessage("_convertToAccessors", "unknown type_:" + (String(type_) + ""), "", "", ""));
	  }
	}

	function convertToAccessors(param) {
	  return reduceOneParam((function (arr, param) {
	                var byteOffset = param[/* byteOffset */1];
	                var bufferView = param[/* bufferView */0];
	                return push(/* record */[
	                            /* bufferView */bufferView !== undefined ? bufferView : fatal(buildFatalMessage("_convertToAccessors", "bufferView should exist", "", "", "")),
	                            /* byteOffset */byteOffset !== undefined ? byteOffset : 0,
	                            /* count */param[/* count */2],
	                            /* componentType */_convertComponentType(param[/* componentType */3]),
	                            /* type_ */_convertType(param[/* type_ */4])
	                          ], arr);
	              }), /* array */[], param[/* accessors */8]);
	}

	function convertToBufferViews(param) {
	  return reduceOneParam((function (arr, param) {
	                var byteOffset = param[/* byteOffset */1];
	                return push(/* record */[
	                            /* buffer */param[/* buffer */0],
	                            /* byteOffset */byteOffset !== undefined ? byteOffset : 0,
	                            /* byteLength */param[/* byteLength */2],
	                            /* byteStride */param[/* byteStride */3]
	                          ], arr);
	              }), /* array */[], param[/* bufferViews */7]);
	}


	/* Log-WonderLog Not a pure module */

	function convertToBasicCameraViews(param) {
	  var cameras = param[/* cameras */9];
	  return /* record */[/* count */cameras !== undefined ? cameras.length : 0];
	}

	function _convertRadiansToDegree(angle) {
	  return angle * 180 / Math.PI;
	}

	function convertToPerspectiveCameraProjections(param) {
	  var cameras = param[/* cameras */9];
	  if (cameras !== undefined) {
	    return reduceOneParam((function (arr, param) {
	                  if (param[/* type_ */0] === "perspective") {
	                    var match = unsafeGet$1(param[/* perspective */1]);
	                    return push(/* record */[
	                                /* near */match[/* znear */3],
	                                /* far */match[/* zfar */2],
	                                /* fovy */_convertRadiansToDegree(match[/* yfov */1]),
	                                /* aspect */match[/* aspectRatio */0]
	                              ], arr);
	                  } else {
	                    return arr;
	                  }
	                }), /* array */[], cameras);
	  } else {
	    return /* array */[];
	  }
	}

	function convertToArcballCameraControllers(param) {
	  var extras = param[/* extras */15];
	  if (extras !== undefined) {
	    var arcballCameraControllers = extras[/* arcballCameraControllers */0];
	    if (arcballCameraControllers !== undefined) {
	      return reduceOneParam((function (arr, data) {
	                    return push(data, arr);
	                  }), /* array */[], arcballCameraControllers);
	    } else {
	      return /* array */[];
	    }
	  } else {
	    return /* array */[];
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _convertToImageTextureIndices(source, index, param) {
	  var imageIndices = param[1];
	  var imageTextureIndices = param[0];
	  if (source !== undefined) {
	    return /* tuple */[
	            push(index, imageTextureIndices),
	            push(valFromOption(source), imageIndices)
	          ];
	  } else {
	    return /* tuple */[
	            imageTextureIndices,
	            imageIndices
	          ];
	  }
	}

	function _convertToSamplerTextureIndices(sampler, index, param) {
	  var samplerIndices = param[1];
	  var samplerTextureIndices = param[0];
	  if (sampler !== undefined) {
	    return /* tuple */[
	            push(index, samplerTextureIndices),
	            push(valFromOption(sampler), samplerIndices)
	          ];
	  } else {
	    return /* tuple */[
	            samplerTextureIndices,
	            samplerIndices
	          ];
	  }
	}

	function convertToImageAndSamplerTextureIndices(param) {
	  var textures = param[/* textures */4];
	  if (textures !== undefined) {
	    return ensureCheck((function (param) {
	                  var match = param[1];
	                  var samplerIndices = match[1];
	                  var samplerTextureIndices = match[0];
	                  var match$1 = param[0];
	                  var imageIndices = match$1[1];
	                  var imageTextureIndices = match$1[0];
	                  test(buildAssertMessage("imageTextureIndices\' count == imageIndices\' count", "not"), (function () {
	                          return Operators[/* = */0](imageTextureIndices.length, imageIndices.length);
	                        }));
	                  return test(buildAssertMessage("samplerTextureIndices\' count == samplerIndices\' count", "not"), (function () {
	                                return Operators[/* = */0](samplerTextureIndices.length, samplerIndices.length);
	                              }));
	                }), getIsDebug(stateData), reduceOneParami((function (param, param$1, index) {
	                      var match = param[1];
	                      var match$1 = param[0];
	                      return /* tuple */[
	                              _convertToImageTextureIndices(param$1[/* source */1], index, /* tuple */[
	                                    match$1[0],
	                                    match$1[1]
	                                  ]),
	                              _convertToSamplerTextureIndices(param$1[/* sampler */0], index, /* tuple */[
	                                    match[0],
	                                    match[1]
	                                  ])
	                            ];
	                    }), /* tuple */[
	                    /* tuple */[
	                      /* array */[],
	                      /* array */[]
	                    ],
	                    /* tuple */[
	                      /* array */[],
	                      /* array */[]
	                    ]
	                  ], textures));
	  } else {
	    return /* tuple */[
	            /* tuple */[
	              /* array */[],
	              /* array */[]
	            ],
	            /* tuple */[
	              /* array */[],
	              /* array */[]
	            ]
	          ];
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _setMapMaterialIndices(materialMap, materialIndex, param) {
	  var diffuseMapIndices = param[1];
	  var materialIndices = param[0];
	  if (materialMap !== undefined) {
	    return /* tuple */[
	            push(materialIndex, materialIndices),
	            push(materialMap[/* index */0], diffuseMapIndices)
	          ];
	  } else {
	    return /* tuple */[
	            materialIndices,
	            diffuseMapIndices
	          ];
	  }
	}

	function convertToMaterialIndices(param) {
	  var materials = param[/* materials */12];
	  if (materials !== undefined) {
	    var match = reduceOneParami((function (param, param$1, index) {
	            var pbrMetallicRoughness = param$1[/* pbrMetallicRoughness */0];
	            var diffuseMapIndices = param[1];
	            var materialIndices = param[0];
	            if (pbrMetallicRoughness !== undefined) {
	              return _setMapMaterialIndices(pbrMetallicRoughness[/* baseColorTexture */1], index, /* tuple */[
	                          materialIndices,
	                          diffuseMapIndices
	                        ]);
	            } else {
	              return /* tuple */[
	                      materialIndices,
	                      diffuseMapIndices
	                    ];
	            }
	          }), /* tuple */[
	          /* array */[],
	          /* array */[]
	        ], materials);
	    return ensureCheck((function (param) {
	                  var match = param[/* diffuseMapMaterialIndices */0];
	                  var mapIndices = match[/* mapIndices */1];
	                  var materialIndices = match[/* materialIndices */0];
	                  return test(buildAssertMessage("materialIndices\' count === mapIndices\' count", "not"), (function () {
	                                return Operators[/* = */0](materialIndices.length, mapIndices.length);
	                              }));
	                }), getIsDebug(stateData), /* record */[/* diffuseMapMaterialIndices : record */[
	                  /* materialIndices */match[0],
	                  /* mapIndices */match[1]
	                ]]);
	  } else {
	    return /* record */[/* diffuseMapMaterialIndices : record */[
	              /* materialIndices : array */[],
	              /* mapIndices : array */[]
	            ]];
	  }
	}


	/* Log-WonderLog Not a pure module */

	function convertToChildrenTransformIndexData(transformGameObjectIndexData, nodes) {
	  requireCheck((function () {
	          return test(buildAssertMessage("every node should has one transform component", "not"), (function () {
	                        return Operators[/* = */0](transformGameObjectIndexData[/* gameObjectIndices */0].length, nodes.length);
	                      }));
	        }), getIsDebug(stateData));
	  var match = reduceOneParami((function (param, param$1, index) {
	          var children = param$1[/* children */3];
	          var childrenTransformIndices = param[1];
	          var parentTransformIndices = param[0];
	          if (children !== undefined) {
	            return /* tuple */[
	                    push(index, parentTransformIndices),
	                    push(children, childrenTransformIndices)
	                  ];
	          } else {
	            return /* tuple */[
	                    parentTransformIndices,
	                    childrenTransformIndices
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return ensureCheck((function (param) {
	                var childrenTransformIndices = param[/* childrenTransformIndices */1];
	                var parentTransformIndices = param[/* parentTransformIndices */0];
	                return test(buildAssertMessage("parentTransformIndices\' count === childrenTransformIndices\' count", "not"), (function () {
	                              return Operators[/* = */0](parentTransformIndices.length, childrenTransformIndices.length);
	                            }));
	              }), getIsDebug(stateData), /* record */[
	              /* parentTransformIndices */match[0],
	              /* childrenTransformIndices */match[1]
	            ]);
	}


	/* Log-WonderLog Not a pure module */

	function _checkGameObjectAndComponentIndicesCountShouldEqual(componentGameObjectIndexData) {
	  var componentIndices = componentGameObjectIndexData[/* componentIndices */1];
	  var gameObjectIndices = componentGameObjectIndexData[/* gameObjectIndices */0];
	  requireCheck((function () {
	          return test(buildAssertMessage("gameObjectIndices\' count === componentIndices\' count", "not"), (function () {
	                        return Operators[/* = */0](gameObjectIndices.length, componentIndices.length);
	                      }));
	        }), getIsDebug(stateData));
	  return componentGameObjectIndexData;
	}

	function convertToTransformGameObjectIndexData(nodes) {
	  var match = reduceOneParami((function (param, _, index) {
	          return /* tuple */[
	                  push(index, param[0]),
	                  push(index, param[1])
	                ];
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return ensureCheck((function (param) {
	                var gameObjectIndices = param[/* gameObjectIndices */0];
	                return test(buildAssertMessage("every node should has one transform component", "not"), (function () {
	                              return Operators[/* = */0](gameObjectIndices.length, nodes.length);
	                            }));
	              }), getIsDebug(stateData), _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	                  /* gameObjectIndices */match[0],
	                  /* componentIndices */match[1]
	                ]));
	}

	function convertToBasicCameraViewGameObjectIndexData(nodes) {
	  var match = reduceOneParami((function (param, param$1, index) {
	          var camera = param$1[/* camera */1];
	          var componentIndices = param[1];
	          var gameObjectIndices = param[0];
	          if (camera !== undefined) {
	            return /* tuple */[
	                    push(index, gameObjectIndices),
	                    push(camera, componentIndices)
	                  ];
	          } else {
	            return /* tuple */[
	                    gameObjectIndices,
	                    componentIndices
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	              /* gameObjectIndices */match[0],
	              /* componentIndices */match[1]
	            ]);
	}

	function _buildPerspectiveCameraActualIndexMap(cameras) {
	  return reduceOneParami((function (param, param$1, perspectiveCameraIndex) {
	                var perspectiveCameraActualIndex = param[1];
	                var perspectiveCameraActualIndexMap = param[0];
	                if (param$1[/* type_ */0] === "perspective") {
	                  return /* tuple */[
	                          set$1(perspectiveCameraIndex, perspectiveCameraActualIndex, perspectiveCameraActualIndexMap),
	                          perspectiveCameraActualIndex + 1 | 0
	                        ];
	                } else {
	                  return /* tuple */[
	                          perspectiveCameraActualIndexMap,
	                          perspectiveCameraActualIndex
	                        ];
	                }
	              }), /* tuple */[
	              createEmpty$2(/* () */0),
	              0
	            ], cameras);
	}

	function _buildPerspectiveCameraProjectionGameObjectIndexData(nodes, cameras, perspectiveCameraActualIndexMap) {
	  return reduceOneParami((function (param, param$1, index) {
	                var camera = param$1[/* camera */1];
	                var componentIndices = param[1];
	                var gameObjectIndices = param[0];
	                if (camera !== undefined) {
	                  var camera$1 = camera;
	                  var match = cameras[camera$1];
	                  if (match[/* type_ */0] === "perspective") {
	                    return /* tuple */[
	                            push(index, gameObjectIndices),
	                            push(unsafeGet$2(camera$1, perspectiveCameraActualIndexMap), componentIndices)
	                          ];
	                  } else {
	                    return /* tuple */[
	                            gameObjectIndices,
	                            componentIndices
	                          ];
	                  }
	                } else {
	                  return /* tuple */[
	                          gameObjectIndices,
	                          componentIndices
	                        ];
	                }
	              }), /* tuple */[
	              /* array */[],
	              /* array */[]
	            ], nodes);
	}

	function convertToPerspectiveCameraProjectionGameObjectIndexData(nodes, cameras) {
	  if (cameras !== undefined) {
	    var cameras$1 = cameras;
	    var match = _buildPerspectiveCameraActualIndexMap(cameras$1);
	    var match$1 = _buildPerspectiveCameraProjectionGameObjectIndexData(nodes, cameras$1, match[0]);
	    return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	                /* gameObjectIndices */match$1[0],
	                /* componentIndices */match$1[1]
	              ]);
	  } else {
	    return /* record */[
	            /* gameObjectIndices : array */[],
	            /* componentIndices : array */[]
	          ];
	  }
	}

	function convertToArcballCameraControllerGameObjectIndexData(nodes) {
	  var match = reduceOneParami((function (param, param$1, index) {
	          var extras = param$1[/* extras */8];
	          var componentIndices = param[1];
	          var gameObjectIndices = param[0];
	          if (extras !== undefined) {
	            var cameraController = extras[/* cameraController */3];
	            if (cameraController !== undefined) {
	              return /* tuple */[
	                      push(index, gameObjectIndices),
	                      push(cameraController, componentIndices)
	                    ];
	            } else {
	              return /* tuple */[
	                      gameObjectIndices,
	                      componentIndices
	                    ];
	            }
	          } else {
	            return /* tuple */[
	                    gameObjectIndices,
	                    componentIndices
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	              /* gameObjectIndices */match[0],
	              /* componentIndices */match[1]
	            ]);
	}

	function _convertToGameObjectIndexDataFromExtras(component, param, index) {
	  return /* tuple */[
	          push(index, param[0]),
	          push(component, param[1])
	        ];
	}

	function convertToBasicMaterialGameObjectIndexData(nodes, _, _$1) {
	  var match = reduceOneParami((function (param, param$1, index) {
	          var extras = param$1[/* extras */8];
	          var componentIndices = param[1];
	          var gameObjectIndices = param[0];
	          if (extras !== undefined) {
	            var basicMaterial = extras[/* basicMaterial */1];
	            if (isSome(basicMaterial)) {
	              return _convertToGameObjectIndexDataFromExtras(unsafeGet$1(basicMaterial), /* tuple */[
	                          gameObjectIndices,
	                          componentIndices
	                        ], index);
	            } else {
	              return /* tuple */[
	                      gameObjectIndices,
	                      componentIndices
	                    ];
	            }
	          } else {
	            return /* tuple */[
	                    gameObjectIndices,
	                    componentIndices
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	              /* gameObjectIndices */match[0],
	              /* componentIndices */match[1]
	            ]);
	}

	function _convertToLightMaterialGameObjectIndexDataFromMesh(mesh, meshes, param, index) {
	  var componentIndices = param[1];
	  var gameObjectIndices = param[0];
	  if (mesh !== undefined) {
	    var match = meshes[mesh];
	    var match$1 = getPrimitiveData(match[/* primitives */0]);
	    var material = match$1[/* material */2];
	    if (material !== undefined) {
	      return /* tuple */[
	              push(index, gameObjectIndices),
	              push(material, componentIndices)
	            ];
	    } else {
	      return /* tuple */[
	              gameObjectIndices,
	              componentIndices
	            ];
	    }
	  } else {
	    return /* tuple */[
	            gameObjectIndices,
	            componentIndices
	          ];
	  }
	}

	function convertToLightMaterialGameObjectIndexData(nodes, meshes, _) {
	  var match = reduceOneParami((function (param, param$1, index) {
	          var extras = param$1[/* extras */8];
	          var componentIndices = param[1];
	          var gameObjectIndices = param[0];
	          var exit = 0;
	          if (extras !== undefined) {
	            var lightMaterial = extras[/* lightMaterial */2];
	            if (isSome(lightMaterial)) {
	              return _convertToGameObjectIndexDataFromExtras(unsafeGet$1(lightMaterial), /* tuple */[
	                          gameObjectIndices,
	                          componentIndices
	                        ], index);
	            } else {
	              exit = 1;
	            }
	          } else {
	            exit = 1;
	          }
	          if (exit === 1) {
	            return _convertToLightMaterialGameObjectIndexDataFromMesh(param$1[/* mesh */2], meshes, /* tuple */[
	                        gameObjectIndices,
	                        componentIndices
	                      ], index);
	          }
	          
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	              /* gameObjectIndices */match[0],
	              /* componentIndices */match[1]
	            ]);
	}

	function convertToGeometryGameObjectIndexData(nodes) {
	  var match = reduceOneParami((function (param, param$1, index) {
	          var mesh = param$1[/* mesh */2];
	          var componentIndices = param[1];
	          var gameObjectIndices = param[0];
	          if (mesh !== undefined) {
	            return /* tuple */[
	                    push(index, gameObjectIndices),
	                    push(mesh, componentIndices)
	                  ];
	          } else {
	            return /* tuple */[
	                    gameObjectIndices,
	                    componentIndices
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	              /* gameObjectIndices */match[0],
	              /* componentIndices */match[1]
	            ]);
	}

	function convertToMeshRendererGameObjectIndexData(nodes) {
	  var match = reduceOneParami((function (param, param$1, index) {
	          var extras = param$1[/* extras */8];
	          var componentIndices = param[1];
	          var gameObjectIndices = param[0];
	          var exit = 0;
	          if (extras !== undefined) {
	            var meshRenderer = extras[/* meshRenderer */0];
	            if (isSome(meshRenderer)) {
	              return _convertToGameObjectIndexDataFromExtras(unsafeGet$1(meshRenderer), /* tuple */[
	                          gameObjectIndices,
	                          componentIndices
	                        ], index);
	            } else {
	              exit = 1;
	            }
	          } else {
	            exit = 1;
	          }
	          if (exit === 1) {
	            if (param$1[/* mesh */2] !== undefined) {
	              return /* tuple */[
	                      push(index, gameObjectIndices),
	                      push(gameObjectIndices.length - 1 | 0, componentIndices)
	                    ];
	            } else {
	              return /* tuple */[
	                      gameObjectIndices,
	                      componentIndices
	                    ];
	            }
	          }
	          
	        }), /* tuple */[
	        /* array */[],
	        /* array */[]
	      ], nodes);
	  return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	              /* gameObjectIndices */match[0],
	              /* componentIndices */match[1]
	            ]);
	}

	function _getLightActualIndexMap(lightType, lights) {
	  return reduceOneParami((function (param, param$1, lightIndex) {
	                var lightActualIndex = param[1];
	                var lightActualIndexMap = param[0];
	                if (param$1[/* type_ */0] === lightType) {
	                  return /* tuple */[
	                          set$1(lightIndex, lightActualIndex, lightActualIndexMap),
	                          lightActualIndex + 1 | 0
	                        ];
	                } else {
	                  return /* tuple */[
	                          lightActualIndexMap,
	                          lightActualIndex
	                        ];
	                }
	              }), /* tuple */[
	              createEmpty$2(/* () */0),
	              0
	            ], lights);
	}

	function _buildLightGameObjectIndexData(nodes, lights, lightType, lightActualIndexMap) {
	  return reduceOneParami((function (param, param$1, index) {
	                var extensions = param$1[/* extensions */9];
	                var componentIndices = param[1];
	                var gameObjectIndices = param[0];
	                if (extensions !== undefined) {
	                  var khr_lights = extensions[/* khr_lights */0];
	                  if (khr_lights !== undefined) {
	                    var light = khr_lights[/* light */0];
	                    var match = lights[light];
	                    if (match[/* type_ */0] === lightType) {
	                      return /* tuple */[
	                              push(index, gameObjectIndices),
	                              push(unsafeGet$2(light, lightActualIndexMap), componentIndices)
	                            ];
	                    } else {
	                      return /* tuple */[
	                              gameObjectIndices,
	                              componentIndices
	                            ];
	                    }
	                  } else {
	                    return /* tuple */[
	                            gameObjectIndices,
	                            componentIndices
	                          ];
	                  }
	                } else {
	                  return /* tuple */[
	                          gameObjectIndices,
	                          componentIndices
	                        ];
	                }
	              }), /* tuple */[
	              /* array */[],
	              /* array */[]
	            ], nodes);
	}

	function convertToLightGameObjectIndexData(lightType, nodes, extensions) {
	  if (extensions !== undefined) {
	    var khr_lights = extensions[/* khr_lights */0];
	    if (khr_lights !== undefined) {
	      var lights = khr_lights[/* lights */0];
	      var match = _getLightActualIndexMap(lightType, lights);
	      var match$1 = _buildLightGameObjectIndexData(nodes, lights, lightType, match[0]);
	      return _checkGameObjectAndComponentIndicesCountShouldEqual(/* record */[
	                  /* gameObjectIndices */match$1[0],
	                  /* componentIndices */match$1[1]
	                ]);
	    } else {
	      return /* record */[
	              /* gameObjectIndices : array */[],
	              /* componentIndices : array */[]
	            ];
	    }
	  } else {
	    return /* record */[
	            /* gameObjectIndices : array */[],
	            /* componentIndices : array */[]
	          ];
	  }
	}


	/* Log-WonderLog Not a pure module */

	function convertToGameObjectIndexData(param) {
	  var extensions = param[/* extensions */14];
	  var materials = param[/* materials */12];
	  var meshes = param[/* meshes */11];
	  var nodes = param[/* nodes */10];
	  var transformGameObjectIndexData = convertToTransformGameObjectIndexData(nodes);
	  return /* record */[
	          /* childrenTransformIndexData */convertToChildrenTransformIndexData(transformGameObjectIndexData, nodes),
	          /* transformGameObjectIndexData */transformGameObjectIndexData,
	          /* basicCameraViewGameObjectIndexData */convertToBasicCameraViewGameObjectIndexData(nodes),
	          /* perspectiveCameraProjectionGameObjectIndexData */convertToPerspectiveCameraProjectionGameObjectIndexData(nodes, param[/* cameras */9]),
	          /* arcballCameraControllerGameObjectIndexData */convertToArcballCameraControllerGameObjectIndexData(nodes),
	          /* basicMaterialGameObjectIndexData */convertToBasicMaterialGameObjectIndexData(nodes, meshes, materials),
	          /* lightMaterialGameObjectIndexData */convertToLightMaterialGameObjectIndexData(nodes, meshes, materials),
	          /* directionLightGameObjectIndexData */convertToLightGameObjectIndexData("directional", nodes, extensions),
	          /* pointLightGameObjectIndexData */convertToLightGameObjectIndexData("point", nodes, extensions),
	          /* customGeometryGameObjectIndexData */convertToGeometryGameObjectIndexData(nodes),
	          /* meshRendererGameObjectIndexData */convertToMeshRendererGameObjectIndexData(nodes)
	        ];
	}


	/* ConvertChildrenDataSystem-Wonderjs Not a pure module */

	function convertToIndices(gltf) {
	  var match = convertToImageAndSamplerTextureIndices(gltf);
	  var match$1 = match[1];
	  var match$2 = match[0];
	  return /* record */[
	          /* gameObjectIndices */convertToGameObjectIndexData(gltf),
	          /* materialIndices */convertToMaterialIndices(gltf),
	          /* imageTextureIndices : record */[
	            /* textureIndices */match$2[0],
	            /* imageIndices */match$2[1]
	          ],
	          /* samplerTextureIndices : record */[
	            /* textureIndices */match$1[0],
	            /* samplerIndices */match$1[1]
	          ]
	        ];
	}


	/* ConvertTextureIndicesSystem-Wonderjs Not a pure module */

	function _getFormat(mimeType) {
	  switch (mimeType) {
	    case "image/jpeg" : 
	        return /* RGB */0;
	    case "image/png" : 
	        return /* RGBA */1;
	    default:
	      return fatal(buildFatalMessage("convertToBasicSourceTextures", "unknown mimeType", "", "", "mimeType: " + (String(mimeType) + "")));
	  }
	}

	function convertToBasicSourceTextures(gltf) {
	  var textures = gltf[/* textures */4];
	  if (textures !== undefined) {
	    var images = gltf[/* images */3];
	    return reduceOneParami((function (arr, texture, index) {
	                  var name = texture[/* name */2];
	                  var source = texture[/* source */1];
	                  var tmp;
	                  if (name !== undefined) {
	                    tmp = name;
	                  } else if (source !== undefined) {
	                    var match = unsafeGet$1(images)[source];
	                    var name$1 = match[/* name */1];
	                    tmp = name$1 !== undefined ? name$1 : buildDefaultName("texture", index);
	                  } else {
	                    tmp = buildDefaultName("texture", index);
	                  }
	                  var image = unsafeGet$1(images)[unsafeGet$1(source)];
	                  return push(/* record */[
	                              /* name */tmp,
	                              /* format */_getFormat(unsafeGet$1(image[/* mimeType */3]))
	                            ], arr);
	                }), /* array */[], textures);
	  } else {
	    return /* array */[];
	  }
	}

	function _convertMagFilter(magFilter) {
	  if (magFilter !== undefined) {
	    var magFilter$1 = magFilter;
	    if (magFilter$1 !== 9728) {
	      if (magFilter$1 !== 9729) {
	        return fatal(buildFatalMessage("_convertToSamplers", "unknown magFilter: " + (String(magFilter$1) + ""), "", "", ""));
	      } else {
	        return /* LINEAR */1;
	      }
	    } else {
	      return /* NEAREST */0;
	    }
	  } else {
	    return /* LINEAR */1;
	  }
	}

	function _convertMinFilter(minFilter) {
	  if (minFilter !== undefined) {
	    var minFilter$1 = minFilter;
	    var switcher = minFilter$1 - 9728 | 0;
	    if (switcher === 0 || switcher === 1) {
	      if (switcher !== 0) {
	        return /* LINEAR */1;
	      } else {
	        return /* NEAREST */0;
	      }
	    } else {
	      var switcher$1 = switcher - 256 | 0;
	      if (switcher$1 > 3 || switcher$1 < 0) {
	        return fatal(buildFatalMessage("_convertToSamplers", "unknown minFilter: " + (String(minFilter$1) + ""), "", "", ""));
	      } else {
	        return switcher$1 + 2 | 0;
	      }
	    }
	  } else {
	    return /* NEAREST */0;
	  }
	}

	function _convertWrapS(wrapS) {
	  if (wrapS !== undefined) {
	    var wrapS$1 = wrapS;
	    if (wrapS$1 !== 10497) {
	      if (wrapS$1 !== 33071) {
	        if (wrapS$1 !== 33648) {
	          return fatal(buildFatalMessage("_convertToSamplers", "unknown wrapS: " + (String(wrapS$1) + ""), "", "", ""));
	        } else {
	          return /* MIRRORED_REPEAT */1;
	        }
	      } else {
	        return /* CLAMP_TO_EDGE */0;
	      }
	    } else {
	      return /* REPEAT */2;
	    }
	  } else {
	    return /* CLAMP_TO_EDGE */0;
	  }
	}

	function _convertWrapT(wrapT) {
	  if (wrapT !== undefined) {
	    var wrapT$1 = wrapT;
	    if (wrapT$1 !== 10497) {
	      if (wrapT$1 !== 33071) {
	        if (wrapT$1 !== 33648) {
	          return fatal(buildFatalMessage("_convertToSamplers", "unknown wrapT: " + (String(wrapT$1) + ""), "", "", ""));
	        } else {
	          return /* MIRRORED_REPEAT */1;
	        }
	      } else {
	        return /* CLAMP_TO_EDGE */0;
	      }
	    } else {
	      return /* REPEAT */2;
	    }
	  } else {
	    return /* CLAMP_TO_EDGE */0;
	  }
	}

	function convertToSamplers(param) {
	  var samplers = param[/* samplers */5];
	  if (samplers !== undefined) {
	    return reduceOneParam((function (arr, param) {
	                  return push(/* record */[
	                              /* magFilter */_convertMagFilter(param[/* magFilter */0]),
	                              /* minFilter */_convertMinFilter(param[/* minFilter */1]),
	                              /* wrapS */_convertWrapS(param[/* wrapS */2]),
	                              /* wrapT */_convertWrapT(param[/* wrapT */3])
	                            ], arr);
	                }), /* array */[], samplers);
	  } else {
	    return /* array */[];
	  }
	}


	/* Log-WonderLog Not a pure module */

	function _convertToGeometry(param) {
	  var primitives = param[/* primitives */0];
	  requireCheck((function () {
	          return test(buildAssertMessage("not has texCoord_1", "has"), (function () {
	                        var match = getPrimitiveData(primitives);
	                        return assertNotExist(match[/* attributes */0][/* texCoord_1 */3]);
	                      }));
	        }), getIsDebug(stateData));
	  var match = primitives.length > 1;
	  if (match) {
	    return undefined;
	  } else {
	    var match$1 = getPrimitiveData(primitives);
	    var attributes = match$1[/* attributes */0];
	    return /* record */[
	            /* position */attributes[/* position */0],
	            /* normal */attributes[/* normal */1],
	            /* texCoord */attributes[/* texCoord_0 */2],
	            /* index */unsafeGet$1(match$1[/* indices */1])
	          ];
	  }
	}

	function convertToGeometrys(param) {
	  return reduceOneParam((function (arr, mesh) {
	                return push(_convertToGeometry(mesh), arr);
	              }), /* array */[], param[/* meshes */11]);
	}


	/* Log-WonderLog Not a pure module */

	function convertToBasicMaterials(param) {
	  var extras = param[/* extras */15];
	  if (extras !== undefined) {
	    var basicMaterials = extras[/* basicMaterials */1];
	    if (basicMaterials !== undefined) {
	      return reduceOneParami((function (arr, param, index) {
	                    var name = param[/* name */1];
	                    var colorFactor = param[/* colorFactor */0];
	                    var tmp;
	                    if (colorFactor !== undefined) {
	                      var colorFactor$1 = colorFactor;
	                      tmp = /* array */[
	                        caml_array_get(colorFactor$1, 0),
	                        caml_array_get(colorFactor$1, 1),
	                        caml_array_get(colorFactor$1, 2)
	                      ];
	                    } else {
	                      tmp = /* array */[
	                        1,
	                        1,
	                        1
	                      ];
	                    }
	                    return push(/* record */[
	                                /* color */tmp,
	                                /* name */name !== undefined ? name : buildDefaultName("basicMaterial", index)
	                              ], arr);
	                  }), /* array */[], basicMaterials);
	    } else {
	      return /* array */[];
	    }
	  } else {
	    return /* array */[];
	  }
	}

	function convertToLightMaterials(param) {
	  var materials = param[/* materials */12];
	  if (materials !== undefined) {
	    return reduceOneParami((function (arr, param, index) {
	                  var pbrMetallicRoughness = param[/* pbrMetallicRoughness */0];
	                  if (pbrMetallicRoughness !== undefined) {
	                    var baseColorFactor = pbrMetallicRoughness[/* baseColorFactor */0];
	                    var name = param[/* name */1];
	                    var tmp;
	                    if (baseColorFactor !== undefined) {
	                      var baseColorFactor$1 = baseColorFactor;
	                      tmp = /* array */[
	                        caml_array_get(baseColorFactor$1, 0),
	                        caml_array_get(baseColorFactor$1, 1),
	                        caml_array_get(baseColorFactor$1, 2)
	                      ];
	                    } else {
	                      tmp = /* array */[
	                        1,
	                        1,
	                        1
	                      ];
	                    }
	                    return push(/* record */[
	                                /* diffuseColor */tmp,
	                                /* name */name !== undefined ? name : buildDefaultName("lightMaterial", index)
	                              ], arr);
	                  } else {
	                    return arr;
	                  }
	                }), /* array */[], materials);
	  } else {
	    return /* array */[];
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _getTranslationTuple(mat) {
	  return /* tuple */[
	          caml_array_get(mat, 12),
	          caml_array_get(mat, 13),
	          caml_array_get(mat, 14)
	        ];
	}

	function _getScaleTuple(mat) {
	  var m11 = caml_array_get(mat, 0);
	  var m12 = caml_array_get(mat, 1);
	  var m13 = caml_array_get(mat, 2);
	  var m21 = caml_array_get(mat, 4);
	  var m22 = caml_array_get(mat, 5);
	  var m23 = caml_array_get(mat, 6);
	  var m31 = caml_array_get(mat, 8);
	  var m32 = caml_array_get(mat, 9);
	  var m33 = caml_array_get(mat, 10);
	  return /* tuple */[
	          Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13),
	          Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23),
	          Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33)
	        ];
	}

	function _getRotationTuple(mat) {
	  var trace = caml_array_get(mat, 0) + caml_array_get(mat, 5) + caml_array_get(mat, 10);
	  if (trace > 0) {
	    var s = Math.sqrt(trace + 1.0) * 2;
	    return /* tuple */[
	            (caml_array_get(mat, 6) - caml_array_get(mat, 9)) / s,
	            (caml_array_get(mat, 8) - caml_array_get(mat, 2)) / s,
	            (caml_array_get(mat, 1) - caml_array_get(mat, 4)) / s,
	            0.25 * s
	          ];
	  } else if (caml_array_get(mat, 0) > caml_array_get(mat, 5) && caml_array_get(mat, 0) > caml_array_get(mat, 10)) {
	    var s$1 = Math.sqrt(1.0 + caml_array_get(mat, 0) - caml_array_get(mat, 5) - caml_array_get(mat, 10)) * 2;
	    return /* tuple */[
	            0.25 * s$1,
	            (caml_array_get(mat, 1) + caml_array_get(mat, 4)) / s$1,
	            (caml_array_get(mat, 8) + caml_array_get(mat, 2)) / s$1,
	            (caml_array_get(mat, 6) - caml_array_get(mat, 9)) / s$1
	          ];
	  } else if (caml_array_get(mat, 5) > caml_array_get(mat, 10)) {
	    var s$2 = Math.sqrt(1.0 + caml_array_get(mat, 5) - caml_array_get(mat, 0) - caml_array_get(mat, 10)) * 2;
	    return /* tuple */[
	            (caml_array_get(mat, 1) + caml_array_get(mat, 4)) / s$2,
	            0.25 * s$2,
	            (caml_array_get(mat, 6) + caml_array_get(mat, 9)) / s$2,
	            (caml_array_get(mat, 8) - caml_array_get(mat, 2)) / s$2
	          ];
	  } else {
	    var s$3 = Math.sqrt(1.0 + caml_array_get(mat, 10) - caml_array_get(mat, 0) - caml_array_get(mat, 5)) * 2;
	    return /* tuple */[
	            (caml_array_get(mat, 8) + caml_array_get(mat, 2)) / s$3,
	            (caml_array_get(mat, 6) + caml_array_get(mat, 9)) / s$3,
	            0.25 * s$3,
	            (caml_array_get(mat, 1) - caml_array_get(mat, 4)) / s$3
	          ];
	  }
	}

	function convertToTransforms(param) {
	  return reduceOneParam((function (arr, param) {
	                var scale = param[/* scale */7];
	                var rotation = param[/* rotation */6];
	                var translation = param[/* translation */5];
	                var matrix = param[/* matrix */4];
	                if (matrix !== undefined) {
	                  var matrix$1 = matrix;
	                  return push(/* record */[
	                              /* translation */_getTranslationTuple(matrix$1),
	                              /* rotation */_getRotationTuple(matrix$1),
	                              /* scale */_getScaleTuple(matrix$1)
	                            ], arr);
	                } else {
	                  return push(/* record */[
	                              /* translation */translation !== undefined ? translation : undefined,
	                              /* rotation */rotation !== undefined ? rotation : undefined,
	                              /* scale */scale !== undefined ? scale : undefined
	                            ], arr);
	                }
	              }), /* array */[], param[/* nodes */10]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _getNames(param) {
	  var meshes = param[/* meshes */11];
	  return reduceOneParami((function (nameArr, node, index) {
	                var name = node[/* name */0];
	                if (name !== undefined) {
	                  return push(name, nameArr);
	                } else {
	                  var match = node[/* mesh */2];
	                  if (match !== undefined) {
	                    var match$1 = meshes[match];
	                    var name$1 = match$1[/* name */1];
	                    if (name$1 !== undefined) {
	                      return push(name$1, nameArr);
	                    } else {
	                      return push(buildDefaultName("gameObject", index), nameArr);
	                    }
	                  } else {
	                    return push(buildDefaultName("gameObject", index), nameArr);
	                  }
	                }
	              }), /* array */[], param[/* nodes */10]);
	}

	function convert(gltf) {
	  return /* record */[
	          /* count */getCount$1(gltf[/* nodes */10]),
	          /* names */_getNames(gltf)
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _convertByMesh(meshes, customGeometryGameObjectIndices, customGeometryIndices) {
	  return customGeometryGameObjectIndices.map((function (_, index) {
	                var customGeometryIndex = customGeometryIndices[index];
	                var match = meshes[customGeometryIndex];
	                var match$1 = getPrimitiveData(match[/* primitives */0]);
	                var mode = match$1[/* mode */3];
	                var tmp;
	                if (mode !== undefined) {
	                  var match$2 = mode;
	                  if (match$2 > 6 || match$2 < 0) {
	                    throw [
	                          match_failure,
	                          /* tuple */[
	                            "ConvertMeshRenderersSystem.re",
	                            17,
	                            13
	                          ]
	                        ];
	                  } else {
	                    tmp = match$2;
	                  }
	                } else {
	                  tmp = /* Triangles */4;
	                }
	                return /* record */[/* drawMode */tmp];
	              }));
	}

	function convertToMeshRenderers(param, param$1) {
	  var extras = param$1[/* extras */15];
	  var meshes = param$1[/* meshes */11];
	  var customGeometryIndices = param[/* componentIndices */1];
	  var customGeometryGameObjectIndices = param[/* gameObjectIndices */0];
	  if (extras !== undefined) {
	    var meshRenderers = extras[/* meshRenderers */2];
	    if (meshRenderers !== undefined) {
	      var meshRenderers$1 = meshRenderers;
	      if (meshRenderers$1.length > 0) {
	        return reduceOneParami((function (arr, param, _) {
	                      return push(/* record */[/* drawMode */param[/* drawMode */0]], arr);
	                    }), /* array */[], meshRenderers$1);
	      } else {
	        return _convertByMesh(meshes, customGeometryGameObjectIndices, customGeometryIndices);
	      }
	    } else {
	      return _convertByMesh(meshes, customGeometryGameObjectIndices, customGeometryIndices);
	    }
	  } else {
	    return _convertByMesh(meshes, customGeometryGameObjectIndices, customGeometryIndices);
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _createDefaultMaterial() {
	  return /* record */[
	          /* pbrMetallicRoughness *//* record */[
	            /* baseColorFactor *//* array */[
	              1,
	              1,
	              1
	            ],
	            /* baseColorTexture */undefined,
	            /* metallicFactor */1,
	            /* roughnessFactor */1,
	            /* metallicRoughnessTexture */undefined
	          ],
	          /* name */"defaultLightMaterial"
	        ];
	}

	function _addDefaultMaterial(gltf) {
	  var materials = gltf[/* materials */12];
	  var defaultMaterial = _createDefaultMaterial(/* () */0);
	  var match;
	  if (materials !== undefined) {
	    var materials$1 = materials;
	    match = /* tuple */[
	      materials$1.length,
	      push(defaultMaterial, materials$1)
	    ];
	  } else {
	    match = /* tuple */[
	      0,
	      /* array */[defaultMaterial]
	    ];
	  }
	  return /* tuple */[
	          match[0],
	          /* record */[
	            /* asset */gltf[/* asset */0],
	            /* scenes */gltf[/* scenes */1],
	            /* scene */gltf[/* scene */2],
	            /* images */gltf[/* images */3],
	            /* textures */gltf[/* textures */4],
	            /* samplers */gltf[/* samplers */5],
	            /* buffers */gltf[/* buffers */6],
	            /* bufferViews */gltf[/* bufferViews */7],
	            /* accessors */gltf[/* accessors */8],
	            /* cameras */gltf[/* cameras */9],
	            /* nodes */gltf[/* nodes */10],
	            /* meshes */gltf[/* meshes */11],
	            /* materials */match[1],
	            /* extensionsUsed */gltf[/* extensionsUsed */13],
	            /* extensions */gltf[/* extensions */14],
	            /* extras */gltf[/* extras */15]
	          ]
	        ];
	}

	function _isNeedAddDefaultMaterialByJudgeMesh(mesh, meshes) {
	  var match = meshes[mesh];
	  return isNone(getPrimitiveData(match[/* primitives */0])[/* material */2]);
	}

	function _isNeedAddDefaultMaterial(param, meshes) {
	  var mesh = param[/* mesh */2];
	  if (mesh !== undefined) {
	    var mesh$1 = mesh;
	    var extras = param[/* extras */8];
	    if (extras !== undefined) {
	      var match = extras;
	      if (match[/* basicMaterial */1] !== undefined || match[/* lightMaterial */2] !== undefined) {
	        return false;
	      } else {
	        return _isNeedAddDefaultMaterialByJudgeMesh(mesh$1, meshes);
	      }
	    } else {
	      return _isNeedAddDefaultMaterialByJudgeMesh(mesh$1, meshes);
	    }
	  } else {
	    return false;
	  }
	}

	function _setDefaultMaterial(param) {
	  var gltf = param[1];
	  var meshes = gltf[/* meshes */11];
	  var defaultMaterialIndex = param[0];
	  return /* record */[
	          /* asset */gltf[/* asset */0],
	          /* scenes */gltf[/* scenes */1],
	          /* scene */gltf[/* scene */2],
	          /* images */gltf[/* images */3],
	          /* textures */gltf[/* textures */4],
	          /* samplers */gltf[/* samplers */5],
	          /* buffers */gltf[/* buffers */6],
	          /* bufferViews */gltf[/* bufferViews */7],
	          /* accessors */gltf[/* accessors */8],
	          /* cameras */gltf[/* cameras */9],
	          /* nodes */reduceOneParam((function (newNodes, node) {
	                  var extras = node[/* extras */8];
	                  var match = _isNeedAddDefaultMaterial(node, meshes);
	                  if (match) {
	                    var tmp;
	                    if (extras !== undefined) {
	                      var extras$1 = extras;
	                      tmp = /* record */[
	                        /* meshRenderer */extras$1[/* meshRenderer */0],
	                        /* basicMaterial */undefined,
	                        /* lightMaterial */defaultMaterialIndex,
	                        /* cameraController */extras$1[/* cameraController */3]
	                      ];
	                    } else {
	                      tmp = /* record */[
	                        /* meshRenderer */undefined,
	                        /* basicMaterial */undefined,
	                        /* lightMaterial */defaultMaterialIndex,
	                        /* cameraController */undefined
	                      ];
	                    }
	                    return push(/* record */[
	                                /* name */node[/* name */0],
	                                /* camera */node[/* camera */1],
	                                /* mesh */node[/* mesh */2],
	                                /* children */node[/* children */3],
	                                /* matrix */node[/* matrix */4],
	                                /* translation */node[/* translation */5],
	                                /* rotation */node[/* rotation */6],
	                                /* scale */node[/* scale */7],
	                                /* extras */tmp,
	                                /* extensions */node[/* extensions */9]
	                              ], newNodes);
	                  } else {
	                    return push(node, newNodes);
	                  }
	                }), /* array */[], gltf[/* nodes */10]),
	          /* meshes */gltf[/* meshes */11],
	          /* materials */gltf[/* materials */12],
	          /* extensionsUsed */gltf[/* extensionsUsed */13],
	          /* extensions */gltf[/* extensions */14],
	          /* extras */gltf[/* extras */15]
	        ];
	}

	function convert$1(gltf) {
	  var meshes = gltf[/* meshes */11];
	  var isNeedAddDefaultMaterial = reduceOneParam((function (isNeedAddDefaultMaterial, node) {
	          if (isNeedAddDefaultMaterial) {
	            return isNeedAddDefaultMaterial;
	          } else {
	            return _isNeedAddDefaultMaterial(node, meshes);
	          }
	        }), false, gltf[/* nodes */10]);
	  if (isNeedAddDefaultMaterial) {
	    return _setDefaultMaterial(_addDefaultMaterial(gltf));
	  } else {
	    return gltf;
	  }
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _buildMultiPrimitivesName(name, primitiveIndex) {
	  if (name !== undefined) {
	    return "" + (String(valFromOption(name)) + ("_" + (String(primitiveIndex) + "")));
	  }
	  
	}

	function _buildMultiPrimitivesMeshMap(meshes) {
	  return reduceOneParami((function (param, param$1, meshIndex) {
	                  var name = param$1[/* name */1];
	                  var primitives = param$1[/* primitives */0];
	                  var newMeshIndex = param[1];
	                  var multiPrimitivesMeshMap = param[0];
	                  var primitivesLen = primitives.length;
	                  if (primitivesLen === 0 || primitivesLen === 1) {
	                    return /* tuple */[
	                            multiPrimitivesMeshMap,
	                            newMeshIndex
	                          ];
	                  } else {
	                    var newMeshDataArr = reduceOneParami((function (newMeshDataArr, primitive, primitiveIndex) {
	                            return push(/* tuple */[
	                                        /* record */[
	                                          /* primitives : array */[primitive],
	                                          /* name */_buildMultiPrimitivesName(name, primitiveIndex)
	                                        ],
	                                        newMeshIndex + primitiveIndex | 0
	                                      ], newMeshDataArr);
	                          }), /* array */[], primitives);
	                    return /* tuple */[
	                            set$1(meshIndex, newMeshDataArr, multiPrimitivesMeshMap),
	                            newMeshIndex + newMeshDataArr.length | 0
	                          ];
	                  }
	                }), /* tuple */[
	                createEmpty$2(/* () */0),
	                meshes.length
	              ], meshes)[0];
	}

	function _buildNewMeshes(meshes, multiPrimitivesMeshMap) {
	  return reduceiValid((function (newMeshes, newMeshDataArr, _) {
	                return newMeshes.concat(newMeshDataArr.map((function (param) {
	                                  return param[0];
	                                })));
	              }), meshes.slice(), multiPrimitivesMeshMap);
	}

	function _buildNewNodes(nodes, multiPrimitivesMeshMap) {
	  var match = reduceOneParam((function (param, node) {
	          var mesh = node[/* mesh */2];
	          var name = node[/* name */0];
	          var newNodeIndex = param[2];
	          var newNodesOfMultiPrimitives = param[1];
	          var newNodes = param[0];
	          if (mesh !== undefined) {
	            var match = get$3(mesh, multiPrimitivesMeshMap);
	            if (match !== undefined) {
	              var newMeshDataArr = match;
	              var newNodesOfMultiPrimitives$1 = reduceOneParami((function (newNodesOfMultiPrimitives, param, primitiveIndex) {
	                      return push(/* record */[
	                                  /* name */_buildMultiPrimitivesName(name, primitiveIndex),
	                                  /* camera */undefined,
	                                  /* mesh */param[1],
	                                  /* children */undefined,
	                                  /* matrix */undefined,
	                                  /* translation */undefined,
	                                  /* rotation */undefined,
	                                  /* scale */undefined,
	                                  /* extras */undefined,
	                                  /* extensions */undefined
	                                ], newNodesOfMultiPrimitives);
	                    }), newNodesOfMultiPrimitives, newMeshDataArr);
	              var newChildren = range$1(newNodeIndex, (newNodeIndex + newMeshDataArr.length | 0) - 1 | 0);
	              var match$1 = node[/* children */3];
	              return /* tuple */[
	                      push(/* record */[
	                            /* name */node[/* name */0],
	                            /* camera */node[/* camera */1],
	                            /* mesh */undefined,
	                            /* children */match$1 !== undefined ? match$1.concat(newChildren) : newChildren,
	                            /* matrix */node[/* matrix */4],
	                            /* translation */node[/* translation */5],
	                            /* rotation */node[/* rotation */6],
	                            /* scale */node[/* scale */7],
	                            /* extras */node[/* extras */8],
	                            /* extensions */node[/* extensions */9]
	                          ], newNodes),
	                      newNodesOfMultiPrimitives$1,
	                      newNodeIndex + newMeshDataArr.length | 0
	                    ];
	            } else {
	              return /* tuple */[
	                      push(node, newNodes),
	                      newNodesOfMultiPrimitives,
	                      newNodeIndex
	                    ];
	            }
	          } else {
	            return /* tuple */[
	                    push(node, newNodes),
	                    newNodesOfMultiPrimitives,
	                    newNodeIndex
	                  ];
	          }
	        }), /* tuple */[
	        /* array */[],
	        /* array */[],
	        nodes.length
	      ], nodes);
	  return match[0].concat(match[1]);
	}

	function convertMultiPrimitivesToNodes(gltf) {
	  var meshes = gltf[/* meshes */11];
	  var multiPrimitivesMeshMap = _buildMultiPrimitivesMeshMap(meshes);
	  return /* record */[
	          /* asset */gltf[/* asset */0],
	          /* scenes */gltf[/* scenes */1],
	          /* scene */gltf[/* scene */2],
	          /* images */gltf[/* images */3],
	          /* textures */gltf[/* textures */4],
	          /* samplers */gltf[/* samplers */5],
	          /* buffers */gltf[/* buffers */6],
	          /* bufferViews */gltf[/* bufferViews */7],
	          /* accessors */gltf[/* accessors */8],
	          /* cameras */gltf[/* cameras */9],
	          /* nodes */_buildNewNodes(gltf[/* nodes */10], multiPrimitivesMeshMap),
	          /* meshes */_buildNewMeshes(meshes, multiPrimitivesMeshMap),
	          /* materials */gltf[/* materials */12],
	          /* extensionsUsed */gltf[/* extensionsUsed */13],
	          /* extensions */gltf[/* extensions */14],
	          /* extras */gltf[/* extras */15]
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	var Bottom = create$1("Array.Bottom");


	/* No side effect */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function _isInteger(value) {
	  if (isFinite(value)) {
	    return Math.floor(value) === value;
	  } else {
	    return false;
	  }
	}

	var DecodeError = create$1("Json_decode-WonderBsJson.DecodeError");

	function bool(json) {
	  if (typeof json === "boolean") {
	    return json;
	  } else {
	    throw [
	          DecodeError,
	          "Expected boolean, got " + JSON.stringify(json)
	        ];
	  }
	}

	function $$float(json) {
	  if (typeof json === "number") {
	    return json;
	  } else {
	    throw [
	          DecodeError,
	          "Expected number, got " + JSON.stringify(json)
	        ];
	  }
	}

	function $$int(json) {
	  var f = $$float(json);
	  if (_isInteger(f)) {
	    return f;
	  } else {
	    throw [
	          DecodeError,
	          "Expected integer, got " + JSON.stringify(json)
	        ];
	  }
	}

	function string(json) {
	  if (typeof json === "string") {
	    return json;
	  } else {
	    throw [
	          DecodeError,
	          "Expected string, got " + JSON.stringify(json)
	        ];
	  }
	}

	function array(decode, json) {
	  if (Array.isArray(json)) {
	    var length = json.length;
	    var target = new Array(length);
	    for(var i = 0 ,i_finish = length - 1 | 0; i <= i_finish; ++i){
	      var value;
	      try {
	        value = _1(decode, json[i]);
	      }
	      catch (raw_exn){
	        var exn = internalToOCamlException(raw_exn);
	        if (exn[0] === DecodeError) {
	          throw [
	                DecodeError,
	                exn[1] + ("\n\tin array at index " + String(i))
	              ];
	        } else {
	          throw exn;
	        }
	      }
	      target[i] = value;
	    }
	    return target;
	  } else {
	    throw [
	          DecodeError,
	          "Expected array, got " + JSON.stringify(json)
	        ];
	  }
	}

	function tuple3(decodeA, decodeB, decodeC, json) {
	  if (Array.isArray(json)) {
	    var length = json.length;
	    if (length === 3) {
	      try {
	        return /* tuple */[
	                _1(decodeA, json[0]),
	                _1(decodeB, json[1]),
	                _1(decodeC, json[2])
	              ];
	      }
	      catch (raw_exn){
	        var exn = internalToOCamlException(raw_exn);
	        if (exn[0] === DecodeError) {
	          throw [
	                DecodeError,
	                exn[1] + "\n\tin tuple3"
	              ];
	        } else {
	          throw exn;
	        }
	      }
	    } else {
	      throw [
	            DecodeError,
	            "Expected array of length 3, got array of length " + (String(length) + "")
	          ];
	    }
	  } else {
	    throw [
	          DecodeError,
	          "Expected array, got " + JSON.stringify(json)
	        ];
	  }
	}

	function field(key, decode, json) {
	  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
	    var match = json[key];
	    if (match !== undefined) {
	      try {
	        return _1(decode, match);
	      }
	      catch (raw_exn){
	        var exn = internalToOCamlException(raw_exn);
	        if (exn[0] === DecodeError) {
	          throw [
	                DecodeError,
	                exn[1] + ("\n\tat field '" + (key + "'"))
	              ];
	        } else {
	          throw exn;
	        }
	      }
	    } else {
	      throw [
	            DecodeError,
	            "Expected field \'" + (String(key) + "\'")
	          ];
	    }
	  } else {
	    throw [
	          DecodeError,
	          "Expected object, got " + JSON.stringify(json)
	        ];
	  }
	}

	function optimizedField(key, decode, json) {
	  if (typeof json === "object" && !Array.isArray(json) && json !== null) {
	    var match = json[key];
	    if (match !== undefined) {
	      try {
	        return _1(decode, match);
	      }
	      catch (raw_exn){
	        var exn = internalToOCamlException(raw_exn);
	        if (exn[0] === DecodeError) {
	          throw [
	                DecodeError,
	                exn[1] + ("\n\tat field '" + (key + "'"))
	              ];
	        } else {
	          throw exn;
	        }
	      }
	    } else {
	      return 1000;
	    }
	  } else {
	    throw [
	          DecodeError,
	          "Expected object, got " + JSON.stringify(json)
	        ];
	  }
	}

	function optional(decode, json) {
	  try {
	    return some$1(_1(decode, json));
	  }
	  catch (raw_exn){
	    var exn = internalToOCamlException(raw_exn);
	    if (exn[0] === DecodeError) {
	      return undefined;
	    } else {
	      throw exn;
	    }
	  }
	}

	function optimizedOptional(decode, json) {
	  var result = _1(decode, json);
	  var match = result === 1000;
	  if (match) {
	    return undefined;
	  } else {
	    return some$1(result);
	  }
	}


	/* No side effect */

	function _convertAsset(json) {
	  return field("asset", (function (json) {
	                return /* record */[
	                        /* version */field("version", string, json),
	                        /* generator */optional((function (param) {
	                                return field("generator", string, param);
	                              }), json)
	                      ];
	              }), json);
	}

	function _convertSamplers(json) {
	  return optional((function (param) {
	                return field("samplers", (function (param) {
	                              return array((function (json) {
	                                            return /* record */[
	                                                    /* magFilter */optional((function (param) {
	                                                            return field("magFilter", $$int, param);
	                                                          }), json),
	                                                    /* minFilter */optional((function (param) {
	                                                            return field("minFilter", $$int, param);
	                                                          }), json),
	                                                    /* wrapS */optional((function (param) {
	                                                            return field("wrapS", $$int, param);
	                                                          }), json),
	                                                    /* wrapT */optional((function (param) {
	                                                            return field("wrapT", $$int, param);
	                                                          }), json)
	                                                  ];
	                                          }), param);
	                            }), param);
	              }), json);
	}

	function _convertBuffers(json) {
	  return field("buffers", (function (param) {
	                return array((function (json) {
	                              return /* record */[
	                                      /* uri */optional((function (param) {
	                                              return field("uri", string, param);
	                                            }), json),
	                                      /* byteLength */field("byteLength", $$int, json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function _convertBufferViews(json) {
	  return field("bufferViews", (function (param) {
	                return array((function (json) {
	                              return /* record */[
	                                      /* buffer */field("buffer", $$int, json),
	                                      /* byteOffset */optional((function (param) {
	                                              return field("byteOffset", $$int, param);
	                                            }), json),
	                                      /* byteLength */field("byteLength", $$int, json),
	                                      /* byteStride */optional((function (param) {
	                                              return field("byteStride", $$int, param);
	                                            }), json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function _convertAccessors(json) {
	  return field("accessors", (function (param) {
	                return array((function (json) {
	                              return /* record */[
	                                      /* bufferView */optional((function (param) {
	                                              return field("bufferView", $$int, param);
	                                            }), json),
	                                      /* byteOffset */optional((function (param) {
	                                              return field("byteOffset", $$int, param);
	                                            }), json),
	                                      /* count */field("count", $$int, json),
	                                      /* componentType */field("componentType", $$int, json),
	                                      /* type_ */field("type", string, json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function _convertTextures(json) {
	  return optional((function (param) {
	                return field("textures", (function (param) {
	                              return array((function (json) {
	                                            return /* record */[
	                                                    /* sampler */optional((function (param) {
	                                                            return field("sampler", $$int, param);
	                                                          }), json),
	                                                    /* source */optional((function (param) {
	                                                            return field("source", $$int, param);
	                                                          }), json),
	                                                    /* name */optional((function (param) {
	                                                            return field("name", string, param);
	                                                          }), json)
	                                                  ];
	                                          }), param);
	                            }), param);
	              }), json);
	}

	function _convertImages(json) {
	  return optional((function (param) {
	                return field("images", (function (param) {
	                              return array((function (json) {
	                                            return /* record */[
	                                                    /* uri */optional((function (param) {
	                                                            return field("uri", string, param);
	                                                          }), json),
	                                                    /* name */optional((function (param) {
	                                                            return field("name", string, param);
	                                                          }), json),
	                                                    /* bufferView */optional((function (param) {
	                                                            return field("bufferView", $$int, param);
	                                                          }), json),
	                                                    /* mimeType */optional((function (param) {
	                                                            return field("mimeType", string, param);
	                                                          }), json)
	                                                  ];
	                                          }), param);
	                            }), param);
	              }), json);
	}

	var _convertCustomData = function (json){
	      return json.customData;
	      };

	function _convertScenes(json) {
	  return field("scenes", (function (param) {
	                return array((function (json) {
	                              return /* record */[
	                                      /* nodes */optional((function (param) {
	                                              return field("nodes", (function (param) {
	                                                            return array($$int, param);
	                                                          }), param);
	                                            }), json),
	                                      /* extensions */optional((function (param) {
	                                              return field("extensions", (function (json) {
	                                                            return /* record */[/* khr_lights */optional((function (param) {
	                                                                            return field("KHR_lights", (function (json) {
	                                                                                          return /* record */[/* light */field("light", $$int, json)];
	                                                                                        }), param);
	                                                                          }), json)];
	                                                          }), param);
	                                            }), json),
	                                      /* extras */optional((function (param) {
	                                              return field("extras", (function (json) {
	                                                            return /* record */[/* imgui */optional((function (param) {
	                                                                            return field("imgui", (function (json) {
	                                                                                          return /* record */[
	                                                                                                  /* imguiFunc */field("imguiFunc", string, json),
	                                                                                                  /* customData */_convertCustomData(json)
	                                                                                                ];
	                                                                                        }), param);
	                                                                          }), json)];
	                                                          }), param);
	                                            }), json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function _convertExtensions(json) {
	  return optional((function (param) {
	                return field("extensions", (function (json) {
	                              return /* record */[/* khr_lights */optional((function (param) {
	                                              return field("KHR_lights", (function (json) {
	                                                            return /* record */[/* lights */field("lights", (function (param) {
	                                                                            return array((function (json) {
	                                                                                          return /* record */[
	                                                                                                  /* type_ */field("type", string, json),
	                                                                                                  /* color */optional((function (param) {
	                                                                                                          return field("color", (function (param) {
	                                                                                                                        return array($$float, param);
	                                                                                                                      }), param);
	                                                                                                        }), json),
	                                                                                                  /* intensity */optional((function (param) {
	                                                                                                          return field("intensity", $$float, param);
	                                                                                                        }), json),
	                                                                                                  /* constantAttenuation */optional((function (param) {
	                                                                                                          return field("constantAttenuation", $$float, param);
	                                                                                                        }), json),
	                                                                                                  /* linearAttenuation */optional((function (param) {
	                                                                                                          return field("linearAttenuation", $$float, param);
	                                                                                                        }), json),
	                                                                                                  /* quadraticAttenuation */optional((function (param) {
	                                                                                                          return field("quadraticAttenuation", $$float, param);
	                                                                                                        }), json),
	                                                                                                  /* range */optional((function (param) {
	                                                                                                          return field("range", $$float, param);
	                                                                                                        }), json)
	                                                                                                ];
	                                                                                        }), param);
	                                                                          }), json)];
	                                                          }), param);
	                                            }), json)];
	                            }), param);
	              }), json);
	}

	function _convertExtras(json) {
	  return optional((function (param) {
	                return field("extras", (function (json) {
	                              return /* record */[
	                                      /* arcballCameraControllers */optional((function (param) {
	                                              return field("arcballCameraControllers", (function (param) {
	                                                            return array((function (json) {
	                                                                          return /* record */[
	                                                                                  /* distance */field("distance", $$float, json),
	                                                                                  /* minDistance */field("minDistance", $$float, json),
	                                                                                  /* phi */field("phi", $$float, json),
	                                                                                  /* theta */field("theta", $$float, json),
	                                                                                  /* thetaMargin */field("thetaMargin", $$float, json),
	                                                                                  /* target */field("target", (function (param) {
	                                                                                          return tuple3($$float, $$float, $$float, param);
	                                                                                        }), json),
	                                                                                  /* moveSpeedX */field("moveSpeedX", $$float, json),
	                                                                                  /* moveSpeedY */field("moveSpeedY", $$float, json),
	                                                                                  /* rotateSpeed */field("rotateSpeed", $$float, json),
	                                                                                  /* wheelSpeed */field("wheelSpeed", $$float, json)
	                                                                                ];
	                                                                        }), param);
	                                                          }), param);
	                                            }), json),
	                                      /* basicMaterials */optional((function (param) {
	                                              return field("basicMaterials", (function (param) {
	                                                            return array((function (json) {
	                                                                          return /* record */[
	                                                                                  /* colorFactor */optional((function (param) {
	                                                                                          return field("colorFactor", (function (param) {
	                                                                                                        return array($$float, param);
	                                                                                                      }), param);
	                                                                                        }), json),
	                                                                                  /* name */optional((function (param) {
	                                                                                          return field("name", string, param);
	                                                                                        }), json)
	                                                                                ];
	                                                                        }), param);
	                                                          }), param);
	                                            }), json),
	                                      /* meshRenderers */optional((function (param) {
	                                              return field("meshRenderers", (function (param) {
	                                                            return array((function (json) {
	                                                                          return /* record */[/* drawMode */field("drawMode", $$int, json)];
	                                                                        }), param);
	                                                          }), param);
	                                            }), json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function _convertCameras(json) {
	  return optional((function (param) {
	                return field("cameras", (function (param) {
	                              return array((function (json) {
	                                            return /* record */[
	                                                    /* type_ */field("type", string, json),
	                                                    /* perspective */optional((function (param) {
	                                                            return field("perspective", (function (json) {
	                                                                          return /* record */[
	                                                                                  /* aspectRatio */optional((function (param) {
	                                                                                          return field("aspectRatio", $$float, param);
	                                                                                        }), json),
	                                                                                  /* yfov */field("yfov", $$float, json),
	                                                                                  /* zfar */optional((function (param) {
	                                                                                          return field("zfar", $$float, param);
	                                                                                        }), json),
	                                                                                  /* znear */field("znear", $$float, json)
	                                                                                ];
	                                                                        }), param);
	                                                          }), json),
	                                                    /* orthographic */optional((function (param) {
	                                                            return field("orthographic", (function (json) {
	                                                                          return /* record */[
	                                                                                  /* xmag */field("xmag", $$float, json),
	                                                                                  /* ymag */field("ymag", $$float, json),
	                                                                                  /* zfar */field("zfar", $$float, json),
	                                                                                  /* znear */field("znear", $$float, json)
	                                                                                ];
	                                                                        }), param);
	                                                          }), json)
	                                                  ];
	                                          }), param);
	                            }), param);
	              }), json);
	}

	function _convertMeshes(json) {
	  return field("meshes", (function (param) {
	                return array((function (json) {
	                              return /* record */[
	                                      /* primitives */field("primitives", (function (param) {
	                                              return array((function (json) {
	                                                            return /* record */[
	                                                                    /* attributes */field("attributes", (function (json) {
	                                                                            return /* record */[
	                                                                                    /* position */field("POSITION", $$int, json),
	                                                                                    /* normal */optional((function (param) {
	                                                                                            return field("NORMAL", $$int, param);
	                                                                                          }), json),
	                                                                                    /* texCoord_0 */optional((function (param) {
	                                                                                            return field("TEXCOORD_0", $$int, param);
	                                                                                          }), json),
	                                                                                    /* texCoord_1 */optional((function (param) {
	                                                                                            return field("TEXCOORD_1", $$int, param);
	                                                                                          }), json)
	                                                                                  ];
	                                                                          }), json),
	                                                                    /* indices */optional((function (param) {
	                                                                            return field("indices", $$int, param);
	                                                                          }), json),
	                                                                    /* material */optional((function (param) {
	                                                                            return field("material", $$int, param);
	                                                                          }), json),
	                                                                    /* mode */optional((function (param) {
	                                                                            return field("mode", $$int, param);
	                                                                          }), json)
	                                                                  ];
	                                                          }), param);
	                                            }), json),
	                                      /* name */optional((function (param) {
	                                              return field("name", string, param);
	                                            }), json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function _convertMaterials(json) {
	  return optional((function (param) {
	                return field("materials", (function (param) {
	                              return array((function (json) {
	                                            return /* record */[
	                                                    /* pbrMetallicRoughness */optional((function (param) {
	                                                            return field("pbrMetallicRoughness", (function (json) {
	                                                                          return /* record */[
	                                                                                  /* baseColorFactor */optional((function (param) {
	                                                                                          return field("baseColorFactor", (function (param) {
	                                                                                                        return array($$float, param);
	                                                                                                      }), param);
	                                                                                        }), json),
	                                                                                  /* baseColorTexture */optional((function (param) {
	                                                                                          return field("baseColorTexture", (function (json) {
	                                                                                                        return /* record */[
	                                                                                                                /* index */field("index", $$int, json),
	                                                                                                                /* texCoord */optional((function (param) {
	                                                                                                                        return field("texCoord", $$int, param);
	                                                                                                                      }), json)
	                                                                                                              ];
	                                                                                                      }), param);
	                                                                                        }), json),
	                                                                                  /* metallicFactor */optional((function (param) {
	                                                                                          return field("metallicFactor", $$float, param);
	                                                                                        }), json),
	                                                                                  /* roughnessFactor */optional((function (param) {
	                                                                                          return field("roughnessFactor", $$float, param);
	                                                                                        }), json),
	                                                                                  /* metallicRoughnessTexture */optional((function (param) {
	                                                                                          return field("metallicRoughnessTexture", (function (json) {
	                                                                                                        return /* record */[
	                                                                                                                /* index */field("index", $$int, json),
	                                                                                                                /* texCoord */optional((function (param) {
	                                                                                                                        return field("texCoord", $$int, param);
	                                                                                                                      }), json)
	                                                                                                              ];
	                                                                                                      }), param);
	                                                                                        }), json)
	                                                                                ];
	                                                                        }), param);
	                                                          }), json),
	                                                    /* name */optional((function (param) {
	                                                            return field("name", string, param);
	                                                          }), json)
	                                                  ];
	                                          }), param);
	                            }), param);
	              }), json);
	}

	function _convertNodes(json) {
	  return field("nodes", (function (param) {
	                return array((function (json) {
	                              return /* record */[
	                                      /* name */optimizedOptional((function (param) {
	                                              return optimizedField("name", string, param);
	                                            }), json),
	                                      /* camera */optimizedOptional((function (param) {
	                                              return optimizedField("camera", $$int, param);
	                                            }), json),
	                                      /* mesh */optimizedOptional((function (param) {
	                                              return optimizedField("mesh", $$int, param);
	                                            }), json),
	                                      /* children */optimizedOptional((function (param) {
	                                              return optimizedField("children", (function (param) {
	                                                            return array($$int, param);
	                                                          }), param);
	                                            }), json),
	                                      /* matrix */optimizedOptional((function (param) {
	                                              return optimizedField("matrix", (function (param) {
	                                                            return array($$float, param);
	                                                          }), param);
	                                            }), json),
	                                      /* translation */optimizedOptional((function (param) {
	                                              return optimizedField("translation", (function (param) {
	                                                            return array($$float, param);
	                                                          }), param);
	                                            }), json),
	                                      /* rotation */optimizedOptional((function (param) {
	                                              return optimizedField("rotation", (function (param) {
	                                                            return array($$float, param);
	                                                          }), param);
	                                            }), json),
	                                      /* scale */optimizedOptional((function (param) {
	                                              return optimizedField("scale", (function (param) {
	                                                            return array($$float, param);
	                                                          }), param);
	                                            }), json),
	                                      /* extras */optimizedOptional((function (param) {
	                                              return optimizedField("extras", (function (json) {
	                                                            return /* record */[
	                                                                    /* meshRenderer */optimizedOptional((function (param) {
	                                                                            return optimizedField("meshRenderer", $$int, param);
	                                                                          }), json),
	                                                                    /* basicMaterial */optimizedOptional((function (param) {
	                                                                            return optimizedField("basicMaterial", $$int, param);
	                                                                          }), json),
	                                                                    /* lightMaterial */optimizedOptional((function (param) {
	                                                                            return optimizedField("lightMaterial", $$int, param);
	                                                                          }), json),
	                                                                    /* cameraController */optimizedOptional((function (param) {
	                                                                            return optimizedField("cameraController", $$int, param);
	                                                                          }), json)
	                                                                  ];
	                                                          }), param);
	                                            }), json),
	                                      /* extensions */optional((function (param) {
	                                              return field("extensions", (function (json) {
	                                                            return /* record */[/* khr_lights */optional((function (param) {
	                                                                            return field("KHR_lights", (function (json) {
	                                                                                          return /* record */[/* light */field("light", $$int, json)];
	                                                                                        }), param);
	                                                                          }), json)];
	                                                          }), param);
	                                            }), json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function convert$2(json) {
	  return /* record */[
	          /* asset */_convertAsset(json),
	          /* scenes */_convertScenes(json),
	          /* scene */optional((function (param) {
	                  return field("scene", $$int, param);
	                }), json),
	          /* images */_convertImages(json),
	          /* textures */_convertTextures(json),
	          /* samplers */_convertSamplers(json),
	          /* buffers */_convertBuffers(json),
	          /* bufferViews */_convertBufferViews(json),
	          /* accessors */_convertAccessors(json),
	          /* cameras */_convertCameras(json),
	          /* nodes */_convertNodes(json),
	          /* meshes */_convertMeshes(json),
	          /* materials */_convertMaterials(json),
	          /* extensionsUsed */optional((function (param) {
	                  return field("extensionsUsed", (function (param) {
	                                return array(string, param);
	                              }), param);
	                }), json),
	          /* extensions */_convertExtensions(json),
	          /* extras */_convertExtras(json)
	        ];
	}


	/* No side effect */

	function _convertIMGUI(extras) {
	  if (extras !== undefined) {
	    var imgui = extras[/* imgui */0];
	    if (imgui !== undefined) {
	      var match = imgui;
	      return /* record */[
	              /* imguiFunc */match[/* imguiFunc */0],
	              /* customData */match[/* customData */1]
	            ];
	    } else {
	      return undefined;
	    }
	  }
	  
	}

	function _convertToScene(ambientLightArr, param) {
	  var scene = param[/* scene */2];
	  var scenes = param[/* scenes */1];
	  requireCheck((function () {
	          test(buildAssertMessage("only has one scene", "not"), (function () {
	                  return Operators[/* = */0](scenes.length, 1);
	                }));
	          return test(buildAssertMessage("has one ambientLight at most", "not"), (function () {
	                        return Operators[/* <= */11](ambientLightArr.length, 1);
	                      }));
	        }), getIsDebug(stateData));
	  var scene$1 = scene !== undefined ? scene : 0;
	  var match = getScene(scenes, scene$1);
	  var match$1 = ambientLightArr.length === 1;
	  return /* record */[
	          /* gameObjects */unsafeGet$1(match[/* nodes */0]),
	          /* ambientLight */match$1 ? /* record */[/* color */caml_array_get(ambientLightArr, 0)[/* color */0]] : undefined,
	          /* imgui */_convertIMGUI(match[/* extras */2])
	        ];
	}

	function _getBinBufferByteLength(binBuffer) {
	  return ensureCheck((function (byteLength) {
	                return test(buildAssertMessage("binBuffer aligned with multiple of 4", "not"), (function () {
	                              return Operators[/* = */0](byteLength % 4, 0);
	                            }));
	              }), getIsDebug(stateData), binBuffer.byteLength);
	}

	function _copyUint8ArrayToArrayBuffer(byteOffset, param, dataView) {
	  var uint8Array = param[2];
	  var uint8ArrayAlignedByteLength = param[1];
	  var emptyUint8Data = param[0];
	  var resultByteOffset = byteOffset + uint8ArrayAlignedByteLength | 0;
	  var byteOffset$1 = byteOffset;
	  var uint8ArrayByteLength = uint8Array.length;
	  for(var i = 0 ,i_finish = uint8ArrayAlignedByteLength - 1 | 0; i <= i_finish; ++i){
	    var value = i >= uint8ArrayByteLength ? emptyUint8Data : getUint8_1(i, uint8Array);
	    byteOffset$1 = writeUint8_1(value, byteOffset$1, dataView);
	  }
	  return /* tuple */[
	          resultByteOffset,
	          uint8Array,
	          dataView
	        ];
	}

	function _buildWDBJsonUint8Array(gltf) {
	  var gltf$1 = convert$1(convertMultiPrimitivesToNodes(gltf));
	  var match = convertToLights(gltf$1);
	  var indices = convertToIndices(gltf$1);
	  var encoder = new TextEncoder();
	  return encoder.encode(JSON.stringify(/* record */[
	                  /* asset : record */[
	                    /* version */gltf$1[/* asset */0][/* version */0],
	                    /* generator */getGenerator(/* () */0)
	                  ],
	                  /* scene */_convertToScene(match[0], gltf$1),
	                  /* indices */indices,
	                  /* gameObjects */convert(gltf$1),
	                  /* images */convertToImages(gltf$1),
	                  /* basicSourceTextures */convertToBasicSourceTextures(gltf$1),
	                  /* samplers */convertToSamplers(gltf$1),
	                  /* buffers */convertToBuffers(gltf$1),
	                  /* bufferViews */convertToBufferViews(gltf$1),
	                  /* accessors */convertToAccessors(gltf$1),
	                  /* directionLights */match[1],
	                  /* pointLights */match[2],
	                  /* basicCameraViews */convertToBasicCameraViews(gltf$1),
	                  /* perspectiveCameraProjections */convertToPerspectiveCameraProjections(gltf$1),
	                  /* arcballCameraControllers */convertToArcballCameraControllers(gltf$1),
	                  /* transforms */convertToTransforms(gltf$1),
	                  /* customGeometrys */convertToGeometrys(gltf$1),
	                  /* meshRenderers */convertToMeshRenderers(indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */9], gltf$1),
	                  /* basicMaterials */convertToBasicMaterials(gltf$1),
	                  /* lightMaterials */convertToLightMaterials(gltf$1)
	                ]));
	}

	function _writeHeader(totalByteLength, dataView) {
	  var __x = writeUint32_1(1179937896, 0, dataView);
	  var __x$1 = writeUint32_1(1, __x, dataView);
	  return writeUint32_1(totalByteLength, __x$1, dataView);
	}

	function _writeJson(byteOffset, param, dataView) {
	  var jsonByteLength = param[1];
	  var __x = writeUint32_1(jsonByteLength, byteOffset, dataView);
	  var byteOffset$1 = writeUint32_1(1313821514, __x, dataView);
	  return _copyUint8ArrayToArrayBuffer(byteOffset$1, /* tuple */[
	              param[0],
	              jsonByteLength,
	              param[2]
	            ], dataView);
	}

	function _writeBinaryBuffer(byteOffset, param, dataView) {
	  var binBuffer = param[1];
	  var binBufferByteLength = param[0];
	  requireCheck((function () {
	          test(buildAssertMessage("binBufferByteLength === binBuffer.byteLength", "not"), (function () {
	                  return Operators[/* = */0](binBufferByteLength, binBuffer.byteLength);
	                }));
	          return test(buildAssertMessage("binBuffer aligned with multiple of 4", "not"), (function () {
	                        return Operators[/* = */0](binBufferByteLength % 4, 0);
	                      }));
	        }), getIsDebug(stateData));
	  var __x = writeUint32_1(binBufferByteLength, byteOffset, dataView);
	  var byteOffset$1 = writeUint32_1(5130562, __x, dataView);
	  var binBufferUint8Arr = new Uint8Array(binBuffer);
	  setUint8Array(binBufferUint8Arr, new Uint8Array(dataView.buffer, byteOffset$1, binBufferByteLength / 1 | 0));
	  return /* tuple */[
	          byteOffset$1 + binBufferByteLength | 0,
	          binBufferUint8Arr,
	          dataView
	        ];
	}

	function _getEmptyEncodedUint8Data() {
	  var encoder = new TextEncoder();
	  var emptyUint8DataArr = encoder.encode(" ");
	  return getUint8_1(0, emptyUint8DataArr);
	}

	function _convertGLBToWDB(gltf, binBuffer) {
	  var jsonUint8Array = _buildWDBJsonUint8Array(gltf);
	  var jsonByteLength = alignedLength(jsonUint8Array.byteLength);
	  var binBufferByteLength = _getBinBufferByteLength(binBuffer);
	  var totalByteLength = ((20 + jsonByteLength | 0) + 8 | 0) + binBufferByteLength | 0;
	  var wdb = new ArrayBuffer(totalByteLength);
	  var dataView = create$63(wdb);
	  var byteOffset = _writeHeader(totalByteLength, dataView);
	  var emptyEncodedUint8Data = _getEmptyEncodedUint8Data(/* () */0);
	  var match = _writeJson(byteOffset, /* tuple */[
	        emptyEncodedUint8Data,
	        jsonByteLength,
	        jsonUint8Array
	      ], dataView);
	  _writeBinaryBuffer(match[0], /* tuple */[
	        binBufferByteLength,
	        binBuffer
	      ], match[2]);
	  return wdb;
	}

	function _checkGLB(dataView) {
	  requireCheck((function () {
	          test(buildAssertMessage("Source file to be a GLB (glTF Binary) model", "not"), (function () {
	                  var match = getUint32_1$1(0, dataView);
	                  return Operators[/* = */0](match[0], 1179937895);
	                }));
	          var match = getUint32_1$1(4, dataView);
	          var readVersion = match[0];
	          return test(buildAssertMessage("Only GLB version 2 is supported", "Detected version: " + (String(readVersion) + "")), (function () {
	                        return Operators[/* = */0](readVersion, 2);
	                      }));
	        }), getIsDebug(stateData));
	  return dataView;
	}

	function convertGLBData(param) {
	  return _convertGLBToWDB(convert$2(param[0]), param[1]);
	}

	function convertGLB(glb) {
	  var match = decode(glb, _checkGLB);
	  return convertGLBData(/* tuple */[
	              JSON.parse(match[0]),
	              match[1]
	            ]);
	}


	/* Log-WonderLog Not a pure module */

	var convertGLBToWDB$1 = convertGLB;


	/* ConvertGLBSystem-Wonderjs Not a pure module */

	var getPointDownEventName$2 = getPointDownEventName$1;

	var getPointUpEventName$2 = getPointUpEventName$1;

	var getPointTapEventName$2 = getPointTapEventName$1;

	var getPointMoveEventName$2 = getPointMoveEventName$1;

	var getPointScaleEventName$2 = getPointScaleEventName$1;

	var getPointDragEventName$2 = getPointDragEventName$1;


	/* No side effect */

	function createSparseMap$1() {
	  return createEmpty$2(/* () */0);
	}

	var unsafeGetSparseMapValue$1 = unsafeGet$2;

	var getSparseMapValue$1 = get$3;

	var setSparseMapValue$1 = set$1;


	/* No side effect */

	function isExceedMaxCount$2(lightIndexFromRecord, _) {
	  return lightIndexFromRecord >= getBufferMaxCount(/* () */0);
	}


	/* BufferDirectionLightService-Wonderjs Not a pure module */

	function createPointLight$1(state) {
	  var match = create$26(state[/* pointLightRecord */22]);
	  state[/* pointLightRecord */22] = match[0];
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}

	function unsafeGetPointLightGameObject$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$9(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function getPointLightColor$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return getColor$8(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function setPointLightColor$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setColor$4(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), color, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function getPointLightIntensity$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return getIntensity$4(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function setPointLightIntensity$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setIntensity$2(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), color, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function getPointLightConstant$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return getConstant$2(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function setPointLightConstant$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setConstant$1(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), color, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function getPointLightLinear$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return getLinear$1(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function setPointLightLinear$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setLinear$1(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), color, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function getPointLightQuadratic$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return getQuadratic$2(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function setPointLightQuadratic$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setQuadratic$1(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), color, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function getPointLightRange$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  return getRange$2(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), state[/* pointLightRecord */22]);
	}

	function setPointLightRange$1(light, range, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setRange$1(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), range, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function setPointLightRangeLevel$1(light, level, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$5, state[/* pointLightRecord */22]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* pointLightRecord */22] = setRangeLevel(getMappedIndex(light, getMappedIndexMap$1(state[/* pointLightRecord */22])), level, state[/* pointLightRecord */22]);
	  return newrecord;
	}

	function isExceedMaxCount$1(param) {
	  var pointLightRecord = param[/* pointLightRecord */22];
	  return isExceedMaxCount$2(pointLightRecord[/* index */0], getBufferMaxCount$1(/* () */0));
	}


	/* Contract-WonderLog Not a pure module */

	var getRenderWorkerCustomData$2 = getRenderWorkerCustomData$1;

	var getMainWorkerCustomData$2 = getMainWorkerCustomData$1;

	var setMainWorkerCustomData$2 = setMainWorkerCustomData$1;


	/* No side effect */

	var newBlobFromArrayBuffer = function (arrayBuffer,type_){
	return new Blob([arrayBuffer], {type: type_})
	  };

	var createObjectURL$1 = function (blob){
	     return URL.createObjectURL( blob )
	    };

	var revokeObjectURL$1 = function (blob){
	     URL.revokeObjectURL( blob );
	    };


	/* No side effect */

	var _loadBlobImage$1 = function (objectUrl,errorInfo,resolve,reject){
	        if (typeof window.loadImageBlob_wonder === "undefined") {
	window.loadImageBlob_wonder = function(objectUrl, errorInfo, resolve, reject){
	                    var image = new Image();

	                    image.src = objectUrl;

	                    image.onload = (function () {
	                        return resolve(image);
	                      });

	                    image.onerror = (function (e) {
	                      console.trace();
	                              return reject(new Error(errorInfo));
	                            });
	};
	        }

	window.loadImageBlob_wonder(objectUrl, errorInfo, resolve, reject);
	  };

	function loadBlobImage(objectUrl, errorInfo) {
	  return fromPromise(new Promise((function (resolve, reject) {
	                    return _loadBlobImage$1(objectUrl, errorInfo, resolve, reject);
	                  })));
	}


	/* most Not a pure module */

	function addChildrenToParent(parent, children, param) {
	  return /* tuple */[
	          reduceOneParam((function (parentMap, child) {
	                  return set$1(child, parent, parentMap);
	                }), param[0], children),
	          set$1(parent, children, param[1])
	        ];
	}

	function checkNotDisposedBefore(disposedIndexArray) {
	  return requireCheck((function () {
	                return test(buildAssertMessage("not disposed before", "do"), (function () {
	                              return Operators[/* = */0](disposedIndexArray.length, 0);
	                            }));
	              }), getIsDebug(stateData));
	}


	/* Log-WonderLog Not a pure module */

	function _checkNotExceedMaxCountByIndex(maxCount, indexArr) {
	  checkNotExceedMaxCountByIndex(maxCount, indexArr[indexArr.length - 1 | 0]);
	  return indexArr;
	}

	function _batchCreateGameObject(param, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var count = param[/* gameObjects */3][/* count */0];
	  var uid = gameObjectRecord[/* uid */0];
	  var aliveUidArray = gameObjectRecord[/* aliveUidArray */20];
	  var uidArr = range$1(uid, (uid + count | 0) - 1 | 0);
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(gameObjectRecord);
	  newrecord$1[/* uid */0] = uid + count | 0;
	  newrecord$1[/* aliveUidArray */20] = aliveUidArray.concat(uidArr);
	  newrecord[/* gameObjectRecord */11] = newrecord$1;
	  return /* tuple */[
	          newrecord,
	          uidArr
	        ];
	}

	function _setDefaultChildren$1(indexArr, childMap) {
	  return reduceOneParam((function (childMap, index) {
	                return set$1(index, createEmpty$1(/* () */0), childMap);
	              }), childMap, indexArr);
	}

	function _initTransformDataWhenCreate(indexArr, transformRecord) {
	  var childMap = transformRecord[/* childMap */16];
	  var newrecord = caml_array_dup(transformRecord);
	  newrecord[/* childMap */16] = _setDefaultChildren$1(indexArr, childMap);
	  return newrecord;
	}

	function _batchCreateTransform(param, state) {
	  checkNotDisposedBefore(getRecord$1(state)[/* disposedIndexArray */21]);
	  var transformRecord = getRecord$1(state);
	  var index = transformRecord[/* index */0];
	  var newIndex = index + param[/* transforms */15].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getTransformCount(state[/* settingRecord */1]), range$1(index, newIndex - 1 | 0));
	  transformRecord[/* index */0] = newIndex;
	  var transformRecord$1 = _initTransformDataWhenCreate(indexArr, transformRecord);
	  state[/* transformRecord */12] = reduceOneParam((function (transformRecord, index) {
	          return mark(index, true, transformRecord);
	        }), transformRecord$1, indexArr);
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreateCustomGeometry(param, state) {
	  checkNotDisposedBefore(getRecord$6(state)[/* disposedIndexArray */17]);
	  var customGeometryRecord = getRecord$6(state);
	  var index = customGeometryRecord[/* index */0];
	  var newIndex = index + param[/* customGeometrys */16].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getCustomGeometryCount(state[/* settingRecord */1]), range$1(index, newIndex - 1 | 0));
	  state[/* customGeometryRecord */24] = /* record */[
	    /* index */newIndex,
	    /* buffer */customGeometryRecord[/* buffer */1],
	    /* vertices */customGeometryRecord[/* vertices */2],
	    /* texCoords */customGeometryRecord[/* texCoords */3],
	    /* normals */customGeometryRecord[/* normals */4],
	    /* indices */customGeometryRecord[/* indices */5],
	    /* verticesInfos */customGeometryRecord[/* verticesInfos */6],
	    /* texCoordsInfos */customGeometryRecord[/* texCoordsInfos */7],
	    /* normalsInfos */customGeometryRecord[/* normalsInfos */8],
	    /* indicesInfos */customGeometryRecord[/* indicesInfos */9],
	    /* verticesOffset */customGeometryRecord[/* verticesOffset */10],
	    /* texCoordsOffset */customGeometryRecord[/* texCoordsOffset */11],
	    /* normalsOffset */customGeometryRecord[/* normalsOffset */12],
	    /* indicesOffset */customGeometryRecord[/* indicesOffset */13],
	    /* disposeCount */customGeometryRecord[/* disposeCount */14],
	    /* gameObjectMap */customGeometryRecord[/* gameObjectMap */15],
	    /* groupCountMap */customGeometryRecord[/* groupCountMap */16],
	    /* disposedIndexArray */customGeometryRecord[/* disposedIndexArray */17],
	    /* disposedIndexMap */customGeometryRecord[/* disposedIndexMap */18],
	    /* aliveIndexArray */customGeometryRecord[/* aliveIndexArray */19].concat(indexArr)
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreateMeshRenderer(param, state) {
	  checkNotDisposedBefore(getRecord$2(state)[/* disposedIndexArray */6]);
	  var meshRendererRecord = getRecord$2(state);
	  var index = meshRendererRecord[/* index */0];
	  var newIndex = index + param[/* meshRenderers */17].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getMeshRendererCount(state[/* settingRecord */1]), range$1(index, newIndex - 1 | 0));
	  state[/* meshRendererRecord */25] = /* record */[
	    /* index */newIndex,
	    /* buffer */meshRendererRecord[/* buffer */1],
	    /* drawModes */meshRendererRecord[/* drawModes */2],
	    /* basicMaterialRenderGameObjectMap */meshRendererRecord[/* basicMaterialRenderGameObjectMap */3],
	    /* lightMaterialRenderGameObjectMap */meshRendererRecord[/* lightMaterialRenderGameObjectMap */4],
	    /* gameObjectMap */meshRendererRecord[/* gameObjectMap */5],
	    /* disposedIndexArray */meshRendererRecord[/* disposedIndexArray */6]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreateBasicCameraView(param, state) {
	  var basicCameraViewRecord = state[/* basicCameraViewRecord */14];
	  checkNotDisposedBefore(basicCameraViewRecord[/* disposedIndexArray */2]);
	  var index = basicCameraViewRecord[/* index */0];
	  var newIndex = index + param[/* basicCameraViews */12][/* count */0] | 0;
	  var indexArr = range$1(index, newIndex - 1 | 0);
	  state[/* basicCameraViewRecord */14] = /* record */[
	    /* index */newIndex,
	    /* gameObjectMap */basicCameraViewRecord[/* gameObjectMap */1],
	    /* disposedIndexArray */basicCameraViewRecord[/* disposedIndexArray */2]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreatePerspectiveCameraProjection(param, state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  checkNotDisposedBefore(perspectiveCameraProjectionRecord[/* disposedIndexArray */8]);
	  var index = perspectiveCameraProjectionRecord[/* index */0];
	  var newIndex = index + param[/* perspectiveCameraProjections */13].length | 0;
	  var indexArr = range$1(index, newIndex - 1 | 0);
	  state[/* perspectiveCameraProjectionRecord */15] = /* record */[
	    /* index */newIndex,
	    /* dirtyArray */indexArr,
	    /* pMatrixMap */reduceOneParam((function (pMatrixMap, index) {
	            return setDefaultPMatrix(index, pMatrixMap);
	          }), perspectiveCameraProjectionRecord[/* pMatrixMap */2], indexArr),
	    /* nearMap */perspectiveCameraProjectionRecord[/* nearMap */3],
	    /* farMap */perspectiveCameraProjectionRecord[/* farMap */4],
	    /* fovyMap */perspectiveCameraProjectionRecord[/* fovyMap */5],
	    /* aspectMap */perspectiveCameraProjectionRecord[/* aspectMap */6],
	    /* gameObjectMap */perspectiveCameraProjectionRecord[/* gameObjectMap */7],
	    /* disposedIndexArray */perspectiveCameraProjectionRecord[/* disposedIndexArray */8]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _createArcballCameraControllerOneByOne(param, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  checkNotDisposedBefore(arcballCameraControllerRecord[/* disposedIndexArray */18]);
	  var match = reduceOneParam((function (param, _) {
	          var match = create$32(param[0]);
	          return /* tuple */[
	                  match[0],
	                  push(match[1], param[1])
	                ];
	        }), /* tuple */[
	        arcballCameraControllerRecord,
	        /* array */[]
	      ], param[/* arcballCameraControllers */14]);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* arcballCameraControllerRecord */26] = match[0], newrecord),
	          match[1]
	        ];
	}

	function _batchCreateBasicMaterial(param, state) {
	  var basicMaterialRecord = getRecord$4(state);
	  var index = basicMaterialRecord[/* index */0];
	  checkNotDisposedBefore(basicMaterialRecord[/* disposedIndexArray */10]);
	  var newIndex = index + param[/* basicMaterials */18].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getBasicMaterialCount(state[/* settingRecord */1]), range$1(index, newIndex - 1 | 0));
	  state[/* basicMaterialRecord */16] = /* record */[
	    /* index */newIndex,
	    /* buffer */basicMaterialRecord[/* buffer */1],
	    /* shaderIndices */basicMaterialRecord[/* shaderIndices */2],
	    /* colors */basicMaterialRecord[/* colors */3],
	    /* textureIndices */basicMaterialRecord[/* textureIndices */4],
	    /* mapUnits */basicMaterialRecord[/* mapUnits */5],
	    /* textureCountMap */reduceOneParam((function (textureCountMap, index) {
	            return set$1(index, getDefaultCount(/* () */0), textureCountMap);
	          }), basicMaterialRecord[/* textureCountMap */6], indexArr),
	    /* defaultColor */basicMaterialRecord[/* defaultColor */7],
	    /* gameObjectMap */basicMaterialRecord[/* gameObjectMap */8],
	    /* groupCountMap */basicMaterialRecord[/* groupCountMap */9],
	    /* disposedIndexArray */basicMaterialRecord[/* disposedIndexArray */10],
	    /* nameMap */basicMaterialRecord[/* nameMap */11],
	    /* materialArrayForWorkerInit */basicMaterialRecord[/* materialArrayForWorkerInit */12]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreateLightMaterial(param, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var index = lightMaterialRecord[/* index */0];
	  checkNotDisposedBefore(lightMaterialRecord[/* disposedIndexArray */15]);
	  var newIndex = index + param[/* lightMaterials */19].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getLightMaterialCount(state[/* settingRecord */1]), range$1(index, newIndex - 1 | 0));
	  state[/* lightMaterialRecord */17] = /* record */[
	    /* index */newIndex,
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	    /* specularColors */lightMaterialRecord[/* specularColors */4],
	    /* shininess */lightMaterialRecord[/* shininess */5],
	    /* textureIndices */lightMaterialRecord[/* textureIndices */6],
	    /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	    /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	    /* textureCountMap */reduceOneParam((function (textureCountMap, index) {
	            return set$1(index, getDefaultCount(/* () */0), textureCountMap);
	          }), lightMaterialRecord[/* textureCountMap */9], indexArr),
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreateBasicSourceTextureArr(param, state) {
	  var basicSourceTextureRecord = getRecord$9(state);
	  var index = basicSourceTextureRecord[/* index */0];
	  checkNotDisposedBefore(basicSourceTextureRecord[/* disposedIndexArray */12]);
	  var newIndex = index + param[/* basicSourceTextures */5].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getBasicSourceTextureCount(state[/* settingRecord */1]), range$1(index, newIndex - 1 | 0).map(generateBasicSourceTextureIndex$1));
	  state[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */newIndex,
	    /* wrapSs */basicSourceTextureRecord[/* wrapSs */1],
	    /* wrapTs */basicSourceTextureRecord[/* wrapTs */2],
	    /* magFilters */basicSourceTextureRecord[/* magFilters */3],
	    /* minFilters */basicSourceTextureRecord[/* minFilters */4],
	    /* formats */basicSourceTextureRecord[/* formats */5],
	    /* types */basicSourceTextureRecord[/* types */6],
	    /* isNeedUpdates */basicSourceTextureRecord[/* isNeedUpdates */7],
	    /* flipYs */basicSourceTextureRecord[/* flipYs */8],
	    /* sourceMap */basicSourceTextureRecord[/* sourceMap */9],
	    /* glTextureMap */basicSourceTextureRecord[/* glTextureMap */10],
	    /* bindTextureUnitCacheMap */basicSourceTextureRecord[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */basicSourceTextureRecord[/* disposedIndexArray */12],
	    /* needAddedSourceArray */basicSourceTextureRecord[/* needAddedSourceArray */13],
	    /* needInitedTextureIndexArray */basicSourceTextureRecord[/* needInitedTextureIndexArray */14],
	    /* nameMap */basicSourceTextureRecord[/* nameMap */15]
	  ];
	  var state$1 = reduceOneParam((function (state, index) {
	          return setFlipY$4(index, false, state);
	        }), state, indexArr);
	  return /* tuple */[
	          state$1,
	          indexArr
	        ];
	}

	function _batchCreateDirectionLightArr(param, state) {
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var index = directionLightRecord[/* index */0];
	  var newIndex = index + param[/* directionLights */10].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getBufferMaxCount(/* () */0), range$1(index, newIndex - 1 | 0));
	  state[/* directionLightRecord */21] = /* record */[
	    /* index */newIndex,
	    /* buffer */directionLightRecord[/* buffer */1],
	    /* colors */directionLightRecord[/* colors */2],
	    /* intensities */directionLightRecord[/* intensities */3],
	    /* mappedIndexMap */reduceOneParam((function (mappedIndexMap, index) {
	            return setMappedIndex(index, index, mappedIndexMap);
	          }), directionLightRecord[/* mappedIndexMap */4], indexArr),
	    /* gameObjectMap */directionLightRecord[/* gameObjectMap */5]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function _batchCreatePointLightArr(param, state) {
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var index = pointLightRecord[/* index */0];
	  var newIndex = index + param[/* pointLights */11].length | 0;
	  var indexArr = _checkNotExceedMaxCountByIndex(getBufferMaxCount$1(/* () */0), range$1(index, newIndex - 1 | 0));
	  state[/* pointLightRecord */22] = /* record */[
	    /* index */newIndex,
	    /* buffer */pointLightRecord[/* buffer */1],
	    /* colors */pointLightRecord[/* colors */2],
	    /* intensities */pointLightRecord[/* intensities */3],
	    /* constants */pointLightRecord[/* constants */4],
	    /* linears */pointLightRecord[/* linears */5],
	    /* quadratics */pointLightRecord[/* quadratics */6],
	    /* ranges */pointLightRecord[/* ranges */7],
	    /* mappedIndexMap */reduceOneParam((function (mappedIndexMap, index) {
	            return setMappedIndex(index, index, mappedIndexMap);
	          }), pointLightRecord[/* mappedIndexMap */8], indexArr),
	    /* gameObjectMap */pointLightRecord[/* gameObjectMap */9]
	  ];
	  return /* tuple */[
	          state,
	          indexArr
	        ];
	}

	function batchCreate(wd, state) {
	  var match = _batchCreateGameObject(wd, state);
	  var match$1 = _batchCreateTransform(wd, match[0]);
	  var match$2 = _batchCreateCustomGeometry(wd, match$1[0]);
	  var match$3 = _batchCreateMeshRenderer(wd, match$2[0]);
	  var match$4 = _batchCreateBasicCameraView(wd, match$3[0]);
	  var match$5 = _batchCreatePerspectiveCameraProjection(wd, match$4[0]);
	  var match$6 = _createArcballCameraControllerOneByOne(wd, match$5[0]);
	  var match$7 = _batchCreateBasicMaterial(wd, match$6[0]);
	  var match$8 = _batchCreateLightMaterial(wd, match$7[0]);
	  var match$9 = _batchCreateBasicSourceTextureArr(wd, match$8[0]);
	  var match$10 = _batchCreateDirectionLightArr(wd, match$9[0]);
	  var match$11 = _batchCreatePointLightArr(wd, match$10[0]);
	  return /* tuple */[
	          match$11[0],
	          match[1],
	          /* tuple */[
	            match$1[1],
	            match$2[1],
	            match$3[1],
	            match$4[1],
	            match$5[1],
	            match$6[1],
	            match$7[1],
	            match$8[1],
	            match$10[1],
	            match$11[1]
	          ],
	          match$9[1]
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	function batchSetDirectionLightData(param, directionLightArr, state) {
	  return reduceOneParami((function (state, param, index) {
	                var directionLightRecord = state[/* directionLightRecord */21];
	                var mappedIndex = getMappedIndex(caml_array_get(directionLightArr, index), getMappedIndexMap(directionLightRecord));
	                var newrecord = caml_array_dup(state);
	                newrecord[/* directionLightRecord */21] = setIntensity$3(mappedIndex, param[/* intensity */1], setColor$5(mappedIndex, param[/* color */0], directionLightRecord));
	                return newrecord;
	              }), state, param[/* directionLights */10]);
	}

	function batchSetPointLightData(param, pointLightArr, state) {
	  return reduceOneParami((function (state, param, index) {
	                var pointLightRecord = state[/* pointLightRecord */22];
	                var mappedIndex = getMappedIndex(caml_array_get(pointLightArr, index), getMappedIndexMap$1(pointLightRecord));
	                var newrecord = caml_array_dup(state);
	                newrecord[/* pointLightRecord */22] = setRange$1(mappedIndex, param[/* range */5], setQuadratic$1(mappedIndex, param[/* quadraticAttenuation */4], setLinear$1(mappedIndex, param[/* linearAttenuation */3], setConstant$1(mappedIndex, param[/* constantAttenuation */2], setIntensity$2(mappedIndex, param[/* intensity */1], setColor$4(mappedIndex, param[/* color */0], pointLightRecord))))));
	                return newrecord;
	              }), state, param[/* pointLights */11]);
	}

	function setAmbientLightData(param, state) {
	  var optionalAmbientLight = param[/* scene */1][/* ambientLight */1];
	  var match = isJsonSerializedValueNone(optionalAmbientLight);
	  if (match) {
	    return state;
	  } else {
	    var match$1 = unsafeGetJsonSerializedValue(optionalAmbientLight);
	    return setAmbientLightColor$1(match$1[/* color */0], state);
	  }
	}


	/* SceneAPI-Wonderjs Not a pure module */

	function _batchSetNewMap(param, param$1, param$2) {
	  var textureCountPerMaterial = param$2[0];
	  var setTextureIndexFunc = param$1[1];
	  var setMapUnitFunc = param$1[0];
	  var mapCount = param[2];
	  var textureArr = param[1];
	  var newTextureCount = mapCount + 1 | 0;
	  return reduceOneParami((function (param, material, index) {
	                var texture = textureArr[index];
	                return /* tuple */[
	                        setTextureIndexFunc(/* tuple */[
	                              material,
	                              mapCount,
	                              textureCountPerMaterial
	                            ], texture, param[0]),
	                        setMapUnitFunc(material, mapCount, param[1]),
	                        setCount(material, newTextureCount, param[2])
	                      ];
	              }), /* tuple */[
	              param$2[1],
	              param$2[2],
	              param$2[3]
	            ], param[0]);
	}

	function _batchSetNewDiffueMaps(diffuseMapLightMaterials, lightMaterialDiffuseMaps, state) {
	  var lightMaterialRecord = getRecord$5(state);
	  var match = _batchSetNewMap(/* tuple */[
	        diffuseMapLightMaterials,
	        lightMaterialDiffuseMaps,
	        0
	      ], /* tuple */[
	        setDiffuseMapUnit,
	        setTextureIndex$2
	      ], /* tuple */[
	        getTextureCountPerMaterial(state[/* settingRecord */1]),
	        lightMaterialRecord[/* textureIndices */6],
	        lightMaterialRecord[/* diffuseMapUnits */7],
	        lightMaterialRecord[/* textureCountMap */9]
	      ]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* lightMaterialRecord */17] = /* record */[
	    /* index */lightMaterialRecord[/* index */0],
	    /* buffer */lightMaterialRecord[/* buffer */1],
	    /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	    /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	    /* specularColors */lightMaterialRecord[/* specularColors */4],
	    /* shininess */lightMaterialRecord[/* shininess */5],
	    /* textureIndices */match[0],
	    /* diffuseMapUnits */match[1],
	    /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8],
	    /* textureCountMap */match[2],
	    /* defaultDiffuseColor */lightMaterialRecord[/* defaultDiffuseColor */10],
	    /* defaultSpecularColor */lightMaterialRecord[/* defaultSpecularColor */11],
	    /* defaultShininess */lightMaterialRecord[/* defaultShininess */12],
	    /* gameObjectMap */lightMaterialRecord[/* gameObjectMap */13],
	    /* groupCountMap */lightMaterialRecord[/* groupCountMap */14],
	    /* disposedIndexArray */lightMaterialRecord[/* disposedIndexArray */15],
	    /* nameMap */lightMaterialRecord[/* nameMap */16],
	    /* materialArrayForWorkerInit */lightMaterialRecord[/* materialArrayForWorkerInit */17]
	  ];
	  return newrecord;
	}

	function _batchSetBasicSourceTextureData(samplerBasicSourceTextures, arrayBufferViewSourceTextureSamplers, state) {
	  return reduceOneParami((function (state, arrayBufferViewSourceTexture, index) {
	                var match = arrayBufferViewSourceTextureSamplers[index];
	                return setMinFilter$2(arrayBufferViewSourceTexture, match[/* minFilter */1], setMagFilter$2(arrayBufferViewSourceTexture, match[/* magFilter */0], setWrapT$2(arrayBufferViewSourceTexture, match[/* wrapT */3], setWrapS$2(arrayBufferViewSourceTexture, match[/* wrapS */2], state))));
	              }), state, samplerBasicSourceTextures);
	}

	function _batchSetBasicSourceTextureSources(imageBasicSourceTextures, basicSourceTextureImages, state) {
	  return reduceOneParami((function (state, basicSourceTexture, index) {
	                var image = basicSourceTextureImages[index];
	                return setSource$1(basicSourceTexture, image, state);
	              }), state, imageBasicSourceTextures);
	}

	function batchSet(param, state) {
	  var match = param[2];
	  var match$1 = param[1];
	  var match$2 = param[0];
	  return _batchSetBasicSourceTextureSources(match[0], match[1], _batchSetBasicSourceTextureData(match$1[0], match$1[1], _batchSetNewDiffueMaps(match$2[0], match$2[1], state)));
	}

	function batchSetFormat(basicSourceTextureArr, basicSourceTextures, state) {
	  return reduceOneParami((function (state, basicSourceTexture, index) {
	                return setFormat$2(basicSourceTexture, basicSourceTextures[index][/* format */1], state);
	              }), state, basicSourceTextureArr);
	}


	/* ArrayService-WonderCommonlib Not a pure module */

	function getIndices$2(index, state) {
	  var match = getRecord$6(state);
	  return getUint16PointData(getInfoIndex(index), match[/* indices */5], match[/* indicesInfos */9]);
	}

	function setIndicesByTypeArray(index, data, state) {
	  var record = getRecord$6(state);
	  var indices = record[/* indices */5];
	  var indicesOffset = record[/* indicesOffset */13];
	  record[/* indicesOffset */13] = setUint16PointData(/* tuple */[
	        getInfoIndex(index),
	        record[/* indicesInfos */9],
	        indicesOffset,
	        data.length
	      ], (function (param) {
	          return fillUint16ArrayWithOffset(indices, data, param);
	        }));
	  return state;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getNormals$2(index, state) {
	  var match = getRecord$6(state);
	  return getFloat32PointData(getInfoIndex(index), match[/* normals */4], match[/* normalsInfos */8]);
	}

	function setNormalsByTypeArray(index, data, state) {
	  var record = getRecord$6(state);
	  var normals = record[/* normals */4];
	  var normalsOffset = record[/* normalsOffset */12];
	  record[/* normalsOffset */12] = setFloat32PointData(/* tuple */[
	        getInfoIndex(index),
	        record[/* normalsInfos */8],
	        normalsOffset,
	        data.length
	      ], (function (param) {
	          return fillFloat32ArrayWithOffset(normals, data, param);
	        }));
	  return state;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getName$4(texture, state) {
	  return getName$1(texture, getRecord$9(state)[/* nameMap */15]);
	}

	function unsafeGetName$4(texture, state) {
	  return unsafeGetName$1(texture, getRecord$9(state)[/* nameMap */15]);
	}

	function setName$4(texture, name, state) {
	  var record = getRecord$9(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */record[/* index */0],
	    /* wrapSs */record[/* wrapSs */1],
	    /* wrapTs */record[/* wrapTs */2],
	    /* magFilters */record[/* magFilters */3],
	    /* minFilters */record[/* minFilters */4],
	    /* formats */record[/* formats */5],
	    /* types */record[/* types */6],
	    /* isNeedUpdates */record[/* isNeedUpdates */7],
	    /* flipYs */record[/* flipYs */8],
	    /* sourceMap */record[/* sourceMap */9],
	    /* glTextureMap */record[/* glTextureMap */10],
	    /* bindTextureUnitCacheMap */record[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */record[/* disposedIndexArray */12],
	    /* needAddedSourceArray */record[/* needAddedSourceArray */13],
	    /* needInitedTextureIndexArray */record[/* needInitedTextureIndexArray */14],
	    /* nameMap */setName$1(texture, name, record[/* nameMap */15])
	  ];
	  return newrecord;
	}


	/* NameService-Wonderjs Not a pure module */

	function getVertices$2(index, state) {
	  var match = getRecord$6(state);
	  return getFloat32PointData(getInfoIndex(index), match[/* vertices */2], match[/* verticesInfos */6]);
	}

	function setVerticesByTypeArray(index, data, state) {
	  var record = getRecord$6(state);
	  var vertices = record[/* vertices */2];
	  var verticesOffset = record[/* verticesOffset */10];
	  record[/* verticesOffset */10] = setFloat32PointData(/* tuple */[
	        getInfoIndex(index),
	        record[/* verticesInfos */6],
	        verticesOffset,
	        data.length
	      ], (function (param) {
	          return fillFloat32ArrayWithOffset(vertices, data, param);
	        }));
	  return state;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function getTexCoords$2(index, state) {
	  var match = getRecord$6(state);
	  return getFloat32PointData(getInfoIndex(index), match[/* texCoords */3], match[/* texCoordsInfos */7]);
	}

	function setTexCoordsByTypeArray(index, data, state) {
	  var record = getRecord$6(state);
	  var texCoords = record[/* texCoords */3];
	  var texCoordsOffset = record[/* texCoordsOffset */11];
	  record[/* texCoordsOffset */11] = setFloat32PointData(/* tuple */[
	        getInfoIndex(index),
	        record[/* texCoordsInfos */7],
	        texCoordsOffset,
	        data.length
	      ], (function (param) {
	          return fillFloat32ArrayWithOffset(texCoords, data, param);
	        }));
	  return state;
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _getBatchArrByIndices(sourceArr, indices) {
	  return indices.map((function (index) {
	                return sourceArr[index];
	              }));
	}

	function _getBatchComponentGameObjectData(param, indices, _, state) {
	  var transformArr = param[1];
	  var gameObjectArr = param[0];
	  var parentTransforms = _getBatchArrByIndices(transformArr, indices[/* gameObjectIndices */0][/* childrenTransformIndexData */0][/* parentTransformIndices */0]);
	  var childrenTransforms = indices[/* gameObjectIndices */0][/* childrenTransformIndexData */0][/* childrenTransformIndices */1].map((function (childrenIndices) {
	          return childrenIndices.map((function (index) {
	                        return transformArr[index];
	                      }));
	        }));
	  var transformGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* transformGameObjectIndexData */1][/* gameObjectIndices */0]);
	  var gameObjectTransforms = _getBatchArrByIndices(transformArr, indices[/* gameObjectIndices */0][/* transformGameObjectIndexData */1][/* componentIndices */1]);
	  var customGeometryGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */9][/* gameObjectIndices */0]);
	  var gameObjectCustomGeometrys = _getBatchArrByIndices(param[2], indices[/* gameObjectIndices */0][/* customGeometryGameObjectIndexData */9][/* componentIndices */1]);
	  var meshRendererGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* meshRendererGameObjectIndexData */10][/* gameObjectIndices */0]);
	  var gameObjectMeshRenderers = _getBatchArrByIndices(param[3], indices[/* gameObjectIndices */0][/* meshRendererGameObjectIndexData */10][/* componentIndices */1]);
	  var basicMaterialGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* basicMaterialGameObjectIndexData */5][/* gameObjectIndices */0]);
	  var gameObjectBasicMaterials = _getBatchArrByIndices(param[7], indices[/* gameObjectIndices */0][/* basicMaterialGameObjectIndexData */5][/* componentIndices */1]);
	  var lightMaterialGameObjects = _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* lightMaterialGameObjectIndexData */6][/* gameObjectIndices */0]);
	  var gameObjectLightMaterials = _getBatchArrByIndices(param[8], indices[/* gameObjectIndices */0][/* lightMaterialGameObjectIndexData */6][/* componentIndices */1]);
	  return /* tuple */[
	          /* tuple */[
	            parentTransforms,
	            childrenTransforms,
	            transformGameObjects,
	            gameObjectTransforms,
	            customGeometryGameObjects,
	            gameObjectCustomGeometrys,
	            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* basicCameraViewGameObjectIndexData */2][/* gameObjectIndices */0]),
	            _getBatchArrByIndices(param[4], indices[/* gameObjectIndices */0][/* basicCameraViewGameObjectIndexData */2][/* componentIndices */1]),
	            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* perspectiveCameraProjectionGameObjectIndexData */3][/* gameObjectIndices */0]),
	            _getBatchArrByIndices(param[5], indices[/* gameObjectIndices */0][/* perspectiveCameraProjectionGameObjectIndexData */3][/* componentIndices */1]),
	            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* arcballCameraControllerGameObjectIndexData */4][/* gameObjectIndices */0]),
	            _getBatchArrByIndices(param[6], indices[/* gameObjectIndices */0][/* arcballCameraControllerGameObjectIndexData */4][/* componentIndices */1]),
	            basicMaterialGameObjects,
	            gameObjectBasicMaterials,
	            lightMaterialGameObjects,
	            gameObjectLightMaterials,
	            meshRendererGameObjects,
	            gameObjectMeshRenderers,
	            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* directionLightGameObjectIndexData */7][/* gameObjectIndices */0]),
	            _getBatchArrByIndices(param[9], indices[/* gameObjectIndices */0][/* directionLightGameObjectIndexData */7][/* componentIndices */1]),
	            _getBatchArrByIndices(gameObjectArr, indices[/* gameObjectIndices */0][/* pointLightGameObjectIndexData */8][/* gameObjectIndices */0]),
	            _getBatchArrByIndices(param[10], indices[/* gameObjectIndices */0][/* pointLightGameObjectIndexData */8][/* componentIndices */1])
	          ],
	          state
	        ];
	}

	function _getBatchTextureData(lightMaterialArr, textureArr, imageArr, param) {
	  var indices = param[/* indices */2];
	  return /* tuple */[
	          /* tuple */[
	            _getBatchArrByIndices(lightMaterialArr, indices[/* materialIndices */1][/* diffuseMapMaterialIndices */0][/* materialIndices */0]),
	            _getBatchArrByIndices(textureArr, indices[/* materialIndices */1][/* diffuseMapMaterialIndices */0][/* mapIndices */1])
	          ],
	          /* tuple */[
	            _getBatchArrByIndices(textureArr, indices[/* samplerTextureIndices */3][/* textureIndices */0]),
	            _getBatchArrByIndices(param[/* samplers */6], indices[/* samplerTextureIndices */3][/* samplerIndices */1])
	          ],
	          /* tuple */[
	            _getBatchArrByIndices(textureArr, indices[/* imageTextureIndices */2][/* textureIndices */0]),
	            _getBatchArrByIndices(imageArr, indices[/* imageTextureIndices */2][/* imageIndices */1])
	          ]
	        ];
	}

	var _getBatchAllTypeTextureData = _getBatchTextureData;

	function _getAccessorTypeSize(param) {
	  switch (param[/* type_ */4]) {
	    case 0 : 
	        return 1;
	    case 1 : 
	        return 2;
	    case 2 : 
	        return 3;
	    case 3 : 
	    case 4 : 
	        return 4;
	    case 5 : 
	        return 9;
	    case 6 : 
	        return 16;
	    
	  }
	}

	function _getBufferData(param, param$1) {
	  var bytes_per_element = param$1[2];
	  var accessorIndex = param$1[0];
	  var accessors = param[/* accessors */9];
	  var bufferViews = param[/* bufferViews */8];
	  requireCheck((function () {
	          return test(buildAssertMessage("not support interleaved buffer data", "is interleaved"), (function () {
	                        var accessor = accessors[accessorIndex];
	                        var match = bufferViews[accessor[/* bufferView */0]];
	                        var byteStride = match[/* byteStride */3];
	                        var match$1 = isJsonSerializedValueNone(byteStride);
	                        if (match$1) {
	                          return /* () */0;
	                        } else {
	                          return Operators[/* = */0](unsafeGetJsonSerializedValue(byteStride), imul(_getAccessorTypeSize(accessor), bytes_per_element));
	                        }
	                      }));
	        }), getIsDebug(stateData));
	  var accessor = accessors[accessorIndex];
	  var bufferView = bufferViews[accessor[/* bufferView */0]];
	  var dataView = param$1[1][bufferView[/* buffer */0]];
	  var offset = accessor[/* byteOffset */1] + bufferView[/* byteOffset */1] | 0;
	  return /* tuple */[
	          dataView.buffer,
	          offset,
	          imul(accessor[/* count */2], _getAccessorTypeSize(accessor))
	        ];
	}

	function _getBufferPointData(param, fromBufferRangeFunc) {
	  var match = _getBufferData(param[3], /* tuple */[
	        param[0],
	        param[2],
	        param[1]
	      ]);
	  return _3(fromBufferRangeFunc, match[0], match[1], match[2]);
	}

	function _getBufferAttributeData(accessorIndex, dataViewArr, wd) {
	  return _getBufferPointData(/* tuple */[
	              accessorIndex,
	              Float32Array.BYTES_PER_ELEMENT,
	              dataViewArr,
	              wd
	            ], (function (prim, prim$1, prim$2) {
	                return new Float32Array(prim, prim$1, prim$2);
	              }));
	}

	function _getBufferIndexData(accessorIndex, dataViewArr, wd) {
	  return _getBufferPointData(/* tuple */[
	              accessorIndex,
	              Uint16Array.BYTES_PER_ELEMENT,
	              dataViewArr,
	              wd
	            ], (function (prim, prim$1, prim$2) {
	                return new Uint16Array(prim, prim$1, prim$2);
	              }));
	}

	function _batchSetCustomGeometryData(wd, customGeometryArr, bufferArr, state) {
	  var dataViewArr = bufferArr.map(create$63);
	  return reduceOneParami((function (state, geometryData, geometryIndex) {
	                var match = isJsonSerializedValueNone(geometryData);
	                if (match) {
	                  return state;
	                } else {
	                  var match$1 = unsafeGetJsonSerializedValue(geometryData);
	                  var texCoord = match$1[/* texCoord */2];
	                  var normal = match$1[/* normal */1];
	                  var customGeometry = customGeometryArr[geometryIndex];
	                  var state$1 = setVerticesByTypeArray(customGeometry, _getBufferAttributeData(match$1[/* position */0], dataViewArr, wd), state);
	                  var match$2 = isJsonSerializedValueNone(normal);
	                  var state$2 = match$2 ? state$1 : setNormalsByTypeArray(customGeometry, _getBufferAttributeData(unsafeGetJsonSerializedValue(normal), dataViewArr, wd), state$1);
	                  var match$3 = isJsonSerializedValueNone(texCoord);
	                  var state$3 = match$3 ? state$2 : setTexCoordsByTypeArray(customGeometry, _getBufferAttributeData(unsafeGetJsonSerializedValue(texCoord), dataViewArr, wd), state$2);
	                  return setIndicesByTypeArray(customGeometry, _getBufferIndexData(match$1[/* index */3], dataViewArr, wd), state$3);
	                }
	              }), state, wd[/* customGeometrys */16]);
	}

	function _batchSetTransformParent(parentTransforms, childrenTransforms, state) {
	  var transformRecord = getRecord$1(state);
	  var parentMap = transformRecord[/* parentMap */15];
	  var childMap = transformRecord[/* childMap */16];
	  var match = reduceOneParami((function (hierachyDataTuple, parentTransform, index) {
	          return addChildrenToParent(parentTransform, childrenTransforms[index], hierachyDataTuple);
	        }), /* tuple */[
	        parentMap,
	        childMap
	      ], parentTransforms);
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(transformRecord);
	  newrecord[/* transformRecord */12] = (newrecord$1[/* parentMap */15] = match[0], newrecord$1[/* childMap */16] = match[1], newrecord$1);
	  return newrecord;
	}

	function _batchSetTransformData(param, gameObjectTransforms, state) {
	  var transforms = param[/* transforms */15];
	  var transformRecord = getRecord$1(state);
	  var localPositions = transformRecord[/* localPositions */3];
	  var localRotations = transformRecord[/* localRotations */4];
	  var localScales = transformRecord[/* localScales */5];
	  var newrecord = caml_array_dup(state);
	  var newrecord$1 = caml_array_dup(transformRecord);
	  newrecord[/* transformRecord */12] = (newrecord$1[/* localPositions */3] = reduceOneParami((function (localPositions, param, index) {
	            var translation = param[/* translation */0];
	            var match = isJsonSerializedValueNone(translation);
	            if (match) {
	              return localPositions;
	            } else {
	              var transform = caml_array_get(gameObjectTransforms, index);
	              return setLocalPositionByTuple(transform, unsafeGetJsonSerializedValue(translation), localPositions);
	            }
	          }), localPositions, transforms), newrecord$1[/* localRotations */4] = reduceOneParami((function (localRotations, param, index) {
	            var rotation = param[/* rotation */1];
	            var match = isJsonSerializedValueNone(rotation);
	            if (match) {
	              return localRotations;
	            } else {
	              var transform = caml_array_get(gameObjectTransforms, index);
	              return setLocalRotationByTuple(transform, unsafeGetJsonSerializedValue(rotation), localRotations);
	            }
	          }), localRotations, transforms), newrecord$1[/* localScales */5] = reduceOneParami((function (localScales, param, index) {
	            var scale = param[/* scale */2];
	            var match = isJsonSerializedValueNone(scale);
	            if (match) {
	              return localScales;
	            } else {
	              var transform = caml_array_get(gameObjectTransforms, index);
	              return setLocalScaleByTuple(transform, unsafeGetJsonSerializedValue(scale), localScales);
	            }
	          }), localScales, transforms), newrecord$1);
	  return newrecord;
	}

	function _batchSetPerspectiveCameraProjectionData(param, perspectiveCameraProjectionArr, state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  reduceOneParami((function (perspectiveCameraProjectionRecord, param, index) {
	          var aspect = param[/* aspect */3];
	          var far = param[/* far */1];
	          var cameraProjection = caml_array_get(perspectiveCameraProjectionArr, index);
	          var perspectiveCameraProjectionRecord$1 = setNear(cameraProjection, param[/* near */0], perspectiveCameraProjectionRecord);
	          var match = isJsonSerializedValueNone(far);
	          var perspectiveCameraProjectionRecord$2 = match ? setFar(cameraProjection, getInfiniteFar(/* () */0), perspectiveCameraProjectionRecord$1) : setFar(cameraProjection, unsafeGetJsonSerializedValue(far), perspectiveCameraProjectionRecord$1);
	          var perspectiveCameraProjectionRecord$3 = setFovy(cameraProjection, param[/* fovy */2], perspectiveCameraProjectionRecord$2);
	          var match$1 = isJsonSerializedValueNone(aspect);
	          if (match$1) {
	            return perspectiveCameraProjectionRecord$3;
	          } else {
	            return setAspect(cameraProjection, unsafeGetJsonSerializedValue(aspect), perspectiveCameraProjectionRecord$3);
	          }
	        }), perspectiveCameraProjectionRecord, param[/* perspectiveCameraProjections */13]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = perspectiveCameraProjectionRecord;
	  return newrecord;
	}

	function _batchSetArcballCameraControllerData(param, arcballCameraControllerArr, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  reduceOneParami((function (arcballCameraControllerRecord, param, index) {
	          var cameraController = caml_array_get(arcballCameraControllerArr, index);
	          return setWheelSpeed(cameraController, param[/* wheelSpeed */9], setRotateSpeed(cameraController, param[/* rotateSpeed */8], setMoveSpeedY(cameraController, param[/* moveSpeedY */7], setMoveSpeedX(cameraController, param[/* moveSpeedX */6], setTarget(cameraController, param[/* target */5], setThetaMargin(cameraController, param[/* thetaMargin */4], setTheta(cameraController, param[/* theta */3], setPhi(cameraController, param[/* phi */2], setDistance(cameraController, param[/* distance */0], setMinDistance(cameraController, param[/* minDistance */1], arcballCameraControllerRecord))))))))));
	        }), arcballCameraControllerRecord, param[/* arcballCameraControllers */14]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = arcballCameraControllerRecord;
	  return newrecord;
	}

	function _batchSetMeshRendererData(param, meshRendererArr, state) {
	  return reduceOneParami((function (state, meshRendererData, index) {
	                var match = isJsonSerializedValueNone(meshRendererData);
	                if (match) {
	                  return state;
	                } else {
	                  var match$1 = unsafeGetJsonSerializedValue(meshRendererData);
	                  var meshRenderer = caml_array_get(meshRendererArr, index);
	                  return setDrawMode$1(meshRenderer, match$1[/* drawMode */0], state);
	                }
	              }), state, param[/* meshRenderers */17]);
	}

	function _batchSetBasicMaterialData(param, basicMaterialArr, state) {
	  return reduceOneParami((function (state, param, index) {
	                var material = caml_array_get(basicMaterialArr, index);
	                return setName$2(material, param[/* name */1], setColor$3(material, param[/* color */0], state));
	              }), state, param[/* basicMaterials */18]);
	}

	function _batchSetLightMaterialData(param, lightMaterialArr, state) {
	  return reduceOneParami((function (state, param, index) {
	                var material = caml_array_get(lightMaterialArr, index);
	                return setName$3(material, param[/* name */1], setDiffuseColor$1(material, param[/* diffuseColor */0], state));
	              }), state, param[/* lightMaterials */19]);
	}

	function _batchSetGameObjectName(targets, names, setNameFunc, state) {
	  return reduceOneParami((function (state, target, index) {
	                return setNameFunc(target, names[index], state);
	              }), state, targets);
	}

	function _batchSetTextureName(basicSourceTextureArr, basicSourceTextures, state) {
	  return reduceOneParami((function (state, basicSourceTexture, index) {
	                return setName$4(basicSourceTexture, basicSourceTextures[index][/* name */0], state);
	              }), state, basicSourceTextureArr);
	}

	function _batchSetNames(param, param$1, state) {
	  return _batchSetTextureName(param[1], param$1[1], _batchSetGameObjectName(param[0], param$1[0][/* names */1], setName, state));
	}

	function batchOperate(wd, blobObjectUrlImageArr, bufferArr, param) {
	  var basicSourceTextureArr = param[3];
	  var match = param[2];
	  var pointLightArr = match[9];
	  var directionLightArr = match[8];
	  var lightMaterialArr = match[7];
	  var basicMaterialArr = match[6];
	  var arcballCameraControllerArr = match[5];
	  var perspectiveCameraProjectionArr = match[4];
	  var meshRendererArr = match[2];
	  var customGeometryArr = match[1];
	  var gameObjectArr = param[1];
	  var basicSourceTextures = wd[/* basicSourceTextures */5];
	  var state = _batchSetNames(/* tuple */[
	        gameObjectArr,
	        basicSourceTextureArr
	      ], /* tuple */[
	        wd[/* gameObjects */3],
	        basicSourceTextures
	      ], param[0]);
	  var match$1 = _getBatchComponentGameObjectData(/* tuple */[
	        gameObjectArr,
	        match[0],
	        customGeometryArr,
	        meshRendererArr,
	        match[3],
	        perspectiveCameraProjectionArr,
	        arcballCameraControllerArr,
	        basicMaterialArr,
	        lightMaterialArr,
	        directionLightArr,
	        pointLightArr
	      ], wd[/* indices */2], wd, state);
	  var match$2 = match$1[0];
	  var gameObjectTransforms = match$2[3];
	  var state$1 = batchSetFormat(basicSourceTextureArr, basicSourceTextures, match$1[1]);
	  var basicSourceTextureData = _getBatchAllTypeTextureData(lightMaterialArr, basicSourceTextureArr, blobObjectUrlImageArr, wd);
	  return /* tuple */[
	          batchSet(basicSourceTextureData, batchAddPointLightComponentForCreate(match$2[20], match$2[21], batchAddDirectionLightComponentForCreate(match$2[18], match$2[19], batchAddMeshRendererComponentForCreate(match$2[16], match$2[17], batchAddLightMaterialComponentForCreate(match$2[14], match$2[15], batchAddBasicMaterialComponentForCreate(match$2[12], match$2[13], batchAddArcballCameraControllerComponentForCreate(match$2[10], match$2[11], batchAddPerspectiveCameraProjectionComponentForCreate(match$2[8], match$2[9], batchAddBasicCameraViewComponentForCreate(match$2[6], match$2[7], batchAddCustomGeometryComponentForCreate(match$2[4], match$2[5], batchAddTransformComponentForCreate(match$2[2], gameObjectTransforms, setAmbientLightData(wd, batchSetPointLightData(wd, pointLightArr, batchSetDirectionLightData(wd, directionLightArr, _batchSetLightMaterialData(wd, lightMaterialArr, _batchSetBasicMaterialData(wd, basicMaterialArr, _batchSetMeshRendererData(wd, meshRendererArr, _batchSetArcballCameraControllerData(wd, arcballCameraControllerArr, _batchSetPerspectiveCameraProjectionData(wd, perspectiveCameraProjectionArr, _batchSetCustomGeometryData(wd, customGeometryArr, bufferArr, _batchSetTransformParent(match$2[0], match$2[1], _batchSetTransformData(wd, gameObjectTransforms, state$1)))))))))))))))))))))),
	          gameObjectArr
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function setIMGUIFunc$4(param, state) {
	  var scene = param[/* scene */1];
	  var match = isJsonSerializedValueNone(scene[/* imgui */2]);
	  if (match) {
	    return state;
	  } else {
	    var match$1 = unsafeGetJsonSerializedValue(scene[/* imgui */2]);
	    return setIMGUIFunc$1(match$1[/* customData */1], deserializeFunction(match$1[/* imguiFunc */0]), state);
	  }
	}


	/* OptionService-Wonderjs Not a pure module */

	function build$1(param, param$1) {
	  var state = param$1[0];
	  var scene = param[/* scene */1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var gameObjectArr = param$1[1];
	  var gameObjects = scene[/* gameObjects */0];
	  var match = gameObjects.length;
	  if (match !== 1) {
	    var match$1 = create$4(state);
	    var gameObject = match$1[1];
	    var state$1 = match$1[0];
	    var transformRecord = getRecord$1(state$1);
	    var parentMap = transformRecord[/* parentMap */15];
	    var childMap = transformRecord[/* childMap */16];
	    var match$2 = addChildrenToParent(unsafeGetTransformComponent(gameObject, gameObjectRecord), scene[/* gameObjects */0].map((function (gameObjectIndex) {
	                return unsafeGetTransformComponent(gameObjectArr[gameObjectIndex], gameObjectRecord);
	              })), /* tuple */[
	          parentMap,
	          childMap
	        ]);
	    var newrecord = caml_array_dup(state$1);
	    var newrecord$1 = caml_array_dup(transformRecord);
	    newrecord[/* transformRecord */12] = (newrecord$1[/* parentMap */15] = match$2[0], newrecord$1[/* childMap */16] = match$2[1], newrecord$1);
	    return /* tuple */[
	            newrecord,
	            gameObject
	          ];
	  } else {
	    return /* tuple */[
	            state,
	            gameObjectArr[caml_array_get(gameObjects, 0)]
	          ];
	  }
	}


	/* AssembleCommon-Wonderjs Not a pure module */

	function _getArrayBuffer(binBuffer, bufferView, bufferViews) {
	  var match = bufferViews[bufferView];
	  var byteOffset = match[/* byteOffset */1];
	  return binBuffer.slice(byteOffset, byteOffset + match[/* byteLength */2] | 0);
	}

	function _buildImageArray(param, binBuffer) {
	  var bufferViews = param[/* bufferViews */8];
	  var images = param[/* images */4];
	  var blobObjectUrlImageArr = /* array */[];
	  var match = isJsonSerializedValueNone(images);
	  return drain(mergeArray(match ? blobObjectUrlImageArr : reduceOneParami((function (streamArr, param, imageIndex) {
	                            var arrayBuffer = _getArrayBuffer(binBuffer, param[/* bufferView */0], bufferViews);
	                            var blob = newBlobFromArrayBuffer(arrayBuffer, param[/* mimeType */1]);
	                            return push(tap((function (image) {
	                                              revokeObjectURL$1(blob);
	                                              push(image, blobObjectUrlImageArr);
	                                              return /* () */0;
	                                            }), loadBlobImage(createObjectURL$1(blob), "load image error. imageIndex: " + (String(imageIndex) + ""))), streamArr);
	                          }), /* array */[], unsafeGetJsonSerializedValue(images)))).then((function () {
	                return Promise.resolve(blobObjectUrlImageArr);
	              }));
	}

	function _buildBufferArray(buffers, binBuffer) {
	  requireCheck((function () {
	          var bufferLen = buffers.length;
	          return test(buildAssertMessage("has only one buffer", "has " + (String(bufferLen) + "")), (function () {
	                        return Operators[/* = */0](bufferLen, 1);
	                      }));
	        }), getIsDebug(stateData));
	  return /* array */[binBuffer];
	}

	function _checkWDB(dataView) {
	  requireCheck((function () {
	          test(buildAssertMessage("Source file to be a WDB (wd Binary) model", "not"), (function () {
	                  var match = getUint32_1$1(0, dataView);
	                  return Operators[/* = */0](match[0], 1179937896);
	                }));
	          var match = getUint32_1$1(4, dataView);
	          var readVersion = match[0];
	          return test(buildAssertMessage("Only WDB version 1 is supported", "Detected version: " + (String(readVersion) + "")), (function () {
	                        return Operators[/* = */0](readVersion, 1);
	                      }));
	        }), getIsDebug(stateData));
	  return dataView;
	}

	function assembleGLBData(wd, binBuffer, state) {
	  var buffers = wd[/* buffers */7];
	  return fromPromise(_buildImageArray(wd, binBuffer).then((function (blobObjectUrlImageArr) {
	                    return Promise.resolve(build$1(wd, batchOperate(wd, blobObjectUrlImageArr, _buildBufferArray(buffers, binBuffer), batchCreate(wd, setIMGUIFunc$4(wd, state)))));
	                  })));
	}

	function assemble(wdb, state) {
	  var match = decode(wdb, _checkWDB);
	  return assembleGLBData(JSON.parse(match[0]), match[1], state);
	}


	/* most Not a pure module */

	function assembleGLB$1(glb, state) {
	  return assemble(convertGLB(glb), state);
	}

	var assembleWDB$1 = assemble;


	/* ConvertGLBSystem-Wonderjs Not a pure module */

	function create$64(record) {
	  var disposedIndexArray = record[/* disposedIndexArray */7];
	  var match = generateIndex(record[/* index */0], disposedIndexArray);
	  return /* tuple */[
	          /* record */[
	            /* index */match[1],
	            /* vertices */record[/* vertices */1],
	            /* texCoords */record[/* texCoords */2],
	            /* normals */record[/* normals */3],
	            /* indices */record[/* indices */4],
	            /* gameObjectMap */record[/* gameObjectMap */5],
	            /* groupCountMap */record[/* groupCountMap */6],
	            /* disposedIndexArray */record[/* disposedIndexArray */7]
	          ],
	          match[0]
	        ];
	}


	/* No side effect */

	function getIndices$3(param) {
	  return param[/* boxGeometryRecord */23][/* indices */4];
	}


	/* ComputePointsBoxGeometryService-Wonderjs Not a pure module */

	function getNormals$3(param) {
	  return param[/* boxGeometryRecord */23][/* normals */3];
	}


	/* No side effect */

	function getVertices$3(param) {
	  return param[/* boxGeometryRecord */23][/* vertices */1];
	}


	/* No side effect */

	function getTexCoords$3(param) {
	  return param[/* boxGeometryRecord */23][/* texCoords */2];
	}


	/* No side effect */

	function createBoxGeometry$1(state) {
	  var match = create$64(getRecord$3(state));
	  state[/* boxGeometryRecord */23] = match[0];
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}

	function getBoxGeometryVertices$1(state) {
	  return getVertices$3(state);
	}

	function getBoxGeometryTexCoords$1(state) {
	  return getTexCoords$3(state);
	}

	function getBoxGeometryNormals$1(state) {
	  return getNormals$3(state);
	}

	function getBoxGeometryIndices$1(state) {
	  return getIndices$3(state);
	}

	function unsafeGetBoxGeometryGameObject$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$9, getRecord$3(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$2(geometry, getRecord$3(state));
	}


	/* Contract-WonderLog Not a pure module */

	function onMouseEvent$2(eventName, priority, handleFunc, state) {
	  return onMouseEvent$1(eventName, handleFunc, state, priority, /* () */0);
	}

	function onKeyboardEvent$2(eventName, priority, handleFunc, state) {
	  return onKeyboardEvent$1(eventName, handleFunc, state, priority, /* () */0);
	}

	function onTouchEvent$2(eventName, priority, handleFunc, state) {
	  return onTouchEvent$1(eventName, handleFunc, state, priority, /* () */0);
	}

	var offMouseEventByHandleFunc$2 = offMouseEventByHandleFunc$1;

	var offKeyboardEventByHandleFunc$2 = offKeyboardEventByHandleFunc$1;

	var offTouchEventByHandleFunc$2 = offTouchEventByHandleFunc$1;

	function onCustomGlobalEvent$2(eventName, priority, handleFunc, state) {
	  return onCustomGlobalEvent$1(eventName, handleFunc, state, priority, /* () */0);
	}

	var offCustomGlobalEventByEventName$2 = offCustomGlobalEventByEventName$1;

	var offCustomGlobalEventByHandleFunc$2 = offCustomGlobalEventByHandleFunc$1;

	function onCustomGameObjectEvent$2(eventName, target, priority, handleFunc, state) {
	  return onCustomGameObjectEvent$1(eventName, handleFunc, target, state, priority, /* () */0);
	}

	var offCustomGameObjectEventByTarget$2 = offCustomGameObjectEventByTarget$1;

	function offCustomGameObjectEventByHandleFunc$2(eventName, target, handleFunc, state) {
	  return offCustomGameObjectEventByHandleFunc$1(eventName, handleFunc, target, state);
	}

	var triggerCustomGlobalEvent$2 = triggerCustomGlobalEvent$1;

	var triggerCustomGameObjectEvent$2 = triggerCustomGameObjectEvent$1;

	var broadcastCustomGameObjectEvent$2 = broadcastCustomGameObjectEvent$1;

	var emitCustomGameObjectEvent$2 = emitCustomGameObjectEvent$1;

	function createCustomEvent$1(eventName, userData) {
	  return create$58(eventName, (userData == null) ? undefined : some$1(userData));
	}

	var getCustomEventUserData$2 = getCustomEventUserData$1;

	function getPointEventLocationInViewOfEvent$1($$event) {
	  return $$event[/* locationInView */2];
	}

	function getPointEventLocationOfEvent$1($$event) {
	  return $$event[/* location */1];
	}

	function getPointEventButtonOfEvent$1($$event) {
	  return $$event[/* button */3];
	}

	function getPointEventWheelOfEvent$1($$event) {
	  return $$event[/* wheel */4];
	}

	function getPointEventMovementDeltaOfEvent$1($$event) {
	  return $$event[/* movementDelta */5];
	}

	function getPointEventEventOfEvent$1($$event) {
	  return $$event[/* event */6];
	}

	var stopPropagationCustomEvent$2 = stopPropagationCustomEvent$1;


	/* ManageEventMainService-Wonderjs Not a pure module */

	function getSetting$5(state) {
	  return getSetting$3(getWonderIMGUIRecord(state));
	}

	function setSetting$4(setting, state) {
	  var newrecord = caml_array_dup(state);
	  var init = state[/* imguiRecord */43];
	  newrecord[/* imguiRecord */43] = /* record */[
	    /* ioData */init[/* ioData */0],
	    /* wonderImguiIMGUIRecord */setSetting$2(setting, getWonderIMGUIRecord(state))
	  ];
	  return newrecord;
	}

	var sendUniformProjectionMatData$4 = sendUniformProjectionMatData$1;

	var setIMGUIFunc$5 = setIMGUIFunc$1;


	/* ManageIMGUIAPI-WonderImgui Not a pure module */

	function unsafeGetGameObject$11(meshRenderer, param) {
	  return unsafeGetGameObject$1(meshRenderer, param[/* gameObjectMap */5]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function createMeshRenderer$1(state) {
	  return create$29(state);
	}

	function unsafeGetMeshRendererGameObject$1(meshRenderer, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(meshRenderer, isAlive$7, getRecord$2(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$11(meshRenderer, getRecord$2(state));
	}

	function getMeshRendererDrawMode$1(meshRenderer, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(meshRenderer, isAlive$7, getRecord$2(state));
	        }), getIsDebug(stateData));
	  return getDrawMode$1(meshRenderer, state);
	}

	function setMeshRendererDrawMode$1(meshRenderer, drawMode, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(meshRenderer, isAlive$7, getRecord$2(state));
	        }), getIsDebug(stateData));
	  return setDrawMode$1(meshRenderer, drawMode, state);
	}


	/* Contract-WonderLog Not a pure module */

	function isSupportRenderWorkerAndSharedArrayBuffer$2() {
	  var isSupportSharedArrayBuffer$$1 = isSupportSharedArrayBuffer(/* () */0);
	  var match = !isSupportSharedArrayBuffer$$1;
	  if (match) {
	    return false;
	  } else {
	    return _2(hasProperty, "transferControlToOffscreen", buildCanvas(/* () */0));
	  }
	}


	/* Worker-Wonderjs Not a pure module */

	function createBasicMaterial$1(state) {
	  return create$30(state);
	}

	function unsafeGetBasicMaterialGameObject$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$3(material, getRecord$4(state));
	}

	function getBasicMaterialColor$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return getColor$7(material, state);
	}

	function setBasicMaterialColor$1(material, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return setColor$3(material, color, state);
	}

	function unsafeGetBasicMaterialMap$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return unsafeGetMap(material, state);
	}

	function setBasicMaterialMap$1(material, texture, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return setMap(material, texture, state);
	}

	function hasBasicMaterialMap$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return hasMap$1(material, state);
	}

	function unsafeGetBasicMaterialName$1(material, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return unsafeGetName$2(material, state);
	}

	function setBasicMaterialName$1(material, name, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(material, isAlive$10, getRecord$4(state));
	        }), getIsDebug(stateData));
	  return setName$2(material, name, state);
	}


	/* Contract-WonderLog Not a pure module */

	function unsafeGetGl$2(state) {
	  return unsafeGetGl$1(state[/* deviceManagerRecord */10]);
	}

	function setViewport$1(viewportData, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* deviceManagerRecord */10] = setViewportData(viewportData, setViewportOfGl(unsafeGetGl$1(state[/* deviceManagerRecord */10]), viewportData, state[/* deviceManagerRecord */10]));
	  return newrecord;
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	function load$2(customTextureSourceDataArr, record) {
	  return load((customTextureSourceDataArr == null) ? /* array */[] : customTextureSourceDataArr, fetch$1, record);
	}

	function addFont$1(fntFilePath, bitmapFilePath, record) {
	  return addFont(/* tuple */[
	              fntFilePath,
	              bitmapFilePath
	            ], record);
	}


	/* FetchService-WonderImgui Not a pure module */

	function createFetchJsonStream(filePath, fetchFunc) {
	  return fromPromise(_1(fetchFunc, filePath).then((function (prim) {
	                    return prim.json();
	                  })));
	}

	function createFetchArrayBufferStream(filePath, fetchFunc) {
	  return fromPromise(_1(fetchFunc, filePath).then((function (prim) {
	                    return prim.arrayBuffer();
	                  })));
	}


	/* most Not a pure module */

	function load$3(wdPath, fetchFunc, state) {
	  return flatMap((function (wdb) {
	                return assemble(wdb, state);
	              }), createFetchArrayBufferStream(wdPath, fetchFunc));
	}


	/* most Not a pure module */

	function join$2(pathArr) {
	  return pathArr.join("");
	}


	/* win32SplitPath Not a pure module */

	function convertToRecord(setting) {
	  return /* record */[
	          /* canvasId */optional((function (param) {
	                  return field("canvas_id", string, param);
	                }), setting),
	          /* memory */optional((function (param) {
	                  return field("memory", (function (json) {
	                                return /* record */[
	                                        /* maxDisposeCount */field("max_dispose_count", $$int, json),
	                                        /* maxTypeArrayPoolSize */field("max_type_array_pool_size", $$int, json),
	                                        /* maxBigTypeArrayPoolSize */field("max_big_type_array_pool_size", $$int, json)
	                                      ];
	                              }), param);
	                }), setting),
	          /* buffer */optional((function (param) {
	                  return field("buffer", (function (json) {
	                                return /* record */[
	                                        /* customGeometryPointCount */field("custom_geometry_point_count", $$int, json),
	                                        /* customGeometryCount */field("custom_geometry_count", $$int, json),
	                                        /* transformCount */field("transform_count", $$int, json),
	                                        /* basicMaterialCount */field("basic_material_count", $$int, json),
	                                        /* lightMaterialCount */field("light_material_count", $$int, json),
	                                        /* textureCountPerMaterial */field("texture_count_per_material", $$int, json),
	                                        /* basicSourceTextureCount */field("basic_source_texture_count", $$int, json),
	                                        /* arrayBufferViewSourceTextureCount */field("arrayBuffer_view_source_texture_count", $$int, json),
	                                        /* meshRendererCount */field("meshRenderer_count", $$int, json),
	                                        /* instanceBuffer */field("instance_buffer", (function (json) {
	                                                return /* record */[
	                                                        /* sourceInstanceCount */field("sourceInstance_count", $$int, json),
	                                                        /* objectInstanceCountPerSourceInstance */field("objectInstance_count_per_source_instance", $$int, json)
	                                                      ];
	                                              }), json)
	                                      ];
	                              }), param);
	                }), setting),
	          /* isDebug */optional((function (param) {
	                  return field("is_debug", bool, param);
	                }), setting),
	          /* context */optional((function (param) {
	                  return field("context", (function (json) {
	                                return /* record */[
	                                        /* alpha */field("alpha", bool, json),
	                                        /* depth */field("depth", bool, json),
	                                        /* stencil */field("stencil", bool, json),
	                                        /* antialias */field("antialias", bool, json),
	                                        /* premultipliedAlpha */field("premultiplied_alpha", bool, json),
	                                        /* preserveDrawingBuffer */field("preserve_drawing_buffer", bool, json)
	                                      ];
	                              }), param);
	                }), setting),
	          /* gpu */optional((function (param) {
	                  return field("gpu", (function (json) {
	                                return /* record */[/* useHardwareInstance */field("use_hardware_instance", bool, json)];
	                              }), param);
	                }), setting),
	          /* worker */optional((function (param) {
	                  return field("worker", (function (json) {
	                                return /* record */[/* useWorker */field("use_worker", bool, json)];
	                              }), param);
	                }), setting)
	        ];
	}


	/* No side effect */

	function convertSettingToRecord(setting) {
	  return /* record */[
	          /* workerFileDir */field("worker_file_dir", string, setting),
	          /* mainInitPipeline */field("main_init_pipeline", string, setting),
	          /* mainLoopPipeline */field("main_loop_pipeline", string, setting),
	          /* workerPipeline */field("worker_pipeline", string, setting)
	        ];
	}

	function convertMainInitPipelinesToRecord(pipelines) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* jobs */field("jobs", (function (json) {
	                                return array((function (json) {
	                                              return /* record */[
	                                                      /* name */field("name", string, json),
	                                                      /* link */field("link", string, json),
	                                                      /* jobs */field("jobs", (function (json) {
	                                                              return array((function (json) {
	                                                                            return /* record */[/* name */field("name", string, json)];
	                                                                          }), json);
	                                                            }), json)
	                                                    ];
	                                            }), json);
	                              }), json)
	                      ];
	              }), pipelines);
	}

	function convertMainLoopPipelinesToRecord(pipelines) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* jobs */field("jobs", (function (json) {
	                                return array((function (json) {
	                                              return /* record */[
	                                                      /* name */field("name", string, json),
	                                                      /* link */field("link", string, json),
	                                                      /* jobs */field("jobs", (function (json) {
	                                                              return array((function (json) {
	                                                                            return /* record */[/* name */field("name", string, json)];
	                                                                          }), json);
	                                                            }), json)
	                                                    ];
	                                            }), json);
	                              }), json)
	                      ];
	              }), pipelines);
	}

	function convertWorkerPipelinesToRecord(pipelines) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* jobs */field("jobs", (function (json) {
	                                return /* record */[/* render */field("render", (function (json) {
	                                                return array((function (json) {
	                                                              return array((function (json) {
	                                                                            return /* record */[/* name */field("name", string, json)];
	                                                                          }), json);
	                                                            }), json);
	                                              }), json)];
	                              }), json)
	                      ];
	              }), pipelines);
	}

	function _convertJobsToRecord(jobs) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* flags */optional((function (param) {
	                                return field("flags", (function (json) {
	                                              return array(string, json);
	                                            }), param);
	                              }), json)
	                      ];
	              }), jobs);
	}

	var convertMainInitJobsToRecord = _convertJobsToRecord;

	var convertMainLoopJobsToRecord = _convertJobsToRecord;

	var convertWorkerJobsToRecord = _convertJobsToRecord;


	/* No side effect */

	function create$65(param) {
	  return /* record */[
	          /* setting */param[0],
	          /* mainInitPipelines */param[1],
	          /* mainLoopPipelines */param[2],
	          /* workerPipelines */param[5],
	          /* mainInitJobs */param[3],
	          /* mainLoopJobs */param[4],
	          /* workerJobs */param[6]
	        ];
	}


	/* No side effect */

	function execJob$82(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* timeControllerRecord */34] = execJob$1(state[/* timeControllerRecord */34]);
	  return newrecord;
	}


	/* TickJobUtils-Wonderjs Not a pure module */

	function execJob$83(_, state) {
	  var match = execJob$74(batchDisposeBasicMaterialComponent, batchDisposeLightMaterialComponentForWorker, state);
	  var state$1 = match[0];
	  var newrecord = caml_array_dup(state$1);
	  newrecord[/* vboBufferRecord */35] = disposeSourceInstanceVboBuffer(match[3], disposeCustomGeometryVboBuffer(match[2], disposeBoxGeometryVboBuffer(match[1], state$1[/* vboBufferRecord */35])));
	  return newrecord;
	}


	/* DisposeJobUtils-Wonderjs Not a pure module */

	function execJob$84(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* deviceManagerRecord */10] = setGl(createGl(convertContextConfigDataToJsObj(unsafeGetContext(state[/* settingRecord */1])), unsafeGetCanvas(state[/* viewRecord */9])), state[/* deviceManagerRecord */10]);
	  return newrecord;
	}


	/* ViewService-Wonderjs Not a pure module */

	function execJob$85(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* gpuDetectRecord */6] = detect$1(unsafeGetGl$1(state[/* deviceManagerRecord */10]), getTextureCountPerMaterial(state[/* settingRecord */1]), state[/* gpuDetectRecord */6]);
	  return newrecord;
	}


	/* GPUDetectService-Wonderjs Not a pure module */

	function execJob$86(_, state) {
	  return initEvent(state);
	}


	/* InitEventJobUtils-Wonderjs Not a pure module */

	function execJob$87(_, state) {
	  var gl = unsafeGetGl$1(state[/* deviceManagerRecord */10]);
	  var state$1 = bindEvent$1(state);
	  var newrecord = caml_array_dup(state$1);
	  newrecord[/* imguiRecord */43] = /* record */[
	    /* ioData */state[/* imguiRecord */43][/* ioData */0],
	    /* wonderImguiIMGUIRecord */init$6(gl, getCanvasSize(state$1), getWonderIMGUIRecord(state$1))
	  ];
	  return newrecord;
	}


	/* ManageIMGUIAPI-WonderImgui Not a pure module */

	function execJob$88(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* deviceManagerRecord */10] = execJob$10(state[/* deviceManagerRecord */10]);
	  return newrecord;
	}


	/* InitStateJobUtils-Wonderjs Not a pure module */

	function execJob$89(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* timeControllerRecord */34] = start(state[/* timeControllerRecord */34]);
	  return newrecord;
	}


	/* TimeControllerService-Wonderjs Not a pure module */

	function execJob$90(flags, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* deviceManagerRecord */10] = execJob$13(flags, state[/* deviceManagerRecord */10]);
	  return newrecord;
	}


	/* ClearColorJobUtils-Wonderjs Not a pure module */

	function execJob$91(_, state) {
	  return init$4(init$5(state));
	}


	/* InitArcballCameraControllerMainService-Wonderjs Not a pure module */

	function execJob$92(flags, state) {
	  var gl = unsafeGetGl$1(state[/* deviceManagerRecord */10]);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* deviceManagerRecord */10] = clearBuffer(gl, getBit(gl, unsafeGetFlags(flags)), state[/* deviceManagerRecord */10]);
	  return newrecord;
	}


	/* JobConfigService-Wonderjs Not a pure module */

	function execJob$93(_, state) {
	  var basicSourceTextureRecord = getRecord$9(state);
	  var arrayBufferViewSourceTextureRecord = getRecord$11(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */basicSourceTextureRecord[/* index */0],
	    /* wrapSs */basicSourceTextureRecord[/* wrapSs */1],
	    /* wrapTs */basicSourceTextureRecord[/* wrapTs */2],
	    /* magFilters */basicSourceTextureRecord[/* magFilters */3],
	    /* minFilters */basicSourceTextureRecord[/* minFilters */4],
	    /* formats */basicSourceTextureRecord[/* formats */5],
	    /* types */basicSourceTextureRecord[/* types */6],
	    /* isNeedUpdates */basicSourceTextureRecord[/* isNeedUpdates */7],
	    /* flipYs */basicSourceTextureRecord[/* flipYs */8],
	    /* sourceMap */basicSourceTextureRecord[/* sourceMap */9],
	    /* glTextureMap */initTextures(unsafeGetGl$1(state[/* deviceManagerRecord */10]), range$1(0, basicSourceTextureRecord[/* index */0] - 1 | 0), basicSourceTextureRecord[/* glTextureMap */10]),
	    /* bindTextureUnitCacheMap */basicSourceTextureRecord[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */basicSourceTextureRecord[/* disposedIndexArray */12],
	    /* needAddedSourceArray */basicSourceTextureRecord[/* needAddedSourceArray */13],
	    /* needInitedTextureIndexArray */basicSourceTextureRecord[/* needInitedTextureIndexArray */14],
	    /* nameMap */basicSourceTextureRecord[/* nameMap */15]
	  ];
	  newrecord[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */arrayBufferViewSourceTextureRecord[/* index */0],
	    /* wrapSs */arrayBufferViewSourceTextureRecord[/* wrapSs */1],
	    /* wrapTs */arrayBufferViewSourceTextureRecord[/* wrapTs */2],
	    /* magFilters */arrayBufferViewSourceTextureRecord[/* magFilters */3],
	    /* minFilters */arrayBufferViewSourceTextureRecord[/* minFilters */4],
	    /* formats */arrayBufferViewSourceTextureRecord[/* formats */5],
	    /* types */arrayBufferViewSourceTextureRecord[/* types */6],
	    /* isNeedUpdates */arrayBufferViewSourceTextureRecord[/* isNeedUpdates */7],
	    /* flipYs */arrayBufferViewSourceTextureRecord[/* flipYs */8],
	    /* widths */arrayBufferViewSourceTextureRecord[/* widths */9],
	    /* heights */arrayBufferViewSourceTextureRecord[/* heights */10],
	    /* sourceMap */arrayBufferViewSourceTextureRecord[/* sourceMap */11],
	    /* glTextureMap */initTextures(unsafeGetGl$1(state[/* deviceManagerRecord */10]), range$1(0, arrayBufferViewSourceTextureRecord[/* index */0] - 1 | 0), arrayBufferViewSourceTextureRecord[/* glTextureMap */12]),
	    /* bindTextureUnitCacheMap */arrayBufferViewSourceTextureRecord[/* bindTextureUnitCacheMap */13],
	    /* disposedIndexArray */arrayBufferViewSourceTextureRecord[/* disposedIndexArray */14],
	    /* needAddedSourceArray */arrayBufferViewSourceTextureRecord[/* needAddedSourceArray */15],
	    /* needInitedTextureIndexArray */arrayBufferViewSourceTextureRecord[/* needInitedTextureIndexArray */16],
	    /* nameMap */arrayBufferViewSourceTextureRecord[/* nameMap */17]
	  ];
	  return newrecord;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function createRenderState$1(state) {
	  var settingRecord = state[/* settingRecord */1];
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  var transformRecord = getRecord$1(state);
	  var localToWorldMatrices = transformRecord[/* localToWorldMatrices */2];
	  var localToWorldMatrixCacheMap = transformRecord[/* localToWorldMatrixCacheMap */19];
	  var normalMatrixCacheMap = transformRecord[/* normalMatrixCacheMap */20];
	  var boxGeometryRecord = getRecord$3(state);
	  var customGeometryRecord = getRecord$6(state);
	  var basicMaterialRecord = getRecord$4(state);
	  var lightMaterialRecord = getRecord$5(state);
	  var meshRendererRecord = getRecord$2(state);
	  var basicSourceTextureRecord = getRecord$9(state);
	  var arrayBufferViewSourceTextureRecord = getRecord$11(state);
	  var sourceInstanceRecord = getRecord$7(state);
	  var isUseWorker$$1 = isUseWorker(state);
	  var renderStateTransformRecord = isUseWorker$$1 ? /* record */[
	      /* localToWorldMatrices */unsafeGetCopiedLocalToWorldMatrices(transformRecord),
	      /* localToWorldMatrixCacheMap */localToWorldMatrixCacheMap,
	      /* normalMatrixCacheMap */normalMatrixCacheMap
	    ] : /* record */[
	      /* localToWorldMatrices */localToWorldMatrices,
	      /* localToWorldMatrixCacheMap */localToWorldMatrixCacheMap,
	      /* normalMatrixCacheMap */normalMatrixCacheMap
	    ];
	  return /* record */[
	          /* sceneRecord : record */[/* ambientLight : record */[/* color */getAmbientLightColor$2(state)]],
	          /* vboBufferRecord */state[/* vboBufferRecord */35],
	          /* typeArrayPoolRecord */state[/* typeArrayPoolRecord */37],
	          /* glslSenderRecord */state[/* glslSenderRecord */31],
	          /* programRecord */state[/* programRecord */29],
	          /* boxGeometryRecord : record */[
	            /* vertices */boxGeometryRecord[/* vertices */1],
	            /* texCoords */boxGeometryRecord[/* texCoords */2],
	            /* normals */boxGeometryRecord[/* normals */3],
	            /* indices */boxGeometryRecord[/* indices */4]
	          ],
	          /* customGeometryRecord : record */[
	            /* vertices */customGeometryRecord[/* vertices */2],
	            /* texCoords */customGeometryRecord[/* texCoords */3],
	            /* normals */customGeometryRecord[/* normals */4],
	            /* indices */customGeometryRecord[/* indices */5],
	            /* verticesInfos */customGeometryRecord[/* verticesInfos */6],
	            /* texCoordsInfos */customGeometryRecord[/* texCoordsInfos */7],
	            /* normalsInfos */customGeometryRecord[/* normalsInfos */8],
	            /* indicesInfos */customGeometryRecord[/* indicesInfos */9]
	          ],
	          /* cameraRecord */getCameraRecord(state),
	          /* basicMaterialRecord : record */[
	            /* shaderIndices */basicMaterialRecord[/* shaderIndices */2],
	            /* colors */basicMaterialRecord[/* colors */3],
	            /* textureIndices */basicMaterialRecord[/* textureIndices */4],
	            /* mapUnits */basicMaterialRecord[/* mapUnits */5]
	          ],
	          /* lightMaterialRecord : record */[
	            /* shaderIndices */lightMaterialRecord[/* shaderIndices */2],
	            /* diffuseColors */lightMaterialRecord[/* diffuseColors */3],
	            /* specularColors */lightMaterialRecord[/* specularColors */4],
	            /* shininess */lightMaterialRecord[/* shininess */5],
	            /* textureIndices */lightMaterialRecord[/* textureIndices */6],
	            /* diffuseMapUnits */lightMaterialRecord[/* diffuseMapUnits */7],
	            /* specularMapUnits */lightMaterialRecord[/* specularMapUnits */8]
	          ],
	          /* meshRendererRecord : record */[/* drawModes */meshRendererRecord[/* drawModes */2]],
	          /* basicSourceTextureRecord : record */[
	            /* wrapSs */basicSourceTextureRecord[/* wrapSs */1],
	            /* wrapTs */basicSourceTextureRecord[/* wrapTs */2],
	            /* magFilters */basicSourceTextureRecord[/* magFilters */3],
	            /* minFilters */basicSourceTextureRecord[/* minFilters */4],
	            /* formats */basicSourceTextureRecord[/* formats */5],
	            /* types */basicSourceTextureRecord[/* types */6],
	            /* isNeedUpdates */basicSourceTextureRecord[/* isNeedUpdates */7],
	            /* flipYs */basicSourceTextureRecord[/* flipYs */8],
	            /* sourceMap */basicSourceTextureRecord[/* sourceMap */9],
	            /* glTextureMap */basicSourceTextureRecord[/* glTextureMap */10],
	            /* bindTextureUnitCacheMap */basicSourceTextureRecord[/* bindTextureUnitCacheMap */11],
	            /* setFlipYFunc */setFlipY$3
	          ],
	          /* arrayBufferViewSourceTextureRecord : record */[
	            /* wrapSs */arrayBufferViewSourceTextureRecord[/* wrapSs */1],
	            /* wrapTs */arrayBufferViewSourceTextureRecord[/* wrapTs */2],
	            /* magFilters */arrayBufferViewSourceTextureRecord[/* magFilters */3],
	            /* minFilters */arrayBufferViewSourceTextureRecord[/* minFilters */4],
	            /* formats */arrayBufferViewSourceTextureRecord[/* formats */5],
	            /* types */arrayBufferViewSourceTextureRecord[/* types */6],
	            /* isNeedUpdates */arrayBufferViewSourceTextureRecord[/* isNeedUpdates */7],
	            /* flipYs */arrayBufferViewSourceTextureRecord[/* flipYs */8],
	            /* widths */arrayBufferViewSourceTextureRecord[/* widths */9],
	            /* heights */arrayBufferViewSourceTextureRecord[/* heights */10],
	            /* sourceMap */arrayBufferViewSourceTextureRecord[/* sourceMap */11],
	            /* glTextureMap */arrayBufferViewSourceTextureRecord[/* glTextureMap */12],
	            /* bindTextureUnitCacheMap */arrayBufferViewSourceTextureRecord[/* bindTextureUnitCacheMap */13],
	            /* setFlipYFunc */setFlipY$3,
	            /* textureIndexOffset */getArrayBufferViewSourceTextureIndexOffset$1(state)
	          ],
	          /* directionLightRecord : record */[
	            /* index */directionLightRecord[/* index */0],
	            /* colors */directionLightRecord[/* colors */2],
	            /* intensities */directionLightRecord[/* intensities */3],
	            /* directionMap */buildDirectionMap(directionLightRecord[/* index */0], getDirection$1, state)
	          ],
	          /* pointLightRecord : record */[
	            /* index */pointLightRecord[/* index */0],
	            /* colors */pointLightRecord[/* colors */2],
	            /* intensities */pointLightRecord[/* intensities */3],
	            /* constants */pointLightRecord[/* constants */4],
	            /* linears */pointLightRecord[/* linears */5],
	            /* quadratics */pointLightRecord[/* quadratics */6],
	            /* ranges */pointLightRecord[/* ranges */7],
	            /* positionMap */buildPositionMap(pointLightRecord[/* index */0], getPosition$2, state)
	          ],
	          /* transformRecord */renderStateTransformRecord,
	          /* sourceInstanceRecord : record */[
	            /* objectInstanceTransformIndexMap */sourceInstanceRecord[/* objectInstanceTransformIndexMap */1],
	            /* objectInstanceTransformCollections */sourceInstanceRecord[/* objectInstanceTransformCollections */4],
	            /* isTransformStatics */sourceInstanceRecord[/* isTransformStatics */3],
	            /* matrixInstanceBufferCapacityMap */sourceInstanceRecord[/* matrixInstanceBufferCapacityMap */5],
	            /* matrixFloat32ArrayMap */sourceInstanceRecord[/* matrixFloat32ArrayMap */6],
	            /* isSendTransformMatrixDataMap */sourceInstanceRecord[/* isSendTransformMatrixDataMap */7]
	          ],
	          /* gpuDetectRecord */state[/* gpuDetectRecord */6],
	          /* globalTempRecord */state[/* globalTempRecord */36],
	          /* deviceManagerRecord */state[/* deviceManagerRecord */10],
	          /* shaderRecord : record */[/* usedShaderIndexArray */state[/* shaderRecord */27][/* usedShaderIndexArray */2]],
	          /* settingRecord : record */[
	            /* gpu */unsafeGetGPU(settingRecord),
	            /* instanceBuffer *//* record */[/* objectInstanceCountPerSourceInstance */getObjectInstanceCountPerSourceInstance(settingRecord)],
	            /* textureCountPerMaterial */getTextureCountPerMaterial(settingRecord)
	          ],
	          /* workerDetectRecord : record */[/* isUseWorker */isUseWorker$$1],
	          /* browserDetectRecord : record */[/* browser */state[/* browserDetectRecord */41][/* browser */0]]
	        ];
	}


	/* BufferSettingService-Wonderjs Not a pure module */

	function _render$2(gl, state) {
	  var match = getBasicRenderObjectRecord(state);
	  if (match !== undefined) {
	    var match$1 = match;
	    render$2(gl, /* tuple */[
	          match$1[/* count */1],
	          match$1[/* transformIndices */2],
	          match$1[/* materialIndices */3],
	          match$1[/* meshRendererIndices */4],
	          match$1[/* geometryIndices */5],
	          match$1[/* geometryTypes */6],
	          match$1[/* sourceInstanceIndices */7]
	        ], createRenderState$1(state));
	    return state;
	  } else {
	    return state;
	  }
	}

	function execJob$94(_, state) {
	  return _render$2(unsafeGetGl$1(state[/* deviceManagerRecord */10]), state);
	}


	/* RenderBasicJobUtils-Wonderjs Not a pure module */

	function execJob$95(_, state) {
	  return resetPointEventStateWhenPointUp(render$1(unsafeGetGl$1(state[/* deviceManagerRecord */10]), getIOData$1(state), getAPIJsObj$1(state), /* tuple */[
	                  getRecord$12,
	                  setRecord
	                ], state));
	}


	/* IOIMGUIMainService-Wonderjs Not a pure module */

	function execJob$96(_, state) {
	  var screenData = queryFullScreenData(/* () */0);
	  var viewportData_000 = screenData[0];
	  var viewportData_001 = screenData[1];
	  var viewportData_002 = screenData[2];
	  var viewportData_003 = screenData[3];
	  var viewportData = /* tuple */[
	    viewportData_000,
	    viewportData_001,
	    viewportData_002,
	    viewportData_003
	  ];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* deviceManagerRecord */10] = setViewportData(viewportData, setViewportOfGl(unsafeGetGl$1(state[/* deviceManagerRecord */10]), viewportData, state[/* deviceManagerRecord */10]));
	  return newrecord;
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	function execJob$97(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* viewRecord */9] = setCanvas(createCanvas(getCanvasId(state[/* settingRecord */1])), state[/* viewRecord */9]);
	  return newrecord;
	}


	/* ViewService-Wonderjs Not a pure module */

	function execJob$98(_, state) {
	  return update$2(update$1(state));
	}


	/* UpdateArcballCameraControllerMainService-Wonderjs Not a pure module */

	function execJob$99(_, state) {
	  return setCameraRecord(getCameraData(state), state);
	}


	/* GetCameraDataJobUtils-Wonderjs Not a pure module */

	function execJob$100(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* viewRecord */9] = setCanvas(setToFullScreen(queryFullScreenData(/* () */0), unsafeGetCanvas(state[/* viewRecord */9])), state[/* viewRecord */9]);
	  return newrecord;
	}


	/* ViewService-Wonderjs Not a pure module */

	function execJob$101(_, state) {
	  var glslRecord = state[/* glslRecord */28];
	  glslRecord[/* precision */0] = getPrecisionSource(state[/* gpuDetectRecord */6], state[/* glslChunkRecord */32]);
	  return state;
	}


	/* PrecisionAllService-Wonderjs Not a pure module */

	function execJob$102(_, state) {
	  var transformRecord = getRecord$1(state);
	  var index = transformRecord[/* index */0];
	  var newrecord = caml_array_dup(state);
	  newrecord[/* transformRecord */12] = execJob$33(index, state[/* globalTempRecord */36], transformRecord);
	  return newrecord;
	}


	/* UpdateTransformJobUtils-Wonderjs Not a pure module */

	function _render$3(gl, state) {
	  var match = getLightRenderObjectRecord(state);
	  if (match !== undefined) {
	    var match$1 = match;
	    render$10(gl, /* tuple */[
	          match$1[/* count */1],
	          match$1[/* transformIndices */2],
	          match$1[/* materialIndices */3],
	          match$1[/* meshRendererIndices */4],
	          match$1[/* geometryIndices */5],
	          match$1[/* geometryTypes */6],
	          match$1[/* sourceInstanceIndices */7]
	        ], createRenderState$1(state));
	    return state;
	  } else {
	    return state;
	  }
	}

	function execJob$103(_, state) {
	  return _render$3(unsafeGetGl$1(state[/* deviceManagerRecord */10]), state);
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	function execJob$104(_, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getRecord$4(state);
	  var index = match[/* index */0];
	  init$1(unsafeGetGl$1(state[/* deviceManagerRecord */10]), /* tuple */[
	        buildMap(index, getRecord$4(state)[/* gameObjectMap */8], gameObjectRecord),
	        isSupportInstance(state)
	      ], createInitMaterialState(/* tuple */[
	            index,
	            match[/* disposedIndexArray */10]
	          ], state));
	  return state;
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	function execJob$105(_, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getRecord$5(state);
	  var index = match[/* index */0];
	  init$3(unsafeGetGl$1(state[/* deviceManagerRecord */10]), /* tuple */[
	        buildMap(index, getRecord$5(state)[/* gameObjectMap */13], gameObjectRecord),
	        isSupportInstance(state)
	      ], createInitMaterialState$1(/* tuple */[
	            index,
	            match[/* disposedIndexArray */15]
	          ], state));
	  return state;
	}


	/* DeviceManagerService-Wonderjs Not a pure module */

	function execJob$106(_, state) {
	  return execJob$50(state);
	}


	/* ReallocateCPUMemoryJobUtils-Wonderjs Not a pure module */

	function execJob$107(_, state) {
	  execJob$70(createRenderState$1(state));
	  return state;
	}


	/* CreateRenderStateMainService-Wonderjs Not a pure module */

	function execJob$108(_, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* glslSenderRecord */31] = execJob$72(state[/* glslSenderRecord */31]);
	  return newrecord;
	}


	/* No side effect */

	function execJob$109(_, state) {
	  var newrecord = caml_array_dup(state);
	  var init = getRecord$13(state);
	  newrecord[/* renderRecord */33] = /* record */[
	    /* basicRenderObjectRecord */execJob$77(state),
	    /* lightRenderObjectRecord */init[/* lightRenderObjectRecord */1],
	    /* cameraRecord */init[/* cameraRecord */2]
	  ];
	  return newrecord;
	}


	/* RecordRenderMainService-Wonderjs Not a pure module */

	function execJob$110(_, state) {
	  var newrecord = caml_array_dup(state);
	  var init = getRecord$13(state);
	  newrecord[/* renderRecord */33] = /* record */[
	    /* basicRenderObjectRecord */init[/* basicRenderObjectRecord */0],
	    /* lightRenderObjectRecord */execJob$79(state),
	    /* cameraRecord */init[/* cameraRecord */2]
	  ];
	  return newrecord;
	}


	/* RecordRenderMainService-Wonderjs Not a pure module */

	function _getInitJobHandles() {
	  return /* :: */[
	          /* tuple */[
	            "create_canvas",
	            execJob$97
	          ],
	          /* :: */[
	            /* tuple */[
	              "create_gl",
	              execJob$84
	            ],
	            /* :: */[
	              /* tuple */[
	                "set_full_screen",
	                execJob$100
	              ],
	              /* :: */[
	                /* tuple */[
	                  "set_viewport",
	                  execJob$96
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "detect_gl",
	                    execJob$85
	                  ],
	                  /* :: */[
	                    /* tuple */[
	                      "init_event",
	                      execJob$86
	                    ],
	                    /* :: */[
	                      /* tuple */[
	                        "init_camera",
	                        execJob$91
	                      ],
	                      /* :: */[
	                        /* tuple */[
	                          "start_time",
	                          execJob$89
	                        ],
	                        /* :: */[
	                          /* tuple */[
	                            "preget_glslData",
	                            execJob$101
	                          ],
	                          /* :: */[
	                            /* tuple */[
	                              "init_imgui",
	                              execJob$87
	                            ],
	                            /* :: */[
	                              /* tuple */[
	                                "init_texture",
	                                execJob$93
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "init_state",
	                                  execJob$88
	                                ],
	                                /* :: */[
	                                  /* tuple */[
	                                    "init_basic_material",
	                                    execJob$104
	                                  ],
	                                  /* :: */[
	                                    /* tuple */[
	                                      "init_light_material",
	                                      execJob$105
	                                    ],
	                                    /* [] */0
	                                  ]
	                                ]
	                              ]
	                            ]
	                          ]
	                        ]
	                      ]
	                    ]
	                  ]
	                ]
	              ]
	            ]
	          ]
	        ];
	}

	function _getLoopJobHandles() {
	  return /* :: */[
	          /* tuple */[
	            "tick",
	            execJob$82
	          ],
	          /* :: */[
	            /* tuple */[
	              "update_transform",
	              execJob$102
	            ],
	            /* :: */[
	              /* tuple */[
	                "update_camera",
	                execJob$98
	              ],
	              /* :: */[
	                /* tuple */[
	                  "clear_color",
	                  execJob$90
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "clear_buffer",
	                    execJob$92
	                  ],
	                  /* :: */[
	                    /* tuple */[
	                      "clear_last_send_component",
	                      execJob$108
	                    ],
	                    /* :: */[
	                      /* tuple */[
	                        "get_camera_data",
	                        execJob$99
	                      ],
	                      /* :: */[
	                        /* tuple */[
	                          "send_uniform_shader_data",
	                          execJob$107
	                        ],
	                        /* :: */[
	                          /* tuple */[
	                            "create_basic_render_object_buffer",
	                            execJob$109
	                          ],
	                          /* :: */[
	                            /* tuple */[
	                              "create_light_render_object_buffer",
	                              execJob$110
	                            ],
	                            /* :: */[
	                              /* tuple */[
	                                "dispose",
	                                execJob$83
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "reallocate_cpu_memory",
	                                  execJob$106
	                                ],
	                                /* :: */[
	                                  /* tuple */[
	                                    "render_basic",
	                                    execJob$94
	                                  ],
	                                  /* :: */[
	                                    /* tuple */[
	                                      "front_render_light",
	                                      execJob$103
	                                    ],
	                                    /* :: */[
	                                      /* tuple */[
	                                        "render_imgui",
	                                        execJob$95
	                                      ],
	                                      /* [] */0
	                                    ]
	                                  ]
	                                ]
	                              ]
	                            ]
	                          ]
	                        ]
	                      ]
	                    ]
	                  ]
	                ]
	              ]
	            ]
	          ]
	        ];
	}

	function createInitJobHandleMap() {
	  return createJobHandleMap(_getInitJobHandles(/* () */0));
	}

	function createLoopJobHandleMap() {
	  return createJobHandleMap(_getLoopJobHandles(/* () */0));
	}


	/* TickJob-Wonderjs Not a pure module */

	function convertSettingToRecord$1(loop_setting) {
	  return /* record */[
	          /* initPipeline */field("init_pipeline", string, loop_setting),
	          /* loopPipeline */field("loop_pipeline", string, loop_setting)
	        ];
	}

	function _convertPipelinesToRecord(pipelines) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* jobs */field("jobs", (function (param) {
	                                return array((function (json) {
	                                              return /* record */[/* name */field("name", string, json)];
	                                            }), param);
	                              }), json)
	                      ];
	              }), pipelines);
	}

	function _convertJobsToRecord$1(jobs) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* flags */optional((function (param) {
	                                return field("flags", (function (json) {
	                                              return array(string, json);
	                                            }), param);
	                              }), json)
	                      ];
	              }), jobs);
	}

	var convertInitPipelinesToRecord = _convertPipelinesToRecord;

	var convertInitJobsToRecord = _convertJobsToRecord$1;

	var convertLoopPipelinesToRecord = _convertPipelinesToRecord;

	var convertLoopJobsToRecord = _convertJobsToRecord$1;


	/* No side effect */

	function _convertShaderMapData(json) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* value */field("value", (function (param) {
	                                return array(string, param);
	                              }), json)
	                      ];
	              }), json);
	}

	function _convertDynamicBranchData(json) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* condition */field("condition", string, json),
	                        /* pass */optional((function (param) {
	                                return field("pass", string, param);
	                              }), json),
	                        /* fail */optional((function (param) {
	                                return field("fail", string, param);
	                              }), json)
	                      ];
	              }), json);
	}

	function convertShadersToRecord(shaders) {
	  return /* record */[
	          /* staticBranchs */field("static_branchs", _convertShaderMapData, shaders),
	          /* dynamicBranchs */field("dynamic_branchs", _convertDynamicBranchData, shaders),
	          /* groups */field("groups", _convertShaderMapData, shaders),
	          /* materialShaders */field("material_shaders", (function (json) {
	                  return array((function (json) {
	                                return /* record */[
	                                        /* name */field("name", string, json),
	                                        /* shaderLibs */field("shader_libs", (function (param) {
	                                                return array((function (json) {
	                                                              return /* record */[
	                                                                      /* type_ */optional((function (param) {
	                                                                              return field("type", string, param);
	                                                                            }), json),
	                                                                      /* name */field("name", string, json)
	                                                                    ];
	                                                            }), param);
	                                              }), json)
	                                      ];
	                              }), json);
	                }), shaders)
	        ];
	}

	function _convertGlslToRecord(json) {
	  return optional((function (param) {
	                return field("glsls", (function (json) {
	                              return array((function (json) {
	                                            return /* record */[
	                                                    /* type_ */field("type", string, json),
	                                                    /* name */field("name", string, json)
	                                                  ];
	                                          }), json);
	                            }), param);
	              }), json);
	}

	function _convertVariableToRecord(json) {
	  return optional((function (param) {
	                return field("variables", (function (json) {
	                              return /* record */[
	                                      /* uniforms */optional((function (param) {
	                                              return field("uniforms", (function (json) {
	                                                            return array((function (json) {
	                                                                          return /* record */[
	                                                                                  /* name */field("name", string, json),
	                                                                                  /* field */field("field", string, json),
	                                                                                  /* type_ */field("type", string, json),
	                                                                                  /* from */field("from", string, json)
	                                                                                ];
	                                                                        }), json);
	                                                          }), param);
	                                            }), json),
	                                      /* attributes */optional((function (param) {
	                                              return field("attributes", (function (json) {
	                                                            return array((function (json) {
	                                                                          return /* record */[
	                                                                                  /* name */optional((function (param) {
	                                                                                          return field("name", string, param);
	                                                                                        }), json),
	                                                                                  /* buffer */field("buffer", $$int, json),
	                                                                                  /* type_ */optional((function (param) {
	                                                                                          return field("type", string, param);
	                                                                                        }), json)
	                                                                                ];
	                                                                        }), json);
	                                                          }), param);
	                                            }), json)
	                                    ];
	                            }), param);
	              }), json);
	}

	function convertShaderLibsToRecord(shaderLibs) {
	  return array((function (json) {
	                return /* record */[
	                        /* name */field("name", string, json),
	                        /* glsls */_convertGlslToRecord(json),
	                        /* variables */_convertVariableToRecord(json)
	                      ];
	              }), shaderLibs);
	}


	/* No side effect */

	function create$66(param) {
	  return /* record */[
	          /* setting */param[0],
	          /* initPipelines */param[1],
	          /* loopPipelines */param[2],
	          /* initJobs */param[3],
	          /* loopJobs */param[4]
	        ];
	}


	/* No side effect */

	function _collectAllRecords(stream) {
	  return reduce$1((function (arr, record) {
	                return push(record, arr);
	              }), /* array */[], stream);
	}

	function _createFetchNoWorkerJobStreamArr(dataDir, fetchFunc) {
	  return /* array */[
	          map$4(convertSettingToRecord$1, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "no_worker/setting/setting.json"
	                      ]), fetchFunc)),
	          map$4(convertInitPipelinesToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "no_worker/pipeline/init_pipelines.json"
	                      ]), fetchFunc)),
	          map$4(convertLoopPipelinesToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "no_worker/pipeline/loop_pipelines.json"
	                      ]), fetchFunc)),
	          map$4(convertInitJobsToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "no_worker/job/init_jobs.json"
	                      ]), fetchFunc)),
	          map$4(convertLoopJobsToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "no_worker/job/loop_jobs.json"
	                      ]), fetchFunc))
	        ];
	}

	function _createFetchRenderConfigStreamArr(dataDir, fetchFunc) {
	  return /* array */[
	          map$4(convertShadersToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "render/shader/shaders.json"
	                      ]), fetchFunc)),
	          map$4(convertShaderLibsToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "render/shader/shader_libs.json"
	                      ]), fetchFunc))
	        ];
	}

	function _setSetting(stateData, state, setting) {
	  setIsDebug$1(stateData, unsafeGetIsDebug(setting));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* settingRecord */1] = setSetting$1(setting);
	  return newrecord;
	}

	function _createHandleNoWorkerJobConfigStreamArr(dataDir, fetchFunc, state) {
	  return fromPromise(_collectAllRecords(concatArray(_createFetchNoWorkerJobStreamArr(dataDir, fetchFunc))).then((function (recordArr) {
	                    var newrecord = caml_array_dup(state);
	                    return Promise.resolve(init(/* tuple */[
	                                    createInitJobHandleMap,
	                                    createLoopJobHandleMap
	                                  ], (newrecord[/* noWorkerJobRecord */3] = create$66(recordArr), newrecord)));
	                  })));
	}

	function _createHandleRenderConfigStreamArr(dataDir, fetchFunc, state) {
	  return fromPromise(_collectAllRecords(concatArray(_createFetchRenderConfigStreamArr(dataDir, fetchFunc))).then((function (recordArr) {
	                    var newrecord = caml_array_dup(state);
	                    return Promise.resolve((newrecord[/* renderConfigRecord */5] = create$62(recordArr), newrecord));
	                  })));
	}

	function _createFetchWorkerJobStreamArr(dataDir, fetchFunc) {
	  return /* array */[
	          map$4(convertSettingToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/setting/setting.json"
	                      ]), fetchFunc)),
	          map$4(convertMainInitPipelinesToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/pipeline/main/main_init_pipelines.json"
	                      ]), fetchFunc)),
	          map$4(convertMainLoopPipelinesToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/pipeline/main/main_loop_pipelines.json"
	                      ]), fetchFunc)),
	          map$4(convertMainInitJobsToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/job/main/main_init_jobs.json"
	                      ]), fetchFunc)),
	          map$4(convertMainLoopJobsToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/job/main/main_loop_jobs.json"
	                      ]), fetchFunc)),
	          map$4(convertWorkerPipelinesToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/pipeline/worker/worker_pipelines.json"
	                      ]), fetchFunc)),
	          map$4(convertWorkerJobsToRecord, createFetchJsonStream(join$2(/* array */[
	                        dataDir,
	                        "worker/job/worker/worker_jobs.json"
	                      ]), fetchFunc))
	        ];
	}

	function _createHandleWorkerJobConfigStreamArr(dataDir, fetchFunc, state) {
	  return fromPromise(_collectAllRecords(concatArray(_createFetchWorkerJobStreamArr(dataDir, fetchFunc))).then((function (recordArr) {
	                    var newrecord = caml_array_dup(state);
	                    return Promise.resolve((newrecord[/* workerJobRecord */4] = create$65(recordArr), newrecord));
	                  })));
	}

	function _createHandleJobConfigStreamArr(dataDir, fetchFunc, state) {
	  var match = isUseWorker(state);
	  if (match) {
	    return _createHandleWorkerJobConfigStreamArr(dataDir, fetchFunc, state);
	  } else {
	    return _createHandleNoWorkerJobConfigStreamArr(dataDir, fetchFunc, state);
	  }
	}

	function _createRecordWithState(state) {
	  return create$3(create$55(create$11(create$12(create$24(create$22(create$23(create$7(create$10(create$9(create$6(state)))))))))));
	}

	function _createAndSetState(stateData) {
	  setState$2(stateData, createState$2(/* () */0));
	  return /* () */0;
	}

	function load$4(jsonPathArr, fetchFunc, stateData) {
	  var settingFilePath = jsonPathArr[0];
	  var dataDir = jsonPathArr[1];
	  _createAndSetState(stateData);
	  return flatMap((function (json) {
	                return tap((function (state) {
	                              setState$2(stateData, state);
	                              return /* () */0;
	                            }), concatMap((function (state) {
	                                  return _createHandleRenderConfigStreamArr(dataDir, fetchFunc, state);
	                                }), _createHandleJobConfigStreamArr(dataDir, fetchFunc, _createRecordWithState(detect$2(detect(_setSetting(stateData, unsafeGetState$2(stateData), convertToRecord(json))))))));
	              }), createFetchJsonStream(settingFilePath, fetchFunc));
	}


	/* most Not a pure module */

	var loadConfig$2 = load$4;

	var loadWDB$2 = load$3;

	function loadIMGUIAsset$2(param, customTextureSourceDataArr, _, state) {
	  return load$2(customTextureSourceDataArr, addFont$1(param[0], param[1], getWonderIMGUIRecord(state))).then((function (imguiRecord) {
	                var newrecord = caml_array_dup(state);
	                var init = state[/* imguiRecord */43];
	                newrecord[/* imguiRecord */43] = /* record */[
	                  /* ioData */init[/* ioData */0],
	                  /* wonderImguiIMGUIRecord */imguiRecord
	                ];
	                return Promise.resolve(newrecord);
	              }));
	}


	/* IOIMGUIAPI-WonderImgui Not a pure module */

	function _fetch(filePath) {
	  return fetch(filePath);
	}

	function loadConfig$1(jsonPathArr) {
	  return loadConfig$2(jsonPathArr, _fetch, stateData);
	}

	function loadWDB$1(wdPath, state) {
	  return loadWDB$2(wdPath, _fetch, state);
	}

	function loadIMGUIAsset$1(fntFilePath, bitmapFilePath, customTextureSourceDataArr, state) {
	  return loadIMGUIAsset$2(/* tuple */[
	              fntFilePath,
	              bitmapFilePath
	            ], customTextureSourceDataArr, _fetch, state);
	}


	/* StateDataMain-Wonderjs Not a pure module */

	function create$67(state) {
	  var customGeometryRecord = getRecord$6(state);
	  var disposedIndexArray = customGeometryRecord[/* disposedIndexArray */17];
	  var match = generateIndex(customGeometryRecord[/* index */0], disposedIndexArray);
	  var index = match[0];
	  state[/* customGeometryRecord */24] = /* record */[
	    /* index */match[1],
	    /* buffer */customGeometryRecord[/* buffer */1],
	    /* vertices */customGeometryRecord[/* vertices */2],
	    /* texCoords */customGeometryRecord[/* texCoords */3],
	    /* normals */customGeometryRecord[/* normals */4],
	    /* indices */customGeometryRecord[/* indices */5],
	    /* verticesInfos */customGeometryRecord[/* verticesInfos */6],
	    /* texCoordsInfos */customGeometryRecord[/* texCoordsInfos */7],
	    /* normalsInfos */customGeometryRecord[/* normalsInfos */8],
	    /* indicesInfos */customGeometryRecord[/* indicesInfos */9],
	    /* verticesOffset */customGeometryRecord[/* verticesOffset */10],
	    /* texCoordsOffset */customGeometryRecord[/* texCoordsOffset */11],
	    /* normalsOffset */customGeometryRecord[/* normalsOffset */12],
	    /* indicesOffset */customGeometryRecord[/* indicesOffset */13],
	    /* disposeCount */customGeometryRecord[/* disposeCount */14],
	    /* gameObjectMap */customGeometryRecord[/* gameObjectMap */15],
	    /* groupCountMap */customGeometryRecord[/* groupCountMap */16],
	    /* disposedIndexArray */match[2],
	    /* disposedIndexMap */customGeometryRecord[/* disposedIndexMap */18],
	    /* aliveIndexArray */push(index, customGeometryRecord[/* aliveIndexArray */19])
	  ];
	  return checkNotExceedMaxCount(getCustomGeometryCount(state[/* settingRecord */1]), /* tuple */[
	              state,
	              index
	            ]);
	}


	/* ArrayService-Wonderjs Not a pure module */

	var createCustomGeometry$1 = create$67;

	function getCustomGeometryVertices$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return getVertices$2(geometry, state);
	}

	function setCustomGeometryVertices$1(geometry, data, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return setVerticesByTypeArray(geometry, data, state);
	}

	function getCustomGeometryTexCoords$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return getTexCoords$2(geometry, state);
	}

	function setCustomGeometryTexCoords$1(geometry, data, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return setTexCoordsByTypeArray(geometry, data, state);
	}

	function getCustomGeometryNormals$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return getNormals$2(geometry, state);
	}

	function setCustomGeometryNormals$1(geometry, data, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return setNormalsByTypeArray(geometry, data, state);
	}

	function getCustomGeometryIndices$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return getIndices$2(geometry, state);
	}

	function setCustomGeometryIndices$1(geometry, data, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return setIndicesByTypeArray(geometry, data, state);
	}

	function unsafeGetCustomGeometryGameObject$1(geometry, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(geometry, isAlive$12, getRecord$6(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$5(geometry, getRecord$6(state));
	}


	/* Contract-WonderLog Not a pure module */

	function createDirectionLight$1(state) {
	  var match = create$27(state[/* directionLightRecord */21]);
	  state[/* directionLightRecord */21] = match[0];
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}

	function unsafeGetDirectionLightGameObject$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$8, state[/* directionLightRecord */21]);
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$10(getMappedIndex(light, getMappedIndexMap(state[/* directionLightRecord */21])), state[/* directionLightRecord */21]);
	}

	function getDirectionLightColor$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$8, state[/* directionLightRecord */21]);
	        }), getIsDebug(stateData));
	  return getColor$9(getMappedIndex(light, getMappedIndexMap(state[/* directionLightRecord */21])), state[/* directionLightRecord */21]);
	}

	function setDirectionLightColor$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$8, state[/* directionLightRecord */21]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* directionLightRecord */21] = setColor$5(getMappedIndex(light, getMappedIndexMap(state[/* directionLightRecord */21])), color, state[/* directionLightRecord */21]);
	  return newrecord;
	}

	function getDirectionLightIntensity$1(light, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$8, state[/* directionLightRecord */21]);
	        }), getIsDebug(stateData));
	  return getIntensity$5(getMappedIndex(light, getMappedIndexMap(state[/* directionLightRecord */21])), state[/* directionLightRecord */21]);
	}

	function setDirectionLightIntensity$1(light, color, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(light, isAlive$8, state[/* directionLightRecord */21]);
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  newrecord[/* directionLightRecord */21] = setIntensity$3(getMappedIndex(light, getMappedIndexMap(state[/* directionLightRecord */21])), color, state[/* directionLightRecord */21]);
	  return newrecord;
	}


	/* Contract-WonderLog Not a pure module */

	function create$68(state) {
	  var record = getRecord$7(state);
	  var match = generateIndex(record[/* index */0], record[/* disposedIndexArray */8]);
	  var index = match[0];
	  state[/* sourceInstanceRecord */7] = /* record */[
	    /* index */match[1],
	    /* objectInstanceTransformIndexMap */setDefaultObjectInstanceTransformIndex(index, record[/* objectInstanceTransformIndexMap */1]),
	    /* buffer */record[/* buffer */2],
	    /* isTransformStatics */record[/* isTransformStatics */3],
	    /* objectInstanceTransformCollections */record[/* objectInstanceTransformCollections */4],
	    /* matrixInstanceBufferCapacityMap */record[/* matrixInstanceBufferCapacityMap */5],
	    /* matrixFloat32ArrayMap */record[/* matrixFloat32ArrayMap */6],
	    /* isSendTransformMatrixDataMap */record[/* isSendTransformMatrixDataMap */7],
	    /* disposedIndexArray */match[2],
	    /* gameObjectMap */record[/* gameObjectMap */9]
	  ];
	  return /* tuple */[
	          state,
	          index
	        ];
	}


	/* ObjectInstanceCollectionService-Wonderjs Not a pure module */

	function unsafeGetGameObject$12(sourceInstance, param) {
	  return unsafeGetGameObject$1(sourceInstance, param[/* gameObjectMap */9]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function create$69(sourceInstance, uid, record) {
	  var match = generateIndex(record[/* index */0], record[/* disposedIndexArray */2]);
	  var index = match[0];
	  return /* tuple */[
	          /* record */[
	            /* index */match[1],
	            /* sourceInstanceMap */set$1(index, sourceInstance, record[/* sourceInstanceMap */1]),
	            /* disposedIndexArray */record[/* disposedIndexArray */2],
	            /* gameObjectMap */addComponentToGameObjectMap(index, uid, record[/* gameObjectMap */3])
	          ],
	          index
	        ];
	}


	/* No side effect */

	function createInstance(sourceInstance, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = create$13(gameObjectRecord);
	  var uid = match[1];
	  var match$1 = create$5(state);
	  var transform = match$1[1];
	  var state$1 = match$1[0];
	  var sourceInstanceRecord = getRecord$7(state$1);
	  state$1[/* gameObjectRecord */11] = match[0];
	  var match$2 = addObjectInstanceTransform(sourceInstance, transform, getObjectInstanceCountPerSourceInstance(state[/* settingRecord */1]), /* tuple */[
	        sourceInstanceRecord[/* objectInstanceTransformIndexMap */1],
	        sourceInstanceRecord[/* objectInstanceTransformCollections */4]
	      ]);
	  state$1[/* sourceInstanceRecord */7] = /* record */[
	    /* index */sourceInstanceRecord[/* index */0],
	    /* objectInstanceTransformIndexMap */match$2[0],
	    /* buffer */sourceInstanceRecord[/* buffer */2],
	    /* isTransformStatics */sourceInstanceRecord[/* isTransformStatics */3],
	    /* objectInstanceTransformCollections */match$2[1],
	    /* matrixInstanceBufferCapacityMap */sourceInstanceRecord[/* matrixInstanceBufferCapacityMap */5],
	    /* matrixFloat32ArrayMap */sourceInstanceRecord[/* matrixFloat32ArrayMap */6],
	    /* isSendTransformMatrixDataMap */sourceInstanceRecord[/* isSendTransformMatrixDataMap */7],
	    /* disposedIndexArray */sourceInstanceRecord[/* disposedIndexArray */8],
	    /* gameObjectMap */sourceInstanceRecord[/* gameObjectMap */9]
	  ];
	  var match$3 = create$69(sourceInstance, uid, state$1[/* objectInstanceRecord */8]);
	  state$1[/* objectInstanceRecord */8] = match$3[0];
	  var state$2 = addObjectInstanceComponent(uid, match$3[1], addTransformComponent(uid, transform, state$1));
	  return /* tuple */[
	          state$2,
	          uid
	        ];
	}


	/* BufferSettingService-Wonderjs Not a pure module */

	function unsafeGetSourceInstanceGameObject$1(sourceInstance, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(sourceInstance, isAlive$14, getRecord$7(state));
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$12(sourceInstance, getRecord$7(state));
	}

	function createObjectInstanceGameObject$1(sourceInstance, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(sourceInstance, isAlive$14, getRecord$7(state));
	        }), getIsDebug(stateData));
	  return createInstance(sourceInstance, state);
	}

	function getSourceInstanceObjectInstanceTransformArray$1(sourceInstance, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(sourceInstance, isAlive$14, getRecord$7(state));
	        }), getIsDebug(stateData));
	  return getObjectInstanceTransformArray$1(sourceInstance, state);
	}

	function markSourceInstanceModelMatrixIsStatic$1(sourceInstance, isStatic, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(sourceInstance, isAlive$14, getRecord$7(state));
	        }), getIsDebug(stateData));
	  var newrecord = caml_array_dup(state);
	  var init = getRecord$7(state);
	  newrecord[/* sourceInstanceRecord */7] = /* record */[
	    /* index */init[/* index */0],
	    /* objectInstanceTransformIndexMap */init[/* objectInstanceTransformIndexMap */1],
	    /* buffer */init[/* buffer */2],
	    /* isTransformStatics */markModelMatrixIsStatic(sourceInstance, isStatic, getRecord$7(state)[/* isTransformStatics */3]),
	    /* objectInstanceTransformCollections */init[/* objectInstanceTransformCollections */4],
	    /* matrixInstanceBufferCapacityMap */init[/* matrixInstanceBufferCapacityMap */5],
	    /* matrixFloat32ArrayMap */init[/* matrixFloat32ArrayMap */6],
	    /* isSendTransformMatrixDataMap */init[/* isSendTransformMatrixDataMap */7],
	    /* disposedIndexArray */init[/* disposedIndexArray */8],
	    /* gameObjectMap */init[/* gameObjectMap */9]
	  ];
	  return newrecord;
	}

	var createSourceInstance$1 = create$68;


	/* Contract-WonderLog Not a pure module */

	function getGameTime$2(state) {
	  return getGameTime$1(state[/* timeControllerRecord */34]);
	}

	function getFps$2(state) {
	  return getFps$1(state[/* timeControllerRecord */34]);
	}


	/* TimeControllerService-Wonderjs Not a pure module */

	function createBasicCameraView$1(state) {
	  var match = create$28(state[/* basicCameraViewRecord */14]);
	  state[/* basicCameraViewRecord */14] = match[0];
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}

	function unsafeGetGameObjectBasicCameraView$1(cameraView, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraView, isAlive, state[/* basicCameraViewRecord */14]);
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject(cameraView, state[/* basicCameraViewRecord */14]);
	}

	function getBasicCameraViewWorldToCameraMatrix$2(cameraView, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraView, isAlive, state[/* basicCameraViewRecord */14]);
	        }), getIsDebug(stateData));
	  return getBasicCameraViewWorldToCameraMatrix$1(cameraView, state);
	}


	/* Contract-WonderLog Not a pure module */

	function create$70(state) {
	  var basicSourceTextureRecord = getRecord$9(state);
	  var match = generateIndex(basicSourceTextureRecord[/* index */0], basicSourceTextureRecord[/* disposedIndexArray */12]);
	  var index = generateBasicSourceTextureIndex$1(match[0]);
	  state[/* basicSourceTextureRecord */19] = /* record */[
	    /* index */match[1],
	    /* wrapSs */basicSourceTextureRecord[/* wrapSs */1],
	    /* wrapTs */basicSourceTextureRecord[/* wrapTs */2],
	    /* magFilters */basicSourceTextureRecord[/* magFilters */3],
	    /* minFilters */basicSourceTextureRecord[/* minFilters */4],
	    /* formats */basicSourceTextureRecord[/* formats */5],
	    /* types */basicSourceTextureRecord[/* types */6],
	    /* isNeedUpdates */basicSourceTextureRecord[/* isNeedUpdates */7],
	    /* flipYs */basicSourceTextureRecord[/* flipYs */8],
	    /* sourceMap */basicSourceTextureRecord[/* sourceMap */9],
	    /* glTextureMap */basicSourceTextureRecord[/* glTextureMap */10],
	    /* bindTextureUnitCacheMap */basicSourceTextureRecord[/* bindTextureUnitCacheMap */11],
	    /* disposedIndexArray */basicSourceTextureRecord[/* disposedIndexArray */12],
	    /* needAddedSourceArray */basicSourceTextureRecord[/* needAddedSourceArray */13],
	    /* needInitedTextureIndexArray */basicSourceTextureRecord[/* needInitedTextureIndexArray */14],
	    /* nameMap */basicSourceTextureRecord[/* nameMap */15]
	  ];
	  return checkNotExceedMaxCount(getBasicSourceTextureCount(state[/* settingRecord */1]), /* tuple */[
	              state,
	              index
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function createBasicSourceTexture$1(state) {
	  return create$70(state);
	}

	var unsafeGetBasicSourceTextureSource$1 = unsafeGetSource$1;

	var setBasicSourceTextureSource$1 = setSource$1;

	var getBasicSourceTextureWidth$1 = getWidth$2;

	var getBasicSourceTextureHeight$1 = getHeight$2;

	var getBasicSourceTextureWrapS$1 = getWrapS$2;

	var setBasicSourceTextureWrapS$1 = setWrapS$2;

	var getBasicSourceTextureWrapT$1 = getWrapT$2;

	var setBasicSourceTextureWrapT$1 = setWrapT$2;

	var getBasicSourceTextureMagFilter$1 = getMagFilter$2;

	var setBasicSourceTextureMagFilter$1 = setMagFilter$2;

	var getBasicSourceTextureMinFilter$1 = getMinFilter$2;

	var setBasicSourceTextureMinFilter$1 = setMinFilter$2;

	var getBasicSourceTextureFormat$1 = getFormat$2;

	var setBasicSourceTextureFormat$1 = setFormat$2;

	var getBasicSourceTextureType$1 = getType$3;

	var setBasicSourceTextureType$1 = setType$2;

	var getBasicSourceTextureFlipY$1 = getFlipY$3;

	var setBasicSourceTextureFlipY$1 = setFlipY$4;

	var getBasicSourceTextureName$1 = getName$4;

	var unsafeGetBasicSourceTextureName$1 = unsafeGetName$4;

	function setBasicSourceTextureName$1(texture, name, state) {
	  return setName$4(texture, name, state);
	}


	/* NameBasicSourceTextureMainService-Wonderjs Not a pure module */

	function _fillVertexBuffer(buffer, points, offset) {
	  setFloat32Array(points, new Float32Array(buffer, offset, points.length));
	  return buffer;
	}

	function _fillIndexBuffer(buffer, indices, offset) {
	  setUint16Array(indices, new Uint16Array(buffer, offset, indices.length));
	  return buffer;
	}

	function _fillImageUint8ArrayBuffer(buffer, uint8Array, offset) {
	  setUint8Array(uint8Array, new Uint8Array(buffer, offset, uint8Array.length));
	  return buffer;
	}

	function build$2(totalByteLength, param, imageUint8DataArr) {
	  var match = param[1];
	  var buffer = new ArrayBuffer(totalByteLength);
	  var buffer$1 = reduceOneParam((function (buffer, param) {
	          return _fillVertexBuffer(buffer, param[1], param[0]);
	        }), buffer, match[0]);
	  var buffer$2 = reduceOneParam((function (buffer, param) {
	          return _fillIndexBuffer(buffer, param[1], param[0]);
	        }), buffer$1, match[1]);
	  return reduceOneParam((function (buffer, param) {
	                return _fillImageUint8ArrayBuffer(buffer, param[/* uint8Array */2], param[/* byteOffset */3]);
	              }), buffer$2, imageUint8DataArr);
	}


	/* TypeArrayService-Wonderjs Not a pure module */

	function _hasMap(gameObject, state) {
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getLightMaterialComponent(gameObject, gameObjectRecord);
	  if (match !== undefined) {
	    var lightMaterial = match;
	    if (hasDiffuseMap(lightMaterial, state)) {
	      return true;
	    } else {
	      return hasSpecularMap(lightMaterial, state);
	    }
	  } else {
	    return false;
	  }
	}

	function _getBoxGeometryData(param, geometry, param$1, state) {
	  var customGeometryDataMap = param$1[1];
	  var boxGeometryDataMap = param$1[0];
	  var meshIndex = param[1];
	  var match = get$3(geometry, boxGeometryDataMap);
	  if (match !== undefined) {
	    var match$1 = match;
	    return /* tuple */[
	            match$1[0],
	            match$1[1],
	            meshIndex,
	            /* tuple */[
	              boxGeometryDataMap,
	              customGeometryDataMap
	            ]
	          ];
	  } else {
	    var match$2 = _hasMap(param[0], state);
	    var pointData = /* tuple */[
	      getVertices$3(state),
	      getNormals$3(state),
	      match$2 ? some$1(getTexCoords$3(state)) : undefined,
	      getIndices$3(state)
	    ];
	    return /* tuple */[
	            meshIndex,
	            pointData,
	            meshIndex + 1 | 0,
	            /* tuple */[
	              set$1(geometry, /* tuple */[
	                    meshIndex,
	                    pointData
	                  ], boxGeometryDataMap),
	              customGeometryDataMap
	            ]
	          ];
	  }
	}

	function _getCustomGeometryData(param, geometry, param$1, state) {
	  var customGeometryDataMap = param$1[1];
	  var boxGeometryDataMap = param$1[0];
	  var meshIndex = param[1];
	  var match = get$3(geometry, customGeometryDataMap);
	  if (match !== undefined) {
	    var match$1 = match;
	    return /* tuple */[
	            match$1[0],
	            match$1[1],
	            meshIndex,
	            /* tuple */[
	              boxGeometryDataMap,
	              customGeometryDataMap
	            ]
	          ];
	  } else {
	    var match$2 = _hasMap(param[0], state);
	    var pointData = /* tuple */[
	      getVertices$2(geometry, state),
	      getNormals$2(geometry, state),
	      match$2 ? some$1(getTexCoords$2(geometry, state)) : undefined,
	      getIndices$2(geometry, state)
	    ];
	    return /* tuple */[
	            meshIndex,
	            pointData,
	            meshIndex + 1 | 0,
	            /* tuple */[
	              boxGeometryDataMap,
	              set$1(geometry, /* tuple */[
	                    meshIndex,
	                    pointData
	                  ], customGeometryDataMap)
	            ]
	          ];
	  }
	}

	function _getMeshData(param, param$1, state) {
	  var customGeometryDataMap = param$1[1];
	  var boxGeometryDataMap = param$1[0];
	  var meshIndex = param[1];
	  var gameObject = param[0];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getGeometryComponentData(gameObject, gameObjectRecord);
	  if (match !== undefined) {
	    var match$1 = match;
	    var type_ = match$1[1];
	    var geometry = match$1[0];
	    if (type_ === getBoxGeometryType(/* () */0)) {
	      return _getBoxGeometryData(/* tuple */[
	                  gameObject,
	                  meshIndex
	                ], geometry, /* tuple */[
	                  boxGeometryDataMap,
	                  customGeometryDataMap
	                ], state);
	    } else if (type_ === getCustomGeometryType(/* () */0)) {
	      return _getCustomGeometryData(/* tuple */[
	                  gameObject,
	                  meshIndex
	                ], geometry, /* tuple */[
	                  boxGeometryDataMap,
	                  customGeometryDataMap
	                ], state);
	    } else {
	      return fatal(buildFatalMessage("unknown type_", "", "", "", "type_: " + (String(type_) + "")));
	    }
	  } else {
	    return /* tuple */[
	            undefined,
	            undefined,
	            meshIndex,
	            /* tuple */[
	              boxGeometryDataMap,
	              customGeometryDataMap
	            ]
	          ];
	  }
	}

	function _getBasicMaterialData(param, basicMaterialDataMap, state) {
	  var materialIndex = param[1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getBasicMaterialComponent(param[0], gameObjectRecord);
	  if (match !== undefined) {
	    var basicMaterial = match;
	    var match$1 = get$3(basicMaterial, basicMaterialDataMap);
	    if (match$1 !== undefined) {
	      var match$2 = match$1;
	      return /* tuple */[
	              match$2[0],
	              match$2[1],
	              materialIndex,
	              basicMaterialDataMap
	            ];
	    } else {
	      var materialData = /* tuple */[
	        basicMaterial,
	        getName$2(basicMaterial, state)
	      ];
	      return /* tuple */[
	              materialIndex,
	              materialData,
	              materialIndex + 1 | 0,
	              set$1(basicMaterial, /* tuple */[
	                    materialIndex,
	                    materialData
	                  ], basicMaterialDataMap)
	            ];
	    }
	  } else {
	    return /* tuple */[
	            undefined,
	            undefined,
	            materialIndex,
	            basicMaterialDataMap
	          ];
	  }
	}

	function _getLightMaterialData(param, lightMaterialDataMap, state) {
	  var materialIndex = param[1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getLightMaterialComponent(param[0], gameObjectRecord);
	  if (match !== undefined) {
	    var lightMaterial = match;
	    var match$1 = get$3(lightMaterial, lightMaterialDataMap);
	    if (match$1 !== undefined) {
	      var match$2 = match$1;
	      return /* tuple */[
	              match$2[0],
	              match$2[1],
	              materialIndex,
	              lightMaterialDataMap
	            ];
	    } else {
	      var materialData = /* tuple */[
	        lightMaterial,
	        getName$3(lightMaterial, state)
	      ];
	      return /* tuple */[
	              materialIndex,
	              materialData,
	              materialIndex + 1 | 0,
	              set$1(lightMaterial, /* tuple */[
	                    materialIndex,
	                    materialData
	                  ], lightMaterialDataMap)
	            ];
	    }
	  } else {
	    return /* tuple */[
	            undefined,
	            undefined,
	            materialIndex,
	            lightMaterialDataMap
	          ];
	  }
	}

	function _getMeshRendererData(param, state) {
	  var meshRendererIndex = param[1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getMeshRendererComponent(param[0], gameObjectRecord);
	  if (match !== undefined) {
	    var meshRendererData = match;
	    return /* tuple */[
	            meshRendererIndex,
	            meshRendererData,
	            meshRendererIndex + 1 | 0
	          ];
	  } else {
	    return /* tuple */[
	            undefined,
	            undefined,
	            meshRendererIndex
	          ];
	  }
	}

	function _getCameraData(param, state) {
	  var cameraIndex = param[1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getPerspectiveCameraProjectionComponent(param[0], gameObjectRecord);
	  if (match !== undefined) {
	    var cameraData = match;
	    return /* tuple */[
	            cameraIndex,
	            cameraData,
	            cameraIndex + 1 | 0
	          ];
	  } else {
	    return /* tuple */[
	            undefined,
	            undefined,
	            cameraIndex
	          ];
	  }
	}

	function _getArcballCameraControllerData(param, state) {
	  var arcballCameraControllerIndex = param[1];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getArcballCameraControllerComponent(param[0], gameObjectRecord);
	  if (match !== undefined) {
	    return /* tuple */[
	            arcballCameraControllerIndex,
	            match,
	            arcballCameraControllerIndex + 1 | 0
	          ];
	  } else {
	    return /* tuple */[
	            undefined,
	            undefined,
	            arcballCameraControllerIndex
	          ];
	  }
	}

	function _getLightData(param, state) {
	  var lightIndex = param[1];
	  var gameObject = param[0];
	  var gameObjectRecord = state[/* gameObjectRecord */11];
	  var match = getDirectionLightComponent(gameObject, gameObjectRecord);
	  if (match !== undefined) {
	    var lightData = /* tuple */[
	      "directional",
	      match
	    ];
	    return /* tuple */[
	            lightIndex,
	            lightData,
	            lightIndex + 1 | 0
	          ];
	  } else {
	    var match$1 = getPointLightComponent(gameObject, gameObjectRecord);
	    if (match$1 !== undefined) {
	      var lightData$1 = /* tuple */[
	        "point",
	        match$1
	      ];
	      return /* tuple */[
	              lightIndex,
	              lightData$1,
	              lightIndex + 1 | 0
	            ];
	    } else {
	      return /* tuple */[
	              undefined,
	              undefined,
	              lightIndex
	            ];
	    }
	  }
	}

	function getComponentData$1(param) {
	  var match = param[4];
	  var lightDataMap = match[6];
	  var arcballCameraControllerDataMap = match[5];
	  var cameraDataMap = match[4];
	  var resultLightMaterialDataMap = match[3];
	  var resultBasicMaterialDataMap = match[2];
	  var meshRendererDataMap = match[1];
	  var meshPointDataMap = match[0];
	  var match$1 = param[3];
	  var match$2 = match$1[0];
	  var match$3 = param[2];
	  var state = param[1];
	  var gameObject = param[0];
	  var match$4 = _getMeshData(/* tuple */[
	        gameObject,
	        match$3[0]
	      ], /* tuple */[
	        match$2[0],
	        match$2[1]
	      ], state);
	  var match$5 = match$4[3];
	  var meshIndex = match$4[0];
	  var meshPointDataMap$1 = meshIndex !== undefined ? set$1(meshIndex, unsafeGet$1(match$4[1]), meshPointDataMap) : meshPointDataMap;
	  var match$6 = _getMeshRendererData(/* tuple */[
	        gameObject,
	        match$3[1]
	      ], state);
	  var meshRendererIndex = match$6[0];
	  var meshRendererDataMap$1 = meshRendererIndex !== undefined ? set$1(meshRendererIndex, unsafeGet$1(match$6[1]), meshRendererDataMap) : meshRendererDataMap;
	  var match$7 = _getBasicMaterialData(/* tuple */[
	        gameObject,
	        match$3[2]
	      ], match$1[1], state);
	  var basicMaterialIndex = match$7[0];
	  var resultBasicMaterialDataMap$1 = basicMaterialIndex !== undefined ? set$1(basicMaterialIndex, unsafeGet$1(match$7[1]), resultBasicMaterialDataMap) : resultBasicMaterialDataMap;
	  var match$8 = _getLightMaterialData(/* tuple */[
	        gameObject,
	        match$3[3]
	      ], match$1[2], state);
	  var lightMaterialIndex = match$8[0];
	  var resultLightMaterialDataMap$1 = lightMaterialIndex !== undefined ? set$1(lightMaterialIndex, unsafeGet$1(match$8[1]), resultLightMaterialDataMap) : resultLightMaterialDataMap;
	  var match$9 = _getCameraData(/* tuple */[
	        gameObject,
	        match$3[4]
	      ], state);
	  var cameraIndex = match$9[0];
	  var cameraDataMap$1 = cameraIndex !== undefined ? set$1(cameraIndex, unsafeGet$1(match$9[1]), cameraDataMap) : cameraDataMap;
	  var match$10 = _getArcballCameraControllerData(/* tuple */[
	        gameObject,
	        match$3[5]
	      ], state);
	  var arcballCameraControllerIndex = match$10[0];
	  var arcballCameraControllerDataMap$1 = arcballCameraControllerIndex !== undefined ? set$1(arcballCameraControllerIndex, unsafeGet$1(match$10[1]), arcballCameraControllerDataMap) : arcballCameraControllerDataMap;
	  var match$11 = _getLightData(/* tuple */[
	        gameObject,
	        match$3[6]
	      ], state);
	  var lightIndex = match$11[0];
	  var lightDataMap$1 = lightIndex !== undefined ? set$1(lightIndex, unsafeGet$1(match$11[1]), lightDataMap) : lightDataMap;
	  return /* tuple */[
	          state,
	          /* tuple */[
	            meshIndex,
	            meshRendererIndex,
	            basicMaterialIndex,
	            lightMaterialIndex,
	            cameraIndex,
	            arcballCameraControllerIndex,
	            lightIndex
	          ],
	          /* tuple */[
	            match$4[2],
	            match$6[2],
	            match$7[2],
	            match$8[2],
	            match$9[2],
	            match$10[2],
	            match$11[2]
	          ],
	          /* tuple */[
	            /* tuple */[
	              match$5[0],
	              match$5[1]
	            ],
	            match$7[3],
	            match$8[3]
	          ],
	          /* tuple */[
	            meshPointDataMap$1,
	            meshRendererDataMap$1,
	            resultBasicMaterialDataMap$1,
	            resultLightMaterialDataMap$1,
	            cameraDataMap$1,
	            arcballCameraControllerDataMap$1,
	            lightDataMap$1
	          ]
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function _setChildren$1(gameObjectChildrenMap, gameObjectNodeIndexMap, nodeDataArr) {
	  return reduceOneParam((function (newNodeDataArr, nodeData) {
	                var match = get$3(nodeData[/* gameObject */0], gameObjectChildrenMap);
	                return push(/* record */[
	                            /* gameObject */nodeData[/* gameObject */0],
	                            /* children */match !== undefined ? match.map((function (childGameObject) {
	                                      return unsafeGet$2(childGameObject, gameObjectNodeIndexMap);
	                                    })) : undefined,
	                            /* translation */nodeData[/* translation */2],
	                            /* rotation */nodeData[/* rotation */3],
	                            /* scale */nodeData[/* scale */4],
	                            /* mesh */nodeData[/* mesh */5],
	                            /* camera */nodeData[/* camera */6],
	                            /* extras */nodeData[/* extras */7],
	                            /* extensions */nodeData[/* extensions */8]
	                          ], newNodeDataArr);
	              }), /* array */[], nodeDataArr);
	}

	function _addNodeData(gameObject, param, param$1, nodeDataArr) {
	  var lightIndex = param$1[6];
	  var lightMaterialIndex = param$1[5];
	  var basicMaterialIndex = param$1[4];
	  var arcballCameraControllerIndex = param$1[3];
	  var meshRendererIndex = param$1[1];
	  var defaultLocalScale = param[6];
	  var defaultLocalRotation = param[5];
	  var defaultLocalPosition = param[4];
	  var transform = param[0];
	  var localPosition = getLocalPositionTuple$1(transform, param[1]);
	  var localRotation = getLocalRotationTuple$1(transform, param[2]);
	  var localScale = getLocalScaleTuple$1(transform, param[3]);
	  var tmp;
	  var exit = 0;
	  if (meshRendererIndex !== undefined || basicMaterialIndex !== undefined || lightMaterialIndex !== undefined || arcballCameraControllerIndex !== undefined) {
	    exit = 1;
	  } else {
	    tmp = undefined;
	  }
	  if (exit === 1) {
	    tmp = /* record */[
	      /* meshRenderer */meshRendererIndex,
	      /* basicMaterial */basicMaterialIndex,
	      /* lightMaterial */lightMaterialIndex,
	      /* cameraController */arcballCameraControllerIndex
	    ];
	  }
	  return push(/* record */[
	              /* gameObject */gameObject,
	              /* children */undefined,
	              /* translation */localPosition[0] === caml_array_get(defaultLocalPosition, 0) && localPosition[1] === caml_array_get(defaultLocalPosition, 1) && localPosition[2] === caml_array_get(defaultLocalPosition, 2) ? undefined : localPosition,
	              /* rotation */localRotation[0] === caml_array_get(defaultLocalRotation, 0) && localRotation[1] === caml_array_get(defaultLocalRotation, 1) && localRotation[2] === caml_array_get(defaultLocalRotation, 2) && localRotation[3] === caml_array_get(defaultLocalRotation, 3) ? undefined : localRotation,
	              /* scale */localScale[0] === caml_array_get(defaultLocalScale, 0) && localScale[1] === caml_array_get(defaultLocalScale, 1) && localScale[2] === caml_array_get(defaultLocalScale, 2) ? undefined : localScale,
	              /* mesh */param$1[0],
	              /* camera */param$1[2],
	              /* extras */tmp,
	              /* extensions */lightIndex !== undefined ? /* record */[/* khr_lights *//* record */[/* light */lightIndex]] : undefined
	            ], nodeDataArr);
	}

	function _getNodeData(state, param, param$1, param$2, param$3) {
	  var match = param$1[0];
	  return reduceOneParam((function (param, transform) {
	                var state = param[0];
	                var match = param[3];
	                var match$1 = param[2];
	                var gameObjectChildrenMap = match$1[3];
	                var match$2 = match$1[0];
	                var match$3 = param[1];
	                var nodeIndex = match$3[0];
	                var transformRecord = getRecord$1(state);
	                var localPositions = transformRecord[/* localPositions */3];
	                var localRotations = transformRecord[/* localRotations */4];
	                var localScales = transformRecord[/* localScales */5];
	                var gameObject = unsafeGetGameObject$6(transform, transformRecord);
	                var childrenTransformArr = unsafeGetChildren(transform, transformRecord);
	                var childrenGameObjectArr = childrenTransformArr.map((function (transform) {
	                        return unsafeGetGameObject$6(transform, transformRecord);
	                      }));
	                var match$4 = childrenGameObjectArr.length;
	                var gameObjectChildrenMap$1 = match$4 !== 0 ? set$1(gameObject, childrenGameObjectArr, gameObjectChildrenMap) : gameObjectChildrenMap;
	                var gameObjectNodeIndexMap = set$1(gameObject, nodeIndex, match$1[4]);
	                var match$5 = getComponentData$1(/* tuple */[
	                      gameObject,
	                      state,
	                      /* tuple */[
	                        match$3[1],
	                        match$3[2],
	                        match$3[3],
	                        match$3[4],
	                        match$3[5],
	                        match$3[6],
	                        match$3[7]
	                      ],
	                      /* tuple */[
	                        /* tuple */[
	                          match$2[0],
	                          match$2[1]
	                        ],
	                        match$1[1],
	                        match$1[2]
	                      ],
	                      /* tuple */[
	                        match[0],
	                        match[1],
	                        match[2],
	                        match[3],
	                        match[4],
	                        match[5],
	                        match[6]
	                      ]
	                    ]);
	                var match$6 = match$5[4];
	                var match$7 = match$5[3];
	                var match$8 = match$7[0];
	                var match$9 = match$5[2];
	                var match$10 = match$5[1];
	                return _getNodeData(match$5[0], /* tuple */[
	                            nodeIndex + 1 | 0,
	                            match$9[0],
	                            match$9[1],
	                            match$9[2],
	                            match$9[3],
	                            match$9[4],
	                            match$9[5],
	                            match$9[6]
	                          ], /* tuple */[
	                            /* tuple */[
	                              match$8[0],
	                              match$8[1]
	                            ],
	                            match$7[1],
	                            match$7[2],
	                            gameObjectChildrenMap$1,
	                            gameObjectNodeIndexMap
	                          ], /* tuple */[
	                            match$6[0],
	                            match$6[1],
	                            match$6[2],
	                            match$6[3],
	                            match$6[4],
	                            match$6[5],
	                            match$6[6]
	                          ], /* tuple */[
	                            childrenTransformArr,
	                            _addNodeData(gameObject, /* tuple */[
	                                  transform,
	                                  localPositions,
	                                  localRotations,
	                                  localScales,
	                                  transformRecord[/* defaultLocalPosition */12],
	                                  transformRecord[/* defaultLocalRotation */13],
	                                  transformRecord[/* defaultLocalScale */14]
	                                ], /* tuple */[
	                                  match$10[0],
	                                  match$10[1],
	                                  match$10[4],
	                                  match$10[5],
	                                  match$10[2],
	                                  match$10[3],
	                                  match$10[6]
	                                ], param[4])
	                          ]);
	              }), /* tuple */[
	              state,
	              /* tuple */[
	                param[0],
	                param[1],
	                param[2],
	                param[3],
	                param[4],
	                param[5],
	                param[6],
	                param[7]
	              ],
	              /* tuple */[
	                /* tuple */[
	                  match[0],
	                  match[1]
	                ],
	                param$1[1],
	                param$1[2],
	                param$1[3],
	                param$1[4]
	              ],
	              /* tuple */[
	                param$2[0],
	                param$2[1],
	                param$2[2],
	                param$2[3],
	                param$2[4],
	                param$2[5],
	                param$2[6]
	              ],
	              param$3[1]
	            ], param$3[0]);
	}

	function getAllNodeData(rootGameObject, state) {
	  var match = _getNodeData(state, /* tuple */[
	        0,
	        0,
	        0,
	        0,
	        0,
	        0,
	        0,
	        0
	      ], /* tuple */[
	        /* tuple */[
	          createEmpty$2(/* () */0),
	          createEmpty$2(/* () */0)
	        ],
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0)
	      ], /* tuple */[
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0),
	        createEmpty$2(/* () */0)
	      ], /* tuple */[
	        /* array */[unsafeGetGameObjectTransformComponent$1(rootGameObject, state)],
	        /* array */[]
	      ]);
	  var match$1 = match[3];
	  var match$2 = match[2];
	  var nodeDataArr = _setChildren$1(match$2[3], match$2[4], match[4]);
	  return /* tuple */[
	          match[0],
	          /* tuple */[
	            match$1[0],
	            match$1[1],
	            match$1[2],
	            match$1[3],
	            match$1[4],
	            match$1[5],
	            match$1[6]
	          ],
	          nodeDataArr
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	var object_ = fromList$1;


	/* Js_dict Not a pure module */

	function checkShouldHasNoSlot(map) {
	  return test(buildAssertMessage("map has no slot", "not"), (function () {
	                return Operators[/* = */0](length$2(getValidValues(map)), length$2(map));
	              }));
	}


	/* Log-WonderLog Not a pure module */

	function getAmbientLightIndex(lightDataArr) {
	  return lightDataArr.length - 1 | 0;
	}

	function build$3(lightDataMap, state) {
	  var directionLightRecord = state[/* directionLightRecord */21];
	  var pointLightRecord = state[/* pointLightRecord */22];
	  requireCheck((function () {
	          return checkShouldHasNoSlot(lightDataMap);
	        }), getIsDebug(stateData));
	  return push(/* record */[
	              /* type_ */"ambient",
	              /* color */getAmbientLightColor$1(state),
	              /* intensity */undefined,
	              /* constantAttenuation */undefined,
	              /* linearAttenuation */undefined,
	              /* quadraticAttenuation */undefined,
	              /* range */undefined
	            ], reduceValid((function (lightDataArr, param) {
	                    var light = param[1];
	                    var type_ = param[0];
	                    switch (type_) {
	                      case "directional" : 
	                          return push(/* record */[
	                                      /* type_ */type_,
	                                      /* color */getColor$9(light, directionLightRecord),
	                                      /* intensity */getIntensity$5(light, directionLightRecord),
	                                      /* constantAttenuation */undefined,
	                                      /* linearAttenuation */undefined,
	                                      /* quadraticAttenuation */undefined,
	                                      /* range */undefined
	                                    ], lightDataArr);
	                      case "point" : 
	                          return push(/* record */[
	                                      /* type_ */type_,
	                                      /* color */getColor$8(light, pointLightRecord),
	                                      /* intensity */getIntensity$4(light, pointLightRecord),
	                                      /* constantAttenuation */getConstant$2(light, pointLightRecord),
	                                      /* linearAttenuation */getLinear$1(light, pointLightRecord),
	                                      /* quadraticAttenuation */getQuadratic$2(light, pointLightRecord),
	                                      /* range */getRange$2(light, pointLightRecord)
	                                    ], lightDataArr);
	                      default:
	                        throw [
	                              match_failure,
	                              /* tuple */[
	                                "BuildLightDataSystem.re",
	                                20,
	                                9
	                              ]
	                            ];
	                    }
	                  }), /* array */[], lightDataMap));
	}


	/* SceneAPI-Wonderjs Not a pure module */

	function _encodeNodeTransform(param, list) {
	  var scale = param[/* scale */4];
	  var rotation = param[/* rotation */3];
	  var translation = param[/* translation */2];
	  var list$1$$1 = translation !== undefined ? /* :: */[
	      /* tuple */[
	        "translation",
	        translation
	      ],
	      list
	    ] : list;
	  var list$2 = rotation !== undefined ? /* :: */[
	      /* tuple */[
	        "rotation",
	        rotation
	      ],
	      list$1$$1
	    ] : list$1$$1;
	  if (scale !== undefined) {
	    return /* :: */[
	            /* tuple */[
	              "scale",
	              scale
	            ],
	            list$2
	          ];
	  } else {
	    return list$2;
	  }
	}

	function _encodeNodeExtensions(extensions, list) {
	  if (extensions !== undefined) {
	    var khr_lights = extensions[/* khr_lights */0];
	    var extensionList = khr_lights !== undefined ? /* :: */[
	        /* tuple */[
	          "KHR_lights",
	          object_(/* :: */[
	                /* tuple */[
	                  "light",
	                  khr_lights[/* light */0]
	                ],
	                /* [] */0
	              ])
	        ],
	        /* [] */0
	      ] : /* [] */0;
	    return /* :: */[
	            /* tuple */[
	              "extensions",
	              object_(extensionList)
	            ],
	            list
	          ];
	  } else {
	    return list;
	  }
	}

	function _encodeNodeMaterial(basicMaterial, lightMaterial, extraList) {
	  var extraList$1 = basicMaterial !== undefined ? /* :: */[
	      /* tuple */[
	        "basicMaterial",
	        basicMaterial
	      ],
	      extraList
	    ] : extraList;
	  if (lightMaterial !== undefined) {
	    return /* :: */[
	            /* tuple */[
	              "lightMaterial",
	              lightMaterial
	            ],
	            extraList$1
	          ];
	  } else {
	    return extraList$1;
	  }
	}

	function _encodeNodeCameraController(cameraController, extraList) {
	  if (cameraController !== undefined) {
	    return /* :: */[
	            /* tuple */[
	              "cameraController",
	              cameraController
	            ],
	            extraList
	          ];
	  } else {
	    return extraList;
	  }
	}

	function _encodeNodeExtras(extras, list) {
	  if (extras !== undefined) {
	    var match = extras;
	    var extraList = _encodeNodeMaterial(match[/* basicMaterial */1], match[/* lightMaterial */2], /* [] */0);
	    var extraList$1 = _encodeNodeCameraController(match[/* cameraController */3], extraList);
	    return /* :: */[
	            /* tuple */[
	              "extras",
	              object_(extraList$1)
	            ],
	            list
	          ];
	  } else {
	    return list;
	  }
	}

	function _encodeNodeComponents(param, list) {
	  var camera = param[/* camera */6];
	  var mesh = param[/* mesh */5];
	  var list$1$$1 = mesh !== undefined ? /* :: */[
	      /* tuple */[
	        "mesh",
	        mesh
	      ],
	      list
	    ] : list;
	  var list$2 = camera !== undefined ? /* :: */[
	      /* tuple */[
	        "camera",
	        camera
	      ],
	      list$1$$1
	    ] : list$1$$1;
	  var list$3 = _encodeNodeExtras(param[/* extras */7], list$2);
	  return _encodeNodeExtensions(param[/* extensions */8], list$3);
	}

	function _encodeNodes(nodeDataArr, state) {
	  return /* tuple */[
	          "nodes",
	          nodeDataArr.map((function (nodeData) {
	                  var children = nodeData[/* children */1];
	                  var match = getName(nodeData[/* gameObject */0], state);
	                  var list = match !== undefined ? /* :: */[
	                      /* tuple */[
	                        "name",
	                        match
	                      ],
	                      /* [] */0
	                    ] : /* [] */0;
	                  var list$1$$1 = children !== undefined ? /* :: */[
	                      /* tuple */[
	                        "children",
	                        children
	                      ],
	                      list
	                    ] : list;
	                  var list$2 = _encodeNodeComponents(nodeData, _encodeNodeTransform(nodeData, list$1$$1));
	                  return object_(rev(list$2));
	                }))
	        ];
	}

	function _encodePerspectiveCamera(param) {
	  var aspect = param[/* aspect */3];
	  var far = param[/* far */1];
	  var perspectiveList_000 = /* tuple */[
	    "znear",
	    param[/* near */0]
	  ];
	  var perspectiveList_001 = /* :: */[
	    /* tuple */[
	      "yfov",
	      param[/* fovy */2]
	    ],
	    /* [] */0
	  ];
	  var perspectiveList = /* :: */[
	    perspectiveList_000,
	    perspectiveList_001
	  ];
	  var perspectiveList$1 = far !== undefined ? /* :: */[
	      /* tuple */[
	        "zfar",
	        far
	      ],
	      perspectiveList
	    ] : perspectiveList;
	  if (aspect !== undefined) {
	    return /* :: */[
	            /* tuple */[
	              "aspectRatio",
	              aspect
	            ],
	            perspectiveList$1
	          ];
	  } else {
	    return perspectiveList$1;
	  }
	}

	function _encodeCameras(cameraDataArr) {
	  return /* tuple */[
	          "cameras",
	          cameraDataArr.map((function (param) {
	                  return object_(/* :: */[
	                              /* tuple */[
	                                "type",
	                                param[/* type_ */0]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "perspective",
	                                  object_(_encodePerspectiveCamera(param[/* perspective */1]))
	                                ],
	                                /* [] */0
	                              ]
	                            ]);
	                }))
	        ];
	}

	function _encodeExtras(meshRendererDataArr, basicMaterialDataArr, arcballCameraControllerDataArr) {
	  var match = meshRendererDataArr.length;
	  var extrasList = match !== 0 ? /* :: */[
	      /* tuple */[
	        "meshRenderers",
	        meshRendererDataArr.map((function (data) {
	                return object_(/* :: */[
	                            /* tuple */[
	                              "drawMode",
	                              data[/* drawMode */0]
	                            ],
	                            /* [] */0
	                          ]);
	              }))
	      ],
	      /* [] */0
	    ] : /* [] */0;
	  var match$1 = basicMaterialDataArr.length;
	  var extrasList$1 = match$1 !== 0 ? /* :: */[
	      /* tuple */[
	        "basicMaterials",
	        basicMaterialDataArr.map((function (data) {
	                var name = data[/* name */1];
	                var colorFactor = data[/* colorFactor */0];
	                var list = colorFactor !== undefined ? /* :: */[
	                    /* tuple */[
	                      "colorFactor",
	                      colorFactor
	                    ],
	                    /* [] */0
	                  ] : /* [] */0;
	                return object_(name !== undefined ? /* :: */[
	                              /* tuple */[
	                                "name",
	                                name
	                              ],
	                              list
	                            ] : list);
	              }))
	      ],
	      extrasList
	    ] : extrasList;
	  var match$2 = arcballCameraControllerDataArr.length;
	  var extrasList$2 = match$2 !== 0 ? /* :: */[
	      /* tuple */[
	        "arcballCameraControllers",
	        arcballCameraControllerDataArr.map((function (data) {
	                return object_(/* :: */[
	                            /* tuple */[
	                              "distance",
	                              data[/* distance */0]
	                            ],
	                            /* :: */[
	                              /* tuple */[
	                                "minDistance",
	                                data[/* minDistance */1]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "phi",
	                                  data[/* phi */2]
	                                ],
	                                /* :: */[
	                                  /* tuple */[
	                                    "theta",
	                                    data[/* theta */3]
	                                  ],
	                                  /* :: */[
	                                    /* tuple */[
	                                      "thetaMargin",
	                                      data[/* thetaMargin */4]
	                                    ],
	                                    /* :: */[
	                                      /* tuple */[
	                                        "target",
	                                        data[/* target */5]
	                                      ],
	                                      /* :: */[
	                                        /* tuple */[
	                                          "moveSpeedX",
	                                          data[/* moveSpeedX */6]
	                                        ],
	                                        /* :: */[
	                                          /* tuple */[
	                                            "moveSpeedY",
	                                            data[/* moveSpeedY */7]
	                                          ],
	                                          /* :: */[
	                                            /* tuple */[
	                                              "rotateSpeed",
	                                              data[/* rotateSpeed */8]
	                                            ],
	                                            /* :: */[
	                                              /* tuple */[
	                                                "wheelSpeed",
	                                                data[/* wheelSpeed */9]
	                                              ],
	                                              /* [] */0
	                                            ]
	                                          ]
	                                        ]
	                                      ]
	                                    ]
	                                  ]
	                                ]
	                              ]
	                            ]
	                          ]);
	              }))
	      ],
	      extrasList$1
	    ] : extrasList$1;
	  return /* tuple */[
	          "extras",
	          object_(extrasList$2)
	        ];
	}

	function _encodeScenes(extensionsUsedArr, lightDataArr, imguiData, _) {
	  var list_000 = /* tuple */[
	    "nodes",
	    /* array */[0]
	  ];
	  var list = /* :: */[
	    list_000,
	    /* [] */0
	  ];
	  var match = extensionsUsedArr.includes("KHR_lights");
	  var list$1$$1 = match ? /* :: */[
	      /* tuple */[
	        "extensions",
	        object_(/* :: */[
	              /* tuple */[
	                "KHR_lights",
	                object_(/* :: */[
	                      /* tuple */[
	                        "light",
	                        getAmbientLightIndex(lightDataArr)
	                      ],
	                      /* [] */0
	                    ])
	              ],
	              /* [] */0
	            ])
	      ],
	      list
	    ] : list;
	  var match$1 = imguiData[0];
	  var list$2;
	  var exit = 0;
	  if (match$1 !== undefined) {
	    var match$2 = imguiData[1];
	    if (match$2 !== undefined) {
	      list$2 = /* :: */[
	        /* tuple */[
	          "extras",
	          object_(/* :: */[
	                /* tuple */[
	                  "customData",
	                  valFromOption(match$1)
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "imguiFunc",
	                    match$2
	                  ],
	                  /* [] */0
	                ]
	              ])
	        ],
	        list$1$$1
	      ];
	    } else {
	      exit = 1;
	    }
	  } else if (imguiData[1] !== undefined) {
	    exit = 1;
	  } else {
	    list$2 = list$1$$1;
	  }
	  if (exit === 1) {
	    list$2 = fatal(buildFatalMessage("_encodeScenes", "imguiData error", "", "", ""));
	  }
	  return /* tuple */[
	          "scenes",
	          /* array */[object_(list$2)]
	        ];
	}

	function _encodeLightMaterials(materialDataArr) {
	  return /* tuple */[
	          "materials",
	          materialDataArr.map((function (param) {
	                  var name = param[/* name */2];
	                  var baseColorTexture = param[/* baseColorTexture */1];
	                  var baseColorFactor = param[/* baseColorFactor */0];
	                  var list = name !== undefined ? /* :: */[
	                      /* tuple */[
	                        "name",
	                        name
	                      ],
	                      /* [] */0
	                    ] : /* [] */0;
	                  var pbrMetallicRoughnessList = baseColorFactor !== undefined ? /* :: */[
	                      /* tuple */[
	                        "baseColorFactor",
	                        baseColorFactor
	                      ],
	                      /* [] */0
	                    ] : /* [] */0;
	                  var pbrMetallicRoughnessList$1 = baseColorTexture !== undefined ? /* :: */[
	                      /* tuple */[
	                        "baseColorTexture",
	                        object_(/* :: */[
	                              /* tuple */[
	                                "index",
	                                baseColorTexture
	                              ],
	                              /* [] */0
	                            ])
	                      ],
	                      pbrMetallicRoughnessList
	                    ] : pbrMetallicRoughnessList;
	                  var list_000 = /* tuple */[
	                    "pbrMetallicRoughness",
	                    object_(pbrMetallicRoughnessList$1)
	                  ];
	                  var list$1$$1 = /* :: */[
	                    list_000,
	                    list
	                  ];
	                  return object_(rev(list$1$$1));
	                }))
	        ];
	}

	function _encodeTextures(textureDataArr) {
	  return /* tuple */[
	          "textures",
	          textureDataArr.map((function (param) {
	                  var name = param[/* name */0];
	                  var list = name !== undefined ? /* :: */[
	                      /* tuple */[
	                        "name",
	                        name
	                      ],
	                      /* [] */0
	                    ] : /* [] */0;
	                  return object_(/* :: */[
	                              /* tuple */[
	                                "sampler",
	                                param[/* sampler */1]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "source",
	                                  param[/* source */2]
	                                ],
	                                list
	                              ]
	                            ]);
	                }))
	        ];
	}

	function _encodeSamplers(samplerDataArr) {
	  return /* tuple */[
	          "samplers",
	          samplerDataArr.map((function (param) {
	                  return object_(/* :: */[
	                              /* tuple */[
	                                "wrapS",
	                                param[/* wrapS */0]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "wrapT",
	                                  param[/* wrapT */1]
	                                ],
	                                /* :: */[
	                                  /* tuple */[
	                                    "magFilter",
	                                    param[/* magFilter */2]
	                                  ],
	                                  /* :: */[
	                                    /* tuple */[
	                                      "minFilter",
	                                      param[/* minFilter */3]
	                                    ],
	                                    /* [] */0
	                                  ]
	                                ]
	                              ]
	                            ]);
	                }))
	        ];
	}

	function _encodeImages(imageUint8DataArr) {
	  return /* tuple */[
	          "images",
	          imageUint8DataArr.map((function (param) {
	                  return object_(/* :: */[
	                              /* tuple */[
	                                "bufferView",
	                                param[/* bufferView */0]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "mimeType",
	                                  param[/* mimeType */1]
	                                ],
	                                /* [] */0
	                              ]
	                            ]);
	                }))
	        ];
	}

	function _encodeAttributes(position, normal, texCoord_0, indices) {
	  var attributesList_000 = /* tuple */[
	    "POSITION",
	    position
	  ];
	  var attributesList = /* :: */[
	    attributesList_000,
	    /* [] */0
	  ];
	  var attributesList$1 = normal !== undefined ? /* :: */[
	      /* tuple */[
	        "NORMAL",
	        normal
	      ],
	      attributesList
	    ] : attributesList;
	  var attributesList$2 = texCoord_0 !== undefined ? /* :: */[
	      /* tuple */[
	        "TEXCOORD_0",
	        texCoord_0
	      ],
	      attributesList$1
	    ] : attributesList$1;
	  return /* :: */[
	          /* tuple */[
	            "attributes",
	            object_(rev(attributesList$2))
	          ],
	          /* :: */[
	            /* tuple */[
	              "indices",
	              indices
	            ],
	            /* [] */0
	          ]
	        ];
	}

	function _encodeMeshes(meshDataArr) {
	  return /* tuple */[
	          "meshes",
	          meshDataArr.map((function (param) {
	                  var primitives = param[/* primitives */0];
	                  var attributes = primitives[/* attributes */0];
	                  var material = primitives[/* material */2];
	                  var name = param[/* name */1];
	                  var primitivesList = _encodeAttributes(attributes[/* position */0], attributes[/* normal */1], attributes[/* texCoord_0 */2], primitives[/* indices */1]);
	                  var primitivesList$1 = material !== undefined ? append$1(/* :: */[
	                          /* tuple */[
	                            "material",
	                            material
	                          ],
	                          /* [] */0
	                        ], primitivesList) : primitivesList;
	                  var primitives_001 = /* array */[object_(primitivesList$1)];
	                  var primitives$1 = /* tuple */[
	                    "primitives",
	                    primitives_001
	                  ];
	                  if (name !== undefined) {
	                    return object_(/* :: */[
	                                primitives$1,
	                                /* :: */[
	                                  /* tuple */[
	                                    "name",
	                                    name
	                                  ],
	                                  /* [] */0
	                                ]
	                              ]);
	                  } else {
	                    return object_(/* :: */[
	                                primitives$1,
	                                /* [] */0
	                              ]);
	                  }
	                }))
	        ];
	}

	function _encodeLights(param) {
	  var range = param[/* range */6];
	  var quadraticAttenuation = param[/* quadraticAttenuation */5];
	  var linearAttenuation = param[/* linearAttenuation */4];
	  var constantAttenuation = param[/* constantAttenuation */3];
	  var intensity = param[/* intensity */2];
	  var color = param[/* color */1];
	  var khrLightsExtensionList_000 = /* tuple */[
	    "type",
	    param[/* type_ */0]
	  ];
	  var khrLightsExtensionList = /* :: */[
	    khrLightsExtensionList_000,
	    /* [] */0
	  ];
	  var khrLightsExtensionList$1 = color !== undefined ? /* :: */[
	      /* tuple */[
	        "color",
	        color
	      ],
	      khrLightsExtensionList
	    ] : khrLightsExtensionList;
	  var khrLightsExtensionList$2 = intensity !== undefined ? /* :: */[
	      /* tuple */[
	        "intensity",
	        intensity
	      ],
	      khrLightsExtensionList$1
	    ] : khrLightsExtensionList$1;
	  var khrLightsExtensionList$3 = constantAttenuation !== undefined ? /* :: */[
	      /* tuple */[
	        "constantAttenuation",
	        constantAttenuation
	      ],
	      khrLightsExtensionList$2
	    ] : khrLightsExtensionList$2;
	  var khrLightsExtensionList$4 = linearAttenuation !== undefined ? /* :: */[
	      /* tuple */[
	        "linearAttenuation",
	        linearAttenuation
	      ],
	      khrLightsExtensionList$3
	    ] : khrLightsExtensionList$3;
	  var khrLightsExtensionList$5 = quadraticAttenuation !== undefined ? /* :: */[
	      /* tuple */[
	        "quadraticAttenuation",
	        quadraticAttenuation
	      ],
	      khrLightsExtensionList$4
	    ] : khrLightsExtensionList$4;
	  if (range !== undefined) {
	    return /* :: */[
	            /* tuple */[
	              "range",
	              range
	            ],
	            khrLightsExtensionList$5
	          ];
	  } else {
	    return khrLightsExtensionList$5;
	  }
	}

	function _encodeExtensions(lightDataArr) {
	  return /* tuple */[
	          "extensions",
	          object_(/* :: */[
	                /* tuple */[
	                  "KHR_lights",
	                  object_(/* :: */[
	                        /* tuple */[
	                          "lights",
	                          lightDataArr.map((function (lightData) {
	                                  return object_(_encodeLights(lightData));
	                                }))
	                        ],
	                        /* [] */0
	                      ])
	                ],
	                /* [] */0
	              ])
	        ];
	}

	function _encodeBuffers(totalByteLength) {
	  return /* tuple */[
	          "buffers",
	          /* array */[object_(/* :: */[
	                  /* tuple */[
	                    "byteLength",
	                    totalByteLength
	                  ],
	                  /* [] */0
	                ])]
	        ];
	}

	function _encodeBufferViews(bufferViewDataArr) {
	  return /* tuple */[
	          "bufferViews",
	          bufferViewDataArr.map((function (param) {
	                  return object_(/* :: */[
	                              /* tuple */[
	                                "buffer",
	                                param[/* buffer */0]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "byteOffset",
	                                  param[/* byteOffset */1]
	                                ],
	                                /* :: */[
	                                  /* tuple */[
	                                    "byteLength",
	                                    param[/* byteLength */2]
	                                  ],
	                                  /* [] */0
	                                ]
	                              ]
	                            ]);
	                }))
	        ];
	}

	function _encodeAccessors(accessorDataArr) {
	  return /* tuple */[
	          "accessors",
	          accessorDataArr.map((function (param) {
	                  return object_(/* :: */[
	                              /* tuple */[
	                                "bufferView",
	                                param[/* bufferView */0]
	                              ],
	                              /* :: */[
	                                /* tuple */[
	                                  "componentType",
	                                  param[/* componentType */1]
	                                ],
	                                /* :: */[
	                                  /* tuple */[
	                                    "count",
	                                    param[/* count */2]
	                                  ],
	                                  /* :: */[
	                                    /* tuple */[
	                                      "type",
	                                      param[/* type_ */3]
	                                    ],
	                                    /* [] */0
	                                  ]
	                                ]
	                              ]
	                            ]);
	                }))
	        ];
	}

	function _encodeAsset() {
	  return /* tuple */[
	          "asset",
	          object_(/* :: */[
	                /* tuple */[
	                  "version",
	                  "2.0"
	                ],
	                /* :: */[
	                  /* tuple */[
	                    "generator",
	                    getGenerator(/* () */0)
	                  ],
	                  /* [] */0
	                ]
	              ])
	        ];
	}

	function encode(totalByteLength, param, state) {
	  var extensionsUsedArr = param[14];
	  var lightDataArr = param[12];
	  var list_000 = _encodeAsset(/* () */0);
	  var list_001 = /* :: */[
	    /* tuple */[
	      "scene",
	      0
	    ],
	    /* :: */[
	      _encodeScenes(extensionsUsedArr, lightDataArr, param[13], state),
	      /* :: */[
	        _encodeCameras(param[10]),
	        /* :: */[
	          _encodeExtras(param[4], param[5], param[11]),
	          /* :: */[
	            _encodeNodes(param[0], state),
	            /* :: */[
	              _encodeLightMaterials(param[6]),
	              /* :: */[
	                _encodeTextures(param[7]),
	                /* :: */[
	                  _encodeSamplers(param[8]),
	                  /* :: */[
	                    _encodeImages(param[9]),
	                    /* :: */[
	                      _encodeBuffers(totalByteLength),
	                      /* :: */[
	                        _encodeBufferViews(param[1]),
	                        /* :: */[
	                          _encodeAccessors(param[2]),
	                          /* :: */[
	                            _encodeMeshes(param[3]),
	                            /* [] */0
	                          ]
	                        ]
	                      ]
	                    ]
	                  ]
	                ]
	              ]
	            ]
	          ]
	        ]
	      ]
	    ]
	  ];
	  var list = /* :: */[
	    list_000,
	    list_001
	  ];
	  var match = extensionsUsedArr.length > 0;
	  var list$1$$1 = match ? /* :: */[
	      /* tuple */[
	        "extensionsUsedArr",
	        extensionsUsedArr
	      ],
	      list
	    ] : list;
	  var match$1 = lightDataArr.length > 0;
	  return object_(match$1 ? /* :: */[
	                _encodeExtensions(lightDataArr),
	                list$1$$1
	              ] : list$1$$1);
	}


	/* Log-WonderLog Not a pure module */

	function build$4(state) {
	  var match = getIMGUIFunc(state);
	  return /* tuple */[
	          getCustomData(state),
	          match !== undefined ? serializeFunction(valFromOption(match)) : undefined
	        ];
	}


	/* ManageIMGUIMainService-Wonderjs Not a pure module */

	function _convertDegreeToRadians(angle) {
	  return angle * Math.PI / 180;
	}

	function build$5(cameraDataMap, state) {
	  var perspectiveCameraProjectionRecord = state[/* perspectiveCameraProjectionRecord */15];
	  requireCheck((function () {
	          return checkShouldHasNoSlot(cameraDataMap);
	        }), getIsDebug(stateData));
	  return reduceValid((function (cameraDataArr, perspectiveCameraProjection) {
	                return push(/* record */[
	                            /* type_ */"perspective",
	                            /* perspective : record */[
	                              /* near */unsafeGetNear(perspectiveCameraProjection, perspectiveCameraProjectionRecord),
	                              /* far */getFar(perspectiveCameraProjection, perspectiveCameraProjectionRecord),
	                              /* fovy */_convertDegreeToRadians(unsafeGetFovy(perspectiveCameraProjection, perspectiveCameraProjectionRecord)),
	                              /* aspect */getAspect(perspectiveCameraProjection, perspectiveCameraProjectionRecord)
	                            ]
	                          ], cameraDataArr);
	              }), /* array */[], cameraDataMap);
	}


	/* Contract-WonderLog Not a pure module */

	function _addBufferViewData(param, param$1, totalByteLength) {
	  var accessorDataArr = param$1[2];
	  var bufferViewDataArr = param$1[1];
	  var bufferViewOffset = param$1[0];
	  var pointType = param[3];
	  var pointsLength = param[0];
	  if (pointsLength !== 0) {
	    var bufferViewByteLength = imul(pointsLength, param[2]);
	    var bufferViewAlignedByteLength = alignedLength(bufferViewByteLength);
	    return /* tuple */[
	            accessorDataArr.length,
	            push(/* record */[
	                  /* bufferView */bufferViewDataArr.length,
	                  /* componentType */pointType >= 3 ? 5123 : 5126,
	                  /* count */param[1],
	                  /* type_ */pointType !== 2 ? (
	                      pointType >= 3 ? "SCALAR" : "VEC3"
	                    ) : "VEC2"
	                ], accessorDataArr),
	            push(/* record */[
	                  /* buffer */0,
	                  /* byteOffset */bufferViewOffset,
	                  /* byteLength */bufferViewByteLength
	                ], bufferViewDataArr),
	            bufferViewOffset + bufferViewAlignedByteLength | 0,
	            totalByteLength + bufferViewAlignedByteLength | 0
	          ];
	  } else {
	    return /* tuple */[
	            undefined,
	            accessorDataArr,
	            bufferViewDataArr,
	            bufferViewOffset,
	            totalByteLength
	          ];
	  }
	}

	function _checkBufferViewOffsetAligned(bufferViewOffset) {
	  requireCheck((function () {
	          return test(buildAssertMessage("bufferViewOffset aligned with multiple of 4", "not"), (function () {
	                        return Operators[/* = */0](bufferViewOffset % 4, 0);
	                      }));
	        }), getIsDebug(stateData));
	  return bufferViewOffset;
	}

	function _addVertexData(param, vertexDataArr) {
	  var bufferViewOffset = param[0];
	  _checkBufferViewOffsetAligned(bufferViewOffset);
	  return push(/* tuple */[
	              bufferViewOffset,
	              param[1]
	            ], vertexDataArr);
	}

	function _addIndexData(param, indexDataArr) {
	  var bufferViewOffset = param[0];
	  _checkBufferViewOffsetAligned(bufferViewOffset);
	  return push(/* tuple */[
	              bufferViewOffset,
	              param[1]
	            ], indexDataArr);
	}

	function _addAllPointData(param, param$1, param$2) {
	  var match = param$2[1];
	  var match$1 = param$1[1];
	  var bufferViewOffset = param$1[0];
	  var match$2 = param[2];
	  var indicesLength = match$2[3];
	  var texCoordsLength = match$2[2];
	  var normalsLength = match$2[1];
	  var verticesLength = match$2[0];
	  var match$3 = param[1];
	  var match$4 = param[0];
	  var texCoords = match$4[2];
	  var verticesCount = div(verticesLength, match$3[0]);
	  var normalsCount = div(normalsLength, match$3[1]);
	  var texCoordsCount = div(texCoordsLength, match$3[2]);
	  var indicesCount = div(indicesLength, match$3[3]);
	  var vertexDataArr = _addVertexData(/* tuple */[
	        bufferViewOffset,
	        match$4[0]
	      ], match[0]);
	  var match$5 = _addBufferViewData(/* tuple */[
	        verticesLength,
	        verticesCount,
	        Float32Array.BYTES_PER_ELEMENT,
	        /* Vertex */0
	      ], /* tuple */[
	        bufferViewOffset,
	        match$1[0],
	        match$1[1]
	      ], param$2[0]);
	  var bufferViewOffset$1 = match$5[3];
	  var vertexDataArr$1 = _addVertexData(/* tuple */[
	        bufferViewOffset$1,
	        match$4[1]
	      ], vertexDataArr);
	  var match$6 = _addBufferViewData(/* tuple */[
	        normalsLength,
	        normalsCount,
	        Float32Array.BYTES_PER_ELEMENT,
	        /* Normal */1
	      ], /* tuple */[
	        bufferViewOffset$1,
	        match$5[2],
	        match$5[1]
	      ], match$5[4]);
	  var bufferViewOffset$2 = match$6[3];
	  var vertexDataArr$2 = texCoords !== undefined ? _addVertexData(/* tuple */[
	          bufferViewOffset$2,
	          valFromOption(texCoords)
	        ], vertexDataArr$1) : vertexDataArr$1;
	  var match$7 = _addBufferViewData(/* tuple */[
	        texCoordsLength,
	        texCoordsCount,
	        Float32Array.BYTES_PER_ELEMENT,
	        /* TexCoord */2
	      ], /* tuple */[
	        bufferViewOffset$2,
	        match$6[2],
	        match$6[1]
	      ], match$6[4]);
	  var bufferViewOffset$3 = match$7[3];
	  var indexDataArr = _addIndexData(/* tuple */[
	        bufferViewOffset$3,
	        match$4[3]
	      ], match[1]);
	  var match$8 = _addBufferViewData(/* tuple */[
	        indicesLength,
	        indicesCount,
	        Uint16Array.BYTES_PER_ELEMENT,
	        /* Index */3
	      ], /* tuple */[
	        bufferViewOffset$3,
	        match$7[2],
	        match$7[1]
	      ], match$7[4]);
	  return /* tuple */[
	          /* tuple */[
	            match$5[0],
	            match$6[0],
	            match$7[0],
	            match$8[0]
	          ],
	          match$8[1],
	          match$8[2],
	          match$8[3],
	          /* tuple */[
	            match$8[4],
	            /* tuple */[
	              vertexDataArr$2,
	              indexDataArr
	            ]
	          ]
	        ];
	}

	function _addMeshData(param, texCoords, meshDataArr) {
	  return push(/* record */[
	              /* primitives : record */[
	                /* attributes : record */[
	                  /* position */unsafeGet$1(param[0]),
	                  /* normal */param[1],
	                  /* texCoord_0 */texCoords !== undefined ? param[2] : undefined
	                ],
	                /* indices */unsafeGet$1(param[3]),
	                /* material */undefined
	              ],
	              /* name */undefined
	            ], meshDataArr);
	}

	function build$6(meshPointDataMap) {
	  requireCheck((function () {
	          return checkShouldHasNoSlot(meshPointDataMap);
	        }), getIsDebug(stateData));
	  var match = reduceiValid((function (param, param$1, _) {
	          var indices = param$1[3];
	          var texCoords = param$1[2];
	          var normals = param$1[1];
	          var vertices = param$1[0];
	          var match = param[2];
	          var match$1 = param[1];
	          var match$2 = param[0];
	          var verticesLength = vertices.length;
	          var normalsLength = normals.length;
	          var texCoordsLength = texCoords !== undefined ? valFromOption(texCoords).length : 0;
	          var indicesLength = indices.length;
	          var match$3 = _addAllPointData(/* tuple */[
	                /* tuple */[
	                  vertices,
	                  normals,
	                  texCoords,
	                  indices
	                ],
	                /* tuple */[
	                  3,
	                  3,
	                  2,
	                  1
	                ],
	                /* tuple */[
	                  verticesLength,
	                  normalsLength,
	                  texCoordsLength,
	                  indicesLength
	                ]
	              ], /* tuple */[
	                match$2[1],
	                /* tuple */[
	                  match$1[0],
	                  match$1[1]
	                ]
	              ], /* tuple */[
	                match$2[0],
	                /* tuple */[
	                  match[0],
	                  match[1]
	                ]
	              ]);
	          var match$4 = match$3[4];
	          var match$5 = match$4[1];
	          var match$6 = match$3[0];
	          return /* tuple */[
	                  /* tuple */[
	                    match$4[0],
	                    match$3[3]
	                  ],
	                  /* tuple */[
	                    match$3[2],
	                    match$3[1],
	                    _addMeshData(/* tuple */[
	                          match$6[0],
	                          match$6[1],
	                          match$6[2],
	                          match$6[3]
	                        ], texCoords, match$1[2])
	                  ],
	                  /* tuple */[
	                    match$5[0],
	                    match$5[1]
	                  ]
	                ];
	        }), /* tuple */[
	        /* tuple */[
	          0,
	          0
	        ],
	        /* tuple */[
	          /* array */[],
	          /* array */[],
	          /* array */[]
	        ],
	        /* tuple */[
	          /* array */[],
	          /* array */[]
	        ]
	      ], meshPointDataMap);
	  var match$1 = match[2];
	  var match$2 = match[1];
	  return /* tuple */[
	          match[0][0],
	          /* tuple */[
	            match$2[0],
	            match$2[1],
	            match$2[2]
	          ],
	          /* tuple */[
	            match$1[0],
	            match$1[1]
	          ]
	        ];
	}


	/* Log-WonderLog Not a pure module */

	function build$8(param, materialDataArr, state) {
	  var color = getColor$7(param[0], state);
	  return push(/* record */[
	              /* colorFactor *//* array */[
	                caml_array_get(color, 0),
	                caml_array_get(color, 1),
	                caml_array_get(color, 2),
	                1.0
	              ],
	              /* name */param[1]
	            ], materialDataArr);
	}


	/* ArrayService-Wonderjs Not a pure module */

	function isBasicSourceTexture(texture, state) {
	  return texture < getArrayBufferViewSourceTextureIndexOffset$1(state);
	}


	/* IndexSourceTextureMainService-Wonderjs Not a pure module */

	function _buildSamplerDataMapKey(wrapS, wrapT, magFilter, minFilter) {
	  return wrapS.toString() + (wrapT.toString() + (magFilter.toString() + minFilter.toString()));
	}

	function _getWrapData(wrap) {
	  switch (wrap) {
	    case 0 : 
	        return 33071;
	    case 1 : 
	        return 33648;
	    case 2 : 
	        return 10497;
	    
	  }
	}

	function _getFilterData(filter) {
	  switch (filter) {
	    case 0 : 
	        return 9728;
	    case 1 : 
	        return 9729;
	    case 2 : 
	        return 9984;
	    case 3 : 
	        return 9985;
	    case 4 : 
	        return 9986;
	    case 5 : 
	        return 9987;
	    
	  }
	}

	function _addSamplerData(texture, samplerIndexMap, state, samplerDataArr) {
	  var wrapS = getWrapS$2(texture, state);
	  var wrapT = getWrapT$2(texture, state);
	  var magFilter = getMagFilter$2(texture, state);
	  var minFilter = getMinFilter$2(texture, state);
	  var key = _buildSamplerDataMapKey(wrapS, wrapT, magFilter, minFilter);
	  var match = get(key, samplerIndexMap);
	  if (match !== undefined) {
	    return /* tuple */[
	            match,
	            samplerIndexMap,
	            samplerDataArr
	          ];
	  } else {
	    var samplerIndex = samplerDataArr.length;
	    return /* tuple */[
	            samplerIndex,
	            set(key, samplerIndex, samplerIndexMap),
	            push(/* record */[
	                  /* wrapS */_getWrapData(wrapS),
	                  /* wrapT */_getWrapData(wrapT),
	                  /* magFilter */_getFilterData(magFilter),
	                  /* minFilter */_getFilterData(minFilter)
	                ], samplerDataArr)
	          ];
	  }
	}

	var _convertImageToBase64 = function (width,height,image){
	    var canvas = document.createElement("canvas");
	    var ctx = canvas.getContext("2d");
	    canvas.height = width;
	    canvas.width = height;
	    ctx.drawImage(image, 0, 0);
	    return canvas.toDataURL();
	    };

	function _convertBase64MimeTypeToWDBMimeType(mimeType) {
	  switch (mimeType) {
	    case "image/jpeg" : 
	    case "image/png" : 
	        return mimeType;
	    default:
	      return fatal(buildFatalMessage("_convertBase64MimeTypeToWDBMimeType", "unknown mimeType: " + (String(mimeType) + ""), "", "", ""));
	  }
	}

	function _getImageBase64(texture, source, imageBase64Map) {
	  var match = get$3(texture, imageBase64Map);
	  if (match !== undefined) {
	    return valFromOption(match);
	  } else {
	    return _convertImageToBase64(getWidth$1(source), getHeight$1(source), source);
	  }
	}

	function _addImageData(param, imageBase64Map, imageUint8DataArr, param$1) {
	  var bufferViewDataArr = param$1[2];
	  var byteOffset = param$1[1];
	  var totalByteLength = param$1[0];
	  var imageMap = param[1];
	  var texture = param[0];
	  requireCheck((function () {
	          return test(buildAssertMessage("byteOffset aligned with multiple of 4", "not"), (function () {
	                        return Operators[/* = */0](byteOffset % 4, 0);
	                      }));
	        }), getIsDebug(stateData));
	  var source = unsafeGetSource$1(texture, param[2]);
	  var imageIndex = indexOf(source, imageMap);
	  if (imageIndex === -1) {
	    var imageIndex$1 = imageUint8DataArr.length;
	    var imageBase64 = _getImageBase64(texture, source, imageBase64Map);
	    var imageUint8Array = convertBase64ToBinary(imageBase64);
	    var imageUint8ArrayByteLength = imageUint8Array.byteLength;
	    var imageUint8ArrayAlignedByteLength = alignedLength(imageUint8ArrayByteLength);
	    return /* tuple */[
	            imageIndex$1,
	            set$1(imageIndex$1, source, imageMap),
	            push(/* record */[
	                  /* bufferView */bufferViewDataArr.length,
	                  /* mimeType */_convertBase64MimeTypeToWDBMimeType(getBase64MimeType(imageBase64)),
	                  /* uint8Array */imageUint8Array,
	                  /* byteOffset */byteOffset
	                ], imageUint8DataArr),
	            /* tuple */[
	              totalByteLength + imageUint8ArrayAlignedByteLength | 0,
	              byteOffset + imageUint8ArrayAlignedByteLength | 0,
	              push(/* record */[
	                    /* buffer */0,
	                    /* byteOffset */byteOffset,
	                    /* byteLength */imageUint8ArrayByteLength
	                  ], bufferViewDataArr)
	            ]
	          ];
	  } else {
	    return /* tuple */[
	            imageIndex,
	            imageMap,
	            imageUint8DataArr,
	            /* tuple */[
	              totalByteLength,
	              byteOffset,
	              bufferViewDataArr
	            ]
	          ];
	  }
	}

	function _addTextureData(texture, param, state, textureDataArr) {
	  return push(/* record */[
	              /* name */getName$4(texture, state),
	              /* sampler */param[0],
	              /* source */param[1]
	            ], textureDataArr);
	}

	function build$9(param, param$1, param$2, state) {
	  var bufferViewDataArr = param$2[2];
	  var byteOffset = param$2[1];
	  var totalByteLength = param$2[0];
	  var match = param$1[1];
	  var imageMap = match[2];
	  var samplerIndexMap = match[1];
	  var textureIndexMap = match[0];
	  var match$1 = param$1[0];
	  var imageUint8DataArr = match$1[3];
	  var samplerDataArr = match$1[2];
	  var textureDataArr = match$1[1];
	  var materialDataArr = match$1[0];
	  var name = param[1];
	  var diffuseMap = param[0];
	  requireCheck((function () {
	          return test(buildAssertMessage("map be basicSourceTexture", "not"), (function () {
	                        return assertTrue(isBasicSourceTexture(diffuseMap, state));
	                      }));
	        }), getIsDebug(stateData));
	  var match$2 = get$3(diffuseMap, textureIndexMap);
	  if (match$2 !== undefined) {
	    return /* tuple */[
	            /* tuple */[
	              push(/* record */[
	                    /* baseColorFactor */undefined,
	                    /* baseColorTexture */match$2,
	                    /* name */name
	                  ], materialDataArr),
	              textureDataArr,
	              samplerDataArr,
	              imageUint8DataArr
	            ],
	            /* tuple */[
	              textureIndexMap,
	              samplerIndexMap,
	              imageMap
	            ],
	            /* tuple */[
	              totalByteLength,
	              byteOffset,
	              bufferViewDataArr
	            ]
	          ];
	  } else {
	    var textureIndex = textureDataArr.length;
	    var textureIndexMap$1 = set$1(diffuseMap, textureIndex, textureIndexMap);
	    var match$3 = _addSamplerData(diffuseMap, samplerIndexMap, state, samplerDataArr);
	    var match$4 = _addImageData(/* tuple */[
	          diffuseMap,
	          imageMap,
	          state
	        ], match[3], imageUint8DataArr, /* tuple */[
	          totalByteLength,
	          byteOffset,
	          bufferViewDataArr
	        ]);
	    var match$5 = match$4[3];
	    return /* tuple */[
	            /* tuple */[
	              push(/* record */[
	                    /* baseColorFactor */undefined,
	                    /* baseColorTexture */textureIndex,
	                    /* name */name
	                  ], materialDataArr),
	              _addTextureData(diffuseMap, /* tuple */[
	                    match$3[0],
	                    match$4[0]
	                  ], state, textureDataArr),
	              match$3[2],
	              match$4[2]
	            ],
	            /* tuple */[
	              textureIndexMap$1,
	              match$3[1],
	              match$4[1]
	            ],
	            /* tuple */[
	              match$5[0],
	              match$5[1],
	              match$5[2]
	            ]
	          ];
	  }
	}


	/* Log-WonderLog Not a pure module */

	function build$10(param, param$1, param$2, state) {
	  var match = param$1[1];
	  var match$1 = param$1[0];
	  var diffuseColor = getDiffuseColor$2(param[0], state);
	  return /* tuple */[
	          /* tuple */[
	            push(/* record */[
	                  /* baseColorFactor *//* array */[
	                    caml_array_get(diffuseColor, 0),
	                    caml_array_get(diffuseColor, 1),
	                    caml_array_get(diffuseColor, 2),
	                    1.0
	                  ],
	                  /* baseColorTexture */undefined,
	                  /* name */param[1]
	                ], match$1[0]),
	            match$1[1],
	            match$1[2],
	            match$1[3]
	          ],
	          /* tuple */[
	            match[0],
	            match[1],
	            match[2]
	          ],
	          /* tuple */[
	            param$2[0],
	            param$2[1],
	            param$2[2]
	          ]
	        ];
	}


	/* ArrayService-Wonderjs Not a pure module */

	function _buildLightMaterialData(lightMaterialDataMap, imageBase64Map, param, state) {
	  return reduceValid((function (param, param$1) {
	                var name = param$1[1];
	                var lightMaterial = param$1[0];
	                var match = param[2];
	                var bufferViewDataArr = match[2];
	                var byteOffset = match[1];
	                var totalByteLength = match[0];
	                var match$1 = param[1];
	                var imageMap = match$1[2];
	                var samplerIndexMap = match$1[1];
	                var textureIndexMap = match$1[0];
	                var match$2 = param[0];
	                var imageUint8DataArr = match$2[3];
	                var samplerDataArr = match$2[2];
	                var textureDataArr = match$2[1];
	                var lightMaterialDataArr = match$2[0];
	                var diffuseMap = getDiffuseMap(lightMaterial, state);
	                if (diffuseMap !== undefined) {
	                  return build$9(/* tuple */[
	                              diffuseMap,
	                              name
	                            ], /* tuple */[
	                              /* tuple */[
	                                lightMaterialDataArr,
	                                textureDataArr,
	                                samplerDataArr,
	                                imageUint8DataArr
	                              ],
	                              /* tuple */[
	                                textureIndexMap,
	                                samplerIndexMap,
	                                imageMap,
	                                imageBase64Map
	                              ]
	                            ], /* tuple */[
	                              totalByteLength,
	                              byteOffset,
	                              bufferViewDataArr
	                            ], state);
	                } else {
	                  return build$10(/* tuple */[
	                              lightMaterial,
	                              name
	                            ], /* tuple */[
	                              /* tuple */[
	                                lightMaterialDataArr,
	                                textureDataArr,
	                                samplerDataArr,
	                                imageUint8DataArr
	                              ],
	                              /* tuple */[
	                                textureIndexMap,
	                                samplerIndexMap,
	                                imageMap
	                              ]
	                            ], /* tuple */[
	                              totalByteLength,
	                              byteOffset,
	                              bufferViewDataArr
	                            ], state);
	                }
	              }), /* tuple */[
	              /* tuple */[
	                /* array */[],
	                /* array */[],
	                /* array */[],
	                /* array */[]
	              ],
	              /* tuple */[
	                /* array */[],
	                createEmpty(/* () */0),
	                /* array */[]
	              ],
	              /* tuple */[
	                param[0],
	                param[1],
	                param[2]
	              ]
	            ], lightMaterialDataMap);
	}

	function build$7(basicMaterialDataMap, lightMaterialDataMap, imageBase64Map, param, state) {
	  requireCheck((function () {
	          checkShouldHasNoSlot(basicMaterialDataMap);
	          return checkShouldHasNoSlot(lightMaterialDataMap);
	        }), getIsDebug(stateData));
	  var match = _buildLightMaterialData(lightMaterialDataMap, imageBase64Map, /* tuple */[
	        param[0],
	        param[1],
	        param[2]
	      ], state);
	  var match$1 = match[2];
	  var match$2 = match[0];
	  var basicMaterialDataArr = reduceValid((function (basicMaterialDataArr, param) {
	          return build$8(/* tuple */[
	                      param[0],
	                      param[1]
	                    ], basicMaterialDataArr, state);
	        }), /* array */[], basicMaterialDataMap);
	  return /* tuple */[
	          basicMaterialDataArr,
	          match$2[0],
	          match$2[1],
	          match$2[2],
	          match$2[3],
	          /* tuple */[
	            match$1[0],
	            match$1[2]
	          ]
	        ];
	}


	/* Contract-WonderLog Not a pure module */

	function buildExtensionsUsed(lightDataArr) {
	  var match = lightDataArr.length > 0;
	  if (match) {
	    return /* array */["KHR_lights"];
	  } else {
	    return /* array */[];
	  }
	}


	/* No side effect */

	function build$11(meshRendererDataMap, state) {
	  requireCheck((function () {
	          return checkShouldHasNoSlot(meshRendererDataMap);
	        }), getIsDebug(stateData));
	  return reduceValid((function (meshRendererDataArr, meshRenderer) {
	                return push(/* record */[/* drawMode */getDrawMode$1(meshRenderer, state)], meshRendererDataArr);
	              }), /* array */[], meshRendererDataMap);
	}


	/* Contract-WonderLog Not a pure module */

	function build$12(arcballCameraControllerDataMap, state) {
	  var arcballCameraControllerRecord = state[/* arcballCameraControllerRecord */26];
	  requireCheck((function () {
	          return checkShouldHasNoSlot(arcballCameraControllerDataMap);
	        }), getIsDebug(stateData));
	  return reduceValid((function (arcballCameraControllerDataArr, cameraController) {
	                return push(/* record */[
	                            /* distance */unsafeGetDistance(cameraController, arcballCameraControllerRecord),
	                            /* minDistance */unsafeGetMinDistance(cameraController, arcballCameraControllerRecord),
	                            /* phi */unsafeGetPhi(cameraController, arcballCameraControllerRecord),
	                            /* theta */unsafeGetTheta(cameraController, arcballCameraControllerRecord),
	                            /* thetaMargin */unsafeGetThetaMargin(cameraController, arcballCameraControllerRecord),
	                            /* target */unsafeGetTarget(cameraController, arcballCameraControllerRecord),
	                            /* moveSpeedX */unsafeGetMoveSpeedX(cameraController, arcballCameraControllerRecord),
	                            /* moveSpeedY */unsafeGetMoveSpeedY(cameraController, arcballCameraControllerRecord),
	                            /* rotateSpeed */unsafeGetRotateSpeed(cameraController, arcballCameraControllerRecord),
	                            /* wheelSpeed */unsafeGetWheelSpeed(cameraController, arcballCameraControllerRecord)
	                          ], arcballCameraControllerDataArr);
	              }), /* array */[], arcballCameraControllerDataMap);
	}


	/* Contract-WonderLog Not a pure module */

	function generateGLBData$3(rootGameObject, imageBase64Map, state) {
	  var match = getAllNodeData(rootGameObject, state);
	  var match$1 = match[1];
	  var state$1 = match[0];
	  var match$2 = build$6(match$1[0]);
	  var totalByteLength = match$2[0];
	  var match$3 = match$2[2];
	  var match$4 = match$2[1];
	  var meshRendererDataArr = build$11(match$1[1], state$1);
	  var match$5 = build$7(match$1[2], match$1[3], imageBase64Map, /* tuple */[
	        totalByteLength,
	        totalByteLength,
	        match$4[0]
	      ], state$1);
	  var match$6 = match$5[5];
	  var totalByteLength$1 = match$6[0];
	  var imageUint8DataArr = match$5[4];
	  var buffer = build$2(totalByteLength$1, /* tuple */[
	        totalByteLength,
	        /* tuple */[
	          match$3[0],
	          match$3[1]
	        ]
	      ], imageUint8DataArr);
	  var cameraDataArr = build$5(match$1[4], state$1);
	  var arcballCameraControllerDataArr = build$12(match$1[5], state$1);
	  var lightDataArr = build$3(match$1[6], state$1);
	  var extensionsUsedArr = buildExtensionsUsed(lightDataArr);
	  return /* tuple */[
	          encode(totalByteLength$1, /* tuple */[
	                match[2],
	                match$6[1],
	                match$4[1],
	                match$4[2],
	                meshRendererDataArr,
	                match$5[0],
	                match$5[1],
	                match$5[2],
	                match$5[3],
	                imageUint8DataArr,
	                cameraDataArr,
	                arcballCameraControllerDataArr,
	                lightDataArr,
	                build$4(state$1),
	                extensionsUsedArr
	              ], state$1),
	          buffer
	        ];
	}


	/* BuildBufferSystem-Wonderjs Not a pure module */

	function generateWDB$3(rootGameObject, imageBase64Map, state) {
	  return /* tuple */[
	          state,
	          convertGLBData(generateGLBData$3(rootGameObject, imageBase64Map, state))
	        ];
	}


	/* ConvertGLBSystem-Wonderjs Not a pure module */

	var generateGLBData$2 = generateGLBData$3;

	var generateWDB$2 = generateWDB$3;


	/* GenerateGLBSystem-Wonderjs Not a pure module */

	var generateGLBData$1 = generateGLBData$2;

	var generateWDB$1 = generateWDB$2;


	/* GenerateSceneGraphSystem-Wonderjs Not a pure module */

	function createArcballCameraController$1(state) {
	  var match = create$32(state[/* arcballCameraControllerRecord */26]);
	  var newrecord = caml_array_dup(state);
	  return /* tuple */[
	          (newrecord[/* arcballCameraControllerRecord */26] = match[0], newrecord),
	          match[1]
	        ];
	}

	function unsafeGetArcballCameraControllerGameObject$1(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraController, isAlive$15, state[/* arcballCameraControllerRecord */26]);
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$7(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function unsafeGetArcballCameraControllerDistance$1(cameraController, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraController, isAlive$15, state[/* arcballCameraControllerRecord */26]);
	        }), getIsDebug(stateData));
	  return unsafeGetDistance(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerDistance$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setDistance(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerMinDistance$1(cameraController, state) {
	  return unsafeGetMinDistance(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerMinDistance$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setMinDistance(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerWheelSpeed$1(cameraController, state) {
	  return unsafeGetWheelSpeed(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerWheelSpeed$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setWheelSpeed(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerPhi$1(cameraController, state) {
	  return unsafeGetPhi(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerPhi$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setPhi(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerTheta$1(cameraController, state) {
	  return unsafeGetTheta(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerTheta$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setTheta(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerThetaMargin$1(cameraController, state) {
	  return unsafeGetThetaMargin(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerThetaMargin$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setThetaMargin(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerTarget$1(cameraController, state) {
	  return unsafeGetTarget(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerTarget$1(cameraController, target, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setTarget(cameraController, target, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerMoveSpeedX$1(cameraController, state) {
	  return unsafeGetMoveSpeedX(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerMoveSpeedX$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setMoveSpeedX(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerMoveSpeedY$1(cameraController, state) {
	  return unsafeGetMoveSpeedY(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerMoveSpeedY$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setMoveSpeedY(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	function unsafeGetArcballCameraControllerRotateSpeed$1(cameraController, state) {
	  return unsafeGetRotateSpeed(cameraController, state[/* arcballCameraControllerRecord */26]);
	}

	function setArcballCameraControllerRotateSpeed$1(cameraController, value, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arcballCameraControllerRecord */26] = setRotateSpeed(cameraController, value, state[/* arcballCameraControllerRecord */26]);
	  return newrecord;
	}

	var bindArcballCameraControllerEvent$1 = bindEvent;

	var unbindArcballCameraControllerEvent$1 = unbindEvent;


	/* Contract-WonderLog Not a pure module */

	// Generated by BUCKLESCRIPT VERSION 4.0.0, PLEASE EDIT WITH CARE

	var label$5 = label$2;

	var image$5 = image$2;


	/* FixedLayoutControlIMGUIService-WonderImgui Not a pure module */

	function label$4(rect, str, align, record) {
	  return label$5(rect, str, align, record);
	}

	function image$4(rect, uv, id, record) {
	  return image$5(rect, uv, id, record);
	}


	/* FixedLayoutControlIMGUIAPI-WonderImgui Not a pure module */

	function unsafeGetGameObject$13(cameraProjection, param) {
	  return unsafeGetGameObject$1(cameraProjection, param[/* gameObjectMap */7]);
	}


	/* GameObjectMapService-Wonderjs Not a pure module */

	function createPerspectiveCameraProjection$1(state) {
	  var match = create$33(state[/* perspectiveCameraProjectionRecord */15]);
	  state[/* perspectiveCameraProjectionRecord */15] = match[0];
	  return /* tuple */[
	          state,
	          match[1]
	        ];
	}

	function unsafeGetPerspectiveCameraProjectionPMatrix$1(cameraProjection, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraProjection, isAlive$16, state[/* perspectiveCameraProjectionRecord */15]);
	        }), getIsDebug(stateData));
	  return unsafeGetPMatrix(cameraProjection, state[/* perspectiveCameraProjectionRecord */15][/* pMatrixMap */2]);
	}

	function unsafeGetPerspectiveCameraProjectionGameObject$1(cameraProjection, state) {
	  requireCheck((function () {
	          return checkComponentShouldAlive$1(cameraProjection, isAlive$16, state[/* perspectiveCameraProjectionRecord */15]);
	        }), getIsDebug(stateData));
	  return unsafeGetGameObject$13(cameraProjection, state[/* perspectiveCameraProjectionRecord */15]);
	}

	function unsafeGetPerspectiveCameraFovy$1(cameraProjection, state) {
	  return unsafeGetFovy(cameraProjection, state[/* perspectiveCameraProjectionRecord */15]);
	}

	function setPerspectiveCameraProjectionFovy$1(cameraProjection, fovy, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = setFovy(cameraProjection, fovy, state[/* perspectiveCameraProjectionRecord */15]);
	  return newrecord;
	}

	function unsafeGetPerspectiveCameraAspect$1(cameraProjection, state) {
	  return unsafeGetAspect(cameraProjection, state[/* perspectiveCameraProjectionRecord */15]);
	}

	function setPerspectiveCameraProjectionAspect$1(cameraProjection, aspect, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = setAspect(cameraProjection, aspect, state[/* perspectiveCameraProjectionRecord */15]);
	  return newrecord;
	}

	function unsafeGetPerspectiveCameraNear$1(cameraProjection, state) {
	  return unsafeGetNear(cameraProjection, state[/* perspectiveCameraProjectionRecord */15]);
	}

	function setPerspectiveCameraProjectionNear$1(cameraProjection, near, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = setNear(cameraProjection, near, state[/* perspectiveCameraProjectionRecord */15]);
	  return newrecord;
	}

	function unsafeGetPerspectiveCameraFar$1(cameraProjection, state) {
	  return unsafeGetFar(cameraProjection, state[/* perspectiveCameraProjectionRecord */15]);
	}

	function setPerspectiveCameraProjectionFar$1(cameraProjection, far, state) {
	  var newrecord = caml_array_dup(state);
	  newrecord[/* perspectiveCameraProjectionRecord */15] = setFar(cameraProjection, far, state[/* perspectiveCameraProjectionRecord */15]);
	  return newrecord;
	}


	/* Contract-WonderLog Not a pure module */

	function unsafeGetName$5(texture, state) {
	  return unsafeGetName$1(texture, getRecord$11(state)[/* nameMap */17]);
	}

	function setName$5(texture, name, state) {
	  var record = getRecord$11(state);
	  var newrecord = caml_array_dup(state);
	  newrecord[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */record[/* index */0],
	    /* wrapSs */record[/* wrapSs */1],
	    /* wrapTs */record[/* wrapTs */2],
	    /* magFilters */record[/* magFilters */3],
	    /* minFilters */record[/* minFilters */4],
	    /* formats */record[/* formats */5],
	    /* types */record[/* types */6],
	    /* isNeedUpdates */record[/* isNeedUpdates */7],
	    /* flipYs */record[/* flipYs */8],
	    /* widths */record[/* widths */9],
	    /* heights */record[/* heights */10],
	    /* sourceMap */record[/* sourceMap */11],
	    /* glTextureMap */record[/* glTextureMap */12],
	    /* bindTextureUnitCacheMap */record[/* bindTextureUnitCacheMap */13],
	    /* disposedIndexArray */record[/* disposedIndexArray */14],
	    /* needAddedSourceArray */record[/* needAddedSourceArray */15],
	    /* needInitedTextureIndexArray */record[/* needInitedTextureIndexArray */16],
	    /* nameMap */setName$1(texture, name, record[/* nameMap */17])
	  ];
	  return newrecord;
	}


	/* NameService-Wonderjs Not a pure module */

	function getMaxArrayBufferViewSourceTextureIndex(state) {
	  return getArrayBufferViewSourceTextureIndexOffset$1(state) + getArrayBufferViewSourceTextureCount(state[/* settingRecord */1]) | 0;
	}


	/* BufferSettingService-Wonderjs Not a pure module */

	function create$71(state) {
	  var arrayBufferViewSourceTextureRecord = getRecord$11(state);
	  var match = generateIndex(arrayBufferViewSourceTextureRecord[/* index */0], arrayBufferViewSourceTextureRecord[/* disposedIndexArray */14]);
	  var index = generateArrayBufferViewSourceTextureIndex$1(match[0], state);
	  state[/* arrayBufferViewSourceTextureRecord */20] = /* record */[
	    /* index */match[1],
	    /* wrapSs */arrayBufferViewSourceTextureRecord[/* wrapSs */1],
	    /* wrapTs */arrayBufferViewSourceTextureRecord[/* wrapTs */2],
	    /* magFilters */arrayBufferViewSourceTextureRecord[/* magFilters */3],
	    /* minFilters */arrayBufferViewSourceTextureRecord[/* minFilters */4],
	    /* formats */arrayBufferViewSourceTextureRecord[/* formats */5],
	    /* types */arrayBufferViewSourceTextureRecord[/* types */6],
	    /* isNeedUpdates */arrayBufferViewSourceTextureRecord[/* isNeedUpdates */7],
	    /* flipYs */arrayBufferViewSourceTextureRecord[/* flipYs */8],
	    /* widths */arrayBufferViewSourceTextureRecord[/* widths */9],
	    /* heights */arrayBufferViewSourceTextureRecord[/* heights */10],
	    /* sourceMap */arrayBufferViewSourceTextureRecord[/* sourceMap */11],
	    /* glTextureMap */arrayBufferViewSourceTextureRecord[/* glTextureMap */12],
	    /* bindTextureUnitCacheMap */arrayBufferViewSourceTextureRecord[/* bindTextureUnitCacheMap */13],
	    /* disposedIndexArray */arrayBufferViewSourceTextureRecord[/* disposedIndexArray */14],
	    /* needAddedSourceArray */arrayBufferViewSourceTextureRecord[/* needAddedSourceArray */15],
	    /* needInitedTextureIndexArray */arrayBufferViewSourceTextureRecord[/* needInitedTextureIndexArray */16],
	    /* nameMap */arrayBufferViewSourceTextureRecord[/* nameMap */17]
	  ];
	  return checkNotExceedMaxCount(getMaxArrayBufferViewSourceTextureIndex(state), /* tuple */[
	              state,
	              index
	            ]);
	}


	/* BufferService-Wonderjs Not a pure module */

	function unsafeGetSource$2(texture, state) {
	  var match = getRecord$11(state);
	  return unsafeGetSource(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* sourceMap */11]);
	}

	function setSource$2(texture, source, state) {
	  var match = isUseWorker(state);
	  if (match) {
	    var match$1 = getRecord$11(state);
	    setSource(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), source, match$1[/* sourceMap */11]);
	    push(/* tuple */[
	          texture,
	          source
	        ], match$1[/* needAddedSourceArray */15]);
	    return state;
	  } else {
	    var match$2 = getRecord$11(state);
	    setSource(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), source, match$2[/* sourceMap */11]);
	    return state;
	  }
	}

	function getWrapS$3(texture, state) {
	  var match = getRecord$11(state);
	  return getWrapS$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* wrapSs */1]);
	}

	function setWrapS$3(texture, wrapS, state) {
	  var match = getRecord$11(state);
	  setWrapS$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), wrapS, match[/* wrapSs */1]);
	  return state;
	}

	function getWrapT$3(texture, state) {
	  var match = getRecord$11(state);
	  return getWrapT$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* wrapTs */2]);
	}

	function setWrapT$3(texture, wrapT, state) {
	  var match = getRecord$11(state);
	  setWrapT$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), wrapT, match[/* wrapTs */2]);
	  return state;
	}

	function getMagFilter$3(texture, state) {
	  var match = getRecord$11(state);
	  return getMagFilter$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* magFilters */3]);
	}

	function setMagFilter$3(texture, filter, state) {
	  var match = getRecord$11(state);
	  setMagFilter$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), filter, match[/* magFilters */3]);
	  return state;
	}

	function getMinFilter$3(texture, state) {
	  var match = getRecord$11(state);
	  return getMinFilter$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* minFilters */4]);
	}

	function setMinFilter$3(texture, filter, state) {
	  var match = getRecord$11(state);
	  setMinFilter$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), filter, match[/* minFilters */4]);
	  return state;
	}

	function getFormat$3(texture, state) {
	  var match = getRecord$11(state);
	  return getFormat$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* formats */5]);
	}

	function setFormat$3(texture, format, state) {
	  var match = getRecord$11(state);
	  setFormat$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), format, match[/* formats */5]);
	  return state;
	}

	function getType$4(texture, state) {
	  var match = getRecord$11(state);
	  return getType$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* types */6]);
	}

	function setType$3(texture, type_, state) {
	  var match = getRecord$11(state);
	  setType$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), type_, match[/* types */6]);
	  return state;
	}

	function getFlipY$4(texture, state) {
	  var match = getRecord$11(state);
	  return getFlipYFromTypeArrayValue(getFlipY$2(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* flipYs */8]));
	}

	function setFlipY$5(texture, flipY, state) {
	  var match = getRecord$11(state);
	  setFlipY$1(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), getFlipYTypeArrayValue(flipY), match[/* flipYs */8]);
	  return state;
	}

	function getWidth$3(texture, state) {
	  var match = getRecord$11(state);
	  return getWidth(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* widths */9]);
	}

	function setWidth$2(texture, width, state) {
	  var match = getRecord$11(state);
	  setWidth(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), width, match[/* widths */9]);
	  return state;
	}

	function getHeight$3(texture, state) {
	  var match = getRecord$11(state);
	  return getHeight(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), match[/* heights */10]);
	}

	function setHeight$2(texture, height, state) {
	  var match = getRecord$11(state);
	  setHeight(getArrayBufferViewSourceTextureIndexInTypeArray(texture, getArrayBufferViewSourceTextureIndexOffset$1(state)), height, match[/* heights */10]);
	  return state;
	}


	/* ArrayService-Wonderjs Not a pure module */

	function createArrayBufferViewSourceTexture$1(state) {
	  return create$71(state);
	}

	var unsafeGetArrayBufferViewSourceTextureSource$1 = unsafeGetSource$2;

	var setArrayBufferViewSourceTextureSource$1 = setSource$2;

	var getArrayBufferViewSourceTextureWrapS$1 = getWrapS$3;

	var setArrayBufferViewSourceTextureWrapS$1 = setWrapS$3;

	var getArrayBufferViewSourceTextureWrapT$1 = getWrapT$3;

	var setArrayBufferViewSourceTextureWrapT$1 = setWrapT$3;

	var getArrayBufferViewSourceTextureMagFilter$1 = getMagFilter$3;

	var setArrayBufferViewSourceTextureMagFilter$1 = setMagFilter$3;

	var getArrayBufferViewSourceTextureMinFilter$1 = getMinFilter$3;

	var setArrayBufferViewSourceTextureMinFilter$1 = setMinFilter$3;

	var getArrayBufferViewSourceTextureFormat$1 = getFormat$3;

	var setArrayBufferViewSourceTextureFormat$1 = setFormat$3;

	var getArrayBufferViewSourceTextureType$1 = getType$4;

	var setArrayBufferViewSourceTextureType$1 = setType$3;

	var getArrayBufferViewSourceTextureFlipY$1 = getFlipY$4;

	var setArrayBufferViewSourceTextureFlipY$1 = setFlipY$5;

	var getArrayBufferViewSourceTextureWidth$1 = getWidth$3;

	var setArrayBufferViewSourceTextureWidth$1 = setWidth$2;

	var getArrayBufferViewSourceTextureHeight$1 = getHeight$3;

	var setArrayBufferViewSourceTextureHeight$1 = setHeight$2;

	var unsafeGetArrayBufferViewSourceTextureName$1 = unsafeGetName$5;

	function setArrayBufferViewSourceTextureName$1(texture, name, state) {
	  return setName$5(texture, name, state);
	}


	/* NameArrayBufferViewSourceTextureMainService-Wonderjs Not a pure module */

	var assembleWDB = assembleWDB$1;

	var assembleGLB = assembleGLB$1;

	var convertGLBToWDB = convertGLBToWDB$1;

	var generateWDB = generateWDB$1;

	var generateGLBData = generateGLBData$1;

	var loadIMGUIAsset = loadIMGUIAsset$1;

	var loadWDB = loadWDB$1;

	var loadConfig = loadConfig$1;

	var unbindArcballCameraControllerEvent = unbindArcballCameraControllerEvent$1;

	var bindArcballCameraControllerEvent = bindArcballCameraControllerEvent$1;

	var setArcballCameraControllerRotateSpeed = setArcballCameraControllerRotateSpeed$1;

	var unsafeGetArcballCameraControllerRotateSpeed = unsafeGetArcballCameraControllerRotateSpeed$1;

	var setArcballCameraControllerMoveSpeedY = setArcballCameraControllerMoveSpeedY$1;

	var unsafeGetArcballCameraControllerMoveSpeedY = unsafeGetArcballCameraControllerMoveSpeedY$1;

	var setArcballCameraControllerMoveSpeedX = setArcballCameraControllerMoveSpeedX$1;

	var unsafeGetArcballCameraControllerMoveSpeedX = unsafeGetArcballCameraControllerMoveSpeedX$1;

	var setArcballCameraControllerTarget = setArcballCameraControllerTarget$1;

	var unsafeGetArcballCameraControllerTarget = unsafeGetArcballCameraControllerTarget$1;

	var setArcballCameraControllerThetaMargin = setArcballCameraControllerThetaMargin$1;

	var unsafeGetArcballCameraControllerThetaMargin = unsafeGetArcballCameraControllerThetaMargin$1;

	var setArcballCameraControllerTheta = setArcballCameraControllerTheta$1;

	var unsafeGetArcballCameraControllerTheta = unsafeGetArcballCameraControllerTheta$1;

	var setArcballCameraControllerPhi = setArcballCameraControllerPhi$1;

	var unsafeGetArcballCameraControllerPhi = unsafeGetArcballCameraControllerPhi$1;

	var setArcballCameraControllerWheelSpeed = setArcballCameraControllerWheelSpeed$1;

	var unsafeGetArcballCameraControllerWheelSpeed = unsafeGetArcballCameraControllerWheelSpeed$1;

	var setArcballCameraControllerMinDistance = setArcballCameraControllerMinDistance$1;

	var unsafeGetArcballCameraControllerMinDistance = unsafeGetArcballCameraControllerMinDistance$1;

	var setArcballCameraControllerDistance = setArcballCameraControllerDistance$1;

	var unsafeGetArcballCameraControllerDistance = unsafeGetArcballCameraControllerDistance$1;

	var unsafeGetArcballCameraControllerGameObject = unsafeGetArcballCameraControllerGameObject$1;

	var createArcballCameraController = createArcballCameraController$1;

	var isSupportRenderWorkerAndSharedArrayBuffer = isSupportRenderWorkerAndSharedArrayBuffer$2;

	var getPointEventEventOfEvent = getPointEventEventOfEvent$1;

	var getPointEventMovementDeltaOfEvent = getPointEventMovementDeltaOfEvent$1;

	var getPointEventWheelOfEvent = getPointEventWheelOfEvent$1;

	var getPointEventButtonOfEvent = getPointEventButtonOfEvent$1;

	var getPointEventLocationOfEvent = getPointEventLocationOfEvent$1;

	var getPointEventLocationInViewOfEvent = getPointEventLocationInViewOfEvent$1;

	var getCustomEventUserData = getCustomEventUserData$2;

	var createCustomEvent = createCustomEvent$1;

	var emitCustomGameObjectEvent = emitCustomGameObjectEvent$2;

	var broadcastCustomGameObjectEvent = broadcastCustomGameObjectEvent$2;

	var triggerCustomGameObjectEvent = triggerCustomGameObjectEvent$2;

	var triggerCustomGlobalEvent = triggerCustomGlobalEvent$2;

	var stopPropagationCustomEvent = stopPropagationCustomEvent$2;

	var offCustomGameObjectEventByHandleFunc = offCustomGameObjectEventByHandleFunc$2;

	var offCustomGameObjectEventByTarget = offCustomGameObjectEventByTarget$2;

	var onCustomGameObjectEvent = onCustomGameObjectEvent$2;

	var offCustomGlobalEventByHandleFunc = offCustomGlobalEventByHandleFunc$2;

	var offCustomGlobalEventByEventName = offCustomGlobalEventByEventName$2;

	var onCustomGlobalEvent = onCustomGlobalEvent$2;

	var offTouchEventByHandleFunc = offTouchEventByHandleFunc$2;

	var offKeyboardEventByHandleFunc = offKeyboardEventByHandleFunc$2;

	var offMouseEventByHandleFunc = offMouseEventByHandleFunc$2;

	var onTouchEvent = onTouchEvent$2;

	var onKeyboardEvent = onKeyboardEvent$2;

	var onMouseEvent = onMouseEvent$2;

	var getPointDragEventName = getPointDragEventName$2;

	var getPointScaleEventName = getPointScaleEventName$2;

	var getPointMoveEventName = getPointMoveEventName$2;

	var getPointTapEventName = getPointTapEventName$2;

	var getPointUpEventName = getPointUpEventName$2;

	var getPointDownEventName = getPointDownEventName$2;

	var unsafeGetBoxGeometryGameObject = unsafeGetBoxGeometryGameObject$1;

	var getBoxGeometryIndices = getBoxGeometryIndices$1;

	var getBoxGeometryNormals = getBoxGeometryNormals$1;

	var getBoxGeometryTexCoords = getBoxGeometryTexCoords$1;

	var getBoxGeometryVertices = getBoxGeometryVertices$1;

	var createBoxGeometry = createBoxGeometry$1;

	var unsafeGetCustomGeometryGameObject = unsafeGetCustomGeometryGameObject$1;

	var setCustomGeometryIndices = setCustomGeometryIndices$1;

	var getCustomGeometryIndices = getCustomGeometryIndices$1;

	var setCustomGeometryNormals = setCustomGeometryNormals$1;

	var getCustomGeometryNormals = getCustomGeometryNormals$1;

	var setCustomGeometryTexCoords = setCustomGeometryTexCoords$1;

	var getCustomGeometryTexCoords = getCustomGeometryTexCoords$1;

	var setCustomGeometryVertices = setCustomGeometryVertices$1;

	var getCustomGeometryVertices = getCustomGeometryVertices$1;

	var createCustomGeometry = createCustomGeometry$1;

	var image = image$4;

	var label = label$4;

	var sendUniformProjectionMatData = sendUniformProjectionMatData$4;

	var setSetting = setSetting$4;

	var getSetting = getSetting$5;

	var setIMGUIFunc = setIMGUIFunc$5;

	var setDirectionLightIntensity = setDirectionLightIntensity$1;

	var getDirectionLightIntensity = getDirectionLightIntensity$1;

	var setDirectionLightColor = setDirectionLightColor$1;

	var getDirectionLightColor = getDirectionLightColor$1;

	var unsafeGetDirectionLightGameObject = unsafeGetDirectionLightGameObject$1;

	var createDirectionLight = createDirectionLight$1;

	var isExceedMaxCount = isExceedMaxCount$1;

	var setPointLightRangeLevel = setPointLightRangeLevel$1;

	var setPointLightRange = setPointLightRange$1;

	var getPointLightRange = getPointLightRange$1;

	var setPointLightQuadratic = setPointLightQuadratic$1;

	var getPointLightQuadratic = getPointLightQuadratic$1;

	var setPointLightLinear = setPointLightLinear$1;

	var getPointLightLinear = getPointLightLinear$1;

	var setPointLightConstant = setPointLightConstant$1;

	var getPointLightConstant = getPointLightConstant$1;

	var setPointLightIntensity = setPointLightIntensity$1;

	var getPointLightIntensity = getPointLightIntensity$1;

	var setPointLightColor = setPointLightColor$1;

	var getPointLightColor = getPointLightColor$1;

	var unsafeGetPointLightGameObject = unsafeGetPointLightGameObject$1;

	var createPointLight = createPointLight$1;

	var setBasicMaterialName = setBasicMaterialName$1;

	var unsafeGetBasicMaterialName = unsafeGetBasicMaterialName$1;

	var hasBasicMaterialMap = hasBasicMaterialMap$1;

	var setBasicMaterialMap = setBasicMaterialMap$1;

	var unsafeGetBasicMaterialMap = unsafeGetBasicMaterialMap$1;

	var setBasicMaterialColor = setBasicMaterialColor$1;

	var getBasicMaterialColor = getBasicMaterialColor$1;

	var unsafeGetBasicMaterialGameObject = unsafeGetBasicMaterialGameObject$1;

	var createBasicMaterial = createBasicMaterial$1;

	var reInitMaterials = reInitMaterials$1;

	var setLightMaterialName = setLightMaterialName$1;

	var unsafeGetLightMaterialName = unsafeGetLightMaterialName$1;

	var hasLightMaterialSpecularMap = hasLightMaterialSpecularMap$1;

	var setLightMaterialSpecularMap = setLightMaterialSpecularMap$1;

	var unsafeGetLightMaterialSpecularMap = unsafeGetLightMaterialSpecularMap$1;

	var hasLightMaterialDiffuseMap = hasLightMaterialDiffuseMap$1;

	var setLightMaterialDiffuseMap = setLightMaterialDiffuseMap$1;

	var unsafeGetLightMaterialDiffuseMap = unsafeGetLightMaterialDiffuseMap$1;

	var setLightMaterialShininess = setLightMaterialShininess$1;

	var getLightMaterialShininess = getLightMaterialShininess$1;

	var setLightMaterialSpecularColor = setLightMaterialSpecularColor$1;

	var getLightMaterialSpecularColor = getLightMaterialSpecularColor$1;

	var setLightMaterialDiffuseColor = setLightMaterialDiffuseColor$1;

	var getLightMaterialDiffuseColor = getLightMaterialDiffuseColor$1;

	var unsafeGetLightMaterialGameObject = unsafeGetLightMaterialGameObject$1;

	var createLightMaterial = createLightMaterial$1;

	var replaceMaterial = replaceMaterial$1;

	var setSparseMapValue = setSparseMapValue$1;

	var getSparseMapValue = getSparseMapValue$1;

	var unsafeGetSparseMapValue = unsafeGetSparseMapValue$1;

	var createSparseMap = createSparseMap$1;

	var setArrayBufferViewSourceTextureName = setArrayBufferViewSourceTextureName$1;

	var unsafeGetArrayBufferViewSourceTextureName = unsafeGetArrayBufferViewSourceTextureName$1;

	var setArrayBufferViewSourceTextureHeight = setArrayBufferViewSourceTextureHeight$1;

	var setArrayBufferViewSourceTextureWidth = setArrayBufferViewSourceTextureWidth$1;

	var setArrayBufferViewSourceTextureFlipY = setArrayBufferViewSourceTextureFlipY$1;

	var getArrayBufferViewSourceTextureFlipY = getArrayBufferViewSourceTextureFlipY$1;

	var setArrayBufferViewSourceTextureType = setArrayBufferViewSourceTextureType$1;

	var getArrayBufferViewSourceTextureType = getArrayBufferViewSourceTextureType$1;

	var setArrayBufferViewSourceTextureFormat = setArrayBufferViewSourceTextureFormat$1;

	var getArrayBufferViewSourceTextureFormat = getArrayBufferViewSourceTextureFormat$1;

	var setArrayBufferViewSourceTextureMinFilter = setArrayBufferViewSourceTextureMinFilter$1;

	var getArrayBufferViewSourceTextureMinFilter = getArrayBufferViewSourceTextureMinFilter$1;

	var setArrayBufferViewSourceTextureMagFilter = setArrayBufferViewSourceTextureMagFilter$1;

	var getArrayBufferViewSourceTextureMagFilter = getArrayBufferViewSourceTextureMagFilter$1;

	var setArrayBufferViewSourceTextureWrapT = setArrayBufferViewSourceTextureWrapT$1;

	var getArrayBufferViewSourceTextureWrapT = getArrayBufferViewSourceTextureWrapT$1;

	var setArrayBufferViewSourceTextureWrapS = setArrayBufferViewSourceTextureWrapS$1;

	var getArrayBufferViewSourceTextureWrapS = getArrayBufferViewSourceTextureWrapS$1;

	var getArrayBufferViewSourceTextureHeight = getArrayBufferViewSourceTextureHeight$1;

	var getArrayBufferViewSourceTextureWidth = getArrayBufferViewSourceTextureWidth$1;

	var setArrayBufferViewSourceTextureSource = setArrayBufferViewSourceTextureSource$1;

	var unsafeGetArrayBufferViewSourceTextureSource = unsafeGetArrayBufferViewSourceTextureSource$1;

	var createArrayBufferViewSourceTexture = createArrayBufferViewSourceTexture$1;

	var setBasicSourceTextureName = setBasicSourceTextureName$1;

	var unsafeGetBasicSourceTextureName = unsafeGetBasicSourceTextureName$1;

	var getBasicSourceTextureName = getBasicSourceTextureName$1;

	var setBasicSourceTextureFlipY = setBasicSourceTextureFlipY$1;

	var getBasicSourceTextureFlipY = getBasicSourceTextureFlipY$1;

	var setBasicSourceTextureType = setBasicSourceTextureType$1;

	var getBasicSourceTextureType = getBasicSourceTextureType$1;

	var setBasicSourceTextureFormat = setBasicSourceTextureFormat$1;

	var getBasicSourceTextureFormat = getBasicSourceTextureFormat$1;

	var setBasicSourceTextureMinFilter = setBasicSourceTextureMinFilter$1;

	var getBasicSourceTextureMinFilter = getBasicSourceTextureMinFilter$1;

	var setBasicSourceTextureMagFilter = setBasicSourceTextureMagFilter$1;

	var getBasicSourceTextureMagFilter = getBasicSourceTextureMagFilter$1;

	var setBasicSourceTextureWrapT = setBasicSourceTextureWrapT$1;

	var getBasicSourceTextureWrapT = getBasicSourceTextureWrapT$1;

	var setBasicSourceTextureWrapS = setBasicSourceTextureWrapS$1;

	var getBasicSourceTextureWrapS = getBasicSourceTextureWrapS$1;

	var getBasicSourceTextureHeight = getBasicSourceTextureHeight$1;

	var getBasicSourceTextureWidth = getBasicSourceTextureWidth$1;

	var setBasicSourceTextureSource = setBasicSourceTextureSource$1;

	var unsafeGetBasicSourceTextureSource = unsafeGetBasicSourceTextureSource$1;

	var createBasicSourceTexture = createBasicSourceTexture$1;

	var setMainWorkerCustomData = setMainWorkerCustomData$2;

	var getMainWorkerCustomData = getMainWorkerCustomData$2;

	var getRenderWorkerCustomData = getRenderWorkerCustomData$2;

	var getBasicCameraViewWorldToCameraMatrix = getBasicCameraViewWorldToCameraMatrix$2;

	var unsafeGetGameObjectBasicCameraView = unsafeGetGameObjectBasicCameraView$1;

	var createBasicCameraView = createBasicCameraView$1;

	var convertWorldToScreen = convertWorldToScreen$1;

	var setViewport = setViewport$1;

	var unsafeGetGl = unsafeGetGl$2;

	var startDirector = startDirector$1;

	var loopBody = loopBody$1;

	var initDirector = initDirector$1;

	var setGameObjectName = setGameObjectName$1;

	var unsafeGetGameObjectName = unsafeGetGameObjectName$1;

	var getGameObjectName = getGameObjectName$1;

	var cloneGameObject = cloneGameObject$1;

	var batchDisposeGameObjectKeepOrder = batchDisposeGameObjectKeepOrder$1;

	var batchDisposeGameObject = batchDisposeGameObject$1;

	var initGameObject = initGameObject$1;

	var disposeGameObjectKeepOrder = disposeGameObjectKeepOrder$1;

	var disposeGameObject = disposeGameObject$1;

	var isGameObjectAlive = isGameObjectAlive$1;

	var disposeGameObjectObjectInstanceComponent = disposeGameObjectObjectInstanceComponent$1;

	var unsafeGetGameObjectObjectInstanceComponent = unsafeGetGameObjectObjectInstanceComponent$1;

	var addGameObjectObjectInstanceComponent = addGameObjectObjectInstanceComponent$1;

	var disposeGameObjectSourceInstanceComponent = disposeGameObjectSourceInstanceComponent$1;

	var hasGameObjectSourceInstanceComponent = hasGameObjectSourceInstanceComponent$1;

	var unsafeGetGameObjectSourceInstanceComponent = unsafeGetGameObjectSourceInstanceComponent$1;

	var addGameObjectSourceInstanceComponent = addGameObjectSourceInstanceComponent$1;

	var hasGameObjectPointLightComponent = hasGameObjectPointLightComponent$1;

	var unsafeGetGameObjectPointLightComponent = unsafeGetGameObjectPointLightComponent$1;

	var disposeGameObjectPointLightComponent = disposeGameObjectPointLightComponent$1;

	var addGameObjectPointLightComponent = addGameObjectPointLightComponent$1;

	var hasGameObjectDirectionLightComponent = hasGameObjectDirectionLightComponent$1;

	var unsafeGetGameObjectDirectionLightComponent = unsafeGetGameObjectDirectionLightComponent$1;

	var disposeGameObjectDirectionLightComponent = disposeGameObjectDirectionLightComponent$1;

	var addGameObjectDirectionLightComponent = addGameObjectDirectionLightComponent$1;

	var hasGameObjectMeshRendererComponent = hasGameObjectMeshRendererComponent$1;

	var unsafeGetGameObjectMeshRendererComponent = unsafeGetGameObjectMeshRendererComponent$1;

	var disposeGameObjectMeshRendererComponent = disposeGameObjectMeshRendererComponent$1;

	var addGameObjectMeshRendererComponent = addGameObjectMeshRendererComponent$1;

	var hasGameObjectLightMaterialComponent = hasGameObjectLightMaterialComponent$1;

	var unsafeGetGameObjectLightMaterialComponent = unsafeGetGameObjectLightMaterialComponent$1;

	var disposeGameObjectLightMaterialComponent = disposeGameObjectLightMaterialComponent$1;

	var addGameObjectLightMaterialComponent = addGameObjectLightMaterialComponent$1;

	var hasGameObjectBasicMaterialComponent = hasGameObjectBasicMaterialComponent$1;

	var unsafeGetGameObjectBasicMaterialComponent = unsafeGetGameObjectBasicMaterialComponent$1;

	var disposeGameObjectBasicMaterialComponent = disposeGameObjectBasicMaterialComponent$1;

	var addGameObjectBasicMaterialComponent = addGameObjectBasicMaterialComponent$1;

	var hasGameObjectGeometryComponent = hasGameObjectGeometryComponent$1;

	var unsafeGetGameObjectGeometryComponent = unsafeGetGameObjectGeometryComponent$1;

	var disposeGameObjectCustomGeometryComponent = disposeGameObjectCustomGeometryComponent$1;

	var addGameObjectCustomGeometryComponent = addGameObjectCustomGeometryComponent$1;

	var hasGameObjectBoxGeometryComponent = hasGameObjectBoxGeometryComponent$1;

	var disposeGameObjectBoxGeometryComponent = disposeGameObjectBoxGeometryComponent$1;

	var addGameObjectBoxGeometryComponent = addGameObjectBoxGeometryComponent$1;

	var hasGameObjectTransformComponent = hasGameObjectTransformComponent$1;

	var unsafeGetGameObjectTransformComponent = unsafeGetGameObjectTransformComponent$1;

	var disposeGameObjectTransformComponent = disposeGameObjectTransformComponent$1;

	var addGameObjectTransformComponent = addGameObjectTransformComponent$1;

	var hasGameObjectArcballCameraControllerComponent = hasGameObjectArcballCameraControllerComponent$1;

	var unsafeGetGameObjectArcballCameraControllerComponent = unsafeGetGameObjectArcballCameraControllerComponent$1;

	var disposeGameObjectArcballCameraControllerComponent = disposeGameObjectArcballCameraControllerComponent$1;

	var addGameObjectArcballCameraControllerComponent = addGameObjectArcballCameraControllerComponent$1;

	var hasGameObjectPerspectiveCameraProjectionComponent = hasGameObjectPerspectiveCameraProjectionComponent$1;

	var unsafeGetGameObjectPerspectiveCameraProjectionComponent = unsafeGetGameObjectPerspectiveCameraProjectionComponent$1;

	var disposeGameObjectPerspectiveCameraProjectionComponent = disposeGameObjectPerspectiveCameraProjectionComponent$1;

	var addGameObjectPerspectiveCameraProjectionComponent = addGameObjectPerspectiveCameraProjectionComponent$1;

	var hasGameObjectBasicCameraViewComponent = hasGameObjectBasicCameraViewComponent$1;

	var unsafeGetGameObjectBasicCameraViewComponent = unsafeGetGameObjectBasicCameraViewComponent$1;

	var disposeGameObjectBasicCameraViewComponent = disposeGameObjectBasicCameraViewComponent$1;

	var addGameObjectBasicCameraViewComponent = addGameObjectBasicCameraViewComponent$1;

	var createGameObject = createGameObject$1;

	var removeWorkerMainLoopJob = removeWorkerMainLoopJob$1;

	var addWorkerMainLoopJob = addWorkerMainLoopJob$1;

	var removeWorkerMainInitJob = removeWorkerMainInitJob$1;

	var addWorkerMainInitJob = addWorkerMainInitJob$1;

	var removeNoWorkerLoopJob = removeNoWorkerLoopJob$1;

	var removeNoWorkerInitJob = removeNoWorkerInitJob$1;

	var addNoWorkerLoopJob = addNoWorkerLoopJob$1;

	var addNoWorkerInitJob = addNoWorkerInitJob$1;

	var setMeshRendererDrawMode = setMeshRendererDrawMode$1;

	var getMeshRendererDrawMode = getMeshRendererDrawMode$1;

	var unsafeGetMeshRendererGameObject = unsafeGetMeshRendererGameObject$1;

	var createMeshRenderer = createMeshRenderer$1;

	var setPerspectiveCameraProjectionFar = setPerspectiveCameraProjectionFar$1;

	var unsafeGetPerspectiveCameraFar = unsafeGetPerspectiveCameraFar$1;

	var setPerspectiveCameraProjectionNear = setPerspectiveCameraProjectionNear$1;

	var unsafeGetPerspectiveCameraNear = unsafeGetPerspectiveCameraNear$1;

	var setPerspectiveCameraProjectionAspect = setPerspectiveCameraProjectionAspect$1;

	var unsafeGetPerspectiveCameraAspect = unsafeGetPerspectiveCameraAspect$1;

	var setPerspectiveCameraProjectionFovy = setPerspectiveCameraProjectionFovy$1;

	var unsafeGetPerspectiveCameraFovy = unsafeGetPerspectiveCameraFovy$1;

	var unsafeGetPerspectiveCameraProjectionGameObject = unsafeGetPerspectiveCameraProjectionGameObject$1;

	var unsafeGetPerspectiveCameraProjectionPMatrix = unsafeGetPerspectiveCameraProjectionPMatrix$1;

	var createPerspectiveCameraProjection = createPerspectiveCameraProjection$1;

	var addSceneChildren = addSceneChildren$1;

	var addSceneChild = addSceneChild$1;

	var getSceneGameObject = getSceneGameObject$1;

	var setAmbientLightColor = setAmbientLightColor$1;

	var getAmbientLightColor = getAmbientLightColor$1;

	var setCurrentCameraGameObject = setCurrentCameraGameObject$1;

	var getCurrentCameraGameObject = getCurrentCameraGameObject$1;

	var setScreenSize = setScreenSize$1;

	var markSourceInstanceModelMatrixIsStatic = markSourceInstanceModelMatrixIsStatic$1;

	var getSourceInstanceObjectInstanceTransformArray = getSourceInstanceObjectInstanceTransformArray$1;

	var createObjectInstanceGameObject = createObjectInstanceGameObject$1;

	var unsafeGetSourceInstanceGameObject = unsafeGetSourceInstanceGameObject$1;

	var createSourceInstance = createSourceInstance$1;

	var setSetStateFunc = setSetStateFunc$1;

	var setUnsafeGetStateFunc = setUnsafeGetStateFunc$1;

	var setIsDebug = setIsDebug$2;

	var setStateToData = setStateToData$1;

	var setState = setState$1;

	var createState = createState$1;

	var getStateFromData = getStateFromData$1;

	var unsafeGetState = unsafeGetState$1;

	var createStateData = createStateData$2;

	var getStateData = getStateData$1;

	var restoreState = restoreState$1;

	var deepCopyForRestore = deepCopyForRestore$8;

	var getFps = getFps$2;

	var getGameTime = getGameTime$2;

	var lookAtWithUp = lookAtWithUp$1;

	var lookAt = lookAt$1;

	var setTransformEulerAngles = setTransformEulerAngles$1;

	var getTransformEulerAngles = getTransformEulerAngles$1;

	var setTransformLocalEulerAngles = setTransformLocalEulerAngles$1;

	var getTransformLocalEulerAngles = getTransformLocalEulerAngles$1;

	var setTransformScale = setTransformScale$1;

	var getTransformScale = getTransformScale$1;

	var setTransformLocalScale = setTransformLocalScale$1;

	var getTransformLocalScale = getTransformLocalScale$1;

	var setTransformRotation = setTransformRotation$1;

	var getTransformRotation = getTransformRotation$1;

	var setTransformLocalRotation = setTransformLocalRotation$1;

	var getTransformLocalRotation = getTransformLocalRotation$1;

	var setTransformPosition = setTransformPosition$1;

	var getTransformPosition = getTransformPosition$1;

	var setTransformLocalPosition = setTransformLocalPosition$1;

	var getTransformLocalPosition = getTransformLocalPosition$1;

	var unsafeGetTransformChildren = unsafeGetTransformChildren$1;

	var setTransformParentKeepOrder = setTransformParentKeepOrder$1;

	var setTransformParent = setTransformParent$1;

	var unsafeGetTransformParent = unsafeGetTransformParent$1;

	var unsafeGetTransformGameObject = unsafeGetTransformGameObject$1;

	var createTransform = createTransform$1;

	var create = create$61;

	var setAPIJsObj = setAPIJsObj$2;

	var getAPIJsObj = getAPIJsObj$3;


	/* JobAPI-Wonderjs Not a pure module */

	exports.assembleWDB = assembleWDB;
	exports.assembleGLB = assembleGLB;
	exports.convertGLBToWDB = convertGLBToWDB;
	exports.generateWDB = generateWDB;
	exports.generateGLBData = generateGLBData;
	exports.loadIMGUIAsset = loadIMGUIAsset;
	exports.loadWDB = loadWDB;
	exports.loadConfig = loadConfig;
	exports.unbindArcballCameraControllerEvent = unbindArcballCameraControllerEvent;
	exports.bindArcballCameraControllerEvent = bindArcballCameraControllerEvent;
	exports.setArcballCameraControllerRotateSpeed = setArcballCameraControllerRotateSpeed;
	exports.unsafeGetArcballCameraControllerRotateSpeed = unsafeGetArcballCameraControllerRotateSpeed;
	exports.setArcballCameraControllerMoveSpeedY = setArcballCameraControllerMoveSpeedY;
	exports.unsafeGetArcballCameraControllerMoveSpeedY = unsafeGetArcballCameraControllerMoveSpeedY;
	exports.setArcballCameraControllerMoveSpeedX = setArcballCameraControllerMoveSpeedX;
	exports.unsafeGetArcballCameraControllerMoveSpeedX = unsafeGetArcballCameraControllerMoveSpeedX;
	exports.setArcballCameraControllerTarget = setArcballCameraControllerTarget;
	exports.unsafeGetArcballCameraControllerTarget = unsafeGetArcballCameraControllerTarget;
	exports.setArcballCameraControllerThetaMargin = setArcballCameraControllerThetaMargin;
	exports.unsafeGetArcballCameraControllerThetaMargin = unsafeGetArcballCameraControllerThetaMargin;
	exports.setArcballCameraControllerTheta = setArcballCameraControllerTheta;
	exports.unsafeGetArcballCameraControllerTheta = unsafeGetArcballCameraControllerTheta;
	exports.setArcballCameraControllerPhi = setArcballCameraControllerPhi;
	exports.unsafeGetArcballCameraControllerPhi = unsafeGetArcballCameraControllerPhi;
	exports.setArcballCameraControllerWheelSpeed = setArcballCameraControllerWheelSpeed;
	exports.unsafeGetArcballCameraControllerWheelSpeed = unsafeGetArcballCameraControllerWheelSpeed;
	exports.setArcballCameraControllerMinDistance = setArcballCameraControllerMinDistance;
	exports.unsafeGetArcballCameraControllerMinDistance = unsafeGetArcballCameraControllerMinDistance;
	exports.setArcballCameraControllerDistance = setArcballCameraControllerDistance;
	exports.unsafeGetArcballCameraControllerDistance = unsafeGetArcballCameraControllerDistance;
	exports.unsafeGetArcballCameraControllerGameObject = unsafeGetArcballCameraControllerGameObject;
	exports.createArcballCameraController = createArcballCameraController;
	exports.isSupportRenderWorkerAndSharedArrayBuffer = isSupportRenderWorkerAndSharedArrayBuffer;
	exports.getPointEventEventOfEvent = getPointEventEventOfEvent;
	exports.getPointEventMovementDeltaOfEvent = getPointEventMovementDeltaOfEvent;
	exports.getPointEventWheelOfEvent = getPointEventWheelOfEvent;
	exports.getPointEventButtonOfEvent = getPointEventButtonOfEvent;
	exports.getPointEventLocationOfEvent = getPointEventLocationOfEvent;
	exports.getPointEventLocationInViewOfEvent = getPointEventLocationInViewOfEvent;
	exports.getCustomEventUserData = getCustomEventUserData;
	exports.createCustomEvent = createCustomEvent;
	exports.emitCustomGameObjectEvent = emitCustomGameObjectEvent;
	exports.broadcastCustomGameObjectEvent = broadcastCustomGameObjectEvent;
	exports.triggerCustomGameObjectEvent = triggerCustomGameObjectEvent;
	exports.triggerCustomGlobalEvent = triggerCustomGlobalEvent;
	exports.stopPropagationCustomEvent = stopPropagationCustomEvent;
	exports.offCustomGameObjectEventByHandleFunc = offCustomGameObjectEventByHandleFunc;
	exports.offCustomGameObjectEventByTarget = offCustomGameObjectEventByTarget;
	exports.onCustomGameObjectEvent = onCustomGameObjectEvent;
	exports.offCustomGlobalEventByHandleFunc = offCustomGlobalEventByHandleFunc;
	exports.offCustomGlobalEventByEventName = offCustomGlobalEventByEventName;
	exports.onCustomGlobalEvent = onCustomGlobalEvent;
	exports.offTouchEventByHandleFunc = offTouchEventByHandleFunc;
	exports.offKeyboardEventByHandleFunc = offKeyboardEventByHandleFunc;
	exports.offMouseEventByHandleFunc = offMouseEventByHandleFunc;
	exports.onTouchEvent = onTouchEvent;
	exports.onKeyboardEvent = onKeyboardEvent;
	exports.onMouseEvent = onMouseEvent;
	exports.getPointDragEventName = getPointDragEventName;
	exports.getPointScaleEventName = getPointScaleEventName;
	exports.getPointMoveEventName = getPointMoveEventName;
	exports.getPointTapEventName = getPointTapEventName;
	exports.getPointUpEventName = getPointUpEventName;
	exports.getPointDownEventName = getPointDownEventName;
	exports.unsafeGetBoxGeometryGameObject = unsafeGetBoxGeometryGameObject;
	exports.getBoxGeometryIndices = getBoxGeometryIndices;
	exports.getBoxGeometryNormals = getBoxGeometryNormals;
	exports.getBoxGeometryTexCoords = getBoxGeometryTexCoords;
	exports.getBoxGeometryVertices = getBoxGeometryVertices;
	exports.createBoxGeometry = createBoxGeometry;
	exports.unsafeGetCustomGeometryGameObject = unsafeGetCustomGeometryGameObject;
	exports.setCustomGeometryIndices = setCustomGeometryIndices;
	exports.getCustomGeometryIndices = getCustomGeometryIndices;
	exports.setCustomGeometryNormals = setCustomGeometryNormals;
	exports.getCustomGeometryNormals = getCustomGeometryNormals;
	exports.setCustomGeometryTexCoords = setCustomGeometryTexCoords;
	exports.getCustomGeometryTexCoords = getCustomGeometryTexCoords;
	exports.setCustomGeometryVertices = setCustomGeometryVertices;
	exports.getCustomGeometryVertices = getCustomGeometryVertices;
	exports.createCustomGeometry = createCustomGeometry;
	exports.image = image;
	exports.label = label;
	exports.sendUniformProjectionMatData = sendUniformProjectionMatData;
	exports.setSetting = setSetting;
	exports.getSetting = getSetting;
	exports.setIMGUIFunc = setIMGUIFunc;
	exports.setDirectionLightIntensity = setDirectionLightIntensity;
	exports.getDirectionLightIntensity = getDirectionLightIntensity;
	exports.setDirectionLightColor = setDirectionLightColor;
	exports.getDirectionLightColor = getDirectionLightColor;
	exports.unsafeGetDirectionLightGameObject = unsafeGetDirectionLightGameObject;
	exports.createDirectionLight = createDirectionLight;
	exports.isExceedMaxCount = isExceedMaxCount;
	exports.setPointLightRangeLevel = setPointLightRangeLevel;
	exports.setPointLightRange = setPointLightRange;
	exports.getPointLightRange = getPointLightRange;
	exports.setPointLightQuadratic = setPointLightQuadratic;
	exports.getPointLightQuadratic = getPointLightQuadratic;
	exports.setPointLightLinear = setPointLightLinear;
	exports.getPointLightLinear = getPointLightLinear;
	exports.setPointLightConstant = setPointLightConstant;
	exports.getPointLightConstant = getPointLightConstant;
	exports.setPointLightIntensity = setPointLightIntensity;
	exports.getPointLightIntensity = getPointLightIntensity;
	exports.setPointLightColor = setPointLightColor;
	exports.getPointLightColor = getPointLightColor;
	exports.unsafeGetPointLightGameObject = unsafeGetPointLightGameObject;
	exports.createPointLight = createPointLight;
	exports.setBasicMaterialName = setBasicMaterialName;
	exports.unsafeGetBasicMaterialName = unsafeGetBasicMaterialName;
	exports.hasBasicMaterialMap = hasBasicMaterialMap;
	exports.setBasicMaterialMap = setBasicMaterialMap;
	exports.unsafeGetBasicMaterialMap = unsafeGetBasicMaterialMap;
	exports.setBasicMaterialColor = setBasicMaterialColor;
	exports.getBasicMaterialColor = getBasicMaterialColor;
	exports.unsafeGetBasicMaterialGameObject = unsafeGetBasicMaterialGameObject;
	exports.createBasicMaterial = createBasicMaterial;
	exports.reInitMaterials = reInitMaterials;
	exports.setLightMaterialName = setLightMaterialName;
	exports.unsafeGetLightMaterialName = unsafeGetLightMaterialName;
	exports.hasLightMaterialSpecularMap = hasLightMaterialSpecularMap;
	exports.setLightMaterialSpecularMap = setLightMaterialSpecularMap;
	exports.unsafeGetLightMaterialSpecularMap = unsafeGetLightMaterialSpecularMap;
	exports.hasLightMaterialDiffuseMap = hasLightMaterialDiffuseMap;
	exports.setLightMaterialDiffuseMap = setLightMaterialDiffuseMap;
	exports.unsafeGetLightMaterialDiffuseMap = unsafeGetLightMaterialDiffuseMap;
	exports.setLightMaterialShininess = setLightMaterialShininess;
	exports.getLightMaterialShininess = getLightMaterialShininess;
	exports.setLightMaterialSpecularColor = setLightMaterialSpecularColor;
	exports.getLightMaterialSpecularColor = getLightMaterialSpecularColor;
	exports.setLightMaterialDiffuseColor = setLightMaterialDiffuseColor;
	exports.getLightMaterialDiffuseColor = getLightMaterialDiffuseColor;
	exports.unsafeGetLightMaterialGameObject = unsafeGetLightMaterialGameObject;
	exports.createLightMaterial = createLightMaterial;
	exports.replaceMaterial = replaceMaterial;
	exports.setSparseMapValue = setSparseMapValue;
	exports.getSparseMapValue = getSparseMapValue;
	exports.unsafeGetSparseMapValue = unsafeGetSparseMapValue;
	exports.createSparseMap = createSparseMap;
	exports.setArrayBufferViewSourceTextureName = setArrayBufferViewSourceTextureName;
	exports.unsafeGetArrayBufferViewSourceTextureName = unsafeGetArrayBufferViewSourceTextureName;
	exports.setArrayBufferViewSourceTextureHeight = setArrayBufferViewSourceTextureHeight;
	exports.setArrayBufferViewSourceTextureWidth = setArrayBufferViewSourceTextureWidth;
	exports.setArrayBufferViewSourceTextureFlipY = setArrayBufferViewSourceTextureFlipY;
	exports.getArrayBufferViewSourceTextureFlipY = getArrayBufferViewSourceTextureFlipY;
	exports.setArrayBufferViewSourceTextureType = setArrayBufferViewSourceTextureType;
	exports.getArrayBufferViewSourceTextureType = getArrayBufferViewSourceTextureType;
	exports.setArrayBufferViewSourceTextureFormat = setArrayBufferViewSourceTextureFormat;
	exports.getArrayBufferViewSourceTextureFormat = getArrayBufferViewSourceTextureFormat;
	exports.setArrayBufferViewSourceTextureMinFilter = setArrayBufferViewSourceTextureMinFilter;
	exports.getArrayBufferViewSourceTextureMinFilter = getArrayBufferViewSourceTextureMinFilter;
	exports.setArrayBufferViewSourceTextureMagFilter = setArrayBufferViewSourceTextureMagFilter;
	exports.getArrayBufferViewSourceTextureMagFilter = getArrayBufferViewSourceTextureMagFilter;
	exports.setArrayBufferViewSourceTextureWrapT = setArrayBufferViewSourceTextureWrapT;
	exports.getArrayBufferViewSourceTextureWrapT = getArrayBufferViewSourceTextureWrapT;
	exports.setArrayBufferViewSourceTextureWrapS = setArrayBufferViewSourceTextureWrapS;
	exports.getArrayBufferViewSourceTextureWrapS = getArrayBufferViewSourceTextureWrapS;
	exports.getArrayBufferViewSourceTextureHeight = getArrayBufferViewSourceTextureHeight;
	exports.getArrayBufferViewSourceTextureWidth = getArrayBufferViewSourceTextureWidth;
	exports.setArrayBufferViewSourceTextureSource = setArrayBufferViewSourceTextureSource;
	exports.unsafeGetArrayBufferViewSourceTextureSource = unsafeGetArrayBufferViewSourceTextureSource;
	exports.createArrayBufferViewSourceTexture = createArrayBufferViewSourceTexture;
	exports.setBasicSourceTextureName = setBasicSourceTextureName;
	exports.unsafeGetBasicSourceTextureName = unsafeGetBasicSourceTextureName;
	exports.getBasicSourceTextureName = getBasicSourceTextureName;
	exports.setBasicSourceTextureFlipY = setBasicSourceTextureFlipY;
	exports.getBasicSourceTextureFlipY = getBasicSourceTextureFlipY;
	exports.setBasicSourceTextureType = setBasicSourceTextureType;
	exports.getBasicSourceTextureType = getBasicSourceTextureType;
	exports.setBasicSourceTextureFormat = setBasicSourceTextureFormat;
	exports.getBasicSourceTextureFormat = getBasicSourceTextureFormat;
	exports.setBasicSourceTextureMinFilter = setBasicSourceTextureMinFilter;
	exports.getBasicSourceTextureMinFilter = getBasicSourceTextureMinFilter;
	exports.setBasicSourceTextureMagFilter = setBasicSourceTextureMagFilter;
	exports.getBasicSourceTextureMagFilter = getBasicSourceTextureMagFilter;
	exports.setBasicSourceTextureWrapT = setBasicSourceTextureWrapT;
	exports.getBasicSourceTextureWrapT = getBasicSourceTextureWrapT;
	exports.setBasicSourceTextureWrapS = setBasicSourceTextureWrapS;
	exports.getBasicSourceTextureWrapS = getBasicSourceTextureWrapS;
	exports.getBasicSourceTextureHeight = getBasicSourceTextureHeight;
	exports.getBasicSourceTextureWidth = getBasicSourceTextureWidth;
	exports.setBasicSourceTextureSource = setBasicSourceTextureSource;
	exports.unsafeGetBasicSourceTextureSource = unsafeGetBasicSourceTextureSource;
	exports.createBasicSourceTexture = createBasicSourceTexture;
	exports.setMainWorkerCustomData = setMainWorkerCustomData;
	exports.getMainWorkerCustomData = getMainWorkerCustomData;
	exports.getRenderWorkerCustomData = getRenderWorkerCustomData;
	exports.getBasicCameraViewWorldToCameraMatrix = getBasicCameraViewWorldToCameraMatrix;
	exports.unsafeGetGameObjectBasicCameraView = unsafeGetGameObjectBasicCameraView;
	exports.createBasicCameraView = createBasicCameraView;
	exports.convertWorldToScreen = convertWorldToScreen;
	exports.setViewport = setViewport;
	exports.unsafeGetGl = unsafeGetGl;
	exports.startDirector = startDirector;
	exports.loopBody = loopBody;
	exports.initDirector = initDirector;
	exports.setGameObjectName = setGameObjectName;
	exports.unsafeGetGameObjectName = unsafeGetGameObjectName;
	exports.getGameObjectName = getGameObjectName;
	exports.cloneGameObject = cloneGameObject;
	exports.batchDisposeGameObjectKeepOrder = batchDisposeGameObjectKeepOrder;
	exports.batchDisposeGameObject = batchDisposeGameObject;
	exports.initGameObject = initGameObject;
	exports.disposeGameObjectKeepOrder = disposeGameObjectKeepOrder;
	exports.disposeGameObject = disposeGameObject;
	exports.isGameObjectAlive = isGameObjectAlive;
	exports.disposeGameObjectObjectInstanceComponent = disposeGameObjectObjectInstanceComponent;
	exports.unsafeGetGameObjectObjectInstanceComponent = unsafeGetGameObjectObjectInstanceComponent;
	exports.addGameObjectObjectInstanceComponent = addGameObjectObjectInstanceComponent;
	exports.disposeGameObjectSourceInstanceComponent = disposeGameObjectSourceInstanceComponent;
	exports.hasGameObjectSourceInstanceComponent = hasGameObjectSourceInstanceComponent;
	exports.unsafeGetGameObjectSourceInstanceComponent = unsafeGetGameObjectSourceInstanceComponent;
	exports.addGameObjectSourceInstanceComponent = addGameObjectSourceInstanceComponent;
	exports.hasGameObjectPointLightComponent = hasGameObjectPointLightComponent;
	exports.unsafeGetGameObjectPointLightComponent = unsafeGetGameObjectPointLightComponent;
	exports.disposeGameObjectPointLightComponent = disposeGameObjectPointLightComponent;
	exports.addGameObjectPointLightComponent = addGameObjectPointLightComponent;
	exports.hasGameObjectDirectionLightComponent = hasGameObjectDirectionLightComponent;
	exports.unsafeGetGameObjectDirectionLightComponent = unsafeGetGameObjectDirectionLightComponent;
	exports.disposeGameObjectDirectionLightComponent = disposeGameObjectDirectionLightComponent;
	exports.addGameObjectDirectionLightComponent = addGameObjectDirectionLightComponent;
	exports.hasGameObjectMeshRendererComponent = hasGameObjectMeshRendererComponent;
	exports.unsafeGetGameObjectMeshRendererComponent = unsafeGetGameObjectMeshRendererComponent;
	exports.disposeGameObjectMeshRendererComponent = disposeGameObjectMeshRendererComponent;
	exports.addGameObjectMeshRendererComponent = addGameObjectMeshRendererComponent;
	exports.hasGameObjectLightMaterialComponent = hasGameObjectLightMaterialComponent;
	exports.unsafeGetGameObjectLightMaterialComponent = unsafeGetGameObjectLightMaterialComponent;
	exports.disposeGameObjectLightMaterialComponent = disposeGameObjectLightMaterialComponent;
	exports.addGameObjectLightMaterialComponent = addGameObjectLightMaterialComponent;
	exports.hasGameObjectBasicMaterialComponent = hasGameObjectBasicMaterialComponent;
	exports.unsafeGetGameObjectBasicMaterialComponent = unsafeGetGameObjectBasicMaterialComponent;
	exports.disposeGameObjectBasicMaterialComponent = disposeGameObjectBasicMaterialComponent;
	exports.addGameObjectBasicMaterialComponent = addGameObjectBasicMaterialComponent;
	exports.hasGameObjectGeometryComponent = hasGameObjectGeometryComponent;
	exports.unsafeGetGameObjectGeometryComponent = unsafeGetGameObjectGeometryComponent;
	exports.disposeGameObjectCustomGeometryComponent = disposeGameObjectCustomGeometryComponent;
	exports.addGameObjectCustomGeometryComponent = addGameObjectCustomGeometryComponent;
	exports.hasGameObjectBoxGeometryComponent = hasGameObjectBoxGeometryComponent;
	exports.disposeGameObjectBoxGeometryComponent = disposeGameObjectBoxGeometryComponent;
	exports.addGameObjectBoxGeometryComponent = addGameObjectBoxGeometryComponent;
	exports.hasGameObjectTransformComponent = hasGameObjectTransformComponent;
	exports.unsafeGetGameObjectTransformComponent = unsafeGetGameObjectTransformComponent;
	exports.disposeGameObjectTransformComponent = disposeGameObjectTransformComponent;
	exports.addGameObjectTransformComponent = addGameObjectTransformComponent;
	exports.hasGameObjectArcballCameraControllerComponent = hasGameObjectArcballCameraControllerComponent;
	exports.unsafeGetGameObjectArcballCameraControllerComponent = unsafeGetGameObjectArcballCameraControllerComponent;
	exports.disposeGameObjectArcballCameraControllerComponent = disposeGameObjectArcballCameraControllerComponent;
	exports.addGameObjectArcballCameraControllerComponent = addGameObjectArcballCameraControllerComponent;
	exports.hasGameObjectPerspectiveCameraProjectionComponent = hasGameObjectPerspectiveCameraProjectionComponent;
	exports.unsafeGetGameObjectPerspectiveCameraProjectionComponent = unsafeGetGameObjectPerspectiveCameraProjectionComponent;
	exports.disposeGameObjectPerspectiveCameraProjectionComponent = disposeGameObjectPerspectiveCameraProjectionComponent;
	exports.addGameObjectPerspectiveCameraProjectionComponent = addGameObjectPerspectiveCameraProjectionComponent;
	exports.hasGameObjectBasicCameraViewComponent = hasGameObjectBasicCameraViewComponent;
	exports.unsafeGetGameObjectBasicCameraViewComponent = unsafeGetGameObjectBasicCameraViewComponent;
	exports.disposeGameObjectBasicCameraViewComponent = disposeGameObjectBasicCameraViewComponent;
	exports.addGameObjectBasicCameraViewComponent = addGameObjectBasicCameraViewComponent;
	exports.createGameObject = createGameObject;
	exports.removeWorkerMainLoopJob = removeWorkerMainLoopJob;
	exports.addWorkerMainLoopJob = addWorkerMainLoopJob;
	exports.removeWorkerMainInitJob = removeWorkerMainInitJob;
	exports.addWorkerMainInitJob = addWorkerMainInitJob;
	exports.removeNoWorkerLoopJob = removeNoWorkerLoopJob;
	exports.removeNoWorkerInitJob = removeNoWorkerInitJob;
	exports.addNoWorkerLoopJob = addNoWorkerLoopJob;
	exports.addNoWorkerInitJob = addNoWorkerInitJob;
	exports.setMeshRendererDrawMode = setMeshRendererDrawMode;
	exports.getMeshRendererDrawMode = getMeshRendererDrawMode;
	exports.unsafeGetMeshRendererGameObject = unsafeGetMeshRendererGameObject;
	exports.createMeshRenderer = createMeshRenderer;
	exports.setPerspectiveCameraProjectionFar = setPerspectiveCameraProjectionFar;
	exports.unsafeGetPerspectiveCameraFar = unsafeGetPerspectiveCameraFar;
	exports.setPerspectiveCameraProjectionNear = setPerspectiveCameraProjectionNear;
	exports.unsafeGetPerspectiveCameraNear = unsafeGetPerspectiveCameraNear;
	exports.setPerspectiveCameraProjectionAspect = setPerspectiveCameraProjectionAspect;
	exports.unsafeGetPerspectiveCameraAspect = unsafeGetPerspectiveCameraAspect;
	exports.setPerspectiveCameraProjectionFovy = setPerspectiveCameraProjectionFovy;
	exports.unsafeGetPerspectiveCameraFovy = unsafeGetPerspectiveCameraFovy;
	exports.unsafeGetPerspectiveCameraProjectionGameObject = unsafeGetPerspectiveCameraProjectionGameObject;
	exports.unsafeGetPerspectiveCameraProjectionPMatrix = unsafeGetPerspectiveCameraProjectionPMatrix;
	exports.createPerspectiveCameraProjection = createPerspectiveCameraProjection;
	exports.addSceneChildren = addSceneChildren;
	exports.addSceneChild = addSceneChild;
	exports.getSceneGameObject = getSceneGameObject;
	exports.setAmbientLightColor = setAmbientLightColor;
	exports.getAmbientLightColor = getAmbientLightColor;
	exports.setCurrentCameraGameObject = setCurrentCameraGameObject;
	exports.getCurrentCameraGameObject = getCurrentCameraGameObject;
	exports.setScreenSize = setScreenSize;
	exports.markSourceInstanceModelMatrixIsStatic = markSourceInstanceModelMatrixIsStatic;
	exports.getSourceInstanceObjectInstanceTransformArray = getSourceInstanceObjectInstanceTransformArray;
	exports.createObjectInstanceGameObject = createObjectInstanceGameObject;
	exports.unsafeGetSourceInstanceGameObject = unsafeGetSourceInstanceGameObject;
	exports.createSourceInstance = createSourceInstance;
	exports.setSetStateFunc = setSetStateFunc;
	exports.setUnsafeGetStateFunc = setUnsafeGetStateFunc;
	exports.setIsDebug = setIsDebug;
	exports.setStateToData = setStateToData;
	exports.setState = setState;
	exports.createState = createState;
	exports.getStateFromData = getStateFromData;
	exports.unsafeGetState = unsafeGetState;
	exports.createStateData = createStateData;
	exports.getStateData = getStateData;
	exports.restoreState = restoreState;
	exports.deepCopyForRestore = deepCopyForRestore;
	exports.getFps = getFps;
	exports.getGameTime = getGameTime;
	exports.lookAtWithUp = lookAtWithUp;
	exports.lookAt = lookAt;
	exports.setTransformEulerAngles = setTransformEulerAngles;
	exports.getTransformEulerAngles = getTransformEulerAngles;
	exports.setTransformLocalEulerAngles = setTransformLocalEulerAngles;
	exports.getTransformLocalEulerAngles = getTransformLocalEulerAngles;
	exports.setTransformScale = setTransformScale;
	exports.getTransformScale = getTransformScale;
	exports.setTransformLocalScale = setTransformLocalScale;
	exports.getTransformLocalScale = getTransformLocalScale;
	exports.setTransformRotation = setTransformRotation;
	exports.getTransformRotation = getTransformRotation;
	exports.setTransformLocalRotation = setTransformLocalRotation;
	exports.getTransformLocalRotation = getTransformLocalRotation;
	exports.setTransformPosition = setTransformPosition;
	exports.getTransformPosition = getTransformPosition;
	exports.setTransformLocalPosition = setTransformLocalPosition;
	exports.getTransformLocalPosition = getTransformLocalPosition;
	exports.unsafeGetTransformChildren = unsafeGetTransformChildren;
	exports.setTransformParentKeepOrder = setTransformParentKeepOrder;
	exports.setTransformParent = setTransformParent;
	exports.unsafeGetTransformParent = unsafeGetTransformParent;
	exports.unsafeGetTransformGameObject = unsafeGetTransformGameObject;
	exports.createTransform = createTransform;
	exports.create = create;
	exports.setAPIJsObj = setAPIJsObj;
	exports.getAPIJsObj = getAPIJsObj;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
